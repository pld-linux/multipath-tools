diff --git a/Makefile b/Makefile
index d0063d0..5b0c61a 100644
--- a/Makefile
+++ b/Makefile
@@ -23,8 +23,10 @@ BUILDDIRS = \
 	libmultipath \
 	libmultipath/prioritizers \
 	libmultipath/checkers \
+	libmpathpersist \
 	multipath \
 	multipathd \
+	mpathpersist \
 	kpartx
 
 ifeq   ($(MULTIPATH_VERSION),)
diff --git a/Makefile.inc b/Makefile.inc
index dbcbc3b..02aef4f 100644
--- a/Makefile.inc
+++ b/Makefile.inc
@@ -28,9 +28,12 @@ libudevdir  = ${prefix}/lib/udev
 multipathdir = $(TOPDIR)/libmultipath
 mandir      = $(prefix)/usr/share/man/man8
 man5dir     = $(prefix)/usr/share/man/man5
+man3dir      = $(prefix)/usr/share/man/man3
 rcdir	    = $(prefix)/etc/init.d
 syslibdir   = $(prefix)/$(LIB)
 libdir	    = $(prefix)/$(LIB)/multipath
+unitdir     = $(prefix)/lib/systemd/system
+mpathpersistdir = $(TOPDIR)/libmpathpersist
 
 GZIP        = /bin/gzip -9 -c
 INSTALL_PROGRAM = install
diff --git a/kpartx/Makefile b/kpartx/Makefile
index e1e9651..1287053 100644
--- a/kpartx/Makefile
+++ b/kpartx/Makefile
@@ -6,6 +6,12 @@ include ../Makefile.inc
 
 CFLAGS += -I. -D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64
 
+LIBDM_API_COOKIE = $(shell grep -Ecs '^[a-z]*[[:space:]]+dm_task_set_cookie' /usr/include/libdevmapper.h)
+
+ifneq ($(strip $(LIBDM_API_COOKIE)),0)
+	CFLAGS += -DLIBDM_API_COOKIE
+endif
+
 LDFLAGS = -ldevmapper
 OBJS = bsd.o dos.o kpartx.o solaris.o unixware.o dasd.o sun.o \
        gpt.o mac.o crc32.o lopart.o xstrncpy.o devmapper.o
@@ -16,7 +22,7 @@ all: $(EXEC)
 $(EXEC): $(OBJS)
 	$(CC) $(OBJS) -o $(EXEC) $(LDFLAGS)
 	$(GZIP) $(EXEC).8 > $(EXEC).8.gz
-	
+
 install: $(EXEC) $(EXEC).8
 	$(INSTALL_PROGRAM) -d $(DESTDIR)$(bindir)
 	$(INSTALL_PROGRAM) -m 755 $(EXEC) $(DESTDIR)$(bindir)
diff --git a/kpartx/devmapper.c b/kpartx/devmapper.c
index f884511..4baebd9 100644
--- a/kpartx/devmapper.c
+++ b/kpartx/devmapper.c
@@ -12,6 +12,14 @@
 
 #define UUID_PREFIX "part%d-"
 #define MAX_PREFIX_LEN 8
+#define PARAMS_SIZE 1024
+
+#ifndef LIBDM_API_COOKIE
+static inline int dm_task_set_cookie(struct dm_task *dmt, uint32_t *c, int a)
+{
+	return 1;
+}
+#endif
 
 extern int
 dm_prereq (char * str, int x, int y, int z)
@@ -81,7 +89,7 @@ dm_simplecmd (int task, const char *name, int no_flush, uint32_t *cookie) {
 
 extern int
 dm_addmap (int task, const char *name, const char *target,
-	   const char *params, uint64_t size, const char *uuid, int part,
+	   const char *params, uint64_t size, int ro, const char *uuid, int part,
 	   mode_t mode, uid_t uid, gid_t gid, uint32_t *cookie) {
 	int r = 0;
 	struct dm_task *dmt;
@@ -96,6 +104,9 @@ dm_addmap (int task, const char *name, const char *target,
 	if (!dm_task_add_target (dmt, 0, size, target, params))
 		goto addout;
 
+	if (ro && !dm_task_set_ro (dmt))
+			goto addout;
+
 	if (task == DM_DEVICE_CREATE && uuid) {
 		prefixed_uuid = malloc(MAX_PREFIX_LEN + strlen(uuid) + 1);
 		if (!prefixed_uuid) {
@@ -268,3 +279,62 @@ out:
 	return r;
 }
 
+int
+dm_get_map(int major, int minor, char * outparams)
+{
+	int r = 1;
+	struct dm_task *dmt;
+	void *next = NULL;
+	uint64_t start, length;
+	char *target_type = NULL;
+	char *params = NULL;
+
+	if (!(dmt = dm_task_create(DM_DEVICE_TABLE)))
+		return 1;
+
+	dm_task_set_major(dmt, major);
+	dm_task_set_minor(dmt, minor);
+	dm_task_no_open_count(dmt);
+
+	if (!dm_task_run(dmt))
+		goto out;
+
+	/* Fetch 1st target */
+	next = dm_get_next_target(dmt, next, &start, &length,
+				  &target_type, &params);
+
+	if (snprintf(outparams, PARAMS_SIZE, "%s", params) <= PARAMS_SIZE)
+		r = 0;
+out:
+	dm_task_destroy(dmt);
+	return r;
+}
+
+#define FEATURE_NO_PART "no_partitions"
+
+int
+dm_no_partitions(int major, int minor)
+{
+	char params[PARAMS_SIZE], *ptr;
+	int i, num_features;
+
+	if (dm_get_map(major, minor, params))
+		return 0;
+
+	ptr = params;
+	num_features = strtoul(params, &ptr, 10);
+	if ((ptr == params) || num_features == 0) {
+		/* No features found, return success */
+		return 0;
+	}
+	for (i = 0; (i < num_features); i++) {
+		if (!ptr || ptr > params + strlen(params))
+			break;
+		/* Skip whitespaces */
+		while(ptr && *ptr == ' ') ptr++;
+		if (!strncmp(ptr, FEATURE_NO_PART, strlen(FEATURE_NO_PART)))
+			return 1;
+		ptr = strchr(ptr, ' ');
+	}
+	return 0;
+}
diff --git a/kpartx/devmapper.h b/kpartx/devmapper.h
index f8692cc..8e350a0 100644
--- a/kpartx/devmapper.h
+++ b/kpartx/devmapper.h
@@ -5,9 +5,10 @@
 int dm_prereq (char *, int, int, int);
 int dm_simplecmd (int, const char *, int, uint32_t *);
 int dm_addmap (int, const char *, const char *, const char *, uint64_t,
-	       const char *, int, mode_t, uid_t, gid_t, uint32_t *);
+	       int, const char *, int, mode_t, uid_t, gid_t, uint32_t *);
 int dm_map_present (char *);
 char * dm_mapname(int major, int minor);
 dev_t dm_get_first_dep(char *devname);
 char * dm_mapuuid(int major, int minor);
 int dm_devn (char * mapname, int *major, int *minor);
+int dm_no_partitions(int major, int minor);
diff --git a/kpartx/gpt.c b/kpartx/gpt.c
index 047a829..3082cae 100644
--- a/kpartx/gpt.c
+++ b/kpartx/gpt.c
@@ -358,6 +358,24 @@ is_gpt_valid(int fd, uint64_t lba,
 		return 0;
 	}
 
+	/* Check that sizeof_partition_entry has the correct value */
+	if (__le32_to_cpu((*gpt)->sizeof_partition_entry) != sizeof(gpt_entry)) {
+		// printf("GUID partition entry size check failed.\n");
+		free(*gpt);
+		*gpt = NULL;
+		return 0;
+	}
+
+
+	/* Check that sizeof_partition_entry has the correct value */
+	if (__le32_to_cpu((*gpt)->sizeof_partition_entry) != sizeof(gpt_entry)) {
+		// printf("GUID partition entry size check failed.\n");
+		free(*gpt);
+		*gpt = NULL;
+		return 0;
+	}
+
+
 	if (!(*ptes = alloc_read_gpt_entries(fd, *gpt))) {
 		free(*gpt);
 		*gpt = NULL;
diff --git a/kpartx/kpartx.8 b/kpartx/kpartx.8
index 923be1e..8a37d4f 100644
--- a/kpartx/kpartx.8
+++ b/kpartx/kpartx.8
@@ -17,20 +17,52 @@ creation and deletion.
 .B \-a
 Add partition mappings
 .TP
+.B \-r
+Readonly partition mappings
+.TP
 .B \-d
 Delete partition mappings
 .TP
+.B \-u
+Update partition mappings
+.TP
 .B \-l
 List partition mappings that would be added -a
 .TP
 .B \-p
 set device name-partition number delimiter
 .TP
+.B \-f
+force creation of mappings; overrides 'no_partitions' feature
+.TP
 .B \-g
 force GUID partition table (GPT)
 .TP
 .B \-v
 Operate verbosely
+.TP
+.B \-s
+Sync mode. Don't return until the partitions are created
+.SH EXAMPLE
+To mount all the partitions in a raw disk image:
+.IP
+kpartx -av disk.img
+.PP
+This will output lines such as:
+.IP
+loop3p1 : 0 20964762 /dev/loop3 63
+.PP
+The 
+.I loop3p1
+is the name of a device file under 
+.I /dev/mapper
+which you can use to access the partition, for example to fsck it:
+.IP
+fsck /dev/mapper/loop3p1
+.PP
+When you're done, you need to remove the devices:
+.IP
+kpartx -d disk.img
 .SH "SEE ALSO"
 .BR multipath (8)
 .BR multipathd (8)
diff --git a/kpartx/kpartx.c b/kpartx/kpartx.c
index 3d33990..b5e0a32 100644
--- a/kpartx/kpartx.c
+++ b/kpartx/kpartx.c
@@ -48,7 +48,7 @@
 
 struct slice slices[MAXSLICES];
 
-enum action { LIST, ADD, DELETE };
+enum action { LIST, ADD, DELETE, UPDATE };
 
 struct pt {
 	char *type;
@@ -82,19 +82,24 @@ initpts(void)
 	addpts("sun", read_sun_pt);
 }
 
-static char short_opts[] = "ladgvp:t:s";
+static char short_opts[] = "rladfgvp:t:su";
 
 /* Used in gpt.c */
 int force_gpt=0;
 
+int force_devmap=0;
+
 static int
 usage(void) {
-	printf("usage : kpartx [-a|-d|-l] [-v] wholedisk\n");
+	printf("usage : kpartx [-a|-d|-l] [-f] [-v] wholedisk\n");
 	printf("\t-a add partition devmappings\n");
+	printf("\t-r devmappings will be readonly\n");
 	printf("\t-d del partition devmappings\n");
+	printf("\t-u update partition devmappings\n");
 	printf("\t-l list partitions devmappings that would be added by -a\n");
 	printf("\t-p set device name-partition number delimiter\n");
 	printf("\t-g force GUID partition table (GPT)\n");
+	printf("\t-f force devmap create\n");
 	printf("\t-v verbose\n");
 	printf("\t-s sync mode. Don't return until the partitions are created\n");
 	return 1;
@@ -185,7 +190,8 @@ get_hotplug_device(void)
 
 int
 main(int argc, char **argv){
-	int fd, i, j, m, n, op, off, arg, c, d;
+	int i, j, m, n, op, off, arg, c, d, ro=0;
+	int fd = -1;
 	struct slice all;
 	struct pt *ptp;
 	enum action what = LIST;
@@ -233,6 +239,12 @@ main(int argc, char **argv){
 	}
 
 	while ((arg = getopt(argc, argv, short_opts)) != EOF) switch(arg) {
+		case 'r':
+			ro=1;
+			break;
+		case 'f':
+			force_devmap=1;
+			break;
 		case 'g':
 			force_gpt=1;
 			break;
@@ -257,15 +269,20 @@ main(int argc, char **argv){
 		case 's':
 			sync = 1;
 			break;
+		case 'u':
+			what = UPDATE;
+			break;
 		default:
 			usage();
 			exit(1);
 	}
 
+#ifdef LIBDM_API_COOKIE
 	if (!sync)
 		dm_udev_set_sync_support(0);
+#endif
 
-	if (dm_prereq(DM_TARGET, 0, 0, 0) && (what == ADD || what == DELETE)) {
+	if (dm_prereq(DM_TARGET, 0, 0, 0) && (what == ADD || what == DELETE || what == UPDATE)) {
 		fprintf(stderr, "device mapper prerequisites not met\n");
 		exit(1);
 	}
@@ -306,12 +323,6 @@ main(int argc, char **argv){
 		device = loopdev;
 	}
 
-	if (delim == NULL) {
-		delim = malloc(DELIM_SIZE);
-		memset(delim, 0, DELIM_SIZE);
-		set_delimiter(device, delim);
-	}
-
 	off = find_devname_offset(device);
 
 	if (!loopdev) {
@@ -326,6 +337,18 @@ main(int argc, char **argv){
 
 	if (!mapname)
 		mapname = device + off;
+	else if (!force_devmap &&
+		 dm_no_partitions((unsigned int)MAJOR(buf.st_rdev),
+				  (unsigned int)MINOR(buf.st_rdev))) {
+		/* Feature 'no_partitions' is set, return */
+		return 0;
+	}
+
+	if (delim == NULL) {
+		delim = malloc(DELIM_SIZE);
+		memset(delim, 0, DELIM_SIZE);
+		set_delimiter(device, delim);
+	}
 
 	fd = open(device, O_RDONLY);
 
@@ -350,8 +373,10 @@ main(int argc, char **argv){
 			printf("%s: %d slices\n", ptp->type, n);
 #endif
 
-		if (n > 0)
+		if (n > 0) {
 			close(fd);
+			fd = -1;
+		}
 		else
 			continue;
 
@@ -399,15 +424,6 @@ main(int argc, char **argv){
 					break;
 			}
 
-			if (loopcreated && S_ISREG (buf.st_mode)) {
-				if (del_loop(device)) {
-					if (verbose)
-						printf("can't del loop : %s\n",
-							device);
-					exit(1);
-				}
-				printf("loop deleted : %s\n", device);
-			}
 			break;
 
 		case DELETE:
@@ -443,6 +459,8 @@ main(int argc, char **argv){
 			break;
 
 		case ADD:
+		case UPDATE:
+			/* ADD and UPDATE share the same code that adds new partitions. */
 			for (j = 0, c = 0; j < n; j++) {
 				if (slices[j].size == 0)
 					continue;
@@ -470,7 +488,7 @@ main(int argc, char **argv){
 					DM_DEVICE_RELOAD : DM_DEVICE_CREATE);
 
 				if (!dm_addmap(op, partname, DM_TARGET, params,
-					       slices[j].size, uuid, j+1,
+					       slices[j].size, ro, uuid, j+1,
 					       buf.st_mode & 0777, buf.st_uid,
 					       buf.st_gid, &cookie)) {
 					fprintf(stderr, "create/reload failed on %s\n",
@@ -536,7 +554,7 @@ main(int argc, char **argv){
 					      DM_DEVICE_RELOAD : DM_DEVICE_CREATE);
 
 					dm_addmap(op, partname, DM_TARGET, params,
-						  slices[j].size, uuid, j+1,
+						  slices[j].size, ro, uuid, j+1,
 						  buf.st_mode & 0777,
 						  buf.st_uid, buf.st_gid,
 						  &cookie);
@@ -559,7 +577,31 @@ main(int argc, char **argv){
 				if (d == c)
 					break;
 			}
-			break;
+
+			if (what == ADD) {
+				/* Skip code that removes devmappings for deleted partitions */
+				break;
+			}
+
+			for (j = MAXSLICES-1; j >= 0; j--) {
+				if (safe_sprintf(partname, "%s%s%d",
+					     mapname, delim, j+1)) {
+					fprintf(stderr, "partname too small\n");
+					exit(1);
+				}
+				strip_slash(partname);
+
+				if (slices[j].size || !dm_map_present(partname))
+					continue;
+
+				if (!dm_simplecmd(DM_DEVICE_REMOVE,
+						  partname, 1, &cookie)) {
+					r++;
+					continue;
+				}
+				if (verbose)
+					printf("del devmap : %s\n", partname);
+			}
 
 		default:
 			break;
@@ -568,7 +610,20 @@ main(int argc, char **argv){
 		if (n > 0)
 			break;
 	}
+	if (what == LIST && loopcreated && S_ISREG (buf.st_mode)) {
+		if (fd != -1)
+			close(fd);
+		if (del_loop(device)) {
+			if (verbose)
+				printf("can't del loop : %s\n",
+					device);
+			exit(1);
+		}
+		printf("loop deleted : %s\n", device);
+	}
+#ifdef LIBDM_API_COOKIE
 	dm_udev_wait(cookie);
+#endif
 	dm_lib_release();
 	dm_lib_exit();
 
diff --git a/kpartx/kpartx.rules b/kpartx/kpartx.rules
index 8978b73..64863a0 100644
--- a/kpartx/kpartx.rules
+++ b/kpartx/kpartx.rules
@@ -17,19 +17,13 @@ OPTIONS="link_priority=50"
 ENV{DM_UUID}=="mpath-*", \
 	SYMLINK+="disk/by-id/$env{DM_TYPE}-$env{DM_NAME}"
 
-# Create persistent links for dmraid tables
-ENV{DM_UUID}=="dmraid-*", \
-        SYMLINK+="disk/by-id/$env{DM_TYPE}-$env{DM_NAME}"
-
 # Create persistent links for partitions
 ENV{DM_PART}=="?*", \
         SYMLINK+="disk/by-id/$env{DM_TYPE}-$env{DM_NAME}-part$env{DM_PART}"
 
 # Create dm tables for partitions
 ENV{DM_STATE}=="ACTIVE", ENV{DM_UUID}=="mpath-*", \
-        RUN+="/sbin/kpartx -a -p -part /dev/$name"
-ENV{DM_STATE}=="ACTIVE", ENV{DM_UUID}=="dmraid-*", \
-        RUN+="/sbin/kpartx -a -p -part /dev/$name"
+        RUN+="/sbin/kpartx -u -p -part /dev/$name"
 
 LABEL="kpartx_end"
 
diff --git a/libmpathpersist/Makefile b/libmpathpersist/Makefile
new file mode 100644
index 0000000..c4ec1c5
--- /dev/null
+++ b/libmpathpersist/Makefile
@@ -0,0 +1,49 @@
+# Makefile
+#
+BUILD = glibc
+include ../Makefile.inc
+
+INSTALL_PROGRAM = install
+
+SONAME=0
+DEVLIB = libmpathpersist.so
+LIBS = $(DEVLIB).$(SONAME)
+
+
+CFLAGS += -I$(multipathdir) -I$(mpathpersistdir) 
+LIBDEPS +=  -lpthread -ldevmapper -ldl -L$(multipathdir) -lmultipath
+
+OBJS = mpath_persist.o mpath_updatepr.o mpath_pr_ioctl.o 
+
+all: $(LIBS)
+
+
+$(LIBS): 
+	$(CC) -Wall -fPIC -c $(CFLAGS) *.c 
+	$(CC)  -shared $(LIBDEPS) -Wl,-soname=$@ $(CFLAGS) -o $@ $(OBJS)
+	ln -s $(LIBS) $(DEVLIB)
+	$(GZIP) mpath_persistent_reserve_in.3 > mpath_persistent_reserve_in.3.gz	
+	$(GZIP) mpath_persistent_reserve_out.3 > mpath_persistent_reserve_out.3.gz	
+
+install: $(LIBS)
+	$(INSTALL_PROGRAM) -d $(DESTDIR)$(syslibdir)
+	$(INSTALL_PROGRAM) -m 755 $(LIBS) $(DESTDIR)$(syslibdir)/$(LIBS)
+	$(INSTALL_PROGRAM) -m 755 -d $(DESTDIR)$(syslibdir)
+	$(INSTALL_PROGRAM) -m 755 -d $(DESTDIR)$(man3dir)
+	$(INSTALL_PROGRAM) -m 755 -d $(DESTDIR)/usr/include/
+	$(INSTALL_PROGRAM) -m 755 -d $(DESTDIR)/usr/share/doc/mpathpersist/
+	ln -sf $(DESTDIR)$(syslibdir)/$(LIBS) $(DESTDIR)$(syslibdir)/$(DEVLIB)
+	install -m 644 mpath_persistent_reserve_in.3.gz $(DESTDIR)$(man3dir)	
+	install -m 644 mpath_persistent_reserve_out.3.gz $(DESTDIR)$(man3dir)	
+	install -m 644 mpath_persist.h $(DESTDIR)/usr/include/
+
+uninstall:
+	rm -f $(DESTDIR)$(syslibdir)/$(LIBS)
+	rm $(DESTDIR)$(mandir)/mpath_persistent_reserve_in.3.gz	
+	rm $(DESTDIR)$(mandir)/mpath_persistent_reserve_out.3.gz	
+
+clean:
+	rm -f core *.a *.o 
+	rm -f libmpathpersist.so.0
+	rm -f libmpathpersist.so
+	rm -f mpath_persistent_reserve_in.3.gz mpath_persistent_reserve_out.3.gz
diff --git a/libmpathpersist/mpath_persist.c b/libmpathpersist/mpath_persist.c
new file mode 100644
index 0000000..302dd3f
--- /dev/null
+++ b/libmpathpersist/mpath_persist.c
@@ -0,0 +1,885 @@
+#include "mpath_persist.h"
+#include <libdevmapper.h>
+#include <defaults.h>
+#include <sys/stat.h>
+#include <linux/kdev_t.h>
+#include <fcntl.h>
+#include <vector.h>
+#include <checkers.h>
+#include <structs.h>
+#include <structs_vec.h>
+
+#include <prio.h>
+#include <unistd.h>
+#include <devmapper.h>
+#include <debug.h>
+#include <config.h>
+#include <switchgroup.h>
+#include <discovery.h>
+#include <dmparser.h>
+#include <ctype.h>
+#include <propsel.h>
+#include <sysfs.h>
+
+#include "mpathpr.h"
+#include "mpath_pr_ioctl.h"
+
+#include <pthread.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define __STDC_FORMAT_MACROS 1
+
+
+int
+mpath_lib_init (void)
+{
+	if (load_config(DEFAULT_CONFIGFILE)){
+		condlog(0, "Failed to initialize multipath config.");
+		return 1;
+	}
+
+	if (sysfs_init(conf->sysfs_dir, FILE_NAME_SIZE)){
+		condlog(0, "Failed. mpathpersist needs sysfs mounted");
+		exit(1);
+	}
+	return 0;
+}
+
+int
+mpath_lib_exit (void)
+{
+	dm_lib_release();
+	dm_lib_exit();
+	cleanup_prio();
+	cleanup_checkers();
+	free_config(conf);
+	conf = NULL;
+	return 0;
+}
+
+static int
+updatepaths (struct multipath * mpp)
+{
+	int i, j;
+	struct pathgroup * pgp;
+	struct path * pp;
+
+	if (!mpp->pg)
+		return 0;
+
+	vector_foreach_slot (mpp->pg, pgp, i){
+		if (!pgp->paths)
+			continue;
+
+		vector_foreach_slot (pgp->paths, pp, j){
+			if (!strlen(pp->dev)){
+				if (devt2devname(pp->dev, pp->dev_t)){
+					/*
+					 * path is not in sysfs anymore
+					 */
+					pp->state = PATH_DOWN;
+					continue;
+				}
+				pp->mpp = mpp;
+				pathinfo(pp, conf->hwtable, DI_ALL);
+				continue;
+			}
+			pp->mpp = mpp;
+			if (pp->state == PATH_UNCHECKED ||
+					pp->state == PATH_WILD)
+				pathinfo(pp, conf->hwtable, DI_CHECKER);
+
+			if (pp->priority == PRIO_UNDEF)
+				pathinfo(pp, conf->hwtable, DI_PRIO);
+		}
+	}
+	return 0;
+}
+
+int 
+mpath_prin_activepath (struct multipath *mpp, int rq_servact,
+	struct prin_resp * resp, int noisy)
+{
+	int i,j, ret = MPATH_PR_DMMP_ERROR;
+	struct pathgroup *pgp = NULL;
+	struct path *pp = NULL;
+
+	vector_foreach_slot (mpp->pg, pgp, j){
+		vector_foreach_slot (pgp->paths, pp, i){
+			if (!((pp->state == PATH_UP) || (pp->state == PATH_GHOST))){
+				condlog(2, "%s: %s not available. Skip.", mpp->wwid, pp->dev);
+				condlog(3, "%s: status = %d.", mpp->wwid, pp->state);
+				continue;
+			}
+
+			condlog(3, "%s: sending pr in command to %s ", mpp->wwid, pp->dev);
+			ret = mpath_send_prin_activepath(pp->dev, rq_servact, resp, noisy);
+			switch(ret)
+			{
+				case MPATH_PR_SUCCESS:
+				case MPATH_PR_SENSE_INVALID_OP:
+					return ret;
+				default:
+					continue;
+			}
+		}
+	}
+	return ret;	
+}
+
+int mpath_persistent_reserve_in (int fd, int rq_servact, struct prin_resp *resp, int noisy, int verbose)
+{
+	struct stat info;
+	vector curmp = NULL;
+	vector pathvec = NULL;
+	char * alias;
+	struct multipath * mpp;
+	int map_present;
+	int major, minor;
+	int ret;
+
+	conf->verbosity = verbose;
+
+	if (fstat( fd, &info) != 0){
+		condlog(0, "stat error %d", fd);
+		return MPATH_PR_FILE_ERROR;
+	} 
+	if(!S_ISBLK(info.st_mode)){
+		condlog(0, "Failed to get major:minor. fd = %d", fd);
+		return MPATH_PR_FILE_ERROR;
+	}
+
+	major = (int)MAJOR(info.st_rdev);
+	minor = (int)MINOR(info.st_rdev);	
+	condlog(4, "Device %d:%d:  ", major, minor);
+
+	/* get alias from major:minor*/
+	alias = dm_mapname(major, minor);
+	if (!alias){
+		condlog(0, "%d:%d failed to get device alias.", major, minor);
+		return MPATH_PR_DMMP_ERROR;
+	}
+
+	condlog(3, "alias = %s", alias);
+	map_present = dm_map_present(alias);
+	if (map_present && dm_type(alias, TGT_MPATH) <= 0){
+		condlog( 0, "%s: not a multipath device.", alias);
+		ret = MPATH_PR_DMMP_ERROR;
+		goto out;
+	}
+
+	/*
+	 * allocate core vectors to store paths and multipaths
+	 */
+	curmp = vector_alloc ();
+	pathvec = vector_alloc ();
+
+	if (!curmp || !pathvec){
+		condlog (0, "%s: vector allocation failed.", alias);
+		ret = MPATH_PR_DMMP_ERROR;
+		goto out;
+	}
+
+	if (path_discovery(pathvec, conf, DI_SYSFS | DI_CHECKER))
+		goto out1;
+
+	/* get info of all paths from the dm device	*/
+	if (get_mpvec (curmp, pathvec, alias)){
+		condlog(0, "%s: failed to get device info.", alias);
+		ret = MPATH_PR_DMMP_ERROR;
+		goto out1;
+	}
+
+	mpp = find_mp_by_alias(curmp, alias);
+	if (!mpp){
+		condlog(0, "%s: devmap not registered.", alias);
+		ret = MPATH_PR_DMMP_ERROR;
+		goto out1;
+	}
+
+	ret = mpath_prin_activepath(mpp, rq_servact, resp, noisy);
+
+out1:
+	free_multipathvec(curmp, KEEP_PATHS);
+	free_pathvec(pathvec, FREE_PATHS);	
+out:
+	FREE(alias);
+	return ret; 						
+}
+
+int mpath_persistent_reserve_out ( int fd, int rq_servact, int rq_scope,
+		unsigned int rq_type, struct prout_param_descriptor *paramp, int noisy, int verbose)
+{
+
+	struct stat info;
+
+	vector curmp = NULL;
+	vector pathvec = NULL;
+
+	char * alias;
+	struct multipath * mpp;
+	int map_present;
+	int major, minor;
+	int ret;
+	int j;
+	unsigned char *keyp;
+	uint64_t prkey;		
+
+	conf->verbosity = verbose;
+
+	if (fstat( fd, &info) != 0){
+		condlog(0, "stat error fd=%d", fd);
+		return MPATH_PR_FILE_ERROR;
+	}
+
+	if(!S_ISBLK(info.st_mode)){
+		condlog(3, "Failed to get major:minor. fd=%d", fd);
+		return MPATH_PR_FILE_ERROR;	
+	}	
+
+	major = (int)MAJOR(info.st_rdev);
+	minor = (int)MINOR(info.st_rdev);
+	condlog(4, "Device  %d:%d", major, minor);
+
+	/* get WWN of the device from major:minor*/
+	alias = dm_mapname(major, minor);
+	if (!alias){
+		return MPATH_PR_DMMP_ERROR;
+	}
+
+	condlog(3, "alias = %s", alias);
+	map_present = dm_map_present(alias);
+
+	if (map_present && dm_type(alias, TGT_MPATH) <= 0){
+		condlog(3, "%s: not a multipath device.", alias);
+		ret = MPATH_PR_DMMP_ERROR;
+		goto out;
+	}
+
+	/*
+	 * allocate core vectors to store paths and multipaths
+	 */
+	curmp = vector_alloc ();
+	pathvec = vector_alloc ();
+
+	 if (!curmp || !pathvec){
+                condlog (0, "%s: vector allocation failed.", alias);
+                ret = MPATH_PR_DMMP_ERROR;
+                goto out;
+        }
+
+	if (path_discovery(pathvec, conf, DI_SYSFS | DI_CHECKER))
+		goto out1;
+
+	/* get info of all paths from the dm device     */
+	if (get_mpvec(curmp, pathvec, alias)){
+		condlog(0, "%s: failed to get device info.", alias);
+		ret = MPATH_PR_DMMP_ERROR;
+		goto out1;
+	}
+
+	mpp = find_mp_by_alias(curmp, alias);
+
+	if (!mpp) {
+		condlog(0, "%s: devmap not registered.", alias);
+		ret = MPATH_PR_DMMP_ERROR;
+		goto out1;
+	}
+
+	select_reservation_key(mpp);
+
+	switch(rq_servact)
+	{
+		case MPATH_PROUT_REG_SA: 
+		case MPATH_PROUT_REG_IGN_SA:  
+			ret= mpath_prout_reg(mpp, rq_servact, rq_scope, rq_type, paramp, noisy);
+			break;
+		case MPATH_PROUT_RES_SA :  
+		case MPATH_PROUT_PREE_SA :  
+		case MPATH_PROUT_PREE_AB_SA :  
+		case MPATH_PROUT_CLEAR_SA:  
+			ret = mpath_prout_common(mpp, rq_servact, rq_scope, rq_type, paramp, noisy);
+			break;
+		case MPATH_PROUT_REL_SA:
+			ret = mpath_prout_rel(mpp, rq_servact, rq_scope, rq_type, paramp, noisy);
+			break;
+		default:
+			ret = MPATH_PR_OTHER;
+			goto out1;
+	}
+
+	if ((ret == MPATH_PR_SUCCESS) && ((rq_servact == MPATH_PROUT_REG_SA) ||
+				(rq_servact ==  MPATH_PROUT_REG_IGN_SA)))
+	{
+		keyp=paramp->sa_key;
+		prkey = 0;
+		for (j = 0; j < 8; ++j) {
+			if (j > 0)
+				prkey <<= 8;
+			prkey |= *keyp;
+			++keyp;
+		}
+		if (prkey == 0)
+			update_prflag(alias, "unset", noisy);
+		else
+			update_prflag(alias, "set", noisy);
+	} else {
+		if ((ret == MPATH_PR_SUCCESS) && ((rq_servact == MPATH_PROUT_CLEAR_SA) || 
+					(rq_servact == MPATH_PROUT_PREE_AB_SA ))){
+			update_prflag(alias, "unset", noisy);
+		}
+	}
+out1:
+	free_multipathvec(curmp, KEEP_PATHS);
+	free_pathvec(pathvec, FREE_PATHS);
+
+out:
+	FREE(alias);
+	return ret; 
+}
+
+int
+get_mpvec (vector curmp, vector pathvec, char * refwwid)
+{
+	int i;
+	struct multipath *mpp;
+	char params[PARAMS_SIZE], status[PARAMS_SIZE];
+
+	if (dm_get_maps (curmp)){
+		return 1;
+	}
+
+	vector_foreach_slot (curmp, mpp, i){
+		/*
+		 * discard out of scope maps
+		 */
+		if (mpp->alias && refwwid && strncmp (mpp->alias, refwwid, WWID_SIZE)){
+			free_multipath (mpp, KEEP_PATHS);
+			vector_del_slot (curmp, i);
+			i--;
+			continue;
+		}
+
+		dm_get_map(mpp->alias, &mpp->size, params);
+		condlog(3, "params = %s", params);
+		dm_get_status(mpp->alias, status);
+                condlog(3, "status = %s", status);
+		disassemble_map (pathvec, params, mpp);
+		
+		/*
+		 * disassemble_map() can add new paths to pathvec.
+		 * If not in "fast list mode", we need to fetch information
+		 * about them
+		 */
+		updatepaths(mpp);
+		mpp->bestpg = select_path_group (mpp);
+		disassemble_status (status, mpp);
+
+	}
+	return MPATH_PR_SUCCESS ;
+}
+
+void * mpath_prin_pthread_fn (void *p)
+{
+	int ret;
+	struct prin_param * pparam = (struct prin_param *)p;
+
+	ret = prin_do_scsi_ioctl(pparam->dev, pparam->rq_servact, pparam->resp,  pparam->noisy);
+	pparam->status = ret;	
+	pthread_exit(NULL);	
+}
+
+int mpath_send_prin_activepath (char * dev, int rq_servact, struct prin_resp * resp, int noisy)
+{
+
+	int rc;
+
+	rc = prin_do_scsi_ioctl(dev, rq_servact, resp,  noisy);
+	
+	return (rc);
+}
+
+int mpath_prout_reg(struct multipath *mpp,int rq_servact, int rq_scope,
+	unsigned int rq_type, struct prout_param_descriptor * paramp, int noisy)
+{
+
+	int i, j;
+	struct pathgroup *pgp = NULL;
+	struct path *pp = NULL;
+	int rollback = 0;
+	int active_pathcount=0;	
+	int rc;
+	int count=0;
+	int status = MPATH_PR_SUCCESS;
+	uint64_t sa_key;	
+
+	if (!mpp)
+		return MPATH_PR_DMMP_ERROR; 
+
+	active_pathcount = pathcount(mpp, PATH_UP) + pathcount(mpp, PATH_GHOST);
+
+	if (active_pathcount == 0) {
+		condlog (0, "%s: no path available", mpp->wwid);
+		return MPATH_PR_DMMP_ERROR;
+	}
+
+	if ( paramp->sa_flags & MPATH_F_ALL_TG_PT_MASK ) {
+		condlog (1, "Warning: ALL_TG_PT is set. Configuration not supported");
+	}
+
+	struct threadinfo thread[active_pathcount];
+
+	memset(thread, 0, sizeof(thread));
+
+	/* init thread parameter */
+	for (i =0; i< active_pathcount; i++){
+		thread[i].param.rq_servact = rq_servact;
+		thread[i].param.rq_scope = rq_scope;
+		thread[i].param.rq_type = rq_type;
+		thread[i].param.paramp = paramp;
+		thread[i].param.noisy = noisy;
+		thread[i].param.status = -1;
+
+		condlog (3, "THRED ID [%d] INFO]", i);
+		condlog (3, "rq_servact=%d ", thread[i].param.rq_servact);
+		condlog (3, "rq_scope=%d ", thread[i].param.rq_scope); 
+		condlog (3, "rq_type=%d ", thread[i].param.rq_type);  
+		condlog (3, "rkey="); 
+		condlog (3, "paramp->sa_flags =%02x ", thread[i].param.paramp->sa_flags); 
+		condlog (3, "noisy=%d ", thread[i].param.noisy); 
+		condlog (3, "status=%d ", thread[i].param.status); 
+	}
+
+	pthread_attr_t attr;
+	pthread_attr_init(&attr);
+	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
+
+	vector_foreach_slot (mpp->pg, pgp, j){
+		vector_foreach_slot (pgp->paths, pp, i){
+			if (!((pp->state == PATH_UP) || (pp->state == PATH_GHOST))){
+				condlog (1, "%s: %s path not up. Skip.", mpp->wwid, pp->dev);
+				continue;
+			}
+			strncpy(thread[count].param.dev, pp->dev, FILE_NAME_SIZE);
+
+			if (count && (thread[count].param.paramp->sa_flags & MPATH_F_SPEC_I_PT_MASK)){
+				/*
+				 * Clearing SPEC_I_PT as transportids are already registered by now.
+				 */
+				thread[count].param.paramp->sa_flags &= (~MPATH_F_SPEC_I_PT_MASK);
+			}
+
+			condlog (3, "%s: sending pr out command to %s", mpp->wwid, pp->dev);
+
+			rc = pthread_create(&thread[count].id, &attr, mpath_prout_pthread_fn, (void *)(&thread[count].param));
+			if (rc){
+				condlog (0, "%s: failed to create thread %d", mpp->wwid, rc);
+			}
+			count = count +1;
+		}
+	}
+	for( i=0; i < active_pathcount ; i++){
+		rc = pthread_join(thread[i].id, NULL);
+		if (rc){
+			condlog (0, "%s: Thread[%d] failed to join thread %d", mpp->wwid, i, rc);
+		}
+		if (!rollback && (thread[i].param.status == MPATH_PR_RESERV_CONFLICT)){
+			rollback = 1;
+			sa_key = 0;
+			for (i = 0; i < 8; ++i){
+				if (i > 0)
+					sa_key <<= 8;
+				sa_key |= paramp->sa_key[i];
+			}
+			status = MPATH_PR_RESERV_CONFLICT ;
+		}
+		if (!rollback && (status == MPATH_PR_SUCCESS)){
+			status = thread[i].param.status;
+		}
+	}
+	if (rollback && ((rq_servact == MPATH_PROUT_REG_SA) && sa_key != 0 )){
+		condlog (3, "%s: ERROR: initiating pr out rollback", mpp->wwid);
+		for( i=0 ; i < active_pathcount ; i++){
+			if((thread[i].param.status == MPATH_PR_SUCCESS) &&
+					((pp->state == PATH_UP) || (pp->state == PATH_GHOST))){
+				memcpy(&thread[i].param.paramp->key, &thread[i].param.paramp->sa_key, 8);
+				memset(&thread[i].param.paramp->sa_key, 0, 8);
+				thread[i].param.status = MPATH_PR_SUCCESS;
+				rc = pthread_create(&thread[i].id, &attr, mpath_prout_pthread_fn, 
+						(void *)(&thread[count].param));
+				if (rc){
+					condlog (0, "%s: failed to create thread for rollback. %d",  mpp->wwid, rc);
+				}
+			}
+		}
+		for(i=0; i < active_pathcount ; i++){
+			rc = pthread_join(thread[i].id, NULL);
+			if (rc){
+				condlog (3, "%s: failed to join thread while rolling back %d",
+						mpp->wwid, i);
+			}
+		}
+	}
+
+	pthread_attr_destroy(&attr);
+	return (status);
+}
+
+void * mpath_prout_pthread_fn(void *p)
+{
+	int ret;
+	struct prout_param * param = (struct prout_param *)p;
+
+	ret = prout_do_scsi_ioctl( param->dev,param->rq_servact, param->rq_scope,
+			param->rq_type, param->paramp, param->noisy);
+	param->status = ret;
+	pthread_exit(NULL);
+}
+
+int mpath_prout_common(struct multipath *mpp,int rq_servact, int rq_scope,
+        unsigned int rq_type, struct prout_param_descriptor* paramp, int noisy)
+{
+	int i,j, ret;
+	struct pathgroup *pgp = NULL;
+	struct path *pp = NULL;
+
+	vector_foreach_slot (mpp->pg, pgp, j){
+		vector_foreach_slot (pgp->paths, pp, i){
+			if (!((pp->state == PATH_UP) || (pp->state == PATH_GHOST))){
+				condlog (1, "%s: %s path not up. Skip", mpp->wwid, pp->dev); 
+				continue;
+			}
+
+			condlog (3, "%s: sending pr out command to %s", mpp->wwid, pp->dev);
+			ret = send_prout_activepath(pp->dev, rq_servact, rq_scope, rq_type, 
+					paramp, noisy); 
+			return ret ;
+		}
+	}
+	return MPATH_PR_SUCCESS;
+}
+
+int send_prout_activepath(char * dev, int rq_servact, int rq_scope,
+	unsigned int rq_type, struct prout_param_descriptor * paramp, int noisy)
+{
+	struct prout_param param;
+	param.rq_servact = rq_servact;
+	param.rq_scope  = rq_scope;
+	param.rq_type   = rq_type;
+	param.paramp    = paramp;
+	param.noisy = noisy;
+	param.status = -1;
+
+	pthread_t thread;
+	pthread_attr_t attr;
+	int rc;
+
+	memset(&thread, 0, sizeof(thread));
+	strncpy(param.dev, dev, FILE_NAME_SIZE);
+	/* Initialize and set thread joinable attribute */
+	pthread_attr_init(&attr);
+	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
+
+	rc = pthread_create(&thread, &attr, mpath_prout_pthread_fn, (void *)(&param));
+	if (rc){
+		condlog (3, "%s: failed to create thread %d", dev, rc);
+		exit(-1);
+	}
+	/* Free attribute and wait for the other threads */
+	pthread_attr_destroy(&attr);
+	rc = pthread_join(thread, NULL);
+
+	return (param.status);
+}
+
+int mpath_prout_rel(struct multipath *mpp,int rq_servact, int rq_scope,
+        unsigned int rq_type, struct prout_param_descriptor * paramp, int noisy)
+{
+	int i, j;
+	int num = 0;
+	struct pathgroup *pgp = NULL;
+	struct path *pp = NULL;
+	int active_pathcount = 0;
+	pthread_attr_t attr;
+	int rc, found = 0;;
+	int count = 0;
+	int status = MPATH_PR_SUCCESS;
+	struct prin_resp resp;
+	struct prout_param_descriptor *pamp;
+	struct prin_resp *pr_buff;
+	int length;
+	struct transportid *pptr;	
+
+	if (!mpp)
+		return MPATH_PR_DMMP_ERROR;
+
+	active_pathcount = pathcount (mpp, PATH_UP) + pathcount (mpp, PATH_GHOST);
+
+	struct threadinfo thread[active_pathcount];
+	memset(thread, 0, sizeof(thread));
+	for (i = 0; i < active_pathcount; i++){
+		thread[i].param.rq_servact = rq_servact;
+		thread[i].param.rq_scope = rq_scope;
+		thread[i].param.rq_type = rq_type;
+		thread[i].param.paramp = paramp;
+		thread[i].param.noisy = noisy;
+		thread[i].param.status = -1;
+
+		condlog (3, " path count = %d", i);
+		condlog (3, "rq_servact=%d ", thread[i].param.rq_servact);
+		condlog (3, "rq_scope=%d ", thread[i].param.rq_scope);
+		condlog (3, "rq_type=%d ", thread[i].param.rq_type);
+		condlog (3, "noisy=%d ", thread[i].param.noisy);
+		condlog (3, "status=%d ", thread[i].param.status);
+	}
+
+	pthread_attr_init (&attr);
+	pthread_attr_setdetachstate (&attr, PTHREAD_CREATE_JOINABLE);
+
+	vector_foreach_slot (mpp->pg, pgp, j){
+		vector_foreach_slot (pgp->paths, pp, i){
+			if (!((pp->state == PATH_UP) || (pp->state == PATH_GHOST))){
+				condlog (1, "%s: %s path not up.", mpp->wwid, pp->dev);
+				continue;
+			}
+			
+			strncpy(thread[count].param.dev, pp->dev, FILE_NAME_SIZE);
+			condlog (3, "%s: sending pr out command to %s", mpp->wwid, pp->dev);
+			rc = pthread_create (&thread[count].id, &attr, mpath_prout_pthread_fn,
+					(void *) (&thread[count].param));
+			if (rc)
+				condlog (0, "%s: failed to create thread. %d",  mpp->wwid, rc);
+			count = count + 1;
+		}
+	}
+	pthread_attr_destroy (&attr);
+	for (i = 0; i < active_pathcount; i++){
+		rc = pthread_join (thread[i].id, NULL);
+		if (rc){
+			condlog (1, "%s: failed to join thread.  %d",  mpp->wwid,  rc);
+		}
+	}
+
+	for (i = 0; i < active_pathcount; i++){
+		/*  check thread status here and return the status */
+
+		if (thread[i].param.status == MPATH_PR_RESERV_CONFLICT)
+			status = MPATH_PR_RESERV_CONFLICT;
+		else if (status == MPATH_PR_SUCCESS
+				&& thread[i].param.status != MPATH_PR_RESERV_CONFLICT)
+			status = thread[i].param.status;
+	}
+
+	status = mpath_prin_activepath (mpp, MPATH_PRIN_RRES_SA, &resp, noisy);
+	if (status != MPATH_PR_SUCCESS){
+		condlog (0, "%s: pr in read reservation command failed.", mpp->wwid);
+		return MPATH_PR_OTHER;
+	}
+
+	num = resp.prin_descriptor.prin_readresv.additional_length / 8;
+	if (num == 0){
+		condlog (2, "%s: Path holding reservation is released.", mpp->wwid);
+		return MPATH_PR_SUCCESS;	
+	}
+	condlog (2, "%s: Path holding reservation is not avialable.", mpp->wwid);
+
+	pr_buff =  mpath_alloc_prin_response(MPATH_PRIN_RFSTAT_SA);
+	if (!pr_buff){
+		condlog (0, "%s: failed to  alloc pr in response buffer.", mpp->wwid);	
+		return MPATH_PR_OTHER;
+	}
+
+	status = mpath_prin_activepath (mpp, MPATH_PRIN_RFSTAT_SA, pr_buff, noisy);
+
+	if (status != MPATH_PR_SUCCESS){
+		condlog (0,  "%s: pr in read full status command failed.",  mpp->wwid);
+		goto out;
+	}
+
+	num = pr_buff->prin_descriptor.prin_readfd.number_of_descriptor;
+	if (0 == num){
+		goto out;
+	}
+	length = sizeof (struct prout_param_descriptor) + (sizeof (struct transportid *));
+
+	pamp = (struct prout_param_descriptor *)malloc (length);
+	if (!pamp){
+		condlog (0, "%s: failed to alloc pr out parameter.", mpp->wwid);
+		goto out1;
+	}
+
+	memset(pamp, 0, length);
+
+	pamp->trnptid_list[0] = (struct transportid *) malloc (sizeof (struct transportid));
+	if (!pamp->trnptid_list[0]){
+		condlog (0, "%s: failed to alloc pr out transportid.", mpp->wwid);
+		goto out1;
+	}
+
+	if (mpp->reservation_key ){
+		memcpy (pamp->key, mpp->reservation_key, 8);
+		condlog (3, "%s: reservation key set.", mpp->wwid);
+	}
+
+	mpath_prout_common (mpp, MPATH_PROUT_CLEAR_SA, rq_scope, rq_type, pamp,
+			noisy);
+
+	pamp->num_transportid = 1;
+	pptr=pamp->trnptid_list[0];
+
+	for (i = 0; i < num; i++){
+		if (mpp->reservation_key && 
+			memcmp(pr_buff->prin_descriptor.prin_readfd.descriptors[i]->key,
+			mpp->reservation_key, 8)){	
+			/*register with tarnsport id*/
+			memset(pamp, 0, length);
+			pamp->trnptid_list[0] = pptr;
+			memset (pamp->trnptid_list[0], 0, sizeof (struct transportid));
+			memcpy (pamp->sa_key,
+					pr_buff->prin_descriptor.prin_readfd.descriptors[i]->key, 8);
+			pamp->sa_flags = MPATH_F_SPEC_I_PT_MASK;
+			pamp->num_transportid = 1;
+
+			memcpy (pamp->trnptid_list[0],
+					&pr_buff->prin_descriptor.prin_readfd.descriptors[i]->trnptid,
+					sizeof (struct transportid));
+			status = mpath_prout_common (mpp, MPATH_PROUT_REG_SA, 0, rq_type,
+					pamp, noisy);
+
+			pamp->sa_flags = 0;
+			memcpy (pamp->key, pr_buff->prin_descriptor.prin_readfd.descriptors[i]->key, 8);
+			memset (pamp->sa_key, 0, 8);
+			pamp->num_transportid = 0;
+			status = mpath_prout_common (mpp, MPATH_PROUT_REG_SA, 0, rq_type,
+					pamp, noisy);
+		}
+		else
+		{
+			if (mpp->reservation_key)
+				found = 1;
+		}
+
+
+	}
+
+	if (found){
+		memset (pamp, 0, length);
+		memcpy (pamp->sa_key, mpp->reservation_key, 8);
+		memset (pamp->key, 0, 8);
+		status = mpath_prout_reg(mpp, MPATH_PROUT_REG_SA, rq_scope, rq_type, pamp, noisy);	
+	}
+
+
+	free(pptr);
+out1:
+	free (pamp);
+out:
+	free (pr_buff);
+	return (status);
+}
+
+void * mpath_alloc_prin_response(int prin_sa)
+{
+	void * ptr = NULL;
+	int size=0;
+	switch (prin_sa)
+	{
+		case MPATH_PRIN_RKEY_SA:
+			size = sizeof(struct prin_readdescr);
+			ptr = malloc(size);
+			memset(ptr, 0, size);
+			break;
+		case MPATH_PRIN_RRES_SA:
+			size = sizeof(struct prin_resvdescr);
+			ptr = malloc(size);
+			memset(ptr, 0, size);
+			break;
+		case MPATH_PRIN_RCAP_SA:
+			size=sizeof(struct prin_capdescr);
+			ptr = malloc(size);
+			memset(ptr, 0, size);
+			break;
+		case MPATH_PRIN_RFSTAT_SA:
+			size = sizeof(struct print_fulldescr_list) + 
+				sizeof(struct prin_fulldescr *)*MPATH_MX_TIDS;
+			ptr = malloc(size);
+			memset(ptr, 0, size);
+			break;
+	}
+	return ptr;
+}
+
+int update_map_pr(struct multipath *mpp)
+{
+	int noisy=0;
+	struct prin_resp *resp;
+	int i,j, ret, isFound;
+	unsigned char *keyp;
+	uint64_t prkey;
+
+	if (!mpp->reservation_key)
+	{
+		/* Nothing to do. Assuming pr mgmt feature is disabled*/
+		condlog(3, "%s: reservation_key not set in multiapth.conf", mpp->alias);
+		return MPATH_PR_SUCCESS;
+	}
+
+	resp = mpath_alloc_prin_response(MPATH_PRIN_RKEY_SA);
+	if (!resp)
+	{
+		condlog(0,"%s : failed to alloc resp in update_map_pr", mpp->alias);
+		return MPATH_PR_OTHER;
+	}
+	ret = mpath_prin_activepath(mpp, MPATH_PRIN_RKEY_SA, resp, noisy);
+
+	if (ret != MPATH_PR_SUCCESS )
+	{
+		condlog(0,"%s : pr in read keys service action failed Error=%d", mpp->alias, ret);
+		free(resp);
+		return  ret;
+	}
+
+	if (resp->prin_descriptor.prin_readkeys.additional_length == 0 )
+	{
+		condlog(0,"%s: No key found. Device may not be registered. ", mpp->alias);
+		free(resp);
+		return MPATH_PR_SUCCESS;
+	}
+
+	prkey = 0;
+	keyp = mpp->reservation_key;
+	for (j = 0; j < 8; ++j) {
+		if (j > 0)
+			prkey <<= 8;
+		prkey |= *keyp;
+		++keyp;
+	}
+	condlog(2, "%s: Multipath  reservation_key: 0x%" PRIx64 " ", mpp->alias, prkey);
+
+	isFound =0;
+	for (i = 0; i < resp->prin_descriptor.prin_readkeys.additional_length/8; i++ )
+	{
+		condlog(2, "%s: PR IN READKEYS[%d]  reservation key:", mpp->alias, i);
+		dumpHex((char *)&resp->prin_descriptor.prin_readkeys.key_list[i*8], 8 , 1);
+
+		if (!memcmp(mpp->reservation_key, &resp->prin_descriptor.prin_readkeys.key_list[i*8], 8))
+		{
+			condlog(2, "%s: reservation key found in pr in readkeys response", mpp->alias);
+			isFound =1;
+		}
+	}
+
+	if (isFound)
+	{
+		mpp->prflag = 1;
+		condlog(2, "%s: prflag flag set.", mpp->alias );
+	}
+
+	free(resp);
+	return MPATH_PR_SUCCESS;
+}
+
+
+
diff --git a/libmpathpersist/mpath_persist.h b/libmpathpersist/mpath_persist.h
new file mode 100644
index 0000000..42294e9
--- /dev/null
+++ b/libmpathpersist/mpath_persist.h
@@ -0,0 +1,241 @@
+/* version - 1.0 */
+
+#ifndef MPATH_PERSIST_LIB_H
+#define MPATH_PERSIST_LIB_H
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <inttypes.h>
+
+#define MPATH_MAX_PARAM_LEN	8192
+
+#define MPATH_MX_TIDS 		32	  /* Max number of transport ids"*/
+#define MPATH_MX_TID_LEN	256	  /* Max lenght of transport id */
+
+/* PRIN Service Actions */
+#define MPATH_PRIN_RKEY_SA	0x00	   /* READ KEYS SA*/
+#define MPATH_PRIN_RRES_SA	0x01	   /* READ RESERVATION  SA*/
+#define MPATH_PRIN_RCAP_SA	0x02	   /* REPORT CAPABILITIES SA*/
+#define MPATH_PRIN_RFSTAT_SA	0x03	   /* READ FULL STATUS SA*/
+
+/* PROUT Service Actions */
+#define MPATH_PROUT_REG_SA	0x00	    /* REGISTER SA */
+#define MPATH_PROUT_RES_SA	0x01	    /* RESERVE SA*/
+#define MPATH_PROUT_REL_SA	0x02	    /* RELEASE SA*/
+#define MPATH_PROUT_CLEAR_SA	0x03	    /* CLEAR SA*/
+#define MPATH_PROUT_PREE_SA	0x04	    /* PREEMPT SA*/
+#define MPATH_PROUT_PREE_AB_SA	0x05	    /* PREEMPT AND ABORT SA*/
+#define MPATH_PROUT_REG_IGN_SA	0x06	    /* REGISTER AND IGNORE EXISTING KEY SA*/
+#define MPATH_PROUT_REG_MOV_SA	0x07	    /* REGISTER AND MOVE SA*/
+
+#define MPATH_LU_SCOPE		0x00	    /* LU_SCOPE */
+
+/* Persistent reservations type */
+#define MPATH_PRTPE_WE	 	0x01	    /* Write Exclusive */
+#define MPATH_PRTPE_EA 		0x03	    /* Exclusive Access*/
+#define MPATH_PRTPE_WE_RO 	0x05	    /* WriteExclusive Registrants Only */
+#define MPATH_PRTPE_EA_RO 	0x06	    /* Exclusive Access. Registrants Only*/
+#define MPATH_PRTPE_WE_AR	0x07	    /* Write Exclusive. All Registrants*/
+#define MPATH_PRTPE_EA_AR 	0x08	    /* Exclusive Access. All Registrants */
+
+
+/* PR RETURN_STATUS */
+#define MPATH_PR_SUCCESS 		0
+#define MPATH_PR_SYNTAX_ERROR		1   /*  syntax error or invalid parameter */
+					    /* status for check condition */
+#define MPATH_PR_SENSE_NOT_READY 	2   /*	[sk,asc,ascq: 0x2,*,*] */
+#define MPATH_PR_SENSE_MEDIUM_ERROR	3   /*	[sk,asc,ascq: 0x3,*,*] */
+#define MPATH_PR_SENSE_HARDWARE_ERROR	4   /*	[sk,asc,ascq: 0x4,*,*] */
+#define MPATH_PR_ILLEGAL_REQ 		5   /*	[sk,asc,ascq: 0x5,*,*]*/
+#define MPATH_PR_SENSE_UNIT_ATTENTION	6   /*	[sk,asc,ascq: 0x6,*,*] */
+#define MPATH_PR_SENSE_INVALID_OP	7   /* 	[sk,asc,ascq: 0x5,0x20,0x0]*/
+#define MPATH_PR_SENSE_ABORTED_COMMAND  8   /*  [sk,asc,ascq: 0xb,*,*] */
+#define MPATH_PR_NO_SENSE		9   /*	[sk,asc,ascq: 0x0,*,*] */
+
+#define MPATH_PR_SENSE_MALFORMED	10  /* Response to SCSI command malformed */
+#define MPATH_PR_RESERV_CONFLICT	11  /* Reservation conflict on the device */
+#define MPATH_PR_FILE_ERROR		12  /* file (device node) problems(e.g. not found)*/
+#define MPATH_PR_DMMP_ERROR		13  /* DMMP related error.(e.g Error in getting dm info */
+#define MPATH_PR_OTHER			14  /*other error/warning has occurred(transport
+					      or driver error) */
+
+/* PR MASK */
+#define MPATH_F_APTPL_MASK		0x01	/* APTPL MASK*/
+#define MPATH_F_ALL_TG_PT_MASK		0x04	/* ALL_TG_PT MASK*/
+#define MPATH_F_SPEC_I_PT_MASK		0x08	/* SPEC_I_PT MASK*/
+#define MPATH_PR_TYPE_MASK 		0x0f	/* TYPE MASK*/
+#define MPATH_PR_SCOPE_MASK		0xf0	/* SCOPE MASK*/
+
+/*Transport ID PROTOCOL IDENTIFIER values */
+#define MPATH_PROTOCOL_ID_FC		0x00
+#define MPATH_PROTOCOL_ID_ISCSI		0x05
+#define MPATH_PROTOCOL_ID_SAS		0x06
+
+
+/*Transport ID FORMATE CODE */
+#define MPATH_WWUI_DEVICE_NAME		0x00	/* World wide unique initiator device name */
+#define MPATH_WWUI_PORT_IDENTIFIER	0x40	/* World wide unique initiator port identifier	*/
+
+
+
+
+struct prin_readdescr
+{
+	uint32_t prgeneration;
+	uint32_t additional_length;	/* The value should be either 0 or divisible by 8.
+					   0 indicates no registered reservation key. */
+	uint8_t	 key_list[MPATH_MAX_PARAM_LEN];
+};
+
+struct prin_resvdescr
+{
+	uint32_t prgeneration;
+	uint32_t additional_length;	/* The value should be either 0 or 10h. 0 indicates
+					   there is no reservation held. 10h indicates the
+					   key[8] and scope_type have valid values */
+	uint8_t  key[8];
+	uint32_t _obsolete;
+	uint8_t  _reserved;
+	uint8_t  scope_type;            /* Use PR SCOPE AND TYPE MASK specified above */
+	uint16_t _obsolete1;
+};
+
+struct prin_capdescr
+{
+	uint16_t length;
+	uint8_t  flags[2];
+	uint16_t pr_type_mask;
+	uint16_t _reserved;
+};
+
+struct transportid
+{
+	uint8_t format_code;
+	uint8_t protocol_id;
+	union {
+		uint8_t n_port_name[8];	/* FC transport*/
+		uint8_t sas_address[8];	/* SAS transport */
+		uint8_t iscsi_name[256]; /* ISCSI  transport */
+	};
+};
+
+struct prin_fulldescr
+{
+	uint8_t key[8];
+	uint8_t flag; 			/* All_tg_pt and reservation holder */
+	uint8_t scope_type;		/* Use PR SCOPE AND TYPE MASK specified above.
+					   Meaningful only for reservation holder */
+	uint16_t rtpi;
+	struct transportid trnptid;
+};
+
+struct print_fulldescr_list
+{
+	uint32_t prgeneration;
+	uint32_t number_of_descriptor;
+	uint8_t private_buffer[MPATH_MAX_PARAM_LEN]; /*Private buffer for list storage*/
+	struct prin_fulldescr *descriptors[];
+};
+
+struct prin_resp
+{
+	union
+	{
+		struct prin_readdescr prin_readkeys; /* for PRIN read keys SA*/
+		struct prin_resvdescr prin_readresv; /* for PRIN read reservation SA*/
+		struct prin_capdescr  prin_readcap;  /* for PRIN Report Capabilities SA*/
+		struct print_fulldescr_list prin_readfd;   /* for PRIN read full status SA*/
+	}prin_descriptor;
+};
+
+struct prout_param_descriptor { 	/* PROUT parameter descriptor */
+	uint8_t	 key[8];
+	uint8_t	 sa_key[8];
+	uint32_t _obsolete;
+	uint8_t	 sa_flags;
+	uint8_t _reserved;
+	uint16_t _obsolete1;
+	uint8_t  private_buffer[MPATH_MAX_PARAM_LEN]; /*private buffer for list storage*/
+	uint32_t num_transportid;	/* Number of Transport ID listed in trnptid_list[]*/
+	struct transportid *trnptid_list[];
+};
+
+
+/* Function declarations */
+
+/*
+ * DESCRIPTION :
+ *	Initialize device mapper multipath configuration. This function must be invoked first
+ *	before performing reservation management functions.
+ * RESTRICTIONS:
+ *
+ * RETURNS: 0->Success, 1->Failed.
+ */
+extern int mpath_lib_init (void );
+
+
+/*
+ * DESCRIPTION :
+ *	Release device mapper multipath configuration. This function must be invoked after
+ *	performing reservation management functions.
+ * RESTRICTIONS:
+ *
+ * RETURNS: 0->Success, 1->Failed.
+ */
+extern int mpath_lib_exit (void );
+
+
+/*
+ * DESCRIPTION :
+ * This function sends PRIN command to the DM device and get the response.
+ *
+ * @fd:	The file descriptor of a multipath device. Input argument.
+ * @rq_servact: PRIN command service action. Input argument
+ * @resp: The response from PRIN service action. The resp is a struct specified below. The caller should
+ * 	manage the memory allocation of this struct
+ * @noisy: Turn on debugging trace: Input argument. 0->Disable, 1->Enable
+ * @verbose: Set verbosity level. Input argument. value:[0-3]. 0->disabled, 3->Max verbose
+ *
+ * RESTRICTIONS:
+ *
+ * RETURNS: MPATH_PR_SUCCESS if PR command successful else returns any of the PR status (specified
+ *	 above).
+ *
+ */
+extern int mpath_persistent_reserve_in (int fd, int rq_servact, struct prin_resp *resp,
+		int noisy, int verbose);
+
+/*
+ * DESCRIPTION :
+ * This function sends PROUT command to the DM device and get the response.
+ *
+ * @fd: The file descriptor of a multipath device. Input argument.
+ * @rq_servact: PROUT command service action. Input argument
+ * @rq_scope: Persistent reservation scope. The value should be always LU_SCOPE (0h).
+ * @rq_type: Persistent reservation type. The valid values of persistent reservation types are
+ *	5h (Write exclusive - registrants only)
+ *	8h (Exclusive access - registrants only)
+ *	7h (Write exclusive - All registrants)
+ *	8h (Exclusive access - All registrants).
+ * @paramp: PROUT command parameter data. The paramp is a struct which describes PROUT
+ * 	    parameter list. The caller should manage the memory allocation of this struct.
+ * @noisy: Turn on debugging trace: Input argument.0->Disable, 1->Enable.
+ * @verbose: Set verbosity level. Input argument. value:0 to 3. 0->disabled, 3->Max verbose
+ *
+ * RESTRICTIONS:
+ *
+ * RETURNS: MPATH_PR_SUCCESS if PR command successful else returns any of the status specified
+ *       above in RETURN_STATUS.
+ */
+extern int mpath_persistent_reserve_out ( int fd, int rq_servact, int rq_scope,
+		unsigned int rq_type, struct prout_param_descriptor *paramp, int noisy,
+		int verbose);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /*MPATH_PERSIST_LIB_H*/
diff --git a/libmpathpersist/mpath_persistent_reserve_in.3 b/libmpathpersist/mpath_persistent_reserve_in.3
new file mode 100644
index 0000000..c404e13
--- /dev/null
+++ b/libmpathpersist/mpath_persistent_reserve_in.3
@@ -0,0 +1,80 @@
+.\"
+.TH MPATH_PERSISTENT_RESERVE_IN 3  2011-04-08 "Linux Manpage" 
+.SH NAME
+mpath_persistent_reserve_in
+.SH SYNOPSIS
+.B #include <mpath_persist.h>
+.sp
+.BI "int mpath_persistent_reserve_in (int fd, int rq_servact, struct prin_resp *resp, int noisy, int verbose)"
+.sp
+.SH DESCRIPTION
+The function in the
+.BR mpath_persistent_reserve_in ()
+sends PRIN command to the DM device and gets the response.
+.br
+.BI Parameters:
+.br
+.I fd
+.B The file descriptor of a multipath device. Input argument.
+.br
+.I rq_servact
+.B PRIN command service action. Input argument
+.br
+.I resp
+.B The response from PRIN service action. The caller should manage the memory allocation of this structure
+.br
+.I noisy
+.B Turn on debugging trace: Input argument. 0->Disable, 1->Enable
+.br
+.I verbose
+.B Set verbosity level. Input argument. value:[0-3]. 0->Crits and Errors, 1->Warnings, 2->Info, 3->Debug
+.br
+
+.SH "RETURNS"
+.I MPATH_PR_SUCCESS
+.B if PR command successful
+.br
+.I MPATH_PR_SYNTAX_ERROR        
+.B if  syntax error or invalid parameter
+.br
+.I MPATH_PR_SENSE_NOT_READY     
+.B  if command fails with [sk,asc,ascq: 0x2,*,*]
+.br
+.I MPATH_PR_SENSE_MEDIUM_ERROR
+.B  if command fails with [sk,asc,ascq: 0x3,*,*]
+.br
+.I MPATH_PR_SENSE_HARDWARE_ERROR
+.B  if command fails with [sk,asc,ascq: 0x4,*,*]
+.br
+.I MPATH_PR_SENSE_INVALID_OP
+.B  if command fails with [sk,asc,ascq: 0x5,0x20,0x0]
+.br
+.I MPATH_PR_ILLEGAL_REQ
+.B  if command fails with [sk,asc,ascq: 0x5,*,*]
+.br
+.I MPATH_PR_SENSE_UNIT_ATTENTION
+.B  if command fails with [sk,asc,ascq: 0x6,*,*]
+.br
+.I MPATH_PR_SENSE_ABORTED_COMMAND
+.B  if command fails with [sk,asc,ascq: 0xb,*,*]
+.br
+.I MPATH_PR_NO_SENSE
+.B  if command fails with [sk,asc,ascq: 0x0,*,*]
+.br
+.I MPATH_PR_SENSE_MALFORMED  
+.B if command fails with SCSI command malformed
+.br
+.I MPATH_PR_FILE_ERROR
+.B if command fails while accessing file (device node) problems(e.g. not found)
+.br
+.I MPATH_PR_DMMP_ERROR
+.B if Device Mapper related error.(e.g Error in getting dm info) 
+.br
+.I MPATH_PR_OTHER
+.B if other error/warning has occurred(e.g transport or driver error)
+.br
+
+
+.SH "SEE ALSO"
+.I  mpath_persistent_reserve_out      mpathpersist     /usr/share/doc/mpathpersist/README
+.br
diff --git a/libmpathpersist/mpath_persistent_reserve_out.3 b/libmpathpersist/mpath_persistent_reserve_out.3
new file mode 100644
index 0000000..44f950b
--- /dev/null
+++ b/libmpathpersist/mpath_persistent_reserve_out.3
@@ -0,0 +1,92 @@
+.\"
+.TH MPATH_PERSISTENT_RESERVE_OUT 3  2011-04-08 "Linux Manpage" 
+.SH NAME
+mpath_persistent_reserve_out
+.SH SYNOPSIS
+.B #include <mpath_persist.h>
+.sp
+.BI "int mpath_persistent_reserve_out (int fd, int rq_servact, struct prin_resp *resp, int noisy, int verbose)"
+.sp
+.SH DESCRIPTION
+The function in the
+.BR mpath_persistent_reserve_out ()
+sends PR OUT command to the DM device and gets the response.
+.br
+.BI Parameters:
+.br
+.I fd 
+.B The file descriptor of a multipath device. Input argument.
+.br
+.I rq_servact
+.B PROUT command service action. Input argument
+.br
+.I rq_scope
+.B Persistent reservation scope. The value should be always LU_SCOPE (0h).
+.br
+.I rq_type
+.B Persistent reservation type. The valid values of persistent reservation types are
+      5h (Write exclusive - registrants only)
+      8h (Exclusive access - registrants only)
+      7h (Write exclusive - All registrants)
+      8h (Exclusive access - All registrants).
+.br
+.I paramp
+.B PROUT command parameter data. The paramp is a struct which describes PROUT parameter list. Caller should manage the memory allocation of this structure.
+.br
+.I noisy
+.B Turn on debugging trace: Input argument. 0->Disable, 1->Enable.
+.br
+.I verbose
+.B Set verbosity level. Input argument. value: 0 to 3. 0->Crits and Errors, 1->Warnings, 2->Info, 3->Debug
+
+.SH "RETURNS"
+.I MPATH_PR_SUCCESS
+.B if PR command successful else returns any one of the status mentioned below
+.br
+.I MPATH_PR_SYNTAX_ERROR        
+.B if  syntax error or invalid parameter
+.br
+.I MPATH_PR_SENSE_NOT_READY     
+.B  if command fails with [sk,asc,ascq: 0x2,*,*]
+.br
+.I MPATH_PR_SENSE_MEDIUM_ERROR
+.B  if command fails with [sk,asc,ascq: 0x3,*,*]
+.br
+.I MPATH_PR_SENSE_HARDWARE_ERROR
+.B  if command fails with [sk,asc,ascq: 0x4,*,*]
+.br
+.I MPATH_PR_SENSE_INVALID_OP
+.B  if command fails with [sk,asc,ascq: 0x5,0x20,0x0]
+.br
+.I MPATH_PR_ILLEGAL_REQ
+.B  if command fails with [sk,asc,ascq: 0x5,*,*]
+.br
+.I MPATH_PR_SENSE_UNIT_ATTENTION
+.B  if command fails with [sk,asc,ascq: 0x6,*,*]
+.br
+.I MPATH_PR_SENSE_ABORTED_COMMAND
+.B  if command fails with [sk,asc,ascq: 0xb,*,*]
+.br
+.I MPATH_PR_NO_SENSE
+.B  if command fails with [sk,asc,ascq: 0x0,*,*]
+.br
+.I MPATH_PR_SENSE_MALFORMED  
+.B if command fails with SCSI command malformed
+.br
+.I MPATH_PR_RESERV_CONFLICT
+.B if command fails with reservation conflict
+.br
+.I MPATH_PR_FILE_ERROR
+.B if command fails while accessing file (device node) problems(e.g. not found)
+.br
+.I MPATH_PR_DMMP_ERROR
+.B if Device Mapper related error.(e.g Error in getting dm info) 
+.br
+.I MPATH_PR_OTHER
+.B if other error/warning has occurred(e.g transport or driver error)
+.br
+
+
+.SH "SEE ALSO"
+.I  mpath_persistent_reserve_in		mpathpersist     /usr/share/doc/mpathpersist/README
+.br
diff --git a/libmpathpersist/mpath_pr_ioctl.c b/libmpathpersist/mpath_pr_ioctl.c
new file mode 100644
index 0000000..2d4d968
--- /dev/null
+++ b/libmpathpersist/mpath_pr_ioctl.c
@@ -0,0 +1,574 @@
+#include <stdio.h>
+#include <stdlib.h>
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <scsi/sg.h>
+#include <scsi/scsi.h>
+#include <unistd.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <unistd.h>
+#include "mpath_pr_ioctl.h" 
+#include <mpath_persist.h> 
+
+#include <debug.h>
+
+#define FILE_NAME_SIZE          256
+
+#define TIMEOUT 2000
+#define MAXRETRY 5
+
+int prin_do_scsi_ioctl(char * dev, int rq_servact, struct prin_resp *resp, int noisy);
+void mpath_format_readkeys(struct prin_resp *pr_buff, int len , int noisy);
+void mpath_format_readfullstatus(struct prin_resp *pr_buff, int len, int noisy);
+int mpath_translate_response (char * dev, struct sg_io_hdr io_hdr, SenseData_t Sensedata, int noisy);
+void dumpHex(const char* str, int len, int no_ascii);
+int prout_do_scsi_ioctl( char * dev, int rq_servact, int rq_scope,
+                unsigned int rq_type, struct prout_param_descriptor *paramp, int noisy);
+uint32_t  format_transportids(struct prout_param_descriptor *paramp);
+void mpath_reverse_uint32_byteorder(uint32_t *num);
+void mpath_reverse_uint16_byteorder(uint16_t *num);
+void decode_transport_id(struct prin_fulldescr *fdesc, unsigned char * p, int length);
+int get_prin_length(int rq_servact);
+int mpath_isLittleEndian(void);
+
+extern unsigned int mpath_mx_alloc_len;
+
+int prout_do_scsi_ioctl(char * dev, int rq_servact, int rq_scope,
+                unsigned int rq_type, struct prout_param_descriptor *paramp, int noisy)
+{
+
+	int status, paramlen = 24, ret = 0;
+	uint32_t translen=0;
+	int retry = MAXRETRY;
+	SenseData_t Sensedata;
+	struct sg_io_hdr io_hdr;
+	char devname[FILE_NAME_SIZE];
+	int fd = -1;
+
+	snprintf(devname, FILE_NAME_SIZE, "/dev/%s",dev);
+	fd = open(devname, O_WRONLY);
+	if(fd < 0){
+		condlog (1, "%s: unable to open device.", dev);
+		return MPATH_PR_FILE_ERROR;
+	}
+
+	unsigned char cdb[MPATH_PROUT_CMDLEN] =
+	{MPATH_PROUT_CMD, 0, 0, 0, 0, 0, 0, 0, 0, 0};
+
+
+	if (paramp->sa_flags & MPATH_F_SPEC_I_PT_MASK)
+	{
+		translen = format_transportids(paramp);
+		paramlen = 24 + translen;
+	}	
+	else
+		paramlen = 24;
+
+	if ( rq_servact > 0)
+		cdb[1] = (unsigned char)(rq_servact & 0x1f);
+	cdb[2] = (((rq_scope & 0xf) << 4) | (rq_type & 0xf));
+	cdb[7] = (unsigned char)((paramlen >> 8) & 0xff);
+	cdb[8] = (unsigned char)(paramlen & 0xff);
+
+retry :
+	condlog(3, "%s: rq_servact = %d", dev, rq_servact); 
+	condlog(3, "%s: rq_scope = %d ", dev, rq_scope);
+	condlog(3, "%s: rq_type = %d ", dev, rq_type);
+	condlog(3, "%s: paramlen = %d", dev, paramlen);
+
+	if (noisy)
+	{
+		condlog(3, "%s: Persistent Reservation OUT parameter:", dev);
+		dumpHex((const char *)paramp, paramlen,1);
+	}
+
+	memset(&Sensedata, 0, sizeof(SenseData_t));
+	memset(&io_hdr,0 , sizeof( struct sg_io_hdr));
+	io_hdr.interface_id = 'S';
+	io_hdr.cmd_len = MPATH_PROUT_CMDLEN;
+	io_hdr.cmdp = cdb;
+	io_hdr.sbp = (void *)&Sensedata;
+	io_hdr.mx_sb_len = sizeof (SenseData_t);
+	io_hdr.timeout = TIMEOUT;
+
+	if (paramlen > 0) {
+		io_hdr.dxferp = (void *)paramp;
+		io_hdr.dxfer_len = paramlen;
+		io_hdr.dxfer_direction = SG_DXFER_TO_DEV ;
+	}
+	else {
+		io_hdr.dxfer_direction = SG_DXFER_NONE;
+	}
+	ret = ioctl(fd, SG_IO, &io_hdr);
+	if (ret < 0)
+	{
+		condlog(0, "%s: ioctl failed %d", dev, ret);
+		close(fd);
+		return ret;
+	}
+
+	condlog(2, "%s: Duration=%u (ms)", dev, io_hdr.duration);
+
+	status = mpath_translate_response(dev, io_hdr, Sensedata, noisy);
+	condlog(3, "%s: status = %d", dev, status);
+
+	if (status == MPATH_PR_SENSE_UNIT_ATTENTION && (retry > 0))
+	{
+		--retry;
+		condlog(2, "%s: retrying for Unit Attention. Remaining retries = %d", 
+			dev, retry);
+		goto retry;
+	}
+
+	if (((status == MPATH_PR_SENSE_NOT_READY )&& (Sensedata.ASC == 0x04)&&
+				(Sensedata.ASCQ == 0x07))&& (retry > 0))
+	{
+		usleep(1000);
+		--retry;
+		condlog(2, "%s: retrying for sense 02/04/07."
+			" Remaining retries = %d", dev, retry);
+		goto retry;
+	}
+
+	close(fd);	
+	return status;
+}
+
+uint32_t  format_transportids(struct prout_param_descriptor *paramp)
+{
+	int i = 0, len;	
+	uint32_t buff_offset = 4;
+	memset(paramp->private_buffer, 0, MPATH_MAX_PARAM_LEN);
+	for (i=0; i < paramp->num_transportid; i++ )
+	{
+		paramp->private_buffer[buff_offset] = (uint8_t)((paramp->trnptid_list[i]->format_code & 0xff)|
+							(paramp->trnptid_list[i]->protocol_id & 0xff));
+		buff_offset += 1;
+		switch(paramp->trnptid_list[i]->protocol_id)
+		{
+			case MPATH_PROTOCOL_ID_FC:
+				buff_offset += 7;
+				memcpy(&paramp->private_buffer[buff_offset], &paramp->trnptid_list[i]->n_port_name, 8);
+				buff_offset +=8 ;
+				buff_offset +=8 ;
+				break;
+			case MPATH_PROTOCOL_ID_SAS:
+				buff_offset += 3;
+				memcpy(&paramp->private_buffer[buff_offset], &paramp->trnptid_list[i]->sas_address, 8);
+				buff_offset += 12;
+				break;
+			case MPATH_PROTOCOL_ID_ISCSI:
+				buff_offset += 1;
+				len = (paramp->trnptid_list[i]->iscsi_name[1] & 0xff)+2;	
+				memcpy(&paramp->private_buffer[buff_offset], &paramp->trnptid_list[i]->iscsi_name,len);
+				buff_offset += len ; 
+				break;
+		}
+
+	}
+	buff_offset -= 4; 
+	paramp->private_buffer[0] = (unsigned char)((buff_offset >> 24) & 0xff);
+	paramp->private_buffer[1] = (unsigned char)((buff_offset >> 16) & 0xff);
+	paramp->private_buffer[2] = (unsigned char)((buff_offset >> 8) & 0xff);
+	paramp->private_buffer[3] = (unsigned char)(buff_offset & 0xff);
+	buff_offset += 4; 
+	return buff_offset;	
+}
+
+void mpath_format_readkeys( struct prin_resp *pr_buff, int len, int noisy)
+{
+        mpath_reverse_uint32_byteorder(&pr_buff->prin_descriptor.prin_readkeys.prgeneration);
+        mpath_reverse_uint32_byteorder(&pr_buff->prin_descriptor.prin_readkeys.additional_length);
+}
+
+void mpath_format_readresv(struct prin_resp *pr_buff, int len, int noisy)
+{
+
+        mpath_reverse_uint32_byteorder(&pr_buff->prin_descriptor.prin_readkeys.prgeneration);
+        mpath_reverse_uint32_byteorder(&pr_buff->prin_descriptor.prin_readkeys.additional_length);
+
+        return;
+}
+
+void mpath_format_reportcapabilities(struct prin_resp *pr_buff, int len, int noisy)
+{
+        mpath_reverse_uint16_byteorder(&pr_buff->prin_descriptor.prin_readcap.length);
+        mpath_reverse_uint16_byteorder(&pr_buff->prin_descriptor.prin_readcap.pr_type_mask);
+
+        return;
+}
+
+void mpath_format_readfullstatus(struct prin_resp *pr_buff, int len, int noisy)
+{
+	int num, k, tid_len_len=0;
+	uint32_t fdesc_count=0;
+	unsigned char *p;
+	char  *ppbuff;
+	uint32_t additional_length;
+
+
+	mpath_reverse_uint32_byteorder(&pr_buff->prin_descriptor.prin_readfd.prgeneration);
+	mpath_reverse_uint32_byteorder(&pr_buff->prin_descriptor.prin_readfd.number_of_descriptor);
+
+	if (0 == pr_buff->prin_descriptor.prin_readfd.number_of_descriptor)
+	{
+		return ;
+	}
+
+
+	if (pr_buff->prin_descriptor.prin_readfd.number_of_descriptor == 0)
+	{
+		condlog(2, "No registration or resrvation found.");
+		return;
+	}
+
+	additional_length = pr_buff->prin_descriptor.prin_readfd.number_of_descriptor;
+
+	char tempbuff[MPATH_MAX_PARAM_LEN];
+	struct prin_fulldescr fdesc;
+	memset(&fdesc, 0, sizeof(struct prin_fulldescr));
+
+	memcpy( tempbuff, pr_buff->prin_descriptor.prin_readfd.private_buffer,MPATH_MAX_PARAM_LEN );
+	memset(&pr_buff->prin_descriptor.prin_readfd.private_buffer, 0, MPATH_MAX_PARAM_LEN);
+
+	p =(unsigned char *)tempbuff;
+	ppbuff = (char *)pr_buff->prin_descriptor.prin_readfd.private_buffer;
+
+	for (k = 0; k < additional_length; k += num, p += num) {
+		memcpy(&fdesc.key, p, 8 );
+		fdesc.flag = p[12];
+		fdesc.scope_type =  p[13];
+		fdesc.rtpi = ((p[18] << 8) | p[19]);
+
+		tid_len_len = ((p[20] << 24) | (p[21] << 16) |
+				(p[22] << 8) | p[23]);
+
+		if (tid_len_len > 0)
+			decode_transport_id( &fdesc, &p[24], tid_len_len);
+
+		num = 24 + tid_len_len;
+		memcpy(ppbuff, &fdesc, sizeof(struct prin_fulldescr));
+		pr_buff->prin_descriptor.prin_readfd.descriptors[fdesc_count]= (struct prin_fulldescr *)ppbuff;
+		ppbuff += sizeof(struct prin_fulldescr);
+		++fdesc_count;
+	}
+
+	pr_buff->prin_descriptor.prin_readfd.number_of_descriptor = fdesc_count;
+
+	return;
+}
+
+void
+decode_transport_id(struct prin_fulldescr *fdesc, unsigned char * p, int length)
+{
+	int num, k;
+	int jump;
+	for (k = 0, jump = 24; k < length; k += jump, p += jump) {
+		fdesc->trnptid.format_code = ((p[0] >> 6) & 0x3);
+		fdesc->trnptid.protocol_id = (p[0] & 0xf);
+		switch (fdesc->trnptid.protocol_id) {
+			case MPATH_PROTOCOL_ID_FC:
+				memcpy(&fdesc->trnptid.n_port_name, &p[8], 8);
+				jump = 24;
+				break;
+			case MPATH_PROTOCOL_ID_ISCSI:
+				num = ((p[2] << 8) | p[3]);
+				memcpy(&fdesc->trnptid.iscsi_name, &p[4], num);
+				jump = (((num + 4) < 24) ? 24 : num + 4);
+				break;
+			case MPATH_PROTOCOL_ID_SAS:
+				memcpy(&fdesc->trnptid.sas_address, &p[4], 8);
+				jump = 24;
+				break;
+			default:
+				jump = 24;
+				break;
+		}
+	}
+}
+
+int prin_do_scsi_ioctl(char * dev, int rq_servact, struct prin_resp * resp, int noisy)
+{
+
+	int ret, status, got, fd;
+	int mx_resp_len;
+	SenseData_t Sensedata;
+	int retry = MAXRETRY;
+	struct sg_io_hdr io_hdr;
+	char devname[FILE_NAME_SIZE];
+	unsigned char cdb[MPATH_PRIN_CMDLEN] =
+	{MPATH_PRIN_CMD, 0, 0, 0, 0, 0, 0, 0, 0, 0};
+
+	snprintf(devname, FILE_NAME_SIZE, "/dev/%s",dev);
+        fd = open(devname, O_WRONLY);
+        if(fd < 0){
+        	condlog(0, "%s: Unable to open device ", dev);
+		return MPATH_PR_FILE_ERROR;
+         }
+
+	if (mpath_mx_alloc_len)
+		mx_resp_len = mpath_mx_alloc_len;
+	else
+		mx_resp_len = get_prin_length(rq_servact);
+
+	cdb[1] = (unsigned char)(rq_servact & 0x1f);
+	cdb[7] = (unsigned char)((mx_resp_len >> 8) & 0xff);
+	cdb[8] = (unsigned char)(mx_resp_len & 0xff);
+
+retry :
+	memset(&Sensedata, 0, sizeof(SenseData_t));
+	memset(&io_hdr,0 , sizeof( struct sg_io_hdr));
+
+	io_hdr.interface_id = 'S';
+	io_hdr.cmd_len = MPATH_PRIN_CMDLEN;
+	io_hdr.mx_sb_len = sizeof (SenseData_t);
+	io_hdr.dxfer_direction = SG_DXFER_FROM_DEV;
+	io_hdr.cmdp = cdb;
+	io_hdr.sbp = (void *)&Sensedata;
+	io_hdr.timeout = TIMEOUT;
+
+
+
+	io_hdr.dxfer_len = mx_resp_len;
+	io_hdr.dxferp = (void *)resp;
+
+	ret =ioctl(fd, SG_IO, &io_hdr);
+	if (ret < 0){
+		condlog(0, "%s: IOCTL failed %d", dev, ret);
+		status = MPATH_PR_OTHER;
+		goto out;
+	}
+
+	got = mx_resp_len - io_hdr.resid;
+
+	condlog(2, "%s: duration = %u (ms)", dev, io_hdr.duration);
+	condlog(2, "%s: persistent reservation in: requested %d bytes but got %d bytes)", dev, mx_resp_len, got);
+
+	status = mpath_translate_response(dev, io_hdr, Sensedata, noisy);
+
+	if (status == MPATH_PR_SENSE_UNIT_ATTENTION && (retry > 0))
+	{
+		--retry;
+		condlog(2, "%s: retrying for Unit Attention. Remaining retries = %d", dev, retry);
+		goto retry;
+	}
+
+	if (((status == MPATH_PR_SENSE_NOT_READY )&& (Sensedata.ASC == 0x04)&&
+				(Sensedata.ASCQ == 0x07))&& (retry > 0))
+	{
+		usleep(1000);
+		--retry;
+		condlog(2, "%s: retrying for 02/04/07. Remaining retries = %d", dev, retry);
+		goto retry;
+	}
+
+	if (status != MPATH_PR_SUCCESS)
+		goto out;
+
+	if (noisy)
+		dumpHex((const char *)resp, got , 1);
+
+
+	switch (rq_servact)
+	{
+		case MPATH_PRIN_RKEY_SA :
+			mpath_format_readkeys(resp, got, noisy);
+			break;
+		case MPATH_PRIN_RRES_SA :
+			mpath_format_readresv(resp, got, noisy);
+			break;
+		case MPATH_PRIN_RCAP_SA :
+			mpath_format_reportcapabilities(resp, got, noisy);
+			break;
+		case MPATH_PRIN_RFSTAT_SA :
+			mpath_format_readfullstatus(resp, got, noisy);
+	}
+
+out:
+	close(fd);
+	return status;
+}
+
+int mpath_translate_response (char * dev, struct sg_io_hdr io_hdr, SenseData_t Sensedata, int noisy)
+{
+	condlog(3, "%s: status driver:%02x host:%02x scsi:%02x", dev, 
+			io_hdr.driver_status, io_hdr.host_status ,io_hdr.status);
+	io_hdr.status &= 0x7e;
+	if ((0 == io_hdr.status) && (0 == io_hdr.host_status) &&
+			(0 == io_hdr.driver_status))
+	{
+		return MPATH_PR_SUCCESS;
+	}
+
+	switch(io_hdr.status)
+	{
+		case SAM_STAT_GOOD:
+			break;
+		case SAM_STAT_CHECK_CONDITION:
+			condlog(2, "%s: Sense_Key=%02x, ASC=%02x ASCQ=%02x", dev,
+					Sensedata.Sense_Key, Sensedata.ASC, Sensedata.ASCQ);
+			switch(Sensedata.Sense_Key)
+			{
+				case NO_SENSE:
+					return MPATH_PR_NO_SENSE;
+				case RECOVERED_ERROR:
+					return MPATH_PR_SUCCESS;
+				case NOT_READY:
+					return MPATH_PR_SENSE_NOT_READY;
+				case MEDIUM_ERROR:
+					return MPATH_PR_SENSE_MEDIUM_ERROR;
+				case BLANK_CHECK:
+					return MPATH_PR_OTHER;
+				case HARDWARE_ERROR:
+					return MPATH_PR_SENSE_HARDWARE_ERROR;
+				case ILLEGAL_REQUEST:
+					return MPATH_PR_ILLEGAL_REQ;
+				case UNIT_ATTENTION:
+					return MPATH_PR_SENSE_UNIT_ATTENTION;
+				case DATA_PROTECT:
+				case COPY_ABORTED:
+					return MPATH_PR_OTHER;
+				case ABORTED_COMMAND:
+					return MPATH_PR_SENSE_ABORTED_COMMAND;
+
+				default :
+					return MPATH_PR_OTHER;
+			}
+		case SAM_STAT_RESERVATION_CONFLICT:
+			return MPATH_PR_RESERV_CONFLICT;
+
+		default :
+			return  MPATH_PR_OTHER;
+	}
+
+	switch(io_hdr.host_status)
+	{
+		case DID_OK :
+			break;
+		default :
+			return MPATH_PR_OTHER;
+	}
+	switch(io_hdr.driver_status)
+	{
+		case DRIVER_OK:
+			break;
+		default :
+			return MPATH_PR_OTHER;
+	}
+	return MPATH_PR_SUCCESS;
+}
+
+int mpath_isLittleEndian()
+{
+	int num = 1;
+	if(*(char *)&num == 1)
+	{
+		condlog(2, "Little-Endian");
+	}
+	else
+	{
+		condlog(2, "Big-Endian");
+	}
+	return 0;
+}
+
+void mpath_reverse_uint16_byteorder(uint16_t *num)
+{
+	uint16_t byte0, byte1;
+
+	byte0 = (*num & 0x000000FF) >>  0 ;
+	byte1 = (*num & 0x0000FF00) >>  8 ;
+
+	*num = ((byte0 << 8) | (byte1 << 0));
+}
+
+void mpath_reverse_uint32_byteorder(uint32_t *num)
+{
+	uint32_t byte0, byte1, byte2, byte3;
+
+	byte0 = (*num & 0x000000FF) >>  0 ;
+	byte1 = (*num & 0x0000FF00) >>  8 ;
+	byte2 = (*num & 0x00FF0000) >> 16 ;
+	byte3 = (*num & 0xFF000000) >> 24 ;
+
+	*num = ((byte0 << 24) | (byte1 << 16) | (byte2 << 8) | (byte3 << 0));
+}
+
+void mpath_reverse_8bytes_order(char * var)
+{
+	char byte[8];
+
+	int i;
+	for(i=0 ; i < 8 ; i++ )
+	{
+		byte[i] = var[i];
+	}
+	for(i=0 ; i < 8 ; i++ )
+	{
+		var[7 - i] = byte[i];
+	}
+}
+
+void
+dumpHex(const char* str, int len, int log)
+{
+	const char * p = str;
+	unsigned char c;
+	char buff[82];
+	const int bpstart = 5;
+	int bpos = bpstart;
+	int  k;
+
+	if (len <= 0)
+		return;
+	memset(buff, ' ', 80);
+	buff[80] = '\0';
+	for (k = 0; k < len; k++) {
+		c = *p++;
+		bpos += 3;
+		if (bpos == (bpstart + (9 * 3)))
+			bpos++;
+		sprintf(&buff[bpos], "%.2x", (int)(unsigned char)c);
+		buff[bpos + 2] = ' ';
+		if ((k > 0) && (0 == ((k + 1) % 16))) {
+			if (log)
+				condlog(0, "%.76s" , buff);
+			else
+				printf("%.76s" , buff);
+			bpos = bpstart;
+			memset(buff, ' ', 80);
+		}
+	}
+	if (bpos > bpstart) {
+		buff[bpos + 2] = '\0';
+		if (log)
+			condlog(0, "%s", buff);
+		else
+			printf("%s\n" , buff);
+	}
+	return;
+}
+
+int get_prin_length(int rq_servact)
+{
+        int mx_resp_len;
+        switch (rq_servact)
+        {
+                case MPATH_PRIN_RKEY_SA:
+                        mx_resp_len =  sizeof(struct prin_readdescr);
+                        break;
+                case MPATH_PRIN_RRES_SA :
+                        mx_resp_len =  sizeof(struct prin_resvdescr);
+                        break;
+                case MPATH_PRIN_RCAP_SA :
+                        mx_resp_len = sizeof(struct prin_capdescr);
+                        break;
+                case MPATH_PRIN_RFSTAT_SA:
+                        mx_resp_len = sizeof(struct print_fulldescr_list) + sizeof(struct prin_fulldescr *)*32;
+                        break;
+        }
+        return mx_resp_len;
+}
diff --git a/libmpathpersist/mpath_pr_ioctl.h b/libmpathpersist/mpath_pr_ioctl.h
new file mode 100644
index 0000000..573ff15
--- /dev/null
+++ b/libmpathpersist/mpath_pr_ioctl.h
@@ -0,0 +1,111 @@
+#define MPATH_XFER_HOST_DEV              0   /*data transfer from initiator to target */
+#define MPATH_XFER_DEV_HOST              1   /*data transfer from target to initiator */
+#define MPATH_XFER_NONE                  2   /*no data transfer */
+#define MPATH_XFER_UNKNOWN               3   /*data transfer direction is unknown */
+
+#if 0
+static const char * pr_type_strs[] = {
+    "obsolete [0]",
+    "Write Exclusive",
+    "obsolete [2]",
+    "Exclusive Access",
+    "obsolete [4]",
+    "Write Exclusive, registrants only",
+    "Exclusive Access, registrants only",
+    "Write Exclusive, all registrants",
+    "Exclusive Access, all registrants",
+    "obsolete [9]", "obsolete [0xa]", "obsolete [0xb]", "obsolete [0xc]",
+    "obsolete [0xd]", "obsolete [0xe]", "obsolete [0xf]",
+};
+#endif
+
+typedef unsigned int     LWORD;     /* unsigned numeric, bit patterns */
+typedef unsigned char    BYTE;      /* unsigned numeric, bit patterns */
+
+typedef struct SenseData
+{
+    BYTE        Error_Code;
+    BYTE        Segment_Number; /* not applicable to DAC */
+    BYTE        Sense_Key;
+    BYTE        Information[ 4 ];
+    BYTE        Additional_Len;
+    LWORD       Command_Specific_Info;
+    BYTE        ASC;
+    BYTE        ASCQ;
+    BYTE        Field_Replaceable_Unit;
+    BYTE        Sense_Key_Specific_Info[ 3 ];
+    BYTE        Recovery_Action[ 2 ];
+    BYTE        Total_Errors;
+    BYTE        Total_Retries;
+    BYTE        ASC_Stack_1;
+    BYTE        ASCQ_Stack_1;
+    BYTE        ASC_Stack_2;
+    BYTE        ASCQ_Stack_2;
+    BYTE        Additional_FRU_Info[ 8 ];
+    BYTE        Error_Specific_Info[ 3 ];
+    BYTE        Error_Detection_Point[ 4 ];
+    BYTE        Original_CDB[10];
+    BYTE        Host_ID;
+    BYTE        Host_Descriptor[ 2 ];
+    BYTE        Serial_Number[ 16 ];
+    BYTE        Array_SW_Revision[ 4 ];
+    BYTE        Data_Xfer_Operation;
+    BYTE        LUN_Number;
+    BYTE        LUN_Status;
+    BYTE        Drive_ID;
+    BYTE        Xfer_Start_Drive_ID;
+    BYTE        Drive_SW_Revision[ 4 ];
+    BYTE        Drive_Product_ID[ 16 ];
+    BYTE        PowerUp_Status[ 2 ];
+    BYTE        RAID_Level;
+    BYTE        Drive_Sense_ID[ 2 ];
+    BYTE        Drive_Sense_Data[ 32 ];
+    BYTE        Reserved2[24];
+} SenseData_t;
+
+#define MPATH_PRIN_CMD 0x5e
+#define MPATH_PRIN_CMDLEN 10
+#define MPATH_PROUT_CMD 0x5f
+#define MPATH_PROUT_CMDLEN 10
+
+#define  DID_OK	0x00
+/*
+ *  Status codes
+ */
+#define SAM_STAT_GOOD            0x00
+#define SAM_STAT_CHECK_CONDITION 0x02
+#define SAM_STAT_CONDITION_MET   0x04
+#define SAM_STAT_BUSY            0x08
+#define SAM_STAT_INTERMEDIATE    0x10
+#define SAM_STAT_INTERMEDIATE_CONDITION_MET 0x14
+#define SAM_STAT_RESERVATION_CONFLICT 0x18
+#define SAM_STAT_COMMAND_TERMINATED 0x22        /* obsolete in SAM-3 */
+#define SAM_STAT_TASK_SET_FULL   0x28
+#define SAM_STAT_ACA_ACTIVE      0x30
+#define SAM_STAT_TASK_ABORTED    0x40
+
+#define STATUS_MASK          0x3e
+
+/*
+ *  SENSE KEYS
+ */
+
+#define NO_SENSE            0x00
+#define RECOVERED_ERROR     0x01
+#define NOT_READY           0x02
+#define MEDIUM_ERROR        0x03
+#define HARDWARE_ERROR      0x04
+#define ILLEGAL_REQUEST     0x05
+#define UNIT_ATTENTION      0x06
+#define DATA_PROTECT        0x07
+#define BLANK_CHECK         0x08
+#define COPY_ABORTED        0x0a
+#define ABORTED_COMMAND     0x0b
+#define VOLUME_OVERFLOW     0x0d
+#define MISCOMPARE          0x0e
+
+
+/* Driver status */
+#define DRIVER_OK 0x00
+
+
diff --git a/libmpathpersist/mpath_updatepr.c b/libmpathpersist/mpath_updatepr.c
new file mode 100644
index 0000000..2982947
--- /dev/null
+++ b/libmpathpersist/mpath_updatepr.c
@@ -0,0 +1,50 @@
+#include<stdio.h>
+#include<unistd.h>
+#include <errno.h>
+
+#include <stdlib.h>
+#include <stdarg.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <sys/poll.h>
+#include <errno.h>
+#include <debug.h>
+#include "memory.h"
+#include "../libmultipath/uxsock.h"
+
+unsigned long mem_allocated;    /* Total memory used in Bytes */
+
+int update_prflag(char * arg1, char * arg2, int noisy)
+{
+	int fd;
+	char str[64];
+	char *reply;
+	size_t len;
+	int ret = 0;
+
+	fd = ux_socket_connect("/var/run/multipathd.sock");
+	if (fd == -1) {
+		condlog (0, "ux socket connect error");
+		return 1 ;
+	}
+
+	snprintf(str,sizeof(str),"map %s %s", arg1, arg2);
+	condlog (2, "%s: pr flag message=%s", arg1, str);
+	send_packet(fd, str, strlen(str) + 1);
+	recv_packet(fd, &reply, &len);
+
+	condlog (2, "%s: message=%s reply=%s", arg1, str, reply);
+	if (!reply || strncmp(reply,"ok", 2) == 0)
+		ret = -1;
+	else if (strncmp(reply, "fail", 4) == 0)
+		ret = -2;
+	else{
+		ret = atoi(reply);
+	}
+
+	free(reply);
+	return ret;
+}
diff --git a/libmpathpersist/mpathpr.h b/libmpathpersist/mpathpr.h
new file mode 100644
index 0000000..54dfb3e
--- /dev/null
+++ b/libmpathpersist/mpathpr.h
@@ -0,0 +1,55 @@
+#ifndef MPATHPR_H
+#define MPATHPR_H
+
+struct prin_param {
+	char dev[FILE_NAME_SIZE];
+        int rq_servact;
+        struct prin_resp *resp;
+        int noisy;
+        int status;
+};
+
+struct prout_param {
+	char dev[FILE_NAME_SIZE];
+        int rq_servact;
+        int rq_scope;
+        unsigned int rq_type;
+        struct prout_param_descriptor  *paramp;
+        int noisy;
+        int status;
+};
+
+struct threadinfo {
+        int status;
+        pthread_t id;
+        struct prout_param param;
+};
+
+
+struct config * conf;
+
+
+int prin_do_scsi_ioctl(char * dev, int rq_servact, struct prin_resp * resp, int noisy);
+int prout_do_scsi_ioctl( char * dev, int rq_servact, int rq_scope,
+                unsigned int rq_type, struct prout_param_descriptor *paramp, int noisy);
+void * _mpath_pr_update (void *arg);
+int mpath_send_prin_activepath (char * dev, int rq_servact, struct prin_resp * resp, int noisy);
+int get_mpvec (vector curmp, vector pathvec, char * refwwid);
+void * mpath_prout_pthread_fn(void *p);
+void dumpHex(const char* , int len, int no_ascii);
+
+int mpath_prout_reg(struct multipath *mpp,int rq_servact, int rq_scope,
+        unsigned int rq_type,  struct prout_param_descriptor * paramp, int noisy);
+int mpath_prout_common(struct multipath *mpp,int rq_servact, int rq_scope,
+        unsigned int rq_type,  struct prout_param_descriptor * paramp, int noisy);
+int mpath_prout_rel(struct multipath *mpp,int rq_servact, int rq_scope,
+        unsigned int rq_type,  struct prout_param_descriptor * paramp, int noisy);
+int send_prout_activepath(char * dev, int rq_servact, int rq_scope,
+        unsigned int rq_type,   struct prout_param_descriptor * paramp, int noisy);
+
+int update_prflag(char * arg1, char * arg2, int noisy);
+void * mpath_alloc_prin_response(int prin_sa);
+int update_map_pr(struct multipath *mpp);
+int devt2devname (char *devname, char *devt);
+
+#endif  
diff --git a/libmultipath/Makefile b/libmultipath/Makefile
index 203833d..f396f49 100644
--- a/libmultipath/Makefile
+++ b/libmultipath/Makefile
@@ -23,10 +23,16 @@ ifneq ($(strip $(LIBDM_API_FLUSH)),0)
 	CFLAGS += -DLIBDM_API_FLUSH -D_GNU_SOURCE
 endif
 
+LIBDM_API_COOKIE = $(shell grep -Ecs '^[a-z]*[[:space:]]+dm_task_set_cookie' /usr/include/libdevmapper.h)
+
+ifneq ($(strip $(LIBDM_API_COOKIE)),0)
+	CFLAGS += -DLIBDM_API_COOKIE
+endif
+
 all: $(LIBS)
 
 $(LIBS): $(OBJS)
-	$(CC) $(SHARED_FLAGS) $(LIBDEPS) -Wl,-soname=$@ $(CFLAGS) -o $@ $(OBJS)
+	$(CC) $(LDFLAGS) $(SHARED_FLAGS) -Wl,-soname=$@ $(CFLAGS) -o $@ $(OBJS) $(LIBDEPS)
 	ln -sf $@ $(DEVLIB)
 
 install:
diff --git a/libmultipath/alias.c b/libmultipath/alias.c
index 95506b4..4159ec6 100644
--- a/libmultipath/alias.c
+++ b/libmultipath/alias.c
@@ -180,34 +180,35 @@ fail:
 }
 
 static int
-format_devname(char *name, int id, int len)
+format_devname(char *name, int id, int len, char *prefix)
 {
 	int pos;
+	int prefix_len = strlen(prefix);
 
 	memset(name,0, len);
-	strcpy(name,"mpath");
-	for (pos = len - 1; pos >= 5; pos--) {
+	strcpy(name, prefix);
+	for (pos = len - 1; pos >= prefix_len; pos--) {
 		name[pos] = 'a' + id % 26;
 		if (id < 26)
 			break;
 		id /= 26;
 		id--;
 	}
-	memmove(name + 5, name + pos, len - pos);
-	name[5 + len - pos] = '\0';
-	return (5 + len - pos);
+	memmove(name + prefix_len, name + pos, len - pos);
+	name[prefix_len + len - pos] = '\0';
+	return (prefix_len + len - pos);
 }
 
 static int
-scan_devname(char *alias)
+scan_devname(char *alias, char *prefix)
 {
 	char *c;
 	int i, n = 0;
 
-	if (strncmp(alias, "mpath", 5))
+	if (!prefix || strncmp(alias, prefix, strlen(prefix)))
 		return -1;
 
-	c = alias + 5;
+	c = alias + strlen(prefix);
 	while (*c != '\0' && *c != ' ' && *c != '\t') {
 		i = *c - 'a';
 		n = ( n * 26 ) + i;
@@ -221,7 +222,7 @@ scan_devname(char *alias)
 }
 
 static int
-lookup_binding(FILE *f, char *map_wwid, char **map_alias)
+lookup_binding(FILE *f, char *map_wwid, char **map_alias, char *prefix)
 {
 	char buf[LINE_MAX];
 	unsigned int line_nr = 0;
@@ -240,7 +241,7 @@ lookup_binding(FILE *f, char *map_wwid, char **map_alias)
 		alias = strtok(buf, " \t");
 		if (!alias) /* blank line */
 			continue;
-		curr_id = scan_devname(alias);
+		curr_id = scan_devname(alias, prefix);
 		if (curr_id >= id)
 			id = curr_id + 1;
 		wwid = strtok(NULL, "");
@@ -284,7 +285,7 @@ rlookup_binding(FILE *f, char **map_wwid, char *map_alias)
 		alias = strtok(buf, " \t");
 		if (!alias) /* blank line */
 			continue;
-		curr_id = scan_devname(alias);
+		curr_id = scan_devname(alias, NULL); /* TBD: Why this call? */
 		if (curr_id >= id)
 			id = curr_id + 1;
 		wwid = strtok(NULL, " \t");
@@ -309,7 +310,7 @@ rlookup_binding(FILE *f, char **map_wwid, char *map_alias)
 }
 
 static char *
-allocate_binding(int fd, char *wwid, int id)
+allocate_binding(int fd, char *wwid, int id, char *prefix)
 {
 	char buf[LINE_MAX];
 	off_t offset;
@@ -321,7 +322,7 @@ allocate_binding(int fd, char *wwid, int id)
 		return NULL;
 	}
 
-	i = format_devname(buf, id, LINE_MAX);
+	i = format_devname(buf, id, LINE_MAX, prefix);
 	c = buf + i;
 	snprintf(c,LINE_MAX - i, " %s\n", wwid);
 	buf[LINE_MAX - 1] = '\0';
@@ -352,7 +353,8 @@ allocate_binding(int fd, char *wwid, int id)
 }
 
 char *
-get_user_friendly_alias(char *wwid, char *file)
+get_user_friendly_alias(char *wwid, char *file, char *prefix,
+			int bindings_read_only)
 {
 	char *alias;
 	int fd, scan_fd, id;
@@ -385,7 +387,7 @@ get_user_friendly_alias(char *wwid, char *file)
 		return NULL;
 	}
 
-	id = lookup_binding(f, wwid, &alias);
+	id = lookup_binding(f, wwid, &alias, prefix);
 	if (id < 0) {
 		fclose(f);
 		close(scan_fd);
@@ -393,8 +395,8 @@ get_user_friendly_alias(char *wwid, char *file)
 		return NULL;
 	}
 
-	if (!alias && can_write)
-		alias = allocate_binding(fd, wwid, id);
+	if (!alias && can_write && !bindings_read_only)
+		alias = allocate_binding(fd, wwid, id, prefix);
 
 	fclose(f);
 	close(scan_fd);
diff --git a/libmultipath/alias.h b/libmultipath/alias.h
index fe1191b..c489a86 100644
--- a/libmultipath/alias.h
+++ b/libmultipath/alias.h
@@ -8,5 +8,6 @@
 "# alias wwid\n" \
 "#\n"
 
-char *get_user_friendly_alias(char *wwid, char *file);
+char *get_user_friendly_alias(char *wwid, char *file, char *prefix,
+			      int bindings_readonly);
 char *get_user_friendly_wwid(char *alias, char *file);
diff --git a/libmultipath/callout.c b/libmultipath/callout.c
index 520343e..ae19051 100644
--- a/libmultipath/callout.c
+++ b/libmultipath/callout.c
@@ -17,17 +17,9 @@
 #include "checkers.h"
 #include "vector.h"
 #include "structs.h"
+#include "util.h"
 #include "debug.h"
 
-#define PROGRAM_SIZE	100
-#define FIELD_PROGRAM
-
-#define strfieldcpy(to, from) \
-do { \
-	to[sizeof(to)-1] = '\0'; \
-	strncpy(to, from, sizeof(to)-1); \
-} while (0)
-
 int execute_program(char *path, char *value, int len)
 {
 	int retval;
@@ -36,16 +28,17 @@ int execute_program(char *path, char *value, int len)
 	int fds[2], null_fd;
 	pid_t pid;
 	char *pos;
-	char arg[PROGRAM_SIZE];
-	char *argv[sizeof(arg) / 2];
+	char arg[CALLOUT_MAX_SIZE];
+	int argc = sizeof(arg) / 2;
+	char *argv[argc + 1];
 	int i;
 
 	i = 0;
 
 	if (strchr(path, ' ')) {
-		strfieldcpy(arg, path);
+		strlcpy(arg, path, sizeof(arg));
 		pos = arg;
-		while (pos != NULL) {
+		while (pos != NULL && i < argc) {
 			if (pos[0] == '\'') {
 				/* don't separate if in apostrophes */
 				pos++;
diff --git a/libmultipath/checkers.c b/libmultipath/checkers.c
index 19d0781..01dafdd 100644
--- a/libmultipath/checkers.c
+++ b/libmultipath/checkers.c
@@ -2,6 +2,7 @@
 #include <string.h>
 #include <stddef.h>
 #include <dlfcn.h>
+#include <sys/stat.h>
 
 #include "debug.h"
 #include "checkers.h"
@@ -34,11 +35,34 @@ int init_checkers (void)
 
 struct checker * alloc_checker (void)
 {
-	return MALLOC(sizeof(struct checker));
+	struct checker *c;
+
+	c = MALLOC(sizeof(struct checker));
+	if (c) {
+		INIT_LIST_HEAD(&c->node);
+		c->refcount = 1;
+	}
+	return c;
 }
 
 void free_checker (struct checker * c)
 {
+	if (!c)
+		return;
+	c->refcount--;
+	if (c->refcount) {
+		condlog(3, "%s checker refcount %d",
+			c->name, c->refcount);
+		return;
+	}
+	condlog(3, "unloading %s checker", c->name);
+	list_del(&c->node);
+	if (c->handle) {
+		if (dlclose(c->handle) != 0) {
+			condlog(0, "Cannot unload checker %s: %s",
+				c->name, dlerror());
+		}
+	}
 	FREE(c);
 }
 
@@ -48,7 +72,6 @@ void cleanup_checkers (void)
 	struct checker * checker_temp;
 
 	list_for_each_entry_safe(checker_loop, checker_temp, &checkers, node) {
-		list_del(&checker_loop->node);
 		free_checker(checker_loop);
 	}
 }
@@ -57,6 +80,8 @@ struct checker * checker_lookup (char * name)
 {
 	struct checker * c;
 
+	if (!name || !strlen(name))
+		return NULL;
 	list_for_each_entry(c, &checkers, node) {
 		if (!strncmp(name, c->name, CHECKER_NAME_LEN))
 			return c;
@@ -67,45 +92,50 @@ struct checker * checker_lookup (char * name)
 struct checker * add_checker (char * name)
 {
 	char libname[LIB_CHECKER_NAMELEN];
-	void * handle;
+	struct stat stbuf;
 	struct checker * c;
 	char *errstr;
 
 	c = alloc_checker();
 	if (!c)
 		return NULL;
+	snprintf(c->name, CHECKER_NAME_LEN, "%s", name);
 	snprintf(libname, LIB_CHECKER_NAMELEN, "%s/libcheck%s.so",
 		 conf->multipath_dir, name);
+	if (stat(libname,&stbuf) < 0) {
+		condlog(0,"Checker '%s' not found in %s",
+			name, conf->multipath_dir);
+		goto out;
+	}
 	condlog(3, "loading %s checker", libname);
-	handle = dlopen(libname, RTLD_NOW);
-	errstr = dlerror();
-	if (errstr != NULL)
-	condlog(0, "A dynamic linking error occurred: (%s)", errstr);
-	if (!handle)
+	c->handle = dlopen(libname, RTLD_NOW);
+	if (!c->handle) {
+		if ((errstr = dlerror()) != NULL)
+			condlog(0, "A dynamic linking error occurred: (%s)",
+				errstr);
 		goto out;
-
-	c->check = (int (*)(struct checker *)) dlsym(handle, "libcheck_check");
+	}
+	c->check = (int (*)(struct checker *)) dlsym(c->handle, "libcheck_check");
 	errstr = dlerror();
 	if (errstr != NULL)
-	condlog(0, "A dynamic linking error occurred: (%s)", errstr);
+		condlog(0, "A dynamic linking error occurred: (%s)", errstr);
 	if (!c->check)
 		goto out;
 
-	c->init = (int (*)(struct checker *)) dlsym(handle, "libcheck_init");
+	c->init = (int (*)(struct checker *)) dlsym(c->handle, "libcheck_init");
 	errstr = dlerror();
 	if (errstr != NULL)
-	condlog(0, "A dynamic linking error occurred: (%s)", errstr);
+		condlog(0, "A dynamic linking error occurred: (%s)", errstr);
 	if (!c->init)
 		goto out;
 
-	c->free = (void (*)(struct checker *)) dlsym(handle, "libcheck_free");
+	c->free = (void (*)(struct checker *)) dlsym(c->handle, "libcheck_free");
 	errstr = dlerror();
 	if (errstr != NULL)
-	condlog(0, "A dynamic linking error occurred: (%s)", errstr);
+		condlog(0, "A dynamic linking error occurred: (%s)", errstr);
 	if (!c->free)
 		goto out;
 
-	snprintf(c->name, CHECKER_NAME_LEN, "%s", name);
 	c->fd = 0;
 	c->sync = 1;
 	list_add(&c->node, &checkers);
@@ -117,48 +147,72 @@ out:
 
 void checker_set_fd (struct checker * c, int fd)
 {
+	if (!c)
+		return;
 	c->fd = fd;
 }
 
 void checker_set_sync (struct checker * c)
 {
+	if (!c)
+		return;
 	c->sync = 1;
 }
 
 void checker_set_async (struct checker * c)
 {
+	if (!c)
+		return;
 	c->sync = 0;
 }
 
 void checker_enable (struct checker * c)
 {
+	if (!c)
+		return;
 	c->disable = 0;
 }
 
 void checker_disable (struct checker * c)
 {
+	if (!c)
+		return;
 	c->disable = 1;
 }
 
 int checker_init (struct checker * c, void ** mpctxt_addr)
 {
+	if (!c)
+		return 1;
 	c->mpcontext = mpctxt_addr;
 	return c->init(c);
 }
 
-void checker_put (struct checker * c)
+void checker_put (struct checker * dst)
 {
-	if (c->free)
-		c->free(c);
-	memset(c, 0x0, sizeof(struct checker));
+	struct checker * src;
+
+	if (!dst)
+		return;
+	src = checker_lookup(dst->name);
+	if (dst->free)
+		dst->free(dst);
+	memset(dst, 0x0, sizeof(struct checker));
+	free_checker(src);
 }
 
 int checker_check (struct checker * c)
 {
 	int r;
 
-	if (c->disable)
+	if (!c)
+		return PATH_WILD;
+
+	c->message[0] = '\0';
+	if (c->disable) {
+		MSG(c, "checker disabled");
 		return PATH_UNCHECKED;
+	}
 	if (c->fd <= 0) {
 		MSG(c, "no usable fd");
 		return PATH_WILD;
@@ -170,23 +224,39 @@ int checker_check (struct checker * c)
 
 int checker_selected (struct checker * c)
 {
+	if (!c)
+		return 0;
 	return (c->check) ? 1 : 0;
 }
 
 char * checker_name (struct checker * c)
 {
+	if (!c)
+		return NULL;
 	return c->name;
 }
 
 char * checker_message (struct checker * c)
 {
+	if (!c)
+		return NULL;
 	return c->message;
 }
 
+void checker_clear_message (struct checker *c)
+{
+	if (!c)
+		return;
+	c->message[0] = '\0';
+}
+
 void checker_get (struct checker * dst, char * name)
 {
 	struct checker * src = checker_lookup(name);
 
+	if (!dst)
+		return;
+
 	if (!src) {
 		dst->check = NULL;
 		return;
@@ -198,4 +268,6 @@ void checker_get (struct checker * dst, char * name)
 	dst->check = src->check;
 	dst->init = src->init;
 	dst->free = src->free;
+	dst->handle = NULL;
+	src->refcount++;
 }
diff --git a/libmultipath/checkers.h b/libmultipath/checkers.h
index 6ba0339..5a96165 100644
--- a/libmultipath/checkers.h
+++ b/libmultipath/checkers.h
@@ -68,20 +68,6 @@ enum path_check_state {
 
 #define DEFAULT_CHECKER DIRECTIO
 
-/*
- * Overloaded storage response time can be very long.
- * SG_IO timouts after DEF_TIMEOUT milliseconds, and checkers interprets this
- * as a path failure. multipathd then proactively evicts the path from the DM
- * multipath table in this case.
- *
- * This generaly snow balls and ends up in full eviction and IO errors for end
- * users. Bad. This may also cause SCSI bus resets, causing disruption for all
- * local and external storage hardware users.
- * 
- * Provision a long timeout. Longer than any real-world application would cope
- * with.
- */
-#define DEF_TIMEOUT		300000
 #define ASYNC_TIMEOUT_SEC	30
 
 /*
@@ -94,8 +80,11 @@ enum path_check_state {
 
 struct checker {
 	struct list_head node;
+	void *handle;
+	int refcount;
 	int fd;
 	int sync;
+	unsigned int timeout;
 	int disable;
 	char name[CHECKER_NAME_LEN];
 	char message[CHECKER_MSG_LEN];       /* comm with callers */
@@ -127,6 +116,7 @@ int checker_check (struct checker *);
 int checker_selected (struct checker *);
 char * checker_name (struct checker *);
 char * checker_message (struct checker *);
+void checker_clear_message (struct checker *c);
 void checker_get (struct checker *, char *);
 
 #endif /* _CHECKERS_H */
diff --git a/libmultipath/checkers/Makefile b/libmultipath/checkers/Makefile
index 92a9382..4b1a108 100644
--- a/libmultipath/checkers/Makefile
+++ b/libmultipath/checkers/Makefile
@@ -18,10 +18,10 @@ CFLAGS += -I..
 all: $(LIBS)
 
 libcheckdirectio.so: libsg.o directio.o
-	$(CC) $(SHARED_FLAGS) -o $@ $^ -laio
+	$(CC) $(LDFLAGS) $(SHARED_FLAGS) -o $@ $^ -laio
 
 libcheck%.so: libsg.o %.o
-	$(CC) $(SHARED_FLAGS) -o $@ $^
+	$(CC) $(LDFLAGS) $(SHARED_FLAGS) -o $@ $^
 
 install:
 	$(INSTALL_PROGRAM) -m 755 $(LIBS) $(DESTDIR)$(libdir)
diff --git a/libmultipath/checkers/directio.c b/libmultipath/checkers/directio.c
index 6696b41..46fe6a7 100644
--- a/libmultipath/checkers/directio.c
+++ b/libmultipath/checkers/directio.c
@@ -12,7 +12,7 @@
 #include <sys/ioctl.h>
 #include <linux/fs.h>
 #include <errno.h>
-#include <asm/unistd.h>
+#include <unistd.h>
 #include <libaio.h>
 
 #include "checkers.h"
@@ -117,7 +117,7 @@ void libcheck_free (struct checker * c)
 }
 
 static int
-check_state(int fd, struct directio_context *ct, int sync)
+check_state(int fd, struct directio_context *ct, int sync, int timeout_secs)
 {
 	struct timespec	timeout = { .tv_nsec = 5 };
 	struct io_event event;
@@ -128,9 +128,9 @@ check_state(int fd, struct directio_context *ct, int sync)
 	if (fstat(fd, &sb) == 0) {
 		LOG(4, "called for %x", (unsigned) sb.st_rdev);
 	}
-	if (sync) {
+	if (sync > 0) {
 		LOG(4, "called in synchronous mode");
-		timeout.tv_sec  = ASYNC_TIMEOUT_SEC;
+		timeout.tv_sec  = timeout_secs;
 		timeout.tv_nsec = 0;
 	}
 
@@ -153,10 +153,22 @@ check_state(int fd, struct directio_context *ct, int sync)
 	if (r < 0 ) {
 		LOG(3, "async io getevents returned %li (errno=%s)", r,
 		    strerror(errno));
+		ct->running = 0;
 		rc = PATH_UNCHECKED;
 	} else if (r < 1L) {
-		if (ct->running > ASYNC_TIMEOUT_SEC || sync) {
+		if (ct->running > timeout_secs || sync) {
+			struct iocb *ios[1] = { &ct->io };
+
 			LOG(3, "abort check on timeout");
+			r = io_cancel(ct->ioctx, ios[0], &event);
+			/*
+			 * Only reset ct->running if we really
+			 * could abort the pending I/O
+			 */
+			if (r)
+				LOG(3, "io_cancel error %i", errno);
+			else
+				ct->running = 0;
 			rc = PATH_DOWN;
 		} else {
 			LOG(3, "async io pending");
@@ -179,7 +191,7 @@ int libcheck_check (struct checker * c)
 	if (!ct)
 		return PATH_UNCHECKED;
 
-	ret = check_state(c->fd, ct, c->sync);
+	ret = check_state(c->fd, ct, c->sync, c->timeout);
 
 	switch (ret)
 	{
diff --git a/libmultipath/checkers/emc_clariion.c b/libmultipath/checkers/emc_clariion.c
index 3a88b0b..b42d267 100644
--- a/libmultipath/checkers/emc_clariion.c
+++ b/libmultipath/checkers/emc_clariion.c
@@ -113,7 +113,7 @@ int libcheck_check (struct checker * c)
 	io_hdr.dxferp = sense_buffer;
 	io_hdr.cmdp = inqCmdBlk;
 	io_hdr.sbp = sb;
-	io_hdr.timeout = DEF_TIMEOUT;
+	io_hdr.timeout = c->timeout;
 	io_hdr.pack_id = 0;
 	if (ioctl(c->fd, SG_IO, &io_hdr) < 0) {
 		MSG(c, "emc_clariion_checker: sending query command failed");
@@ -182,7 +182,8 @@ int libcheck_check (struct checker * c)
 		unsigned char buf[4096];
 
 		memset(buf, 0, 4096);
-		ret = sg_read(c->fd, &buf[0], sbb = &sb[0]);
+		ret = sg_read(c->fd, &buf[0], 4096,
+			      sbb = &sb[0], SENSE_BUFF_LEN, c->timeout);
 		if (ret == PATH_DOWN) {
 			hexadecimal_to_ascii(ct->wwn, wwnstr);
 
diff --git a/libmultipath/checkers/hp_sw.c b/libmultipath/checkers/hp_sw.c
index 3f28d85..b50ac0c 100644
--- a/libmultipath/checkers/hp_sw.c
+++ b/libmultipath/checkers/hp_sw.c
@@ -46,7 +46,7 @@ void libcheck_free (struct checker * c)
 
 static int
 do_inq(int sg_fd, int cmddt, int evpd, unsigned int pg_op,
-       void *resp, int mx_resp_len, int noisy)
+       void *resp, int mx_resp_len, int noisy, unsigned int timeout)
 {
 	unsigned char inqCmdBlk[INQUIRY_CMDLEN] =
 		{ INQUIRY_CMD, 0, 0, 0, 0, 0 };
@@ -70,7 +70,7 @@ do_inq(int sg_fd, int cmddt, int evpd, unsigned int pg_op,
 	io_hdr.dxferp = resp;
 	io_hdr.cmdp = inqCmdBlk;
 	io_hdr.sbp = sense_b;
-	io_hdr.timeout = DEF_TIMEOUT;
+	io_hdr.timeout = timeout;
 
 	if (ioctl(sg_fd, SG_IO, &io_hdr) < 0)
 		return 1;
@@ -98,7 +98,7 @@ do_inq(int sg_fd, int cmddt, int evpd, unsigned int pg_op,
 }
 
 static int
-do_tur (int fd)
+do_tur (int fd, unsigned int timeout)
 {
 	unsigned char turCmdBlk[TUR_CMD_LEN] = { 0x00, 0, 0, 0, 0, 0 };
 	struct sg_io_hdr io_hdr;
@@ -111,7 +111,7 @@ do_tur (int fd)
 	io_hdr.dxfer_direction = SG_DXFER_NONE;
 	io_hdr.cmdp = turCmdBlk;
 	io_hdr.sbp = sense_buffer;
-	io_hdr.timeout = DEF_TIMEOUT;
+	io_hdr.timeout = timeout;
 	io_hdr.pack_id = 0;
 
 	if (ioctl(fd, SG_IO, &io_hdr) < 0)
@@ -128,12 +128,12 @@ libcheck_check (struct checker * c)
 {
 	char buff[MX_ALLOC_LEN];
 
-	if (0 != do_inq(c->fd, 0, 1, 0x80, buff, MX_ALLOC_LEN, 0)) {
+	if (0 != do_inq(c->fd, 0, 1, 0x80, buff, MX_ALLOC_LEN, 0, c->timeout)) {
 		MSG(c, MSG_HP_SW_DOWN);
 		return PATH_DOWN;
 	}
 
-	if (do_tur(c->fd)) {
+	if (do_tur(c->fd, c->timeout)) {
 		MSG(c, MSG_HP_SW_GHOST);
 		return PATH_GHOST;
 	}
diff --git a/libmultipath/checkers/libsg.c b/libmultipath/checkers/libsg.c
index 4cb7ecc..5a989d3 100644
--- a/libmultipath/checkers/libsg.c
+++ b/libmultipath/checkers/libsg.c
@@ -11,17 +11,18 @@
 #include "../libmultipath/sg_include.h"
 
 int
-sg_read (int sg_fd, unsigned char * buff, unsigned char * senseBuff)
+sg_read (int sg_fd, unsigned char * buff, int buff_len,
+	 unsigned char * sense, int sense_len, unsigned int timeout)
 {
 	/* defaults */
-	int blocks = 1;
+	int blocks;
 	long long start_block = 0;
 	int bs = 512;
 	int cdbsz = 10;
 	int * diop = NULL;
 
 	unsigned char rdCmd[cdbsz];
-	unsigned char *sbb = senseBuff;
+	unsigned char *sbb = sense;
 	struct sg_io_hdr io_hdr;
 	int res;
 	int rd_opcode[] = {0x8, 0x28, 0xa8, 0x88};
@@ -32,6 +33,7 @@ sg_read (int sg_fd, unsigned char * buff, unsigned char * senseBuff)
 	if (fstat(sg_fd, &filestatus) != 0)
 		return PATH_DOWN;
 	bs = (filestatus.st_blksize > 4096)? 4096: filestatus.st_blksize;
+	blocks = buff_len / bs;
 	memset(rdCmd, 0, cdbsz);
 	sz_ind = 1;
 	rdCmd[0] = rd_opcode[sz_ind];
@@ -49,15 +51,15 @@ sg_read (int sg_fd, unsigned char * buff, unsigned char * senseBuff)
 	io_hdr.dxfer_direction = SG_DXFER_FROM_DEV;
 	io_hdr.dxfer_len = bs * blocks;
 	io_hdr.dxferp = buff;
-	io_hdr.mx_sb_len = SENSE_BUFF_LEN;
-	io_hdr.sbp = senseBuff;
-	io_hdr.timeout = DEF_TIMEOUT;
+	io_hdr.mx_sb_len = sense_len;
+	io_hdr.sbp = sense;
+	io_hdr.timeout = timeout;
 	io_hdr.pack_id = (int)start_block;
 	if (diop && *diop)
 	io_hdr.flags |= SG_FLAG_DIRECT_IO;
 
-retry: 
-	memset(senseBuff, 0, SENSE_BUFF_LEN);
+retry:
+	memset(sense, 0, sense_len);
 	while (((res = ioctl(sg_fd, SG_IO, &io_hdr)) < 0) && (EINTR == errno));
 
 	if (res < 0) {
diff --git a/libmultipath/checkers/libsg.h b/libmultipath/checkers/libsg.h
index 97c4491..3994f45 100644
--- a/libmultipath/checkers/libsg.h
+++ b/libmultipath/checkers/libsg.h
@@ -3,6 +3,7 @@
 
 #define SENSE_BUFF_LEN 32
 
-int sg_read (int sg_fd, unsigned char * buff, unsigned char * senseBuff);
+int sg_read (int sg_fd, unsigned char * buff, int buff_len,
+	     unsigned char * sense, int sense_len, unsigned int timeout);
 
 #endif /* _LIBSG_H */
diff --git a/libmultipath/checkers/rdac.c b/libmultipath/checkers/rdac.c
index d12eed1..d7dfb08 100644
--- a/libmultipath/checkers/rdac.c
+++ b/libmultipath/checkers/rdac.c
@@ -12,28 +12,113 @@
 #include <errno.h>
 
 #include "checkers.h"
+#include "debug.h"
 
 #include "../libmultipath/sg_include.h"
 
 #define INQUIRY_CMDLEN		6
 #define INQUIRY_CMD		0x12
+#define MODE_SENSE_CMD		0x5a
+#define MODE_SELECT_CMD		0x55
+#define MODE_SEN_SEL_CMDLEN	10
 #define SENSE_BUFF_LEN		32
-#define RDAC_DEF_TIMEOUT	60000
 #define SCSI_CHECK_CONDITION	0x2
 #define SCSI_COMMAND_TERMINATED	0x22
 #define SG_ERR_DRIVER_SENSE	0x08
 #define RECOVERED_ERROR		0x01
 
+
+#define CURRENT_PAGE_CODE_VALUES	0
+#define CHANGEABLE_PAGE_CODE_VALUES	1
+
 #define MSG_RDAC_UP    "rdac checker reports path is up"
 #define MSG_RDAC_DOWN  "rdac checker reports path is down"
 #define MSG_RDAC_GHOST "rdac checker reports path is ghost"
 
+struct control_mode_page {
+	unsigned char header[8];
+	unsigned char page_code;
+	unsigned char page_len;
+	unsigned char dontcare0[3];
+	unsigned char tas_bit;
+	unsigned char dontcare1[6];
+};
+
 struct rdac_checker_context {
 	void * dummy;
 };
 
 int libcheck_init (struct checker * c)
 {
+	unsigned char cmd[MODE_SEN_SEL_CMDLEN];
+	unsigned char sense_b[SENSE_BUFF_LEN];
+	struct sg_io_hdr io_hdr;
+	struct control_mode_page current, changeable;
+	int set = 0;
+
+	memset(cmd, 0, MODE_SEN_SEL_CMDLEN);
+	cmd[0] = MODE_SENSE_CMD;
+	cmd[1] = 0x08; /* DBD bit on */
+	cmd[2] = 0xA + (CURRENT_PAGE_CODE_VALUES << 6);
+	cmd[8] = (sizeof(struct control_mode_page) &  0xff);
+
+	memset(&io_hdr, 0, sizeof(struct sg_io_hdr));
+	memset(sense_b, 0, SENSE_BUFF_LEN);
+	memset(&current, 0, sizeof(struct control_mode_page));
+
+	io_hdr.interface_id = 'S';
+	io_hdr.cmd_len = MODE_SEN_SEL_CMDLEN;
+	io_hdr.mx_sb_len = sizeof(sense_b);
+	io_hdr.dxfer_direction = SG_DXFER_FROM_DEV;
+	io_hdr.dxfer_len = (sizeof(struct control_mode_page) &  0xff);
+	io_hdr.dxferp = &current;
+	io_hdr.cmdp = cmd;
+	io_hdr.sbp = sense_b;
+	io_hdr.timeout = c->timeout;
+
+	if (ioctl(c->fd, SG_IO, &io_hdr) < 0)
+		goto out;
+
+	/* check the TAS bit to see if it is already set */
+	if ((current.tas_bit >> 6) & 0x1) {
+		set = 1;
+		goto out;
+	}
+
+	/* get the changeble values */
+	cmd[2] = 0xA + (CHANGEABLE_PAGE_CODE_VALUES << 6);
+	io_hdr.dxferp = &changeable;
+	memset(&changeable, 0, sizeof(struct control_mode_page));
+
+	if (ioctl(c->fd, SG_IO, &io_hdr) < 0)
+		goto out;
+
+	/* if TAS bit is not settable exit */
+	if (((changeable.tas_bit >> 6) & 0x1) == 0)
+		goto out;
+
+	/* Now go ahead and set it */
+	memset(cmd, 0, MODE_SEN_SEL_CMDLEN);
+	cmd[0] = MODE_SELECT_CMD;
+	cmd[1] = 0x1; /* set SP bit on */
+	cmd[8] = (sizeof(struct control_mode_page) &  0xff);
+
+	/* use the same buffer as current, only set the tas bit */
+	current.page_code = 0xA;
+	current.page_len = 0xA;
+	current.tas_bit |= (1 << 6);
+
+	io_hdr.dxfer_direction = SG_DXFER_TO_DEV;
+	io_hdr.dxferp = &current;
+
+	if (ioctl(c->fd, SG_IO, &io_hdr) < 0)
+		goto out;
+
+	/* Success */
+	set = 1;
+out:
+	if (set == 0)
+		condlog(0, "rdac checker failed to set TAS bit");
 	return 0;
 }
 
@@ -43,12 +128,15 @@ void libcheck_free (struct checker * c)
 }
 
 static int
-do_inq(int sg_fd, unsigned int pg_op, void *resp, int mx_resp_len)
+do_inq(int sg_fd, unsigned int pg_op, void *resp, int mx_resp_len,
+       unsigned int timeout)
 {
 	unsigned char inqCmdBlk[INQUIRY_CMDLEN] = { INQUIRY_CMD, 1, 0, 0, 0, 0 };
 	unsigned char sense_b[SENSE_BUFF_LEN];
 	struct sg_io_hdr io_hdr;
+	int retry_rdac = 5;
 
+retry:
 	inqCmdBlk[2] = (unsigned char) pg_op;
 	inqCmdBlk[4] = (unsigned char) (mx_resp_len & 0xff);
 	memset(&io_hdr, 0, sizeof (struct sg_io_hdr));
@@ -62,7 +150,7 @@ do_inq(int sg_fd, unsigned int pg_op, void *resp, int mx_resp_len)
 	io_hdr.dxferp = resp;
 	io_hdr.cmdp = inqCmdBlk;
 	io_hdr.sbp = sense_b;
-	io_hdr.timeout = RDAC_DEF_TIMEOUT;
+	io_hdr.timeout = timeout;
 
 	if (ioctl(sg_fd, SG_IO, &io_hdr) < 0)
 		return 1;
@@ -72,6 +160,22 @@ do_inq(int sg_fd, unsigned int pg_op, void *resp, int mx_resp_len)
 	if ((0 == io_hdr.status) && (0 == io_hdr.host_status) &&
 	    (0 == io_hdr.driver_status))
 		return 0;
+
+	/* check if we need to retry this error */
+	if (io_hdr.info & SG_INFO_OK_MASK) {
+		switch (io_hdr.host_status) {
+		case DID_BUS_BUSY:
+		case DID_ERROR:
+		case DID_TRANSPORT_DISRUPTED:
+			/* Transport error, retry */
+			if (--retry_rdac)
+				goto retry;
+			break;
+		default:
+			break;
+		}
+	}
+
 	if ((SCSI_CHECK_CONDITION == io_hdr.status) ||
 	    (SCSI_COMMAND_TERMINATED == io_hdr.status) ||
 	    (SG_ERR_DRIVER_SENSE == (0xf & io_hdr.driver_status))) {
@@ -94,7 +198,10 @@ struct volume_access_inq
 	char PQ_PDT;
 	char dontcare0[7];
 	char avtcvp;
-	char dontcare1[39];
+	char dontcare1;
+	char asym_access_state_cur;
+	char vendor_specific_cur;
+	char dontcare2[36];
 };
 
 extern int
@@ -104,16 +211,29 @@ libcheck_check (struct checker * c)
 	int ret;
 
 	memset(&inq, 0, sizeof(struct volume_access_inq));
-	if (0 != do_inq(c->fd, 0xC9, &inq, sizeof(struct volume_access_inq))) {
+	if (0 != do_inq(c->fd, 0xC9, &inq, sizeof(struct volume_access_inq),
+			c->timeout)) {
 		ret = PATH_DOWN;
 		goto done;
-	} else if ((inq.PQ_PDT & 0x20) || (inq.PQ_PDT & 0x7f)) {
+	} else if (((inq.PQ_PDT & 0xE0) == 0x20) || (inq.PQ_PDT & 0x7f)) {
 		/* LUN not connected*/
 		ret = PATH_DOWN;
 		goto done;
 	}
 
-	ret = ((inq.avtcvp & 0x1) ? PATH_UP : PATH_GHOST);
+	/* check if controller is in service mode */
+	if ((inq.avtcvp & 0x10) &&
+	    ((inq.asym_access_state_cur & 0x0F) == 0x3) &&
+	    (inq.vendor_specific_cur == 0x7)) {
+		ret = PATH_DOWN;
+		goto done;
+	}
+
+	/* If owner set or ioship mode is enabled return PATH_UP always */
+	if ((inq.avtcvp & 0x1) || ((inq.avtcvp >> 5) & 0x1))
+		ret = PATH_UP;
+	else
+		ret = PATH_GHOST;
 
 done:
 	switch (ret) {
diff --git a/libmultipath/checkers/readsector0.c b/libmultipath/checkers/readsector0.c
index 24182e6..0550fb6 100644
--- a/libmultipath/checkers/readsector0.c
+++ b/libmultipath/checkers/readsector0.c
@@ -29,7 +29,8 @@ int libcheck_check (struct checker * c)
 	unsigned char sbuf[SENSE_BUFF_LEN];
 	int ret;
 
-	ret = sg_read(c->fd, &buf[0], &sbuf[0]);
+	ret = sg_read(c->fd, &buf[0], 4069, &sbuf[0],
+		      SENSE_BUFF_LEN, c->timeout);
 
 	switch (ret)
 	{
diff --git a/libmultipath/checkers/tur.c b/libmultipath/checkers/tur.c
index 47107a2..224cf76 100644
--- a/libmultipath/checkers/tur.c
+++ b/libmultipath/checkers/tur.c
@@ -12,10 +12,14 @@
 #include <fcntl.h>
 #include <sys/ioctl.h>
 #include <errno.h>
+#include <sys/time.h>
+#include <pthread.h>
 
 #include "checkers.h"
 
+#include "../libmultipath/debug.h"
 #include "../libmultipath/sg_include.h"
+#include "../libmultipath/uevent.h"
 
 #define TUR_CMD_LEN 6
 #define HEAVY_CHECK_COUNT       10
@@ -23,23 +27,54 @@
 #define MSG_TUR_UP	"tur checker reports path is up"
 #define MSG_TUR_DOWN	"tur checker reports path is down"
 #define MSG_TUR_GHOST	"tur checker reports path is in standby state"
+#define MSG_TUR_RUNNING	"tur checker still running"
+#define MSG_TUR_TIMEOUT	"tur checker timed out"
+#define MSG_TUR_FAILED	"tur checker failed to initialize"
 
 struct tur_checker_context {
-	void * dummy;
+	dev_t devt;
+	int state;
+	int running;
+	time_t timeout;
+	pthread_t thread;
+	pthread_mutex_t lock;
+	pthread_cond_t active;
 };
 
+#define TUR_DEVT(c) major((c)->devt), minor((c)->devt)
+
 int libcheck_init (struct checker * c)
 {
+	struct tur_checker_context *ct;
+
+	ct = malloc(sizeof(struct tur_checker_context));
+	if (!ct)
+		return 1;
+	memset(ct, 0, sizeof(struct tur_checker_context));
+
+	ct->state = PATH_UNCHECKED;
+	pthread_cond_init(&ct->active, NULL);
+	pthread_mutex_init(&ct->lock, NULL);
+	c->context = ct;
+
 	return 0;
 }
 
 void libcheck_free (struct checker * c)
 {
+	if (c->context) {
+		struct tur_checker_context *ct = c->context;
+
+		pthread_mutex_destroy(&ct->lock);
+		pthread_cond_destroy(&ct->active);
+		free(c->context);
+		c->context = NULL;
+	}
 	return;
 }
 
-extern int
-libcheck_check (struct checker * c)
+int
+tur_check (struct checker * c)
 {
 	struct sg_io_hdr io_hdr;
 	unsigned char turCmdBlk[TUR_CMD_LEN] = { 0x00, 0, 0, 0, 0, 0 };
@@ -55,12 +90,20 @@ libcheck_check (struct checker * c)
 	io_hdr.dxfer_direction = SG_DXFER_NONE;
 	io_hdr.cmdp = turCmdBlk;
 	io_hdr.sbp = sense_buffer;
-	io_hdr.timeout = DEF_TIMEOUT;
+	io_hdr.timeout = c->timeout;
 	io_hdr.pack_id = 0;
 	if (ioctl(c->fd, SG_IO, &io_hdr) < 0) {
 		MSG(c, MSG_TUR_DOWN);
 		return PATH_DOWN;
 	}
+	if ((io_hdr.status & 0x7e) == 0x18) {
+		/*
+		 * SCSI-3 arrays might return
+		 * reservation conflict on TUR
+		 */
+		MSG(c, MSG_TUR_UP);
+		return PATH_UP;
+	}
 	if (io_hdr.info & SG_INFO_OK_MASK) {
 		int key = 0, asc, ascq;
 
@@ -113,3 +156,161 @@ libcheck_check (struct checker * c)
 	MSG(c, MSG_TUR_UP);
 	return PATH_UP;
 }
+
+#define tur_thread_cleanup_push(ct) pthread_cleanup_push(cleanup_func, ct)
+#define tur_thread_cleanup_pop(ct) pthread_cleanup_pop(1)
+
+void cleanup_func(void *data)
+{
+	struct tur_checker_context *ct = data;
+	ct->thread = 0;
+}
+
+void *tur_thread(void *ctx)
+{
+	struct checker *c = ctx;
+	struct tur_checker_context *ct = c->context;
+	int state;
+
+	condlog(3, "%d:%d: tur checker starting up", TUR_DEVT(ct));
+
+	/* This thread can be canceled, so setup clean up */
+	tur_thread_cleanup_push(ct)
+
+	/* TUR checker start up */
+	pthread_mutex_lock(&ct->lock);
+	ct->state = PATH_PENDING;
+	pthread_mutex_unlock(&ct->lock);
+
+	state = tur_check(c);
+
+	/* TUR checker done */
+	pthread_mutex_lock(&ct->lock);
+	ct->state = state;
+	pthread_mutex_unlock(&ct->lock);
+	pthread_cond_signal(&ct->active);
+
+	condlog(3, "%d:%d: tur checker finished, state %s",
+		TUR_DEVT(ct), checker_state_name(state));
+	tur_thread_cleanup_pop(ct);
+	return ((void *)0);
+}
+
+
+void tur_timeout(struct timespec *tsp)
+{
+	struct timeval now;
+
+	gettimeofday(&now, NULL);
+	tsp->tv_sec = now.tv_sec;
+	tsp->tv_nsec = now.tv_usec * 1000;
+	tsp->tv_nsec += 1000000; /* 1 millisecond */
+}
+
+void tur_set_async_timeout(struct checker *c)
+{
+	struct tur_checker_context *ct = c->context;
+	struct timeval now;
+
+	gettimeofday(&now, NULL);
+	ct->timeout = now.tv_sec + c->timeout;
+}
+
+int tur_check_async_timeout(struct checker *c)
+{
+	struct tur_checker_context *ct = c->context;
+	struct timeval now;
+
+	gettimeofday(&now, NULL);
+	return (now.tv_sec > ct->timeout);
+}
+
+extern int
+libcheck_check (struct checker * c)
+{
+	struct tur_checker_context *ct = c->context;
+	struct timespec tsp;
+	struct stat sb;
+	pthread_attr_t attr;
+	int tur_status, r;
+
+
+	if (!ct)
+		return PATH_UNCHECKED;
+
+	if (fstat(c->fd, &sb) == 0)
+		ct->devt = sb.st_rdev;
+
+	if (c->sync)
+		return tur_check(c);
+
+	/*
+	 * Async mode
+	 */
+	r = pthread_mutex_lock(&ct->lock);
+	if (r != 0) {
+		condlog(2, "%d:%d: tur mutex lock failed with %d",
+			TUR_DEVT(ct), r);
+		MSG(c, MSG_TUR_FAILED);
+		return PATH_WILD;
+	}
+
+	if (ct->running) {
+		/* Check if TUR checker is still running */
+		if (ct->thread) {
+			if (tur_check_async_timeout(c)) {
+				condlog(3, "%d:%d: tur checker timeout",
+					TUR_DEVT(ct));
+				pthread_cancel(ct->thread);
+				ct->running = 0;
+				MSG(c, MSG_TUR_TIMEOUT);
+				tur_status = PATH_DOWN;
+				ct->state = PATH_UNCHECKED;
+			} else {
+				condlog(3, "%d:%d: tur checker not finished",
+					TUR_DEVT(ct));
+				ct->running++;
+				tur_status = PATH_PENDING;
+			}
+		} else {
+			/* TUR checker done */
+			ct->running = 0;
+			tur_status = ct->state;
+		}
+		pthread_mutex_unlock(&ct->lock);
+	} else {
+		if (ct->thread) {
+			/* pthread cancel failed. continue in sync mode */
+			pthread_mutex_unlock(&ct->lock);
+			condlog(3, "%d:%d: tur thread not responding, "
+				"using sync mode", TUR_DEVT(ct));
+			return tur_check(c);
+		}
+		/* Start new TUR checker */
+		ct->state = PATH_UNCHECKED;
+		tur_set_async_timeout(c);
+		setup_thread_attr(&attr, 32 * 1024, 1);
+		r = pthread_create(&ct->thread, &attr, tur_thread, c);
+		if (r) {
+			pthread_mutex_unlock(&ct->lock);
+			ct->thread = 0;
+			condlog(3, "%d:%d: failed to start tur thread, using"
+				" sync mode", TUR_DEVT(ct));
+			return tur_check(c);
+		}
+		pthread_attr_destroy(&attr);
+		tur_timeout(&tsp);
+		r = pthread_cond_timedwait(&ct->active, &ct->lock, &tsp);
+		tur_status = ct->state;
+		pthread_mutex_unlock(&ct->lock);
+		if (ct->thread &&
+		    (tur_status == PATH_PENDING || tur_status == PATH_UNCHECKED)) {
+			condlog(3, "%d:%d: tur checker still running",
+				TUR_DEVT(ct));
+			ct->running = 1;
+			tur_status = PATH_PENDING;
+		}
+	}
+
+	return tur_status;
+}
diff --git a/libmultipath/config.c b/libmultipath/config.c
index a4178be..f99465a 100644
--- a/libmultipath/config.c
+++ b/libmultipath/config.c
@@ -19,6 +19,7 @@
 #include "blacklist.h"
 #include "defaults.h"
 #include "prio.h"
+#include "devmapper.h"
 
 static int
 hwe_strmatch (struct hwentry *hwe1, struct hwentry *hwe2)
@@ -50,42 +51,64 @@ find_hwe_strmatch (vector hwtable, struct hwentry *hwe)
 	return ret;
 }
 
+static int
+hwe_regmatch (struct hwentry *hwe1, struct hwentry *hwe2)
+{
+	regex_t vre, pre, rre;
+	int retval = 1;
+
+	if (hwe1->vendor &&
+	    regcomp(&vre, hwe1->vendor, REG_EXTENDED|REG_NOSUB))
+		goto out;
+
+	if (hwe1->product &&
+	    regcomp(&pre, hwe1->product, REG_EXTENDED|REG_NOSUB))
+		goto out_vre;
+
+	if (hwe1->revision &&
+	    regcomp(&rre, hwe1->revision, REG_EXTENDED|REG_NOSUB))
+		goto out_pre;
+
+	if ((!hwe1->vendor || !hwe2->vendor ||
+	     !regexec(&vre, hwe2->vendor, 0, NULL, 0)) &&
+	    (!hwe1->product || !hwe2->product ||
+	     !regexec(&pre, hwe2->product, 0, NULL, 0)) &&
+	    (!hwe1->revision || !hwe2->revision ||
+	     !regexec(&rre, hwe2->revision, 0, NULL, 0)))
+		retval = 0;
+
+	if (hwe1->revision)
+		regfree(&rre);
+out_pre:
+	if (hwe1->product)
+		regfree(&pre);
+out_vre:
+	if (hwe1->vendor)
+		regfree(&vre);
+out:
+	return retval;
+}
+
 struct hwentry *
 find_hwe (vector hwtable, char * vendor, char * product, char * revision)
 {
 	int i;
-	struct hwentry *hwe, *ret = NULL;
-	regex_t vre, pre, rre;
+	struct hwentry hwe, *tmp, *ret = NULL;
 
-	vector_foreach_slot (hwtable, hwe, i) {
-		if (hwe->vendor &&
-		    regcomp(&vre, hwe->vendor, REG_EXTENDED|REG_NOSUB))
-			break;
-		if (hwe->product &&
-		    regcomp(&pre, hwe->product, REG_EXTENDED|REG_NOSUB)) {
-			regfree(&vre);
-			break;
-		}
-		if (hwe->revision &&
-		    regcomp(&rre, hwe->revision, REG_EXTENDED|REG_NOSUB)) {
-			regfree(&vre);
-			regfree(&pre);
-			break;
-		}
-		if ((!hwe->vendor || !regexec(&vre, vendor, 0, NULL, 0)) &&
-		    (!hwe->product || !regexec(&pre, product, 0, NULL, 0)) &&
-		    (!hwe->revision || !regexec(&rre, revision, 0, NULL, 0)))
-			ret = hwe;
-
-		if (hwe->revision)
-			regfree(&rre);
-		if (hwe->product)
-			regfree(&pre);
-		if (hwe->vendor)
-			regfree(&vre);
-
-		if (ret)
-			break;
+	hwe.vendor = vendor;
+	hwe.product = product;
+	hwe.revision = revision;
+	/*
+	 * Search backwards here.
+	 * User modified entries are attached at the end of
+	 * the list, so we have to check them first before
+	 * continuing to the generic entries
+	 */
+	vector_foreach_slot_backwards (hwtable, tmp, i) {
+		if (hwe_regmatch(tmp, &hwe))
+			continue;
+		ret = tmp;
+		break;
 	}
 	return ret;
 }
@@ -158,6 +181,9 @@ free_hwe (struct hwentry * hwe)
 	if (hwe->prio_args)
 		FREE(hwe->prio_args);
 
+	if (hwe->alias_prefix)
+		FREE(hwe->alias_prefix);
+
 	if (hwe->bl_product)
 		FREE(hwe->bl_product);
 
@@ -197,6 +223,12 @@ free_mpe (struct mpentry * mpe)
 	if (mpe->alias)
 		FREE(mpe->alias);
 
+	if (mpe->prio_name)
+		FREE(mpe->prio_name);
+
+	if (mpe->prio_args)
+		FREE(mpe->prio_args);
+
 	FREE(mpe);
 }
 
@@ -257,20 +289,18 @@ set_param_str(char * str)
 }
 
 #define merge_str(s) \
-	if (hwe2->s) { \
-		if (hwe1->s) \
-			FREE(hwe1->s); \
-		if (!(hwe1->s = set_param_str(hwe2->s))) \
+	if (!dst->s && src->s) { \
+		if (!(dst->s = set_param_str(src->s))) \
 			return 1; \
 	}
 
 #define merge_num(s) \
-	if (hwe2->s) \
-		hwe1->s = hwe2->s
+	if (!dst->s && src->s) \
+		dst->s = src->s
 
 
 static int
-merge_hwe (struct hwentry * hwe1, struct hwentry * hwe2)
+merge_hwe (struct hwentry * dst, struct hwentry * src)
 {
 	merge_str(vendor);
 	merge_str(product);
@@ -282,12 +312,18 @@ merge_hwe (struct hwentry * hwe1, struct hwentry * hwe2)
 	merge_str(checker_name);
 	merge_str(prio_name);
 	merge_str(prio_args);
+	merge_str(alias_prefix);
 	merge_str(bl_product);
 	merge_num(pgpolicy);
 	merge_num(pgfailback);
 	merge_num(rr_weight);
 	merge_num(no_path_retry);
 	merge_num(minio);
+	merge_num(minio_rq);
+	merge_num(pg_timeout);
+	merge_num(flush_on_last_del);
+	merge_num(fast_io_fail);
+	merge_num(dev_loss);
 
 	return 0;
 }
@@ -333,11 +369,15 @@ store_hwe (vector hwtable, struct hwentry * dhwe)
 	if (dhwe->prio_args && !(hwe->prio_args = set_param_str(dhwe->prio_args)))
 		goto out;
 
+	if (dhwe->alias_prefix && !(hwe->alias_prefix = set_param_str(dhwe->alias_prefix)))
+		goto out;
+
 	hwe->pgpolicy = dhwe->pgpolicy;
 	hwe->pgfailback = dhwe->pgfailback;
 	hwe->rr_weight = dhwe->rr_weight;
 	hwe->no_path_retry = dhwe->no_path_retry;
 	hwe->minio = dhwe->minio;
+	hwe->minio_rq = dhwe->minio_rq;
 
 	if (dhwe->bl_product && !(hwe->bl_product = set_param_str(dhwe->bl_product)))
 		goto out;
@@ -353,21 +393,20 @@ out:
 }
 
 static int
-factorize_hwtable (vector hw)
+factorize_hwtable (vector hw, int n)
 {
 	struct hwentry *hwe1, *hwe2;
 	int i, j;
 
 	vector_foreach_slot(hw, hwe1, i) {
-		j = i+1;
+		if (i == n)
+			break;
+		j = n;
 		vector_foreach_slot_after(hw, hwe2, j) {
-			if (hwe_strmatch(hwe1, hwe2))
+			if (hwe_regmatch(hwe1, hwe2))
 				continue;
 			/* dup */
-			merge_hwe(hwe1, hwe2);
-			free_hwe(hwe2);
-			vector_del_slot(hw, j);
-			j--;
+			merge_hwe(hwe2, hwe1);
 		}
 	}
 	return 0;
@@ -406,14 +445,22 @@ free_config (struct config * conf)
 	if (conf->hwhandler)
 		FREE(conf->hwhandler);
 
+	if (conf->bindings_file)
+		FREE(conf->bindings_file);
+
 	if (conf->prio_name)
 		FREE(conf->prio_name);
 
+	if (conf->alias_prefix)
+		FREE(conf->alias_prefix);
+
 	if (conf->prio_args)
 		FREE(conf->prio_args);
 
 	if (conf->checker_name)
 		FREE(conf->checker_name);
+	if (conf->reservation_key)
+		FREE(conf->reservation_key);
 
 	free_blacklist(conf->blist_devnode);
 	free_blacklist(conf->blist_wwid);
@@ -444,13 +491,20 @@ load_config (char * file)
 	if (!conf->verbosity)
 		conf->verbosity = DEFAULT_VERBOSITY;
 
+	conf->dmrq = dm_drv_get_rq();
 	conf->dev_type = DEV_NONE;
-	conf->minio = 1000;
-	conf->max_fds = 0;
-	conf->bindings_file = DEFAULT_BINDINGS_FILE;
+	conf->minio = DEFAULT_MINIO;
+	conf->minio_rq = DEFAULT_MINIO_RQ;
+	get_sys_max_fds(&conf->max_fds);
+	conf->bindings_file = set_default(DEFAULT_BINDINGS_FILE);
+	conf->bindings_read_only = 0;
 	conf->multipath_dir = set_default(DEFAULT_MULTIPATHDIR);
+	conf->features = set_default(DEFAULT_FEATURES);
 	conf->flush_on_last_del = 0;
 	conf->attribute_flags = 0;
+	conf->reassign_maps = DEFAULT_REASSIGN_MAPS;
+	conf->checkint = DEFAULT_CHECKINT;
+	conf->max_checkint = MAX_CHECKINT(conf->checkint);
 
 	/*
 	 * preload default hwtable
@@ -467,19 +521,27 @@ load_config (char * file)
 	/*
 	 * read the config file
 	 */
+	set_current_keywords(&conf->keywords);
+	alloc_keywords();
 	if (filepresent(file)) {
-		set_current_keywords(&conf->keywords);
+		int builtin_hwtable_size;
+
+		builtin_hwtable_size = VECTOR_SIZE(conf->hwtable);
 		if (init_data(file, init_keywords)) {
 			condlog(0, "error parsing config file");
 			goto out;
 		}
-	}
+		if (VECTOR_SIZE(conf->hwtable) > builtin_hwtable_size) {
+			/*
+			 * remove duplica in hwtable. config file
+			 * takes precedence over build-in hwtable
+			 */
+			factorize_hwtable(conf->hwtable, builtin_hwtable_size);
+		}
 
-	/*
-	 * remove duplica in hwtable. config file takes precedence
-	 * over build-in hwtable
-	 */
-	factorize_hwtable(conf->hwtable);
+	} else {
+		init_keywords();
+	}
 
 	/*
 	 * fill the voids left in the config file
@@ -533,7 +595,11 @@ load_config (char * file)
 	if (conf->udev_dir == NULL)
 		conf->udev_dir = set_default(DEFAULT_UDEVDIR);
 
-	if (!conf->udev_dir || !conf->multipath_dir)
+	if (conf->bindings_file == NULL)
+		conf->bindings_file = set_default(DEFAULT_BINDINGS_FILE);
+
+	if (!conf->udev_dir || !conf->multipath_dir ||
+	    !conf->bindings_file)
 		goto out;
 
 	return 0;
diff --git a/libmultipath/config.h b/libmultipath/config.h
index 471eed0..6fcd45e 100644
--- a/libmultipath/config.h
+++ b/libmultipath/config.h
@@ -7,6 +7,13 @@
 #define ORIGIN_DEFAULT 0
 #define ORIGIN_CONFIG  1
 
+/*
+ * In kernel, fast_io_fail == 0 means immediate failure on rport delete.
+ * OTOH '0' means not-configured in various places in multipath-tools.
+ */
+#define MP_FAST_IO_FAIL_OFF (-1)
+#define MP_FAST_IO_FAIL_ZERO (-2)
+
 enum devtypes {
 	DEV_NONE,
 	DEV_DEVT,
@@ -25,12 +32,14 @@ struct hwentry {
 	char * checker_name;
 	char * prio_name;
 	char * prio_args;
+	char * alias_prefix;
 
 	int pgpolicy;
 	int pgfailback;
 	int rr_weight;
 	int no_path_retry;
 	int minio;
+	int minio_rq;
 	int pg_timeout;
 	int flush_on_last_del;
 	int fast_io_fail;
@@ -43,12 +52,17 @@ struct mpentry {
 	char * alias;
 	char * getuid;
 	char * selector;
+	char * features;
 
+	char * prio_name;
+	char * prio_args;
+	unsigned char * reservation_key;
 	int pgpolicy;
 	int pgfailback;
 	int rr_weight;
 	int no_path_retry;
 	int minio;
+	int minio_rq;
 	int pg_timeout;
 	int flush_on_last_del;
 	int attribute_flags;
@@ -58,6 +72,7 @@ struct mpentry {
 };
 
 struct config {
+	int dmrq;
 	int verbosity;
 	int dry_run;
 	int list;
@@ -66,6 +81,7 @@ struct config {
 	int pgpolicy;
 	enum devtypes dev_type;
 	int minio;
+	int minio_rq;
 	int checkint;
 	int max_checkint;
 	int pgfailback;
@@ -73,19 +89,24 @@ struct config {
 	int rr_weight;
 	int no_path_retry;
 	int user_friendly_names;
+	int bindings_read_only;
 	int pg_timeout;
 	int max_fds;
 	int force_reload;
 	int queue_without_daemon;
+	int checker_timeout;
 	int daemon;
 	int flush_on_last_del;
 	int attribute_flags;
 	int fast_io_fail;
 	unsigned int dev_loss;
+	int log_checker_err;
+	int allow_queueing;
 	uid_t uid;
 	gid_t gid;
 	mode_t mode;
 	uint32_t cookie;
+	int reassign_maps;
 
 	char * dev;
 	char * sysfs_dir;
@@ -99,6 +120,8 @@ struct config {
 	char * prio_name;
 	char * prio_args;
 	char * checker_name;
+	char * alias_prefix;
+	unsigned char * reservation_key;
 
 	vector keywords;
 	vector mptable;
diff --git a/libmultipath/configure.c b/libmultipath/configure.c
index c6ca4b6..001c1f0 100644
--- a/libmultipath/configure.c
+++ b/libmultipath/configure.c
@@ -35,13 +35,14 @@
 #include "alias.h"
 #include "prio.h"
 #include "util.h"
+#include "uxsock.h"
 
 extern int
-setup_map (struct multipath * mpp)
+setup_map (struct multipath * mpp, char * params, int params_size)
 {
 	struct pathgroup * pgp;
 	int i;
-	
+
 	/*
 	 * don't bother if devmap size is unknown
 	 */
@@ -72,6 +73,7 @@ setup_map (struct multipath * mpp)
 	select_gid(mpp);
 	select_fast_io_fail(mpp);
 	select_dev_loss(mpp);
+	select_reservation_key(mpp);
 
 	sysfs_set_scsi_tmo(mpp);
 	/*
@@ -88,7 +90,7 @@ setup_map (struct multipath * mpp)
 	if (mpp->pgpolicyfn && mpp->pgpolicyfn(mpp))
 		return 1;
 
-	mpp->nr_active = pathcount(mpp, PATH_UP);
+	mpp->nr_active = pathcount(mpp, PATH_UP) + pathcount(mpp, PATH_GHOST);
 
 	/*
 	 * ponders each path group and determine highest prio pg
@@ -100,7 +102,7 @@ setup_map (struct multipath * mpp)
 	 * transform the mp->pg vector of vectors of paths
 	 * into a mp->params strings to feed the device-mapper
 	 */
-	if (assemble_map(mpp)) {
+	if (assemble_map(mpp, params, params_size)) {
 		condlog(0, "%s: problem assembing map", mpp->alias);
 		return 1;
 	}
@@ -132,7 +134,8 @@ pgcmp (struct multipath * mpp, struct multipath * cmpp)
 		compute_pgid(pgp);
 
 		vector_foreach_slot (cmpp->pg, cpgp, j) {
-			if (pgp->id == cpgp->id) {
+			if (pgp->id == cpgp->id &&
+			    !pathcmp(pgp, cpgp)) {
 				r = 0;
 				break;
 			}
@@ -170,7 +173,7 @@ select_action (struct multipath * mpp, vector curmp, int force_reload)
 	if (!find_mp_by_wwid(curmp, mpp->wwid)) {
 		condlog(2, "%s: remove (wwid changed)", cmpp->alias);
 		dm_flush_map(mpp->alias);
-		strncat(cmpp->wwid, mpp->wwid, WWID_SIZE);
+		strncpy(cmpp->wwid, mpp->wwid, WWID_SIZE);
 		drop_multipath(curmp, cmpp->wwid, KEEP_PATHS);
 		mpp->action = ACT_CREATE;
 		condlog(3, "%s: set ACT_CREATE (map wwid change)",
@@ -191,8 +194,8 @@ select_action (struct multipath * mpp, vector curmp, int force_reload)
 		return;
 	}
 	if (cmpp->size != mpp->size) {
-		mpp->action = ACT_RELOAD;
-		condlog(3, "%s: set ACT_RELOAD (size change)",
+		mpp->action = ACT_RESIZE;
+		condlog(3, "%s: set ACT_RESIZE (size change)",
 			mpp->alias);
 		return;
 	}
@@ -284,6 +287,7 @@ lock_multipath (struct multipath * mpp, int lock)
 	struct pathgroup * pgp;
 	struct path * pp;
 	int i, j;
+	int x, y;
 
 	if (!mpp || !mpp->pg)
 		return 0;
@@ -294,12 +298,25 @@ lock_multipath (struct multipath * mpp, int lock)
 		vector_foreach_slot(pgp->paths, pp, j) {
 			if (lock && flock(pp->fd, LOCK_EX | LOCK_NB) &&
 			    errno == EWOULDBLOCK)
-				return 1;
+				goto fail;
 			else if (!lock)
 				flock(pp->fd, LOCK_UN);
 		}
 	}
 	return 0;
+fail:
+	vector_foreach_slot (mpp->pg, pgp, x) {
+		if (x > i)
+			return 1;
+		if (!pgp->paths)
+			continue;
+		vector_foreach_slot(pgp->paths, pp, y) {
+			if (x == i && y >= j)
+				return 1;
+			flock(pp->fd, LOCK_UN);
+		}
+	}
+	return 1;
 }
 
 /*
@@ -312,7 +329,7 @@ lock_multipath (struct multipath * mpp, int lock)
 #define DOMAP_DRY	3
 
 extern int
-domap (struct multipath * mpp)
+domap (struct multipath * mpp, char * params)
 {
 	int r = 0;
 
@@ -352,28 +369,28 @@ domap (struct multipath * mpp)
 			break;
 		}
 
-		r = dm_addmap_create(mpp);
+		r = dm_addmap_create(mpp, params);
 
 		if (!r)
-			 r = dm_addmap_create_ro(mpp);
+			r = dm_addmap_create_ro(mpp, params);
 
 		lock_multipath(mpp, 0);
 		break;
 
 	case ACT_RELOAD:
-		r = dm_addmap_reload(mpp);
+		r = dm_addmap_reload(mpp, params);
 		if (!r)
-			r = dm_addmap_reload_ro(mpp);
+			r = dm_addmap_reload_ro(mpp, params);
 		if (r)
 			r = dm_simplecmd_noflush(DM_DEVICE_RESUME, mpp->alias);
 		break;
 
- 	case ACT_RESIZE:
-  		r = dm_addmap_reload(mpp);
-  		if (!r)
-  			r = dm_addmap_reload_ro(mpp);
-  		if (r)
-  			r = dm_simplecmd_flush(DM_DEVICE_RESUME, mpp->alias, 1);
+	case ACT_RESIZE:
+		r = dm_addmap_reload(mpp, params);
+		if (!r)
+			r = dm_addmap_reload_ro(mpp, params);
+		if (r)
+			r = dm_simplecmd_flush(DM_DEVICE_RESUME, mpp->alias, 1);
 		break;
 
 	case ACT_RENAME:
@@ -392,13 +409,11 @@ domap (struct multipath * mpp)
 		if (!conf->daemon) {
 			/* multipath client mode */
 			dm_switchgroup(mpp->alias, mpp->bestpg);
-			if (mpp->action != ACT_NOTHING)
-				print_multipath_topology(mpp, conf->verbosity);
 		} else  {
 			/* multipath daemon mode */
 			mpp->stat_map_loads++;
 			condlog(2, "%s: load table [0 %llu %s %s]", mpp->alias,
-				mpp->size, TGT_MPATH, mpp->params);
+				mpp->size, TGT_MPATH, params);
 			/*
 			 * Required action is over, reset for the stateful daemon.
 			 * But don't do it for creation as we use in the caller the
@@ -407,6 +422,7 @@ domap (struct multipath * mpp)
 			if (mpp->action != ACT_CREATE)
 				mpp->action = ACT_NOTHING;
 		}
+		dm_setgeometry(mpp);
 		return DOMAP_OK;
 	}
 	return DOMAP_FAIL;
@@ -434,12 +450,41 @@ deadmap (struct multipath * mpp)
 	return 1; /* dead */
 }
 
+int check_daemon(void)
+{
+	int fd;
+	char *reply;
+	size_t len;
+	int ret = 0;
+
+	fd = ux_socket_connect(DEFAULT_SOCKET);
+	if (fd == -1)
+		return 0;
+
+	if (send_packet(fd, "show daemon", 12) != 0)
+		goto out;
+	if (recv_packet(fd, &reply, &len) != 0)
+		goto out;
+
+	if (strstr(reply, "shutdown"))
+		goto out_free;
+
+	ret = 1;
+
+out_free:
+	FREE(reply);
+out:
+	close(fd);
+	return ret;
+}
+
 extern int
 coalesce_paths (struct vectors * vecs, vector newmp, char * refwwid, int force_reload)
 {
 	int r = 1;
 	int k, i;
 	char empty_buff[WWID_SIZE];
+	char params[PARAMS_SIZE];
 	struct multipath * mpp;
 	struct path * pp1;
 	struct path * pp2;
@@ -458,16 +503,20 @@ coalesce_paths (struct vectors * vecs, vector newmp, char * refwwid, int force_r
 
 		/* 1. if path has no unique id or wwid blacklisted */
 		if (memcmp(empty_buff, pp1->wwid, WWID_SIZE) == 0 ||
-		    filter_path(conf, pp1) > 0)
+		    filter_path(conf, pp1) > 0) {
+			orphan_path(pp1);
 			continue;
+		}
 
 		/* 2. if path already coalesced */
 		if (pp1->mpp)
 			continue;
 
 		/* 3. if path has disappeared */
-		if (!pp1->size)
+		if (!pp1->size) {
+			orphan_path(pp1);
 			continue;
+		}
 
 		/* 4. path is out of scope */
 		if (refwwid && strncmp(pp1->wwid, refwwid, WWID_SIZE))
@@ -511,8 +560,9 @@ coalesce_paths (struct vectors * vecs, vector newmp, char * refwwid, int force_r
 				mpp->action = ACT_REJECT;
 		}
 		verify_paths(mpp, vecs, NULL);
-		
-		if (setup_map(mpp)) {
+
+		params[0] = '\0';
+		if (setup_map(mpp, params, PARAMS_SIZE)) {
 			remove_map(mpp, vecs, 0);
 			continue;
 		}
@@ -520,13 +570,16 @@ coalesce_paths (struct vectors * vecs, vector newmp, char * refwwid, int force_r
 		if (mpp->action == ACT_UNDEF)
 			select_action(mpp, curmp, force_reload);
 
-		r = domap(mpp);
+		r = domap(mpp, params);
 
 		if (r == DOMAP_FAIL || r == DOMAP_RETRY) {
 			condlog(3, "%s: domap (%u) failure "
 				   "for create/reload map",
 				mpp->alias, r);
 			if (r == DOMAP_FAIL) {
+				condlog(2, "%s: %s map",
+					mpp->alias, (mpp->action == ACT_CREATE)?
+					"ignoring" : "removing");
 				remove_map(mpp, vecs, 0);
 				continue;
 			} else /* if (r == DOMAP_RETRY) */
@@ -535,11 +588,29 @@ coalesce_paths (struct vectors * vecs, vector newmp, char * refwwid, int force_r
 		if (r == DOMAP_DRY)
 			continue;
 
-		if (mpp->no_path_retry != NO_PATH_RETRY_UNDEF) {
-			if (mpp->no_path_retry == NO_PATH_RETRY_FAIL)
-				dm_queue_if_no_path(mpp->alias, 0);
-			else
-				dm_queue_if_no_path(mpp->alias, 1);
+		if (!conf->daemon && !conf->allow_queueing && !check_daemon()) {
+			if (mpp->no_path_retry != NO_PATH_RETRY_UNDEF &&
+			    mpp->no_path_retry != NO_PATH_RETRY_FAIL)
+				condlog(3, "%s: multipathd not running, unset "
+					"queue_if_no_path feature", mpp->alias);
+			if (!dm_queue_if_no_path(mpp->alias, 0))
+				remove_feature(&mpp->features,
+					       "queue_if_no_path");
+		}
+		else if (mpp->no_path_retry != NO_PATH_RETRY_UNDEF) {
+			if (mpp->no_path_retry == NO_PATH_RETRY_FAIL) {
+				condlog(3, "%s: unset queue_if_no_path feature",
+					mpp->alias);
+				if (!dm_queue_if_no_path(mpp->alias, 0))
+					remove_feature(&mpp->features,
+						       "queue_if_no_path");
+			} else {
+				condlog(3, "%s: set queue_if_no_path feature",
+					mpp->alias);
+				if (!dm_queue_if_no_path(mpp->alias, 1))
+					add_feature(&mpp->features,
+						    "queue_if_no_path");
+			}
 		}
 		if (mpp->pg_timeout != PGTIMEOUT_UNDEF) {
 			if (mpp->pg_timeout == -PGTIMEOUT_NONE)
@@ -548,6 +619,9 @@ coalesce_paths (struct vectors * vecs, vector newmp, char * refwwid, int force_r
 				dm_set_pg_timeout(mpp->alias, mpp->pg_timeout);
 		}
 
+		if (!conf->daemon && mpp->action != ACT_NOTHING)
+			print_multipath_topology(mpp, conf->verbosity);
+
 		if (newmp) {
 			if (mpp->action != ACT_REJECT) {
 				if (!vector_alloc_slot(newmp))
@@ -577,11 +651,11 @@ coalesce_paths (struct vectors * vecs, vector newmp, char * refwwid, int force_r
 
 			remove_map(mpp, vecs, 0);
 
-			if (dm_flush_map(mpp->alias))
+			if (dm_flush_map(alias))
 				condlog(2, "%s: remove failed (dead)",
-					mpp->alias);
+					alias);
 			else
-				condlog(2, "%s: remove (dead)", mpp->alias);
+				condlog(2, "%s: remove (dead)", alias);
 		}
 	}
 	return 0;
@@ -598,9 +672,13 @@ get_refwwid (char * dev, enum devtypes dev_type, vector pathvec)
 		return NULL;
 
 	if (dev_type == DEV_DEVNODE) {
-		basenamecpy(dev, buff);
+		if (basenamecpy(dev, buff, FILE_NAME_SIZE) == 0) {
+			condlog(1, "basename failed for '%s' (%s)",
+				dev, buff);
+			return NULL;
+		}
+
 		pp = find_path_by_dev(pathvec, buff);
-		
 		if (!pp) {
 			pp = alloc_path();
 
@@ -622,10 +700,10 @@ get_refwwid (char * dev, enum devtypes dev_type, vector pathvec)
 	}
 
 	if (dev_type == DEV_DEVT) {
+		strchop(dev);
 		pp = find_path_by_devt(pathvec, dev);
-		
 		if (!pp) {
-			if (devt2devname(buff, dev))
+			if (devt2devname(buff, FILE_NAME_SIZE, dev))
 				return NULL;
 
 			pp = alloc_path();
@@ -637,7 +715,7 @@ get_refwwid (char * dev, enum devtypes dev_type, vector pathvec)
 
 			if (pathinfo(pp, conf->hwtable, DI_SYSFS | DI_WWID))
 				return NULL;
-			
+
 			if (store_path(pathvec, pp)) {
 				free_path(pp);
 				return NULL;
@@ -680,3 +758,38 @@ out:
 	return NULL;
 }
 
+extern int reload_map(struct vectors *vecs, struct multipath *mpp)
+{
+	char params[PARAMS_SIZE];
+	int r;
+
+	update_mpp_paths(mpp, vecs->pathvec);
+
+	params[0] = '\0';
+	if (setup_map(mpp, params, PARAMS_SIZE)) {
+		condlog(0, "%s: failed to setup map", mpp->alias);
+		return 1;
+	}
+	select_action(mpp, vecs->mpvec, 1);
+
+	r = domap(mpp, params);
+	if (r == DOMAP_FAIL || r == DOMAP_RETRY) {
+		condlog(3, "%s: domap (%u) failure "
+			"for reload map", mpp->alias, r);
+		return 1;
+	}
+	if (mpp->no_path_retry != NO_PATH_RETRY_UNDEF) {
+		if (mpp->no_path_retry == NO_PATH_RETRY_FAIL)
+			dm_queue_if_no_path(mpp->alias, 0);
+		else
+			dm_queue_if_no_path(mpp->alias, 1);
+	}
+	if (mpp->pg_timeout != PGTIMEOUT_UNDEF) {
+		if (mpp->pg_timeout == -PGTIMEOUT_NONE)
+			dm_set_pg_timeout(mpp->alias,  0);
+		else
+			dm_set_pg_timeout(mpp->alias, mpp->pg_timeout);
+	}
+
+	return 0;
+}
diff --git a/libmultipath/configure.h b/libmultipath/configure.h
index 25891ba..6c1c493 100644
--- a/libmultipath/configure.h
+++ b/libmultipath/configure.h
@@ -23,9 +23,10 @@ enum actions {
 #define FLUSH_ONE 1
 #define FLUSH_ALL 2
 
-int setup_map (struct multipath * mpp);
-int domap (struct multipath * mpp);
+int setup_map (struct multipath * mpp, char * params, int params_size );
+int domap (struct multipath * mpp, char * params);
 int reinstate_paths (struct multipath *mpp);
 int coalesce_paths (struct vectors *vecs, vector curmp, char * refwwid, int force_reload);
 char * get_refwwid (char * dev, enum devtypes dev_type, vector pathvec);
+int reload_map(struct vectors *vecs, struct multipath *mpp);
 
diff --git a/libmultipath/defaults.h b/libmultipath/defaults.h
index 5a38d25..294646a 100644
--- a/libmultipath/defaults.h
+++ b/libmultipath/defaults.h
@@ -1,10 +1,12 @@
-#define DEFAULT_GETUID		"/lib/udev/scsi_id --whitelisted --device=/dev/%n"
+#define DEFAULT_GETUID		"/lib/udev/scsi_id --whitelisted --replace-whitespace --device=/dev/%n"
 #define DEFAULT_UDEVDIR		"/dev"
 #define DEFAULT_MULTIPATHDIR	"/" LIB_STRING "/multipath"
 #define DEFAULT_SELECTOR	"round-robin 0"
+#define DEFAULT_ALIAS_PREFIX	"mpath"
 #define DEFAULT_FEATURES	"0"
 #define DEFAULT_HWHANDLER	"0"
 #define DEFAULT_MINIO		1000
+#define DEFAULT_MINIO_RQ	1
 #define DEFAULT_PGPOLICY       FAILOVER
 #define DEFAULT_FAILBACK       -FAILBACK_MANUAL
 #define DEFAULT_RR_WEIGHT      RR_WEIGHT_NONE
@@ -12,10 +14,12 @@
 #define DEFAULT_PGTIMEOUT      -PGTIMEOUT_NONE
 #define DEFAULT_USER_FRIENDLY_NAMES    0
 #define DEFAULT_VERBOSITY	2
+#define DEFAULT_REASSIGN_MAPS	1
 
 #define DEFAULT_CHECKINT	5
 #define MAX_CHECKINT(a)		(a << 2)
 
+#define MAX_DEV_LOSS_TMO	0x7FFFFFFF
 #define DEFAULT_PIDFILE		"/var/run/multipathd.pid"
 #define DEFAULT_SOCKET		"/var/run/multipathd.sock"
 #define DEFAULT_CONFIGFILE	"/etc/multipath.conf"
diff --git a/libmultipath/devmapper.c b/libmultipath/devmapper.c
index 333659b..de7d446 100644
--- a/libmultipath/devmapper.c
+++ b/libmultipath/devmapper.c
@@ -20,6 +20,7 @@
 #include "memory.h"
 #include "devmapper.h"
 #include "config.h"
+#include "sysfs.h"
 
 #include "log_pthread.h"
 #include <sys/types.h>
@@ -31,6 +32,31 @@
 #define UUID_PREFIX "mpath-"
 #define UUID_PREFIX_LEN 6
 
+#ifndef LIBDM_API_COOKIE
+static inline int dm_task_set_cookie(struct dm_task *dmt, uint32_t *c, int a)
+{
+	return 1;
+}
+
+void udev_wait(unsigned int c)
+{
+}
+
+void udev_set_sync_support(int c)
+{
+}
+#else
+void udev_wait(unsigned int c)
+{
+	dm_udev_wait(c);
+}
+
+void udev_set_sync_support(int c)
+{
+	dm_udev_set_sync_support(c);
+}
+#endif
+
 static void
 dm_write_log (int level, const char *file, int line, const char *f, ...)
 {
@@ -72,20 +98,28 @@ dm_init(void) {
 	dm_log_init_verbose(conf ? conf->verbosity + 3 : 0);
 }
 
+#define VERSION_GE(v, minv) ( \
+ (v[0] > minv[0]) || \
+ ((v[0] == minv[0]) && (v[1] > minv[1])) || \
+ ((v[0] == minv[0]) && (v[1] == minv[1]) && (v[2] >= minv[2])) \
+)
+
 static int
-dm_libprereq (void)
+dm_lib_prereq (void)
 {
 	char version[64];
 	int v[3];
+#ifdef LIBDM_API_COOKIE
 	int minv[3] = {1, 2, 38};
+#else
+	int minv[3] = {1, 2, 8};
+#endif
 
 	dm_get_library_version(version, sizeof(version));
 	condlog(3, "libdevmapper version %s", version);
 	sscanf(version, "%d.%d.%d ", &v[0], &v[1], &v[2]);
 
-	if ((v[0] > minv[0]) ||
-	    ((v[0] ==  minv[0]) && (v[1] > minv[1])) ||
-	    ((v[0] == minv[0]) && (v[1] == minv[1]) && (v[2] >= minv[2])))
+	if VERSION_GE(v, minv)
 		return 0;
 	condlog(0, "libdevmapper version must be >= %d.%.2d.%.2d",
 		minv[0], minv[1], minv[2]);
@@ -93,17 +127,16 @@ dm_libprereq (void)
 }
 
 static int
-dm_drvprereq (char * str)
+dm_drv_version (unsigned int * version, char * str)
 {
 	int r = 2;
 	struct dm_task *dmt;
 	struct dm_versions *target;
 	struct dm_versions *last_target;
-	int minv[3] = {1, 0, 3};
 	unsigned int *v;
 
 	if (!(dmt = dm_task_create(DM_DEVICE_LIST_VERSIONS)))
-		return 3;
+		return 1;
 
 	dm_task_no_open_count(dmt);
 
@@ -123,29 +156,71 @@ dm_drvprereq (char * str)
 	} while (last_target != target);
 
 	if (r == 2) {
-		condlog(0, "DM multipath kernel driver not loaded");
+		condlog(0, "DM %s kernel driver not loaded", str);
 		goto out;
 	}
 	v = target->version;
-	if ((v[0] > minv[0]) ||
-	    ((v[0] == minv[0]) && (v[1] > minv[1])) ||
-	    ((v[0] == minv[0]) && (v[1] == minv[1]) && (v[2] >= minv[2]))) {
-		r = 0;
-		goto out;
-	}
-	condlog(0, "DM multipath kernel driver must be >= %u.%.2u.%.2u",
-		minv[0], minv[1], minv[2]);
+        version[0] = v[0];
+        version[1] = v[1];
+        version[2] = v[2];
+	r = 0;
 out:
 	dm_task_destroy(dmt);
 	return r;
 }
 
+int
+dm_drv_get_rq (void)
+{
+	unsigned int minv_dmrq[3] = {1, 1, 0};
+	unsigned int version[3] = {0, 0, 0};
+        unsigned int * v = version;
+
+	if (dm_drv_version(v, TGT_MPATH)) {
+		/* in doubt return least capable */
+		return 0;
+	}
+
+	/* test request based multipath capability */
+	if VERSION_GE(v, minv_dmrq) {
+		condlog(3, "activate request-based multipathing mode "
+			   "(driver >= v%u.%u.%u)",
+			minv_dmrq[0], minv_dmrq[1], minv_dmrq[2]);
+		return 1;
+	}
+	return 0;
+}
+
+static int
+dm_drv_prereq (void)
+{
+	unsigned int minv[3] = {1, 0, 3};
+	unsigned int version[3] = {0, 0, 0};
+        unsigned int * v = version;
+
+	if (dm_drv_version(v, TGT_MPATH)) {
+		/* in doubt return not capable */
+		return 1;
+	}
+
+	/* test request based multipath capability */
+	condlog(3, "DM multipath kernel driver v%u.%u.%u",
+		v[0], v[1], v[2]);
+
+	if VERSION_GE(v, minv)
+		return 0;
+
+	condlog(0, "DM multipath kernel driver must be >= v%u.%u.%u",
+		minv[0], minv[1], minv[2]);
+	return 1;
+}
+
 extern int
 dm_prereq (void)
 {
-	if (dm_libprereq())
+	if (dm_lib_prereq())
 		return 1;
-	return dm_drvprereq(TGT_MPATH);
+	return dm_drv_prereq();
 }
 
 static int
@@ -188,8 +263,8 @@ dm_simplecmd_noflush (int task, const char *name) {
 }
 
 extern int
-dm_addmap (int task, const char *target, struct multipath *mpp, int use_uuid,
-	   int ro) {
+dm_addmap (int task, const char *target, struct multipath *mpp, char * params,
+	   int use_uuid, int ro) {
 	int r = 0;
 	struct dm_task *dmt;
 	char *prefixed_uuid = NULL;
@@ -200,7 +275,7 @@ dm_addmap (int task, const char *target, struct multipath *mpp, int use_uuid,
 	if (!dm_task_set_name (dmt, mpp->alias))
 		goto addout;
 
-	if (!dm_task_add_target (dmt, 0, mpp->size, target, mpp->params))
+	if (!dm_task_add_target (dmt, 0, mpp->size, target, params))
 		goto addout;
 
 	if (ro)
@@ -227,6 +302,8 @@ dm_addmap (int task, const char *target, struct multipath *mpp, int use_uuid,
 	if (mpp->attribute_flags & (1 << ATTR_GID) &&
 	    !dm_task_set_gid(dmt, mpp->gid))
 		goto freeout;
+	condlog(4, "%s: addmap [0 %llu %s %s]\n", mpp->alias, mpp->size,
+		target, params);
 
 	dm_task_no_open_count(dmt);
 
@@ -246,9 +323,9 @@ dm_addmap (int task, const char *target, struct multipath *mpp, int use_uuid,
 }
 
 static int
-_dm_addmap_create (struct multipath *mpp, int ro) {
+_dm_addmap_create (struct multipath *mpp, char * params, int ro) {
 	int r;
-	r = dm_addmap(DM_DEVICE_CREATE, TGT_MPATH, mpp, 1, ro);
+	r = dm_addmap(DM_DEVICE_CREATE, TGT_MPATH, mpp, params, 1, ro);
 	/*
 	 * DM_DEVICE_CREATE is actually DM_DEV_CREATE + DM_TABLE_LOAD.
 	 * Failing the second part leaves an empty map. Clean it up.
@@ -265,23 +342,23 @@ _dm_addmap_create (struct multipath *mpp, int ro) {
 #define ADDMAP_RO 1
 
 extern int
-dm_addmap_create (struct multipath *mpp) {
-	return _dm_addmap_create(mpp, ADDMAP_RW);
+dm_addmap_create (struct multipath *mpp, char *params) {
+	return _dm_addmap_create(mpp, params, ADDMAP_RW);
 }
 
 extern int
-dm_addmap_create_ro (struct multipath *mpp) {
-	return _dm_addmap_create(mpp, ADDMAP_RO);
+dm_addmap_create_ro (struct multipath *mpp, char *params) {
+	return _dm_addmap_create(mpp, params, ADDMAP_RO);
 }
 
 extern int
-dm_addmap_reload (struct multipath *mpp) {
-	return dm_addmap(DM_DEVICE_RELOAD, TGT_MPATH, mpp, 0, ADDMAP_RW);
+dm_addmap_reload (struct multipath *mpp, char *params) {
+	return dm_addmap(DM_DEVICE_RELOAD, TGT_MPATH, mpp, params, 0, ADDMAP_RW);
 }
 
 extern int
-dm_addmap_reload_ro (struct multipath *mpp) {
-	return dm_addmap(DM_DEVICE_RELOAD, TGT_MPATH, mpp, 0, ADDMAP_RO);
+dm_addmap_reload_ro (struct multipath *mpp, char *params) {
+	return dm_addmap(DM_DEVICE_RELOAD, TGT_MPATH, mpp, params, 0, ADDMAP_RO);
 }
 
 extern int
@@ -340,6 +417,10 @@ dm_get_map(char * name, unsigned long long * size, char * outparams)
 	if (size)
 		*size = length;
 
+	if (!outparams) {
+		r = 0;
+		goto out;
+	}
 	if (snprintf(outparams, PARAMS_SIZE, "%s", params) <= PARAMS_SIZE)
 		r = 0;
 out:
@@ -347,8 +428,8 @@ out:
 	return r;
 }
 
-extern int
-dm_get_uuid(char *name, char *uuid)
+static int
+dm_get_prefixed_uuid(const char *name, char *uuid)
 {
 	struct dm_task *dmt;
 	const char *uuidtmp;
@@ -365,12 +446,8 @@ dm_get_uuid(char *name, char *uuid)
 		goto uuidout;
 
 	uuidtmp = dm_task_get_uuid(dmt);
-	if (uuidtmp) {
-		if (!strncmp(uuidtmp, UUID_PREFIX, UUID_PREFIX_LEN))
-			strcpy(uuid, uuidtmp + UUID_PREFIX_LEN);
-		else
-			strcpy(uuid, uuidtmp);
-	}
+	if (uuidtmp)
+		strcpy(uuid, uuidtmp);
 	else
 		uuid[0] = '\0';
 
@@ -381,6 +458,47 @@ uuidout:
 }
 
 extern int
+dm_get_uuid(char *name, char *uuid)
+{
+	char uuidtmp[WWID_SIZE];
+
+	if (dm_get_prefixed_uuid(name, uuidtmp))
+		return 1;
+
+	if (!strncmp(uuidtmp, UUID_PREFIX, UUID_PREFIX_LEN))
+		strcpy(uuid, uuidtmp + UUID_PREFIX_LEN);
+	else
+		strcpy(uuid, uuidtmp);
+
+	return 0;
+}
+
+/*
+ * returns:
+ *    0 : if both uuids end with same suffix which starts with UUID_PREFIX
+ *    1 : otherwise
+ */
+int
+dm_compare_uuid(const char* mapname1, const char* mapname2)
+{
+	char *p1, *p2;
+	char uuid1[WWID_SIZE], uuid2[WWID_SIZE];
+
+	if (dm_get_prefixed_uuid(mapname1, uuid1))
+		return 1;
+
+	if (dm_get_prefixed_uuid(mapname2, uuid2))
+		return 1;
+
+	p1 = strstr(uuid1, UUID_PREFIX);
+	p2 = strstr(uuid2, UUID_PREFIX);
+	if (p1 && p2 && !strcmp(p1, p2))
+		return 0;
+
+	return 1;
+}
+
+extern int
 dm_get_status(char * name, char * outstatus)
 {
 	int r = 1;
@@ -511,6 +629,31 @@ out:
 }
 
 int
+dm_get_major (char * mapname)
+{
+	int r = -1;
+	struct dm_task *dmt;
+	struct dm_info info;
+
+	if (!(dmt = dm_task_create(DM_DEVICE_INFO)))
+		return 0;
+
+	if (!dm_task_set_name(dmt, mapname))
+		goto out;
+
+	if (!dm_task_run(dmt))
+		goto out;
+
+	if (!dm_task_get_info(dmt, &info))
+		goto out;
+
+	r = info.major;
+out:
+	dm_task_destroy(dmt);
+	return r;
+}
+
+int
 dm_get_minor (char * mapname)
 {
 	int r = -1;
@@ -633,7 +776,7 @@ dm_fail_path(char * mapname, char * path)
 {
 	char message[32];
 
-	if (snprintf(message, 32, "fail_path %s\n", path) > 32)
+	if (snprintf(message, 32, "fail_path %s", path) > 32)
 		return 1;
 
 	return dm_message(mapname, message);
@@ -644,7 +787,7 @@ dm_reinstate_path(char * mapname, char * path)
 {
 	char message[32];
 
-	if (snprintf(message, 32, "reinstate_path %s\n", path) > 32)
+	if (snprintf(message, 32, "reinstate_path %s", path) > 32)
 		return 1;
 
 	return dm_message(mapname, message);
@@ -656,9 +799,9 @@ dm_queue_if_no_path(char *mapname, int enable)
 	char *message;
 
 	if (enable)
-		message = "queue_if_no_path\n";
+		message = "queue_if_no_path";
 	else
-		message = "fail_if_no_path\n";
+		message = "fail_if_no_path";
 
 	return dm_message(mapname, message);
 }
@@ -678,7 +821,7 @@ dm_groupmsg (char * msg, char * mapname, int index)
 {
 	char message[32];
 
-	if (snprintf(message, 32, "%s_group %i\n", msg, index) > 32)
+	if (snprintf(message, 32, "%s_group %i", msg, index) > 32)
 		return 1;
 
 	return dm_message(mapname, message);
@@ -748,10 +891,7 @@ dm_get_maps (vector mp)
 			goto out1;
 
 		if (info > 0) {
-			if (dm_get_map(names->name, &mpp->size, mpp->params))
-				goto out1;
-
-			if (dm_get_status(names->name, mpp->status))
+			if (dm_get_map(names->name, &mpp->size, NULL))
 				goto out1;
 
 			dm_get_uuid(names->name, mpp->wwid);
@@ -777,35 +917,49 @@ out:
 	return r;
 }
 
-extern int
-dm_get_name(char *uuid, char *name)
+extern char *
+dm_get_name(char *uuid)
 {
-	vector vec;
-	struct multipath *mpp;
-	int i, rc = 0;
-
-	vec = vector_alloc();
+	struct dm_task *dmt;
+	struct dm_info info;
+	char *prefixed_uuid, *name = NULL;
+	const char *nametmp;
 
-	if (!vec)
-		return 0;
+	dmt = dm_task_create(DM_DEVICE_INFO);
+	if (!dmt)
+		return NULL;
 
-	if (dm_get_maps(vec)) {
-		goto out;
+	prefixed_uuid = MALLOC(UUID_PREFIX_LEN + strlen(uuid) + 1);
+	if (!prefixed_uuid) {
+		condlog(0, "cannot create prefixed uuid : %s\n",
+			strerror(errno));
+		goto freeout;
 	}
+	sprintf(prefixed_uuid, UUID_PREFIX "%s", uuid);
+	if (!dm_task_set_uuid(dmt, prefixed_uuid))
+		goto freeout;
 
-	vector_foreach_slot(vec, mpp, i) {
-		if (!strcmp(uuid, mpp->wwid)) {
-			strcpy(name, mpp->alias);
-			rc=1;
-			break;
-		}
-	}
-out:
-	vector_foreach_slot(vec, mpp, i) {
-		free_multipath(mpp, KEEP_PATHS);
+	if (!dm_task_run(dmt))
+		goto freeout;
+
+	if (!dm_task_get_info(dmt, &info) || !info.exists)
+		goto freeout;
+
+	nametmp = dm_task_get_name(dmt);
+	if (nametmp && strlen(nametmp)) {
+		name = MALLOC(strlen(nametmp) + 1);
+		if (name)
+			strcpy(name, nametmp);
+	} else {
+		condlog(2, "%s: no device-mapper name found", uuid);
 	}
-	vector_free(vec);
-	return rc;
+
+freeout:
+	if (prefixed_uuid)
+		FREE(prefixed_uuid);
+	dm_task_destroy(dmt);
+
+	return name;
 }
 
 int
@@ -813,9 +967,10 @@ dm_geteventnr (char *name)
 {
 	struct dm_task *dmt;
 	struct dm_info info;
+	int event = -1;
 
 	if (!(dmt = dm_task_create(DM_DEVICE_INFO)))
-		return 0;
+		return -1;
 
 	if (!dm_task_set_name(dmt, name))
 		goto out;
@@ -825,20 +980,16 @@ dm_geteventnr (char *name)
 	if (!dm_task_run(dmt))
 		goto out;
 
-	if (!dm_task_get_info(dmt, &info)) {
-		info.event_nr = 0;
+	if (!dm_task_get_info(dmt, &info))
 		goto out;
-	}
 
-	if (!info.exists) {
-		info.event_nr = 0;
-		goto out;
-	}
+	if (info.exists)
+		event = info.event_nr;
 
 out:
 	dm_task_destroy(dmt);
 
-	return info.event_nr;
+	return event;
 }
 
 char *
@@ -927,15 +1078,10 @@ dm_remove_partmaps (const char * mapname, int need_sync)
 		    (dm_type(names->name, TGT_PART) > 0) &&
 
 		    /*
-		     * and the multipath mapname and the part mapname start
-		     * the same
+		     * and both uuid end with same suffix starting
+		     * at UUID_PREFIX
 		     */
-		    !strncmp(names->name, mapname, strlen(mapname)) &&
-
-		    /*
-		     * and the opencount is 0 for us to allow removal
-		     */
-		    !dm_get_opencount(names->name) &&
+		    (!dm_compare_uuid(names->name, mapname)) &&
 
 		    /*
 		     * and we can fetch the map table from the kernel
@@ -947,14 +1093,27 @@ dm_remove_partmaps (const char * mapname, int need_sync)
 		     */
 		    strstr(params, dev_t)
 		   ) {
-				/*
-				 * then it's a kpartx generated partition.
-				 * remove it.
-				 */
-				condlog(4, "partition map %s removed",
-					names->name);
-				dm_simplecmd_flush(DM_DEVICE_REMOVE, names->name, need_sync);
-		   }
+			/*
+			 * then it's a kpartx generated partition.
+			 * remove it.
+			 */
+			/*
+			 * if the opencount is 0 maybe some other
+			 * partitions depend on it.
+			 */
+			if (dm_get_opencount(names->name)) {
+				dm_remove_partmaps(names->name, need_sync);
+				if (dm_get_opencount(names->name)) {
+					condlog(2, "%s: map in use",
+						names->name);
+					goto out;
+				}
+			}
+			condlog(4, "partition map %s removed",
+				names->name);
+			dm_simplecmd_flush(DM_DEVICE_REMOVE, names->name,
+					   need_sync);
+		}
 
 		next = names->next;
 		names = (void *) names + next;
@@ -1119,3 +1278,176 @@ out:
 	dm_task_destroy(dmt);
 	return r;
 }
+
+void dm_reassign_deps(char *table, char *dep, char *newdep)
+{
+	char *p, *n;
+	char newtable[PARAMS_SIZE];
+
+	strcpy(newtable, table);
+	p = strstr(newtable, dep);
+	n = table + (p - newtable);
+	strcpy(n, newdep);
+	n += strlen(newdep);
+	p += strlen(dep);
+	strcat(n, p);
+}
+
+int dm_reassign_table(const char *name, char *old, char *new)
+{
+	int r, modified = 0;
+	uint64_t start, length;
+	struct dm_task *dmt, *reload_dmt;
+	char *target, *params = NULL;
+	char buff[PARAMS_SIZE];
+	void *next = NULL;
+
+	if (!(dmt = dm_task_create(DM_DEVICE_TABLE)))
+		return 0;
+
+	if (!dm_task_set_name(dmt, name))
+		goto out;
+
+	dm_task_no_open_count(dmt);
+
+	if (!dm_task_run(dmt))
+		goto out;
+	if (!(reload_dmt = dm_task_create(DM_DEVICE_RELOAD)))
+		goto out;
+	if (!dm_task_set_name(reload_dmt, name))
+		goto out_reload;
+
+	do {
+		next = dm_get_next_target(dmt, next, &start, &length,
+					  &target, &params);
+		memset(buff, 0, PARAMS_SIZE);
+		strcpy(buff, params);
+		if (strcmp(target, TGT_MPATH) && strstr(params, old)) {
+			condlog(3, "%s: replace target %s %s",
+				name, target, buff);
+			dm_reassign_deps(buff, old, new);
+			condlog(3, "%s: with target %s %s",
+				name, target, buff);
+			modified++;
+		}
+		dm_task_add_target(reload_dmt, start, length, target, buff);
+	} while (next);
+
+	if (modified) {
+		dm_task_no_open_count(reload_dmt);
+
+		if (!dm_task_run(reload_dmt)) {
+			condlog(3, "%s: failed to reassign targets", name);
+			goto out_reload;
+		}
+		dm_simplecmd_noflush(DM_DEVICE_RESUME, name);
+	}
+	r = 1;
+
+out_reload:
+	dm_task_destroy(reload_dmt);
+out:
+	dm_task_destroy(dmt);
+	return r;
+}
+
+
+/*
+ * Reassign existing device-mapper table(s) to not use
+ * the block devices but point to the multipathed
+ * device instead
+ */
+int dm_reassign(const char *mapname)
+{
+	struct dm_deps *deps;
+	struct dm_task *dmt;
+	struct dm_info info;
+	char dev_t[32], dm_dep[32];
+	int r = 0, i;
+
+	if (dm_dev_t(mapname, &dev_t[0], 32)) {
+		condlog(3, "%s: failed to get device number\n", mapname);
+		return 1;
+	}
+
+	if (!(dmt = dm_task_create(DM_DEVICE_DEPS)))
+		return 0;
+
+	if (!dm_task_set_name(dmt, mapname))
+		goto out;
+
+	dm_task_no_open_count(dmt);
+
+	if (!dm_task_run(dmt))
+		goto out;
+
+	if (!dm_task_get_info(dmt, &info))
+		goto out;
+
+	if (!(deps = dm_task_get_deps(dmt)))
+		goto out;
+
+	if (!info.exists)
+		goto out;
+
+	for (i = 0; i < deps->count; i++) {
+		sprintf(dm_dep, "%d:%d",
+			major(deps->device[i]),
+			minor(deps->device[i]));
+		sysfs_check_holders(dm_dep, dev_t);
+	}
+
+	dm_task_destroy (dmt);
+
+	r = 1;
+out:
+	return r;
+}
+
+int dm_setgeometry(struct multipath *mpp)
+{
+	struct dm_task *dmt;
+	struct path *pp;
+	char heads[4], sectors[4];
+	char cylinders[10], start[32];
+	int r = 0;
+
+	if (!mpp)
+		return 1;
+
+	pp = first_path(mpp);
+	if (!pp) {
+		condlog(3, "%s: no path for geometry", mpp->alias);
+		return 1;
+	}
+	if (pp->geom.cylinders == 0 ||
+	    pp->geom.heads == 0 ||
+	    pp->geom.sectors == 0) {
+		condlog(3, "%s: invalid geometry on %s", mpp->alias, pp->dev);
+		return 1;
+	}
+
+	if (!(dmt = dm_task_create(DM_DEVICE_SET_GEOMETRY)))
+		return 0;
+
+	if (!dm_task_set_name(dmt, mpp->alias))
+		goto out;
+
+	dm_task_no_open_count(dmt);
+
+	/* What a sick interface ... */
+	snprintf(heads, 4, "%u", pp->geom.heads);
+	snprintf(sectors, 4, "%u", pp->geom.sectors);
+	snprintf(cylinders, 10, "%u", pp->geom.cylinders);
+	snprintf(start, 32, "%lu", pp->geom.start);
+	if (!dm_task_set_geometry(dmt, cylinders, heads, sectors, start)) {
+		condlog(3, "%s: Failed to set geometry", mpp->alias);
+		goto out;
+	}
+
+	r = dm_task_run(dmt);
+out:
+	dm_task_destroy(dmt);
+
+	return r;
+}
diff --git a/libmultipath/devmapper.h b/libmultipath/devmapper.h
index f3ffeaa..0c2e03f 100644
--- a/libmultipath/devmapper.h
+++ b/libmultipath/devmapper.h
@@ -8,12 +8,13 @@
 
 void dm_init(void);
 int dm_prereq (void);
+int dm_drv_get_rq (void);
 int dm_simplecmd_flush (int, const char *, int);
 int dm_simplecmd_noflush (int, const char *);
-int dm_addmap_create (struct multipath *mpp);
-int dm_addmap_create_ro (struct multipath *mpp);
-int dm_addmap_reload (struct multipath *mpp);
-int dm_addmap_reload_ro (struct multipath *mpp);
+int dm_addmap_create (struct multipath *mpp, char *params);
+int dm_addmap_create_ro (struct multipath *mpp, char *params);
+int dm_addmap_reload (struct multipath *mpp, char *params);
+int dm_addmap_reload_ro (struct multipath *mpp, char *params);
 int dm_map_present (const char *);
 int dm_get_map(char *, unsigned long long *, char *);
 int dm_get_status(char *, char *);
@@ -31,12 +32,18 @@ int dm_enablegroup(char * mapname, int index);
 int dm_disablegroup(char * mapname, int index);
 int dm_get_maps (vector mp);
 int dm_geteventnr (char *name);
+int dm_get_major (char *name);
 int dm_get_minor (char *name);
 char * dm_mapname(int major, int minor);
 int dm_remove_partmaps (const char * mapname, int need_sync);
 int dm_get_uuid(char *name, char *uuid);
 int dm_get_info (char * mapname, struct dm_info ** dmi);
 int dm_rename (char * old, char * new);
-int dm_get_name(char * uuid, char * name);
+char * dm_get_name(char * uuid);
+int dm_reassign(const char * mapname);
+int dm_reassign_table(const char *name, char *old, char *new);
+int dm_setgeometry(struct multipath *mpp);
+void udev_wait(unsigned int c);
+void udev_set_sync_support(int c);
 
 #endif /* _DEVMAPPER_H */
diff --git a/libmultipath/dict.c b/libmultipath/dict.c
index 02aa238..4df3d9b 100644
--- a/libmultipath/dict.c
+++ b/libmultipath/dict.c
@@ -6,7 +6,7 @@
  */
 #include <sys/types.h>
 #include <pwd.h>
-
+#include <string.h>
 #include "checkers.h"
 #include "vector.h"
 #include "hwtable.h"
@@ -20,6 +20,7 @@
 #include "defaults.h"
 #include "prio.h"
 #include "errno.h"
+#include <inttypes.h>
 
 /*
  * default block handlers
@@ -43,10 +44,12 @@ def_fast_io_fail_handler(vector strvec)
 
 	buff = set_value(strvec);
 	if (strlen(buff) == 3 && !strcmp(buff, "off"))
-		conf->fast_io_fail = -1;
+		conf->fast_io_fail = MP_FAST_IO_FAIL_OFF;
 	else if (sscanf(buff, "%d", &conf->fast_io_fail) != 1 ||
-		 conf->fast_io_fail < -1)
+		 conf->fast_io_fail < MP_FAST_IO_FAIL_ZERO)
 		conf->fast_io_fail = 0;
+	else if (conf->fast_io_fail == 0)
+		conf->fast_io_fail = MP_FAST_IO_FAIL_ZERO;
 
 	FREE(buff);
 	return 0;
@@ -58,7 +61,12 @@ def_dev_loss_handler(vector strvec)
 	char * buff;
 
 	buff = set_value(strvec);
-	if (sscanf(buff, "%u", &conf->dev_loss) != 1)
+	if (!buff)
+		return 1;
+
+	if (strlen(buff) == 8 && !strcmp(buff, "infinity"))
+		conf->dev_loss = MAX_DEV_LOSS_TMO;
+	else if (sscanf(buff, "%u", &conf->dev_loss) != 1)
 		conf->dev_loss = 0;
 
 	FREE(buff);
@@ -77,6 +85,33 @@ verbosity_handler(vector strvec)
 }
 
 static int
+max_polling_interval_handler(vector strvec)
+{
+	char *buff;
+
+	buff = VECTOR_SLOT(strvec, 1);
+	conf->max_checkint = atoi(buff);
+
+	return 0;
+}
+
+static int
+reassign_maps_handler(vector strvec)
+{
+	char * buff;
+
+	buff = set_value(strvec);
+	if (!strcmp(buff, "yes"))
+		conf->reassign_maps = 1;
+	else if (!strcmp(buff, "no"))
+		conf->reassign_maps = 0;
+	else
+		return 1;
+
+	return 0;
+}
+
+static int
 udev_dir_handler(vector strvec)
 {
 	conf->udev_dir = set_value(strvec);
@@ -148,6 +183,17 @@ def_prio_handler(vector strvec)
 }
 
 static int
+def_alias_prefix_handler(vector strvec)
+{
+	conf->alias_prefix = set_value(strvec);
+
+	if (!conf->alias_prefix)
+		return 1;
+
+	return 0;
+}
+
+static int
 def_prio_args_handler(vector strvec)
 {
 	conf->prio_args = set_value(strvec);
@@ -197,6 +243,22 @@ def_minio_handler(vector strvec)
 }
 
 static int
+def_minio_rq_handler(vector strvec)
+{
+	char * buff;
+
+	buff = set_value(strvec);
+
+	if (!buff)
+		return 1;
+
+	conf->minio_rq = atoi(buff);
+	FREE(buff);
+
+	return 0;
+}
+
+int
 get_sys_max_fds(int *max_fds)
 {
 	FILE *file;
@@ -327,6 +389,10 @@ def_weight_handler(vector strvec)
 	    !strcmp(buff, "priorities"))
 		conf->rr_weight = RR_WEIGHT_PRIO;
 
+	if (strlen(buff) == strlen("uniform") &&
+	    !strcmp(buff, "uniform"))
+		conf->rr_weight = RR_WEIGHT_NONE;
+
 	FREE(buff);
 
 	return 0;
@@ -395,6 +461,25 @@ def_queue_without_daemon(vector strvec)
 }
 
 static int
+def_checker_timeout_handler(vector strvec)
+{
+	unsigned int checker_timeout;
+	char *buff;
+
+	buff = set_value(strvec);
+	if (!buff)
+		return 1;
+
+	if (sscanf(buff, "%u", &checker_timeout) == 1)
+		conf->checker_timeout = checker_timeout;
+	else
+		conf->checker_timeout = 0;
+
+	free(buff);
+	return 0;
+}
+
+static int
 def_pg_timeout_handler(vector strvec)
 {
 	int pg_timeout;
@@ -443,6 +528,72 @@ def_flush_on_last_del_handler(vector strvec)
 }
 
 static int
+def_log_checker_err_handler(vector strvec)
+{
+	char * buff;
+
+	buff = set_value(strvec);
+
+	if (!buff)
+		return 1;
+
+	if (strlen(buff) == 4 && !strcmp(buff, "once"))
+		conf->log_checker_err = LOG_CHKR_ERR_ONCE;
+	else if (strlen(buff) == 6 && !strcmp(buff, "always"))
+		conf->log_checker_err = LOG_CHKR_ERR_ALWAYS;
+
+	free(buff);
+	return 0;
+}
+
+static int
+def_reservation_key_handler(vector strvec)
+{
+	char *buff;
+	char *tbuff;
+	int j, k;
+	int len;
+	uint64_t prkey;
+
+	buff = set_value(strvec);
+	if (!buff)
+		return 1;
+
+	tbuff = buff;
+
+	if (!memcmp("0x",buff, 2))
+		buff = buff + 2;
+
+	len = strlen(buff);
+
+	k = strspn(buff, "0123456789aAbBcCdDeEfF");
+
+	if (len != k) {
+		FREE(tbuff);
+		return 1;
+	}
+
+	if (1 != sscanf (buff, "%" SCNx64 "", &prkey))
+	{
+		FREE(tbuff);
+		return 1;
+	}
+
+	if (!conf->reservation_key)
+		conf->reservation_key = (unsigned char *) malloc(8);
+
+	memset(conf->reservation_key, 0, 8);
+
+	for (j = 7; j >= 0; --j) {
+		conf->reservation_key[j] = (prkey & 0xff);
+		prkey >>= 8;
+	}
+
+	FREE(tbuff);
+	return 0;
+}
+
+static int
 names_handler(vector strvec)
 {
 	char * buff;
@@ -463,6 +614,17 @@ names_handler(vector strvec)
 	return 0;
 }
 
+static int
+bindings_file_handler(vector strvec)
+{
+	conf->bindings_file = set_value(strvec);
+
+	if (!conf->bindings_file)
+		return 1;
+
+	return 0;
+}
+
 /*
  * blacklist block handlers
  */
@@ -675,6 +837,22 @@ product_handler(vector strvec)
 }
 
 static int
+revision_handler(vector strvec)
+{
+	struct hwentry * hwe = VECTOR_LAST_SLOT(conf->hwtable);
+
+	if (!hwe)
+		return 1;
+
+	hwe->revision = set_value(strvec);
+
+	if (!hwe->revision)
+		return 1;
+
+	return 0;
+}
+
+static int
 bl_product_handler(vector strvec)
 {
 	struct hwentry * hwe = VECTOR_LAST_SLOT(conf->hwtable);
@@ -697,10 +875,12 @@ hw_fast_io_fail_handler(vector strvec)
 
 	buff = set_value(strvec);
 	if (strlen(buff) == 3 && !strcmp(buff, "off"))
-		hwe->fast_io_fail = -1;
+		hwe->fast_io_fail = MP_FAST_IO_FAIL_OFF;
 	else if (sscanf(buff, "%d", &hwe->fast_io_fail) != 1 ||
-		 hwe->fast_io_fail < -1)
+		 hwe->fast_io_fail < MP_FAST_IO_FAIL_ZERO)
 		hwe->fast_io_fail = 0;
+	else if (hwe->fast_io_fail == 0)
+		hwe->fast_io_fail = MP_FAST_IO_FAIL_ZERO;
 
 	FREE(buff);
 	return 0;
@@ -713,7 +893,12 @@ hw_dev_loss_handler(vector strvec)
 	struct hwentry * hwe = VECTOR_LAST_SLOT(conf->hwtable);
 
 	buff = set_value(strvec);
-	if (sscanf(buff, "%u", &hwe->dev_loss) != 1)
+	if (!buff)
+		return 1;
+
+	if (strlen(buff) == 8 && !strcmp(buff, "infinity"))
+		hwe->dev_loss = MAX_DEV_LOSS_TMO;
+	else if (sscanf(buff, "%u", &hwe->dev_loss) != 1)
 		hwe->dev_loss = 0;
 
 	FREE(buff);
@@ -831,6 +1016,22 @@ hw_prio_handler(vector strvec)
 }
 
 static int
+hw_alias_prefix_handler(vector strvec)
+{
+	struct hwentry * hwe = VECTOR_LAST_SLOT(conf->hwtable);
+
+	if (!hwe)
+		return 1;
+
+	hwe->alias_prefix = set_value(strvec);
+
+	if (!hwe->alias_prefix)
+		return 1;
+
+	return 0;
+}
+
+static int
 hw_prio_args_handler(vector strvec)
 {
 	struct hwentry * hwe = VECTOR_LAST_SLOT(conf->hwtable);
@@ -887,6 +1088,10 @@ hw_weight_handler(vector strvec)
 	    !strcmp(buff, "priorities"))
 		hwe->rr_weight = RR_WEIGHT_PRIO;
 
+	if (strlen(buff) == strlen("uniform") &&
+	    !strcmp(buff, "uniform"))
+		hwe->rr_weight = RR_WEIGHT_NONE;
+
 	FREE(buff);
 
 	return 0;
@@ -938,6 +1143,26 @@ hw_minio_handler(vector strvec)
 }
 
 static int
+hw_minio_rq_handler(vector strvec)
+{
+	struct hwentry *hwe = VECTOR_LAST_SLOT(conf->hwtable);
+	char * buff;
+
+	if (!hwe)
+		return 1;
+
+	buff = set_value(strvec);
+
+	if (!buff)
+		return 1;
+
+	hwe->minio_rq = atoi(buff);
+	FREE(buff);
+
+	return 0;
+}
+
+static int
 hw_pg_timeout_handler(vector strvec)
 {
 	int pg_timeout;
@@ -1215,6 +1440,10 @@ mp_weight_handler(vector strvec)
 	    !strcmp(buff, "priorities"))
 		mpe->rr_weight = RR_WEIGHT_PRIO;
 
+	if (strlen(buff) == strlen("uniform") &&
+	    !strcmp(buff, "uniform"))
+		mpe->rr_weight = RR_WEIGHT_NONE;
+
 	FREE(buff);
 
 	return 0;
@@ -1266,6 +1495,26 @@ mp_minio_handler(vector strvec)
 }
 
 static int
+mp_minio_rq_handler(vector strvec)
+{
+	struct mpentry *mpe = VECTOR_LAST_SLOT(conf->mptable);
+	char * buff;
+
+	if (!mpe)
+		return 1;
+
+	buff = set_value(strvec);
+
+	if (!buff)
+		return 1;
+
+	mpe->minio_rq = atoi(buff);
+	FREE(buff);
+
+	return 0;
+}
+
+static int
 mp_pg_timeout_handler(vector strvec)
 {
 	int pg_timeout;
@@ -1295,6 +1544,22 @@ mp_pg_timeout_handler(vector strvec)
 }
 
 static int
+mp_features_handler(vector strvec)
+{
+	struct mpentry * mpe = VECTOR_LAST_SLOT(conf->mptable);
+
+	if (!mpe)
+		return 1;
+
+	mpe->features = set_value(strvec);
+
+	if (!mpe->features)
+		return 1;
+
+	return 0;
+}
+
+static int
 mp_flush_on_last_del_handler(vector strvec)
 {
 	struct mpentry *mpe = VECTOR_LAST_SLOT(conf->mptable);
@@ -1320,6 +1585,87 @@ mp_flush_on_last_del_handler(vector strvec)
 	return 0;
 }
 
+static int
+mp_prio_handler(vector strvec)
+{
+	struct mpentry * mpe = VECTOR_LAST_SLOT(conf->hwtable);
+
+	if (!mpe)
+		return 1;
+
+	mpe->prio_name = set_value(strvec);
+
+	if (!mpe->prio_name)
+		return 1;
+
+	return 0;
+}
+
+static int
+mp_prio_args_handler (vector strvec)
+{
+	struct mpentry *mpe = VECTOR_LAST_SLOT(conf->mptable);
+
+	if (!mpe)
+		return 1;
+
+	mpe->prio_args = set_value(strvec);
+	if (!mpe->prio_args)
+		return 1;
+
+	return 0;
+}
+
+static int
+mp_reservation_key_handler (vector strvec)
+{
+	char *buff;
+	char *tbuff;
+	struct mpentry *mpe = VECTOR_LAST_SLOT(conf->mptable);
+
+	int j, k, len;
+	uint64_t prkey;
+
+	if (!mpe)
+		return 1;
+
+	buff = set_value(strvec);
+	if (!buff)
+		return 1;
+
+	tbuff = buff;
+	if (!memcmp(buff, "0x", 2))
+		buff = buff + 2;
+
+	len = strlen(buff);
+
+	k = strspn(buff, "0123456789aAbBcCdDeEfF");
+	if (len != k) {
+		FREE(tbuff);
+		return 1;
+	}
+
+	if (1 != sscanf (buff, "%" SCNx64 "", &prkey))
+	{
+		FREE(tbuff);
+		return 1;
+	}
+
+	if (!mpe->reservation_key)
+		mpe->reservation_key = (unsigned char *) malloc(8);
+
+	memset(mpe->reservation_key, 0, 8);
+
+	for (j = 7; j >= 0; --j) {
+		mpe->reservation_key[j] = (prkey & 0xff);
+		prkey >>= 8;
+	}
+
+	FREE(tbuff);
+	return 0;
+}
+
+
 /*
  * config file keywords printing
  */
@@ -1339,11 +1685,6 @@ snprint_mp_alias (char * buff, int len, void * data)
 	if (!mpe->alias)
 		return 0;
 
-	if (conf->user_friendly_names &&
-	    (strlen(mpe->alias) == strlen("mpath")) &&
-	    !strcmp(mpe->alias, "mpath"))
-		return 0;
-
 	return snprintf(buff, len, "%s", mpe->alias);
 }
 
@@ -1368,7 +1709,7 @@ snprint_mp_selector (char * buff, int len, void * data)
 	if (!mpe->selector)
 		return 0;
 
-	return snprintf(buff, len, "%s", mpe->selector);
+	return snprintf(buff, len, "\"%s\"", mpe->selector);
 }
 
 static int
@@ -1431,6 +1772,8 @@ snprint_mp_rr_weight (char * buff, int len, void * data)
 		return 0;
 	if (mpe->rr_weight == RR_WEIGHT_PRIO)
 		return snprintf(buff, len, "priorities");
+	if (mpe->rr_weight == RR_WEIGHT_NONE)
+		return snprintf(buff, len, "uniform");
 
 	return 0;
 }
@@ -1469,6 +1812,17 @@ snprint_mp_rr_min_io (char * buff, int len, void * data)
 }
 
 static int
+snprint_mp_rr_min_io_rq (char * buff, int len, void * data)
+{
+	struct mpentry * mpe = (struct mpentry *)data;
+
+	if (!mpe->minio_rq)
+		return 0;
+
+	return snprintf(buff, len, "%u", mpe->minio_rq);
+}
+
+static int
 snprint_mp_pg_timeout (char * buff, int len, void * data)
 {
 	struct mpentry * mpe = (struct mpentry *)data;
@@ -1485,6 +1839,20 @@ snprint_mp_pg_timeout (char * buff, int len, void * data)
 }
 
 static int
+snprint_mp_features (char * buff, int len, void * data)
+{
+	struct mpentry * mpe = (struct mpentry *)data;
+
+	if (!mpe->features)
+		return 0;
+	if (strlen(mpe->features) == strlen(conf->features) &&
+	    !strcmp(mpe->features, conf->features))
+		return 0;
+
+	return snprintf(buff, len, "%s", mpe->features);
+}
+
+static int
 snprint_mp_flush_on_last_del (char * buff, int len, void * data)
 {
 	struct mpentry * mpe = (struct mpentry *)data;
@@ -1499,13 +1867,47 @@ snprint_mp_flush_on_last_del (char * buff, int len, void * data)
 }
 
 static int
+snprint_mp_prio(char * buff, int len, void * data)
+{
+	struct mpentry * mpe = (struct mpentry *)data;
+
+	if (!mpe->prio_name)
+		return 0;
+
+	return snprintf(buff, len, "%s", mpe->prio_name);
+}
+
+static int
+snprint_mp_prio_args(char * buff, int len, void * data)
+{
+	struct mpentry * mpe = (struct mpentry *)data;
+
+	if (!mpe->prio_args)
+		return 0;
+
+	return snprintf(buff, len, "%s", mpe->prio_args);
+}
+
+static int
+snprint_mp_reservation_key (char * buff, int len, void * data)
+{
+	struct mpentry * mpe = (struct mpentry *)data;
+	return snprintf(buff, len, "%s" , mpe->reservation_key);
+}
+
+
+static int
 snprint_hw_fast_io_fail(char * buff, int len, void * data)
 {
 	struct hwentry * hwe = (struct hwentry *)data;
 	if (!hwe->fast_io_fail)
 		return 0;
-	if (hwe->fast_io_fail == -1)
+	if (hwe->fast_io_fail == conf->fast_io_fail)
+		return 0;
+	if (hwe->fast_io_fail == MP_FAST_IO_FAIL_OFF)
 		return snprintf(buff, len, "off");
+	if (hwe->fast_io_fail == MP_FAST_IO_FAIL_ZERO)
+		return snprintf(buff, len, "0");
 	return snprintf(buff, len, "%d", hwe->fast_io_fail);
 }
 
@@ -1515,6 +1917,11 @@ snprint_hw_dev_loss(char * buff, int len, void * data)
 	struct hwentry * hwe = (struct hwentry *)data;
 	if (!hwe->dev_loss)
 		return 0;
+	if (hwe->dev_loss == conf->dev_loss)
+		return 0;
+	if (hwe->dev_loss >= MAX_DEV_LOSS_TMO)
+		return snprintf(buff, len, "infinity");
+
 	return snprintf(buff, len, "%u", hwe->dev_loss);
 }
 
@@ -1541,6 +1948,17 @@ snprint_hw_product (char * buff, int len, void * data)
 }
 
 static int
+snprint_hw_revision (char * buff, int len, void * data)
+{
+	struct hwentry * hwe = (struct hwentry *)data;
+
+	if (!hwe->revision)
+		return 0;
+
+	return snprintf(buff, len, "\"%s\"", hwe->revision);
+}
+
+static int
 snprint_hw_bl_product (char * buff, int len, void * data)
 {
 	struct hwentry * hwe = (struct hwentry *)data;
@@ -1558,10 +1976,6 @@ snprint_hw_getuid_callout (char * buff, int len, void * data)
 
 	if (!hwe->getuid)
 		return 0;
-	if (conf->getuid &&
-	    strlen(hwe->getuid) == strlen(conf->getuid) &&
-	    !strcmp(hwe->getuid, conf->getuid))
-		return 0;
 
 	return snprintf(buff, len, "\"%s\"", hwe->getuid);
 }
@@ -1571,25 +1985,32 @@ snprint_hw_prio (char * buff, int len, void * data)
 {
 	struct hwentry * hwe = (struct hwentry *)data;
 
-	if (!hwe->prio_name || (strlen(hwe->prio_name) == 0))
-		return 0;
-	if (conf->prio_name && !strcmp(hwe->prio_name, conf->prio_name))
+	if (!hwe->prio_name)
 		return 0;
 
 	return snprintf(buff, len, "%s", hwe->prio_name);
 }
 
 static int
+snprint_hw_alias_prefix (char * buff, int len, void * data)
+{
+	struct hwentry * hwe = (struct hwentry *)data;
+
+	if (!hwe->alias_prefix)
+		return 0;
+
+	return snprintf(buff, len, "\"%s\"", hwe->alias_prefix);
+}
+
+static int
 snprint_hw_prio_args (char * buff, int len, void * data)
 {
 	struct hwentry * hwe = (struct hwentry *)data;
 
-        if (!hwe->prio_args || (strlen(hwe->prio_args) == 0))
-                return 0;
-        if (conf->prio_args && !strcmp(hwe->prio_args, conf->prio_args))
-                return 0;
+	if (!hwe->prio_args)
+		return 0;
 
-	return snprintf(buff, len, "%s", hwe->prio_args);
+	return snprintf(buff, len, "\"%s\"", hwe->prio_args);
 }
 
 static int
@@ -1599,10 +2020,6 @@ snprint_hw_features (char * buff, int len, void * data)
 
 	if (!hwe->features)
 		return 0;
-	if (conf->features &&
-	    strlen(hwe->features) == strlen(conf->features) &&
-	    !strcmp(hwe->features, conf->features))
-		return 0;
 
 	return snprintf(buff, len, "\"%s\"", hwe->features);
 }
@@ -1614,10 +2031,6 @@ snprint_hw_hardware_handler (char * buff, int len, void * data)
 
 	if (!hwe->hwhandler)
 		return 0;
-	if (conf->hwhandler &&
-	    strlen(hwe->hwhandler) == strlen(conf->hwhandler) &&
-	    !strcmp(hwe->hwhandler, conf->hwhandler))
-		return 0;
 
 	return snprintf(buff, len, "\"%s\"", hwe->hwhandler);
 }
@@ -1629,12 +2042,8 @@ snprint_hw_selector (char * buff, int len, void * data)
 
 	if (!hwe->selector)
 		return 0;
-	if (conf->selector &&
-	    strlen(hwe->selector) == strlen(conf->selector) &&
-	    !strcmp(hwe->selector, conf->selector))
-		return 0;
 
-	return snprintf(buff, len, "%s", hwe->selector);
+	return snprintf(buff, len, "\"%s\"", hwe->selector);
 }
 
 static int
@@ -1646,8 +2055,6 @@ snprint_hw_path_grouping_policy (char * buff, int len, void * data)
 
 	if (!hwe->pgpolicy)
 		return 0;
-	if (conf->pgpolicy && hwe->pgpolicy == conf->pgpolicy)
-		return 0;
 
 	get_pgpolicy_name(str, POLICY_NAME_SIZE, hwe->pgpolicy);
 
@@ -1661,8 +2068,6 @@ snprint_hw_failback (char * buff, int len, void * data)
 
 	if (!hwe->pgfailback)
 		return 0;
-	if (conf->pgfailback && hwe->pgfailback == conf->pgfailback)
-		return 0;
 
 	switch(hwe->pgfailback) {
 	case  FAILBACK_UNDEF:
@@ -1684,10 +2089,10 @@ snprint_hw_rr_weight (char * buff, int len, void * data)
 
 	if (!hwe->rr_weight)
 		return 0;
-	if (conf->rr_weight && hwe->rr_weight == conf->rr_weight)
-		return 0;
 	if (hwe->rr_weight == RR_WEIGHT_PRIO)
 		return snprintf(buff, len, "priorities");
+	if (hwe->rr_weight == RR_WEIGHT_NONE)
+		return snprintf(buff, len, "uniform");
 
 	return 0;
 }
@@ -1699,8 +2104,6 @@ snprint_hw_no_path_retry (char * buff, int len, void * data)
 
 	if (!hwe->no_path_retry)
 		return 0;
-	if (hwe->no_path_retry == conf->no_path_retry)
-		return 0;
 
 	switch(hwe->no_path_retry) {
 	case NO_PATH_RETRY_UNDEF:
@@ -1723,21 +2126,28 @@ snprint_hw_rr_min_io (char * buff, int len, void * data)
 
 	if (!hwe->minio)
 		return 0;
-	if (hwe->minio == conf->minio)
-		return 0;
 
 	return snprintf(buff, len, "%u", hwe->minio);
 }
 
 static int
+snprint_hw_rr_min_io_rq (char * buff, int len, void * data)
+{
+	struct hwentry * hwe = (struct hwentry *)data;
+
+	if (!hwe->minio_rq)
+		return 0;
+
+	return snprintf(buff, len, "%u", hwe->minio_rq);
+}
+
+static int
 snprint_hw_pg_timeout (char * buff, int len, void * data)
 {
 	struct hwentry * hwe = (struct hwentry *)data;
 
 	if (!hwe->pg_timeout)
 		return 0;
-	if (hwe->pg_timeout == conf->pg_timeout)
-		return 0;
 
 	switch (hwe->pg_timeout) {
 	case PGTIMEOUT_UNDEF:
@@ -1771,9 +2181,6 @@ snprint_hw_path_checker (char * buff, int len, void * data)
 
 	if (!hwe->checker_name)
 		return 0;
-	if (conf->checker_name &&
-	    !strcmp(hwe->checker_name, conf->checker_name))
-		return 0;
 
 	return snprintf(buff, len, "%s", hwe->checker_name);
 }
@@ -1781,8 +2188,6 @@ snprint_hw_path_checker (char * buff, int len, void * data)
 static int
 snprint_def_polling_interval (char * buff, int len, void * data)
 {
-	if (conf->checkint == DEFAULT_CHECKINT)
-		return 0;
 	return snprintf(buff, len, "%i", conf->checkint);
 }
 
@@ -1791,8 +2196,10 @@ snprint_def_fast_io_fail(char * buff, int len, void * data)
 {
 	if (!conf->fast_io_fail)
 		return 0;
-	if (conf->fast_io_fail == -1)
+	if (conf->fast_io_fail == MP_FAST_IO_FAIL_OFF)
 		return snprintf(buff, len, "off");
+	if (conf->fast_io_fail == MP_FAST_IO_FAIL_ZERO)
+		return snprintf(buff, len, "0");
 	return snprintf(buff, len, "%d", conf->fast_io_fail);
 }
 
@@ -1801,25 +2208,39 @@ snprint_def_dev_loss(char * buff, int len, void * data)
 {
 	if (!conf->dev_loss)
 		return 0;
+	if (conf->dev_loss >= MAX_DEV_LOSS_TMO)
+		return snprintf(buff, len, "infinity");
 	return snprintf(buff, len, "%u", conf->dev_loss);
 }
 
 static int
 snprint_def_verbosity (char * buff, int len, void * data)
 {
-	if (conf->checkint == DEFAULT_VERBOSITY)
-		return 0;
 	return snprintf(buff, len, "%i", conf->verbosity);
 }
 
 static int
+snprint_def_max_polling_interval (char * buff, int len, void * data)
+{
+	if (conf->max_checkint == MAX_CHECKINT(conf->checkint))
+		return 0;
+	return snprintf(buff, len, "%i", conf->max_checkint);
+}
+
+static int
+snprint_reassign_maps (char * buff, int len, void * data)
+{
+	if (conf->reassign_maps == DEFAULT_REASSIGN_MAPS)
+		return 0;
+	return snprintf(buff, len, "%s",
+			conf->reassign_maps?"yes":"no");
+}
+
+static int
 snprint_def_udev_dir (char * buff, int len, void * data)
 {
 	if (!conf->udev_dir)
 		return 0;
-	if (strlen(DEFAULT_UDEVDIR) == strlen(conf->udev_dir) &&
-	    !strcmp(conf->udev_dir, DEFAULT_UDEVDIR))
-		return 0;
 
 	return snprintf(buff, len, "\"%s\"", conf->udev_dir);
 }
@@ -1829,9 +2250,6 @@ snprint_def_multipath_dir (char * buff, int len, void * data)
 {
 	if (!conf->udev_dir)
 		return 0;
-	if (strlen(DEFAULT_MULTIPATHDIR) == strlen(conf->multipath_dir) &&
-	    !strcmp(conf->multipath_dir, DEFAULT_MULTIPATHDIR))
-		return 0;
 
 	return snprintf(buff, len, "\"%s\"", conf->multipath_dir);
 }
@@ -1840,25 +2258,21 @@ static int
 snprint_def_selector (char * buff, int len, void * data)
 {
 	if (!conf->selector)
-		return 0;
-	if (strlen(conf->selector) == strlen(DEFAULT_SELECTOR) &&
-	    !strcmp(conf->selector, DEFAULT_SELECTOR))
-		return 0;
+		return snprintf(buff, len, "\"%s\"", DEFAULT_SELECTOR);
 
-	return snprintf(buff, len, "%s", conf->selector);
+	return snprintf(buff, len, "\"%s\"", conf->selector);
 }
 
 static int
 snprint_def_path_grouping_policy (char * buff, int len, void * data)
 {
 	char str[POLICY_NAME_SIZE];
+	int pgpolicy = conf->pgpolicy;
 
-	if (!conf->pgpolicy)
-		return 0;
-	if (conf->pgpolicy == DEFAULT_PGPOLICY)
-		return 0;
+	if (!pgpolicy)
+		pgpolicy = DEFAULT_PGPOLICY;
 
-	get_pgpolicy_name(str, POLICY_NAME_SIZE, conf->pgpolicy);
+	get_pgpolicy_name(str, POLICY_NAME_SIZE, pgpolicy);
 
 	return snprintf(buff, len, "%s", str);
 }
@@ -1867,10 +2281,7 @@ static int
 snprint_def_getuid_callout (char * buff, int len, void * data)
 {
 	if (!conf->getuid)
-		return 0;
-	if (strlen(conf->getuid) == strlen(DEFAULT_GETUID) &&
-	    !strcmp(conf->getuid, DEFAULT_GETUID))
-		return 0;
+		return snprintf(buff, len, "\"%s\"", DEFAULT_GETUID);
 
 	return snprintf(buff, len, "\"%s\"", conf->getuid);
 }
@@ -1879,11 +2290,7 @@ static int
 snprint_def_prio (char * buff, int len, void * data)
 {
 	if (!conf->prio_name)
-		return 0;
-
-	if (strlen(conf->prio_name) == strlen(DEFAULT_PRIO) &&
-	    !strcmp(conf->prio_name, DEFAULT_PRIO))
-		return 0;
+		return snprintf(buff, len, "%s", DEFAULT_PRIO);
 
 	return snprintf(buff, len, "%s", conf->prio_name);
 }
@@ -1892,23 +2299,16 @@ static int
 snprint_def_prio_args (char * buff, int len, void * data)
 {
 	if (!conf->prio_args)
-		return 0;
+		return snprintf(buff, len, "\"%s\"", DEFAULT_PRIO_ARGS);
 
-	if (strlen(conf->prio_args) == strlen(DEFAULT_PRIO_ARGS) &&
-	    !strcmp(conf->prio_args, DEFAULT_PRIO_ARGS))
-		return 0;
-
-	return snprintf(buff, len, "%s", conf->prio_args);
+	return snprintf(buff, len, "\"%s\"", conf->prio_args);
 }
 
 static int
 snprint_def_features (char * buff, int len, void * data)
 {
 	if (!conf->features)
-		return 0;
-	if (strlen(conf->features) == strlen(DEFAULT_FEATURES) &&
-	    !strcmp(conf->features, DEFAULT_FEATURES))
-		return 0;
+		return snprintf(buff, len, "\"%s\"", DEFAULT_FEATURES);
 
 	return snprintf(buff, len, "\"%s\"", conf->features);
 }
@@ -1917,10 +2317,7 @@ static int
 snprint_def_path_checker (char * buff, int len, void * data)
 {
 	if (!conf->checker_name)
-		return 0;
-	if (strlen(conf->checker_name) == strlen(DEFAULT_CHECKER) &&
-	    !strcmp(conf->checker_name, DEFAULT_CHECKER))
-		return 0;
+		return snprintf(buff, len, "%s", DEFAULT_CHECKER);
 
 	return snprintf(buff, len, "%s", conf->checker_name);
 }
@@ -1928,10 +2325,9 @@ snprint_def_path_checker (char * buff, int len, void * data)
 static int
 snprint_def_failback (char * buff, int len, void * data)
 {
-	if (!conf->pgfailback)
-		return 0;
-	if (conf->pgfailback == DEFAULT_FAILBACK)
-		return 0;
+	int pgfailback = conf->pgfailback;
+	if (!pgfailback)
+		pgfailback = DEFAULT_FAILBACK;
 
 	switch(conf->pgfailback) {
 	case  FAILBACK_UNDEF:
@@ -1951,13 +2347,20 @@ snprint_def_rr_min_io (char * buff, int len, void * data)
 {
 	if (!conf->minio)
 		return 0;
-	if (conf->minio == DEFAULT_MINIO)
-		return 0;
 
 	return snprintf(buff, len, "%u", conf->minio);
 }
 
 static int
+snprint_def_rr_min_io_rq (char * buff, int len, void * data)
+{
+	if (!conf->minio_rq)
+		return 0;
+
+	return snprintf(buff, len, "%u", conf->minio_rq);
+}
+
+static int
 snprint_max_fds (char * buff, int len, void * data)
 {
 	if (!conf->max_fds)
@@ -1993,10 +2396,8 @@ snprint_def_gid(char * buff, int len, void * data)
 static int
 snprint_def_rr_weight (char * buff, int len, void * data)
 {
-	if (!conf->rr_weight)
-		return 0;
-	if (conf->rr_weight == DEFAULT_RR_WEIGHT)
-		return 0;
+	if (!conf->rr_weight || conf->rr_weight == RR_WEIGHT_NONE)
+		return snprintf(buff, len, "uniform");
 	if (conf->rr_weight == RR_WEIGHT_PRIO)
 		return snprintf(buff, len, "priorities");
 
@@ -2006,9 +2407,6 @@ snprint_def_rr_weight (char * buff, int len, void * data)
 static int
 snprint_def_no_path_retry (char * buff, int len, void * data)
 {
-	if (conf->no_path_retry == DEFAULT_NO_PATH_RETRY)
-		return 0;
-
 	switch(conf->no_path_retry) {
 	case NO_PATH_RETRY_UNDEF:
 		break;
@@ -2030,20 +2428,26 @@ snprint_def_queue_without_daemon (char * buff, int len, void * data)
 	case QUE_NO_DAEMON_OFF:
 		return snprintf(buff, len, "no");
 	case QUE_NO_DAEMON_ON:
+	case QUE_NO_DAEMON_UNDEF:
 		return snprintf(buff, len, "yes");
 	}
 	return 0;
 }
 
 static int
-snprint_def_pg_timeout (char * buff, int len, void * data)
+snprint_def_checker_timeout (char *buff, int len, void *data)
 {
-	if (conf->pg_timeout == DEFAULT_PGTIMEOUT)
+	if (!conf->checker_timeout)
 		return 0;
 
+	return snprintf(buff, len, "%u", conf->checker_timeout);
+}
+
+static int
+snprint_def_pg_timeout (char * buff, int len, void * data)
+{
 	switch (conf->pg_timeout) {
 	case PGTIMEOUT_UNDEF:
-		break;
 	case -PGTIMEOUT_NONE:
 		return snprintf(buff, len, "none");
 	default:
@@ -2056,19 +2460,27 @@ static int
 snprint_def_flush_on_last_del (char * buff, int len, void * data)
 {
 	switch (conf->flush_on_last_del) {
+	case FLUSH_UNDEF:
 	case FLUSH_DISABLED:
 		return snprintf(buff, len, "no");
 	case FLUSH_ENABLED:
+	case FLUSH_IN_PROGRESS:
 		return snprintf(buff, len, "yes");
 	}
 	return 0;
 }
 
 static int
+snprint_def_log_checker_err (char * buff, int len, void * data)
+{
+	if (conf->log_checker_err == LOG_CHKR_ERR_ONCE)
+		return snprintf(buff, len, "once");
+	return snprintf(buff, len, "always");
+}
+
+static int
 snprint_def_user_friendly_names (char * buff, int len, void * data)
 {
-	if (conf->user_friendly_names == DEFAULT_USER_FRIENDLY_NAMES)
-		return 0;
 	if (!conf->user_friendly_names)
 		return snprintf(buff, len, "no");
 
@@ -2076,6 +2488,32 @@ snprint_def_user_friendly_names (char * buff, int len, void * data)
 }
 
 static int
+snprint_def_alias_prefix (char * buff, int len, void * data)
+{
+	if (!conf->alias_prefix)
+		return snprintf(buff, len, "\"%s\"", DEFAULT_ALIAS_PREFIX);
+	return snprintf(buff, len, "\"%s\"", conf->alias_prefix);
+}
+
+static int
+snprint_def_bindings_file (char * buff, int len, void * data)
+{
+	if (conf->bindings_file == NULL)
+		return 0;
+	if (strlen(conf->bindings_file) == strlen(DEFAULT_BINDINGS_FILE) &&
+	    !strcmp(conf->bindings_file, DEFAULT_BINDINGS_FILE))
+		return 0;
+
+	return snprintf(buff, len, "%s", conf->bindings_file);
+}
+
+static int
+snprint_def_reservation_key(char * buff, int len, void * data)
+{
+	return snprintf(buff, len, "%s", conf->reservation_key);
+}
+
+static int
 snprint_ble_simple (char * buff, int len, void * data)
 {
 	struct blentry * ble = (struct blentry *)data;
@@ -2107,22 +2545,27 @@ init_keywords(void)
 	install_keyword_root("defaults", NULL);
 	install_keyword("verbosity", &verbosity_handler, &snprint_def_verbosity);
 	install_keyword("polling_interval", &polling_interval_handler, &snprint_def_polling_interval);
+	install_keyword("max_polling_interval", &max_polling_interval_handler, &snprint_def_max_polling_interval);
+	install_keyword("reassign_maps", &reassign_maps_handler, &snprint_reassign_maps);
 	install_keyword("udev_dir", &udev_dir_handler, &snprint_def_udev_dir);
 	install_keyword("multipath_dir", &multipath_dir_handler, &snprint_def_multipath_dir);
-	install_keyword("selector", &def_selector_handler, &snprint_def_selector);
+	install_keyword("path_selector", &def_selector_handler, &snprint_def_selector);
 	install_keyword("path_grouping_policy", &def_pgpolicy_handler, &snprint_def_path_grouping_policy);
 	install_keyword("getuid_callout", &def_getuid_callout_handler, &snprint_def_getuid_callout);
 	install_keyword("prio", &def_prio_handler, &snprint_def_prio);
 	install_keyword("prio_args", &def_prio_args_handler, &snprint_def_prio_args);
 	install_keyword("features", &def_features_handler, &snprint_def_features);
 	install_keyword("path_checker", &def_path_checker_handler, &snprint_def_path_checker);
-	install_keyword("checker", &def_path_checker_handler, &snprint_def_path_checker);
+	install_keyword("checker", &def_path_checker_handler, NULL);
+	install_keyword("alias_prefix", &def_alias_prefix_handler, &snprint_def_alias_prefix);
 	install_keyword("failback", &default_failback_handler, &snprint_def_failback);
 	install_keyword("rr_min_io", &def_minio_handler, &snprint_def_rr_min_io);
+	install_keyword("rr_min_io_rq", &def_minio_rq_handler, &snprint_def_rr_min_io_rq);
 	install_keyword("max_fds", &max_fds_handler, &snprint_max_fds);
 	install_keyword("rr_weight", &def_weight_handler, &snprint_def_rr_weight);
 	install_keyword("no_path_retry", &def_no_path_retry_handler, &snprint_def_no_path_retry);
 	install_keyword("queue_without_daemon", &def_queue_without_daemon, &snprint_def_queue_without_daemon);
+	install_keyword("checker_timeout", &def_checker_timeout_handler, &snprint_def_checker_timeout);
 	install_keyword("pg_timeout", &def_pg_timeout_handler, &snprint_def_pg_timeout);
 	install_keyword("flush_on_last_del", &def_flush_on_last_del_handler, &snprint_def_flush_on_last_del);
 	install_keyword("user_friendly_names", &names_handler, &snprint_def_user_friendly_names);
@@ -2131,6 +2574,9 @@ init_keywords(void)
 	install_keyword("gid", &def_gid_handler, &snprint_def_gid);
 	install_keyword("fast_io_fail_tmo", &def_fast_io_fail_handler, &snprint_def_fast_io_fail);
 	install_keyword("dev_loss_tmo", &def_dev_loss_handler, &snprint_def_dev_loss);
+	install_keyword("bindings_file", &bindings_file_handler, &snprint_def_bindings_file);
+	install_keyword("log_checker_err", &def_log_checker_err_handler, &snprint_def_log_checker_err);
+	install_keyword("reservation_key", &def_reservation_key_handler, &snprint_def_reservation_key);
 	__deprecated install_keyword("default_selector", &def_selector_handler, NULL);
 	__deprecated install_keyword("default_path_grouping_policy", &def_pgpolicy_handler, NULL);
 	__deprecated install_keyword("default_getuid_callout", &def_getuid_callout_handler, NULL);
@@ -2138,17 +2584,17 @@ init_keywords(void)
 	__deprecated install_keyword("default_path_checker", &def_path_checker_handler, NULL);
 
 	install_keyword_root("blacklist", &blacklist_handler);
-	install_keyword("devnode", &ble_devnode_handler, &snprint_ble_simple);
-	install_keyword("wwid", &ble_wwid_handler, &snprint_ble_simple);
-	install_keyword("device", &ble_device_handler, NULL);
+	install_keyword_multi("devnode", &ble_devnode_handler, &snprint_ble_simple);
+	install_keyword_multi("wwid", &ble_wwid_handler, &snprint_ble_simple);
+	install_keyword_multi("device", &ble_device_handler, NULL);
 	install_sublevel();
 	install_keyword("vendor", &ble_vendor_handler, &snprint_bled_vendor);
 	install_keyword("product", &ble_product_handler, &snprint_bled_product);
 	install_sublevel_end();
 	install_keyword_root("blacklist_exceptions", &blacklist_exceptions_handler);
-	install_keyword("devnode", &ble_except_devnode_handler, &snprint_ble_simple);
-	install_keyword("wwid", &ble_except_wwid_handler, &snprint_ble_simple);
-	install_keyword("device", &ble_except_device_handler, NULL);
+	install_keyword_multi("devnode", &ble_except_devnode_handler, &snprint_ble_simple);
+	install_keyword_multi("wwid", &ble_except_wwid_handler, &snprint_ble_simple);
+	install_keyword_multi("device", &ble_except_device_handler, NULL);
 	install_sublevel();
 	install_keyword("vendor", &ble_except_vendor_handler, &snprint_bled_vendor);
 	install_keyword("product", &ble_except_product_handler, &snprint_bled_product);
@@ -2166,16 +2612,18 @@ init_keywords(void)
 #endif
 
 	install_keyword_root("devices", &devices_handler);
-	install_keyword("device", &device_handler, NULL);
+	install_keyword_multi("device", &device_handler, NULL);
 	install_sublevel();
 	install_keyword("vendor", &vendor_handler, &snprint_hw_vendor);
 	install_keyword("product", &product_handler, &snprint_hw_product);
+	install_keyword("revision", &revision_handler, &snprint_hw_revision);
 	install_keyword("product_blacklist", &bl_product_handler, &snprint_hw_bl_product);
 	install_keyword("path_grouping_policy", &hw_pgpolicy_handler, &snprint_hw_path_grouping_policy);
 	install_keyword("getuid_callout", &hw_getuid_callout_handler, &snprint_hw_getuid_callout);
 	install_keyword("path_selector", &hw_selector_handler, &snprint_hw_selector);
 	install_keyword("path_checker", &hw_path_checker_handler, &snprint_hw_path_checker);
-	install_keyword("checker", &hw_path_checker_handler, &snprint_hw_path_checker);
+	install_keyword("checker", &hw_path_checker_handler, NULL);
+	install_keyword("alias_prefix", &hw_alias_prefix_handler, &snprint_hw_alias_prefix);
 	install_keyword("features", &hw_features_handler, &snprint_hw_features);
 	install_keyword("hardware_handler", &hw_handler_handler, &snprint_hw_hardware_handler);
 	install_keyword("prio", &hw_prio_handler, &snprint_hw_prio);
@@ -2184,6 +2632,7 @@ init_keywords(void)
 	install_keyword("rr_weight", &hw_weight_handler, &snprint_hw_rr_weight);
 	install_keyword("no_path_retry", &hw_no_path_retry_handler, &snprint_hw_no_path_retry);
 	install_keyword("rr_min_io", &hw_minio_handler, &snprint_hw_rr_min_io);
+	install_keyword("rr_min_io_rq", &hw_minio_rq_handler, &snprint_hw_rr_min_io_rq);
 	install_keyword("pg_timeout", &hw_pg_timeout_handler, &snprint_hw_pg_timeout);
 	install_keyword("flush_on_last_del", &hw_flush_on_last_del_handler, &snprint_hw_flush_on_last_del);
 	install_keyword("fast_io_fail_tmo", &hw_fast_io_fail_handler, &snprint_hw_fast_io_fail);
@@ -2191,20 +2640,25 @@ init_keywords(void)
 	install_sublevel_end();
 
 	install_keyword_root("multipaths", &multipaths_handler);
-	install_keyword("multipath", &multipath_handler, NULL);
+	install_keyword_multi("multipath", &multipath_handler, NULL);
 	install_sublevel();
 	install_keyword("wwid", &wwid_handler, &snprint_mp_wwid);
 	install_keyword("alias", &alias_handler, &snprint_mp_alias);
 	install_keyword("path_grouping_policy", &mp_pgpolicy_handler, &snprint_mp_path_grouping_policy);
 	install_keyword("path_selector", &mp_selector_handler, &snprint_mp_selector);
+	install_keyword("prio", &mp_prio_handler, &snprint_mp_prio);
+	install_keyword("prio_args", &mp_prio_args_handler, &snprint_mp_prio_args);
 	install_keyword("failback", &mp_failback_handler, &snprint_mp_failback);
 	install_keyword("rr_weight", &mp_weight_handler, &snprint_mp_rr_weight);
 	install_keyword("no_path_retry", &mp_no_path_retry_handler, &snprint_mp_no_path_retry);
 	install_keyword("rr_min_io", &mp_minio_handler, &snprint_mp_rr_min_io);
+	install_keyword("rr_min_io_rq", &mp_minio_rq_handler, &snprint_mp_rr_min_io_rq);
 	install_keyword("pg_timeout", &mp_pg_timeout_handler, &snprint_mp_pg_timeout);
 	install_keyword("flush_on_last_del", &mp_flush_on_last_del_handler, &snprint_mp_flush_on_last_del);
+	install_keyword("features", &mp_features_handler, &snprint_mp_features);
 	install_keyword("mode", &mp_mode_handler, &snprint_mp_mode);
 	install_keyword("uid", &mp_uid_handler, &snprint_mp_uid);
 	install_keyword("gid", &mp_gid_handler, &snprint_mp_gid);
+	install_keyword("reservation_key", &mp_reservation_key_handler, &snprint_mp_reservation_key);
 	install_sublevel_end();
 }
diff --git a/libmultipath/dict.h b/libmultipath/dict.h
index 5f77473..688eab7 100644
--- a/libmultipath/dict.h
+++ b/libmultipath/dict.h
@@ -6,5 +6,6 @@
 #endif
 
 void init_keywords(void);
+int get_sys_max_fds(int *);
 
 #endif /* _DICT_H */
diff --git a/libmultipath/discovery.c b/libmultipath/discovery.c
index 122eb8f..1b67e76 100644
--- a/libmultipath/discovery.c
+++ b/libmultipath/discovery.c
@@ -10,6 +10,7 @@
 #include <sys/stat.h>
 #include <dirent.h>
 #include <errno.h>
+#include <libgen.h>
 
 #include "checkers.h"
 #include "vector.h"
@@ -25,6 +26,7 @@
 #include "sysfs.h"
 #include "discovery.h"
 #include "prio.h"
+#include "defaults.h"
 
 struct path *
 store_pathinfo (vector pathvec, vector hwtable, char * devname, int flag)
@@ -127,16 +129,22 @@ path_discovery (vector pathvec, struct config * conf, int flag)
 #define declare_sysfs_get_str(fname) \
 extern int \
 sysfs_get_##fname (struct sysfs_device * dev, char * buff, size_t len) \
-{ \
-	char *attr; \
-\
-	attr = sysfs_attr_get_value(dev->devpath, #fname); \
-	if (!attr) \
-		return 1; \
-	if (strlcpy(buff, attr, len) != strlen(attr)) \
-		return 2; \
-	strchop(buff); \
-	return 0; \
+{								       \
+	int size;						       \
+								       \
+	size = sysfs_attr_get_value(dev->devpath, #fname, buff, len);	\
+	if (!size) {							\
+		condlog(3, "%s: attribute %s not found in sysfs",	\
+			dev->kernel, #fname);				\
+		return 1;						\
+	}								\
+	if (size == len) {						\
+		condlog(3, "%s: overflow in attribute %s",		\
+			dev->kernel, #fname);				\
+		return 2;						\
+	}								\
+	strchop(buff);							\
+	return 0;							\
 }
 
 declare_sysfs_get_str(devtype);
@@ -145,48 +153,70 @@ declare_sysfs_get_str(vendor);
 declare_sysfs_get_str(model);
 declare_sysfs_get_str(rev);
 declare_sysfs_get_str(state);
+declare_sysfs_get_str(dev);
 
 int
-sysfs_get_dev (struct sysfs_device * dev, char * buff, size_t len)
+sysfs_get_timeout(struct sysfs_device *dev, unsigned int *timeout)
 {
-	char *attr;
+	char attr_path[SYSFS_PATH_SIZE], attr[NAME_SIZE];
+	size_t len;
+	int r;
+	unsigned int t;
+
+	if (safe_sprintf(attr_path, "%s/device", dev->devpath))
+		return 1;
 
-	attr = sysfs_attr_get_value(dev->devpath, "dev");
-	if (!attr) {
-		condlog(3, "%s: no 'dev' attribute in sysfs", dev->kernel);
+	len = sysfs_attr_get_value(attr_path, "timeout", attr, NAME_SIZE);
+	if (!len) {
+		condlog(3, "%s: No timeout value in sysfs", dev->devpath);
 		return 1;
 	}
-	if (strlcpy(buff, attr, len) != strlen(attr)) {
-		condlog(3, "%s: overflow in 'dev' attribute", dev->kernel);
-		return 2;
+
+	r = sscanf(attr, "%u\n", &t);
+
+	if (r != 1) {
+		condlog(3, "%s: Cannot parse timeout attribute '%s'",
+			dev->devpath, attr);
+		return 1;
 	}
+
+	*timeout = t * 1000;
+
 	return 0;
 }
 
 int
 sysfs_get_size (struct sysfs_device * dev, unsigned long long * size)
 {
-	char *attr;
+	char attr[NAME_SIZE];
+	size_t len;
 	int r;
 
-	attr = sysfs_attr_get_value(dev->devpath, "size");
-	if (!attr)
+	len = sysfs_attr_get_value(dev->devpath, "size", attr, NAME_SIZE);
+	if (!len) {
+		condlog(3, "%s: No size attribute in sysfs", dev->devpath);
 		return 1;
+	}
 
 	r = sscanf(attr, "%llu\n", size);
 
-	if (r != 1)
+	if (r != 1) {
+		condlog(3, "%s: Cannot parse size attribute '%s'",
+			dev->devpath, attr);
 		return 1;
+	}
 
 	return 0;
 }
 
 int
-sysfs_get_fc_nodename (struct sysfs_device * dev, char * node,
+sysfs_get_tgt_nodename (struct sysfs_device * dev, char * node,
 		       unsigned int host, unsigned int channel,
 		       unsigned int target)
 {
-	char attr_path[SYSFS_PATH_SIZE], *attr;
+	unsigned int checkhost, session;
+	char attr_path[SYSFS_PATH_SIZE];
+	size_t len;
 
 	if (safe_sprintf(attr_path,
 			 "/class/fc_transport/target%i:%i:%i",
@@ -195,13 +225,61 @@ sysfs_get_fc_nodename (struct sysfs_device * dev, char * node,
 		return 1;
 	}
 
-	attr = sysfs_attr_get_value(attr_path, "node_name");
-	if (attr) {
-		strlcpy(node, attr, strlen(attr));
+	len = sysfs_attr_get_value(attr_path, "node_name", node, NODE_NAME_SIZE);
+	if (len)
 		return 0;
+
+	if (sscanf(dev->devpath, "/devices/platform/host%u/session%u/",
+	           &checkhost, &session) != 2)
+		return 1;
+	if (checkhost != host)
+		return 1;
+	if (safe_sprintf(attr_path, "/devices/platform/host%u/session%u/iscsi_session/session%u", host, session, session)) {
+		condlog(0, "attr_path too small");
+		return 1;
 	}
 
-	return 1;
+	len = sysfs_attr_get_value(attr_path, "targetname", node,
+				   NODE_NAME_SIZE);
+	if (!len)
+		return 1;
+
+	return 0;
+}
+
+static int
+find_rport_id(struct path *pp)
+{
+	char attr_path[SYSFS_PATH_SIZE];
+	char *dir, *base;
+	int host, channel, rport_id = -1;
+
+	if (safe_sprintf(attr_path,
+			 "/class/fc_transport/target%i:%i:%i",
+			 pp->sg_id.host_no, pp->sg_id.channel,
+			 pp->sg_id.scsi_id)) {
+		condlog(0, "attr_path too small for target");
+		return 1;
+	}
+
+	if (sysfs_resolve_link(attr_path, SYSFS_PATH_SIZE))
+		return -1;
+
+	condlog(4, "target%d:%d:%d -> path %s", pp->sg_id.host_no, pp->sg_id.channel, pp->sg_id.scsi_id, attr_path);
+	dir = attr_path;
+	do {
+		base = basename(dir);
+		dir = dirname(dir);
+
+		if (sscanf((const char *)base, "rport-%d:%d-%d", &host, &channel, &rport_id) == 3)
+			break;
+	} while (strcmp((const char *)dir, "/"));
+
+	if (rport_id < 0)
+		return -1;
+
+	condlog(4, "target%d:%d:%d -> rport_id %d", pp->sg_id.host_no, pp->sg_id.channel, pp->sg_id.scsi_id, rport_id);
+	return rport_id;
 }
 
 int
@@ -211,31 +289,77 @@ sysfs_set_scsi_tmo (struct multipath *mpp)
 	struct path *pp;
 	int i;
 	char value[11];
-
+	int rport_id;
+	int dev_loss_tmo = mpp->dev_loss;
+
+	if (mpp->no_path_retry > 0) {
+		int no_path_retry_tmo = mpp->no_path_retry * conf->checkint;
+
+		if (no_path_retry_tmo > MAX_DEV_LOSS_TMO)
+			no_path_retry_tmo = MAX_DEV_LOSS_TMO;
+		if (no_path_retry_tmo > dev_loss_tmo)
+			dev_loss_tmo = no_path_retry_tmo;
+		condlog(3, "%s: update dev_loss_tmo to %d",
+			mpp->alias, dev_loss_tmo);
+	} else if (mpp->no_path_retry == NO_PATH_RETRY_QUEUE) {
+		dev_loss_tmo = MAX_DEV_LOSS_TMO;
+		condlog(3, "%s: update dev_loss_tmo to %d",
+			mpp->alias, dev_loss_tmo);
+	}
+	mpp->dev_loss = dev_loss_tmo;
+	if (mpp->dev_loss && mpp->fast_io_fail >= (int)mpp->dev_loss) {
+		condlog(3, "%s: turning off fast_io_fail (%d is not smaller than dev_loss_tmo)",
+			mpp->alias, mpp->fast_io_fail);
+		mpp->fast_io_fail = MP_FAST_IO_FAIL_OFF;
+	}
 	if (!mpp->dev_loss && !mpp->fast_io_fail)
 		return 0;
+
 	vector_foreach_slot(mpp->paths, pp, i) {
+		rport_id = find_rport_id(pp);
+		if (rport_id < 0) {
+			condlog(3, "failed to find rport_id for target%d:%d:%d", pp->sg_id.host_no, pp->sg_id.channel, pp->sg_id.scsi_id);
+			return 1;
+		}
+
 		if (safe_snprintf(attr_path, SYSFS_PATH_SIZE,
 				  "/class/fc_remote_ports/rport-%d:%d-%d",
 				  pp->sg_id.host_no, pp->sg_id.channel,
-				  pp->sg_id.scsi_id)) {
-			condlog(0, "attr_path '/class/fc_remote_ports/rport-%d:%d-%d' too large", pp->sg_id.host_no, pp->sg_id.channel, pp->sg_id.scsi_id);
+				  rport_id)) {
+			condlog(0, "attr_path '/class/fc_remote_ports/rport-%d:%d-%d' too large", pp->sg_id.host_no, pp->sg_id.channel, rport_id);
 			return 1;
 		}
 		if (mpp->dev_loss){
 			snprintf(value, 11, "%u", mpp->dev_loss);
 			if (sysfs_attr_set_value(attr_path, "dev_loss_tmo",
-						 value))
-				return 1;
+						 value, 11) < 0) {
+				int err = 1;
+				if ((!mpp->fast_io_fail || mpp->fast_io_fail == MP_FAST_IO_FAIL_OFF) && mpp->dev_loss > 600) {
+					strncpy(value, "600", 4);
+					condlog(3, "%s: limiting dev_loss_tmo to 600, since fast_io_fail is not set", mpp->alias);
+					if (sysfs_attr_set_value(attr_path, "dev_loss_tmo", value, 11) >= 0)
+						err = 0;
+				}
+				if (err) {
+					condlog(0, "%s failed to set %s/dev_loss_tmo", mpp->alias, attr_path);
+					return 1;
+				}
+			}
 		}
 		if (mpp->fast_io_fail){
-			if (mpp->fast_io_fail == -1)
+			if (mpp->fast_io_fail == MP_FAST_IO_FAIL_OFF)
 				sprintf(value, "off");
+			else if (mpp->fast_io_fail == MP_FAST_IO_FAIL_ZERO)
+				sprintf(value, "0");
 			else
 				snprintf(value, 11, "%u", mpp->fast_io_fail);
 			if (sysfs_attr_set_value(attr_path, "fast_io_fail_tmo",
-						 value))
+						 value, 11) < 0) {
+				condlog(0,
+					"%s failed to set %s/fast_io_fail_tmo", 
+					mpp->alias, attr_path);
 				return 1;
+			}
 		}
 	}
 	return 0;
@@ -261,62 +385,6 @@ opennode (char * dev, int mode)
 	return open(devpath, mode);
 }
 
-extern int
-devt2devname (char *devname, char *devt)
-{
-	FILE *fd;
-	unsigned int tmpmaj, tmpmin, major, minor;
-	char dev[FILE_NAME_SIZE];
-	char block_path[FILE_NAME_SIZE];
-	struct stat statbuf;
-
-	memset(block_path, 0, FILE_NAME_SIZE);
-	if (sscanf(devt, "%u:%u", &major, &minor) != 2) {
-		condlog(0, "Invalid device number %s", devt);
-		return 1;
-	}
-
-	if (!(fd = fopen("/proc/partitions", "r"))) {
-		condlog(0, "Cannot open /proc/partitions");
-		return 1;
-	}
-
-	while (!feof(fd)) {
-		int r = fscanf(fd,"%u %u %*d %s",&tmpmaj, &tmpmin, dev);
-		if (!r) {
-			r = fscanf(fd,"%*s\n");
-			continue;
-		}
-		if (r != 3)
-			continue;
-
-		if ((major == tmpmaj) && (minor == tmpmin)) {
-			if (snprintf(block_path, FILE_NAME_SIZE, "/sys/block/%s", dev) >= FILE_NAME_SIZE) {
-				condlog(0, "device name %s is too long\n", dev);
-				fclose(fd);
-				return 1;
-			}
-			break;
-		}
-	}
-	fclose(fd);
-
-	if (strncmp(block_path,"/sys/block", 10))
-		return 1;
-
-	if (stat(block_path, &statbuf) < 0) {
-		condlog(0, "No sysfs entry for %s\n", block_path);
-		return 1;
-	}
-
-	if (S_ISDIR(statbuf.st_mode) == 0) {
-		condlog(0, "sysfs entry %s is not a directory\n", block_path);
-		return 1;
-	}
-	basenamecpy(block_path, devname);
-	return 0;
-}
-
 int
 do_inq(int sg_fd, int cmddt, int evpd, unsigned int pg_op,
        void *resp, int mx_resp_len)
@@ -334,6 +402,7 @@ do_inq(int sg_fd, int cmddt, int evpd, unsigned int pg_op,
 	inqCmdBlk[3] = (unsigned char)((mx_resp_len >> 8) & 0xff);
 	inqCmdBlk[4] = (unsigned char) (mx_resp_len & 0xff);
 	memset(&io_hdr, 0, sizeof (struct sg_io_hdr));
+	memset(sense_b, 0, SENSE_BUFF_LEN);
 	io_hdr.interface_id = 'S';
 	io_hdr.cmd_len = sizeof (inqCmdBlk);
 	io_hdr.mx_sb_len = sizeof (sense_b);
@@ -458,6 +527,23 @@ get_inq (char * dev, char * vendor, char * product, char * rev, int fd)
 }
 
 static int
+get_geometry(struct path *pp)
+{
+	if (pp->fd < 0)
+		return 1;
+
+	if (ioctl(pp->fd, HDIO_GETGEO, &pp->geom)) {
+		condlog(2, "%s: HDIO_GETGEO failed with %d", pp->dev, errno);
+		memset(&pp->geom, 0, sizeof(pp->geom));
+		return 1;
+	}
+	condlog(3, "%s: %u cyl, %u heads, %u sectors/track, start at %lu",
+		pp->dev, pp->geom.cylinders, pp->geom.heads,
+		pp->geom.sectors, pp->geom.start);
+	return 0;
+}
+
+static int
 scsi_sysfs_pathinfo (struct path * pp, struct sysfs_device * parent)
 {
 	char attr_path[FILE_NAME_SIZE];
@@ -485,7 +571,7 @@ scsi_sysfs_pathinfo (struct path * pp, struct sysfs_device * parent)
 	/*
 	 * host / bus / target / lun
 	 */
-	basenamecpy(parent->devpath, attr_path);
+	basenamecpy(parent->devpath, attr_path, FILE_NAME_SIZE);
 
 	sscanf(attr_path, "%i:%i:%i:%i",
 			&pp->sg_id.host_no,
@@ -502,7 +588,7 @@ scsi_sysfs_pathinfo (struct path * pp, struct sysfs_device * parent)
 	/*
 	 * target node name
 	 */
-	if(!sysfs_get_fc_nodename(parent, pp->tgt_node_name,
+	if(!sysfs_get_tgt_nodename(parent, pp->tgt_node_name,
 				 pp->sg_id.host_no,
 				 pp->sg_id.channel,
 				 pp->sg_id.scsi_id)) {
@@ -544,7 +630,7 @@ ccw_sysfs_pathinfo (struct path * pp, struct sysfs_device * parent)
 	/*
 	 * host / bus / target / lun
 	 */
-	basenamecpy(parent->devpath, attr_path);
+	basenamecpy(parent->devpath, attr_path, FILE_NAME_SIZE);
 	pp->sg_id.lun = 0;
 	sscanf(attr_path, "%i.%i.%x",
 			&pp->sg_id.host_no,
@@ -568,7 +654,7 @@ cciss_sysfs_pathinfo (struct path * pp, struct sysfs_device * dev)
 	/*
 	 * host / bus / target / lun
 	 */
-	basenamecpy(dev->devpath, attr_path);
+	basenamecpy(dev->devpath, attr_path, FILE_NAME_SIZE);
 	pp->sg_id.lun = 0;
 	pp->sg_id.channel = 0;
 	sscanf(attr_path, "cciss!c%id%i",
@@ -586,14 +672,14 @@ cciss_sysfs_pathinfo (struct path * pp, struct sysfs_device * dev)
 static int
 common_sysfs_pathinfo (struct path * pp, struct sysfs_device *dev)
 {
-	char *attr;
+	size_t len;
 
-	attr = sysfs_attr_get_value(dev->devpath, "dev");
-	if (!attr) {
+	len = sysfs_attr_get_value(dev->devpath, "dev",
+				    pp->dev_t, BLK_DEV_SIZE);
+	if (!len) {
 		condlog(3, "%s: no 'dev' attribute in sysfs", pp->dev);
 		return 1;
 	}
-	strlcpy(pp->dev_t, attr, BLK_DEV_SIZE);
 
 	condlog(3, "%s: dev_t = %s", pp->dev, pp->dev_t);
 
@@ -609,6 +695,9 @@ struct sysfs_device *sysfs_device_from_path(struct path *pp)
 {
 	char sysdev[FILE_NAME_SIZE];
 
+	if (pp->sysdev && sysfs_device_verify(pp->sysdev))
+		return pp->sysdev;
+
 	strlcpy(sysdev,"/block/", FILE_NAME_SIZE);
 	strlcat(sysdev,pp->dev, FILE_NAME_SIZE);
 
@@ -621,6 +710,9 @@ path_offline (struct path * pp)
 	struct sysfs_device * parent;
 	char buff[SCSI_STATE_SIZE];
 
+	if (pp->bus != SYSFS_BUS_SCSI)
+		return PATH_UP;
+
 	pp->sysdev = sysfs_device_from_path(pp);
 	if (!pp->sysdev) {
 		condlog(1, "%s: failed to get sysfs information", pp->dev);
@@ -640,7 +732,7 @@ path_offline (struct path * pp)
 	if (sysfs_get_state(parent, buff, SCSI_STATE_SIZE))
 		return PATH_WILD;
 
-	condlog(3, "%s: state = %s", pp->dev, buff);
+	condlog(3, "%s: path state = %s", pp->dev, buff);
 
 	if (!strncmp(buff, "offline", 7)) {
 		pp->offline = 1;
@@ -679,17 +771,13 @@ sysfs_pathinfo(struct path * pp)
 		return 1;
 	}
 
+	pp->bus = SYSFS_BUS_UNDEF;
 	if (!strncmp(pp->dev,"cciss",5))
-		strcpy(parent->subsystem,"cciss");
-
-	condlog(3, "%s: subsystem = %s", pp->dev, parent->subsystem);
-
-	if (!strncmp(parent->subsystem, "scsi",4))
-		pp->bus = SYSFS_BUS_SCSI;
-	if (!strncmp(parent->subsystem, "ccw",3))
-		pp->bus = SYSFS_BUS_CCW;
-	if (!strncmp(parent->subsystem,"cciss",5))
 		pp->bus = SYSFS_BUS_CCISS;
+	if (!strncmp(pp->dev,"dasd", 4))
+		pp->bus = SYSFS_BUS_CCW;
+	if (!strncmp(pp->dev,"sd", 2))
+		pp->bus = SYSFS_BUS_SCSI;
 
 	if (pp->bus == SYSFS_BUS_UNDEF)
 		return 0;
@@ -750,8 +838,13 @@ get_state (struct path * pp, int daemon)
 	condlog(3, "%s: get_state", pp->dev);
 
 	if (!checker_selected(c)) {
-		if (daemon)
-			pathinfo(pp, conf->hwtable, DI_SYSFS);
+		if (daemon || pp->sysdev == NULL) {
+			if (pathinfo(pp, conf->hwtable, DI_SYSFS) != 0) {
+				condlog(3, "%s: couldn't get sysfs pathinfo",
+					pp->dev);
+				return PATH_UNCHECKED;
+			}
+		}
 		select_checker(pp);
 		if (!checker_selected(c)) {
 			condlog(3, "%s: No checker selected", pp->dev);
@@ -763,15 +856,13 @@ get_state (struct path * pp, int daemon)
 			return PATH_UNCHECKED;
 		}
 	}
-	state = path_offline(pp);
-	if (state != PATH_UP) {
-		condlog(3, "%s: path inaccessible", pp->dev);
-		return state;
-	}
+	checker_clear_message(c);
 	if (daemon)
 		checker_set_async(c);
+	if (!conf->checker_timeout)
+		sysfs_get_timeout(pp->sysdev, &(c->timeout));
 	state = checker_check(c);
-	condlog(3, "%s: state = %i", pp->dev, state);
+	condlog(3, "%s: state = %s", pp->dev, checker_state_name(state));
 	if (state == PATH_DOWN && strlen(checker_message(c)))
 		condlog(3, "%s: checker msg is \"%s\"",
 			pp->dev, checker_message(c));
@@ -805,8 +896,7 @@ get_prio (struct path * pp)
 static int
 get_uid (struct path * pp)
 {
-	char buff[CALLOUT_MAX_SIZE];
-	int i;
+	char buff[CALLOUT_MAX_SIZE], *c;
 
 	if (!pp->getuid)
 		select_getuid(pp);
@@ -820,18 +910,22 @@ get_uid (struct path * pp)
 		return 1;
 	}
 	/* Strip any trailing blanks */
-	i = WWID_SIZE - 1;
-	while (i > 0 && pp->wwid[i] == ' ') {
-		pp->wwid[i] = '\0';
-		i--;
-	}
-	condlog(3, "%s: uid = %s (callout)", pp->dev ,pp->wwid);
+	c = strchr(pp->wwid, '\0');
+	c--;
+	while (c && c >= pp->wwid && *c == ' ') {
+		*c = '\0';
+		c--;
+	}
+	condlog(3, "%s: uid = %s (callout)", pp->dev,
+		*pp->wwid == '\0' ? "<empty>" : pp->wwid);
 	return 0;
 }
 
 extern int
 pathinfo (struct path *pp, vector hwtable, int mask)
 {
+	int path_state;
+
 	condlog(3, "%s: mask = 0x%x", pp->dev, mask);
 
 	/*
@@ -840,11 +934,13 @@ pathinfo (struct path *pp, vector hwtable, int mask)
 	if (mask & DI_SYSFS && sysfs_pathinfo(pp))
 		return 1;
 
+	path_state = path_offline(pp);
+
 	/*
 	 * fetch info not available through sysfs
 	 */
 	if (pp->fd < 0)
-		pp->fd = opennode(pp->dev, O_RDONLY);
+		pp->fd = opennode(pp->dev, O_RDWR);
 
 	if (pp->fd < 0) {
 		condlog(4, "Couldn't open node for %s: %s",
@@ -852,7 +948,10 @@ pathinfo (struct path *pp, vector hwtable, int mask)
 		goto blank;
 	}
 
-	if (pp->bus == SYSFS_BUS_SCSI &&
+	if (mask & DI_SERIAL)
+		get_geometry(pp);
+
+	if (path_state == PATH_UP && pp->bus == SYSFS_BUS_SCSI &&
 	    scsi_ioctl_pathinfo(pp, mask))
 		goto blank;
 
@@ -861,20 +960,32 @@ pathinfo (struct path *pp, vector hwtable, int mask)
 		goto blank;
 
 	if (mask & DI_CHECKER) {
-		pp->state = get_state(pp, 0);
-		if (pp->state == PATH_UNCHECKED || pp->state == PATH_WILD)
-			goto blank;
+		if (path_state == PATH_UP) {
+			pp->state = get_state(pp, 0);
+			if (pp->state == PATH_UNCHECKED ||
+			    pp->state == PATH_WILD)
+				goto blank;
+		} else {
+			condlog(3, "%s: path inaccessible", pp->dev);
+			pp->state = path_state;
+		}
 	}
 
 	 /*
 	  * Retrieve path priority, even for PATH_DOWN paths if it has never
 	  * been successfully obtained before.
 	  */
-	if (mask & DI_PRIO &&
-	    (pp->state != PATH_DOWN || pp->priority == PRIO_UNDEF))
-		get_prio(pp);
+	if ((mask & DI_PRIO) && path_state == PATH_UP) {
+		if (pp->state != PATH_DOWN || pp->priority == PRIO_UNDEF) {
+			if (!strlen(pp->wwid))
+				get_uid(pp);
+			get_prio(pp);
+		} else {
+			pp->priority = PRIO_UNDEF;
+		}
+	}
 
-	if (mask & DI_WWID && !strlen(pp->wwid))
+	if (path_state == PATH_UP && (mask & DI_WWID) && !strlen(pp->wwid))
 		get_uid(pp);
 
 	return 0;
diff --git a/libmultipath/discovery.h b/libmultipath/discovery.h
index ec3a358..0ba33d8 100644
--- a/libmultipath/discovery.h
+++ b/libmultipath/discovery.h
@@ -28,13 +28,13 @@ int sysfs_get_dev (struct sysfs_device * dev, char * buff, size_t len);
 int path_discovery (vector pathvec, struct config * conf, int flag);
 
 int do_tur (char *);
-int devt2devname (char *, char *);
 int path_offline (struct path *);
 int get_state (struct path * pp, int daemon);
 int pathinfo (struct path *, vector hwtable, int mask);
 struct path * store_pathinfo (vector pathvec, vector hwtable,
 			      char * devname, int flag);
 int sysfs_set_scsi_tmo (struct multipath *mpp);
+int sysfs_get_timeout(struct sysfs_device *dev, unsigned int *timeout);
 
 /*
  * discovery bitmask
diff --git a/libmultipath/dmparser.c b/libmultipath/dmparser.c
index 1ef3aad..5848ec5 100644
--- a/libmultipath/dmparser.c
+++ b/libmultipath/dmparser.c
@@ -13,6 +13,7 @@
 #include "structs.h"
 #include "util.h"
 #include "debug.h"
+#include "config.h"
 
 #define WORD_SIZE 64
 
@@ -47,25 +48,48 @@ merge_words (char ** dst, char * word, int space)
  * Transforms the path group vector into a proper device map string
  */
 int
-assemble_map (struct multipath * mp)
+assemble_map (struct multipath * mp, char * params, int len)
 {
 	int i, j;
 	int shift, freechar;
 	int minio;
-	char * p;
+	int nr_priority_groups, initial_pg_nr;
+	char * p, * f;
+	char no_path_retry[] = "queue_if_no_path";
 	struct pathgroup * pgp;
 	struct path * pp;
 
 	minio = mp->minio;
-	p = mp->params;
-	freechar = sizeof(mp->params);
+	p = params;
+	freechar = len;
+
+	nr_priority_groups = VECTOR_SIZE(mp->pg);
+	initial_pg_nr = (nr_priority_groups ? mp->bestpg : 0);
+
+	f = STRDUP(mp->features);
+
+	/*
+	 * We have to set 'queue_if_no_path' here even
+	 * to avoid path failures during map reload.
+	 */
+	if (mp->no_path_retry == NO_PATH_RETRY_UNDEF ||
+	    mp->no_path_retry == NO_PATH_RETRY_FAIL) {
+		/* remove queue_if_no_path settings */
+		condlog(3, "%s: remove queue_if_no_path from '%s'",
+			mp->alias, mp->features);
+		remove_feature(&f, no_path_retry);
+	} else {
+		add_feature(&f, no_path_retry);
+	}
 
 	shift = snprintf(p, freechar, "%s %s %i %i",
-			 mp->features, mp->hwhandler,
-			 VECTOR_SIZE(mp->pg), mp->bestpg);
+			 f, mp->hwhandler,
+			 nr_priority_groups, initial_pg_nr);
+
+	FREE(f);
 
 	if (shift >= freechar) {
-		fprintf(stderr, "mp->params too small\n");
+		condlog(0, "%s: params too small", mp->alias);
 		return 1;
 	}
 	p += shift;
@@ -76,7 +100,7 @@ assemble_map (struct multipath * mp)
 		shift = snprintf(p, freechar, " %s %i 1", mp->selector,
 				 VECTOR_SIZE(pgp->paths));
 		if (shift >= freechar) {
-			fprintf(stderr, "mp->params too small\n");
+			condlog(0, "%s: params too small\n", mp->alias);
 			return 1;
 		}
 		p += shift;
@@ -88,11 +112,14 @@ assemble_map (struct multipath * mp)
 			if (mp->rr_weight == RR_WEIGHT_PRIO
 			    && pp->priority > 0)
 				tmp_minio = minio * pp->priority;
-
+			if (!strlen(pp->dev_t) ) {
+				condlog(0, "dev_t not set for '%s'\n", pp->dev);
+				return 1;
+			}
 			shift = snprintf(p, freechar, " %s %d",
 					 pp->dev_t, tmp_minio);
 			if (shift >= freechar) {
-				fprintf(stderr, "mp->params too small\n");
+				condlog(0, "%s: params too small", mp->alias);
 				return 1;
 			}
 			p += shift;
@@ -100,10 +127,12 @@ assemble_map (struct multipath * mp)
 		}
 	}
 	if (freechar < 1) {
-		fprintf(stderr, "mp->params too small\n");
+		condlog(0, "%s: params too small", mp->alias);
 		return 1;
 	}
 	snprintf(p, 1, "\n");
+
+	condlog(3, "%s: assembled map [%s]", mp->alias, params);
 	return 0;
 }
 
@@ -120,11 +149,14 @@ disassemble_map (vector pathvec, char * params, struct multipath * mpp)
 	int num_paths = 0;
 	int num_paths_args = 0;
 	int def_minio = 0;
+	int no_path_retry = NO_PATH_RETRY_UNDEF;
 	struct path * pp;
 	struct pathgroup * pgp;
 
 	p = params;
 
+	condlog(3, "%s: disassemble map [%s]", mpp->alias, params);
+
 	/*
 	 * features
 	 */
@@ -134,6 +166,8 @@ disassemble_map (vector pathvec, char * params, struct multipath * mpp)
 		return 1;
 
 	num_features = atoi(mpp->features);
+	no_path_retry = mpp->no_path_retry;
+	mpp->no_path_retry = NO_PATH_RETRY_UNDEF;
 
 	for (i = 0; i < num_features; i++) {
 		p += get_word(p, &word);
@@ -154,6 +188,17 @@ disassemble_map (vector pathvec, char * params, struct multipath * mpp)
 	}
 
 	/*
+	 * Reset no_path_retry.
+	 * - if not set from features
+	 * - if queue_if_no_path is set from features but
+	 *   no_path_retry > 0 is selected.
+	 */
+	if ((mpp->no_path_retry == NO_PATH_RETRY_UNDEF ||
+	     mpp->no_path_retry == NO_PATH_RETRY_QUEUE) &&
+	    mpp->no_path_retry != no_path_retry)
+		mpp->no_path_retry = no_path_retry;
+
+	/*
 	 * hwhandler
 	 */
 	p += get_word(p, &mpp->hwhandler);
@@ -286,7 +331,7 @@ disassemble_map (vector pathvec, char * params, struct multipath * mpp)
 				strncpy(pp->dev_t, word, BLK_DEV_SIZE);
 
 				/* Only call this in multipath client mode */
-				if (!mpp->waiter && store_path(pathvec, pp))
+				if (!conf->daemon && store_path(pathvec, pp))
 					goto out1;
 			}
 			FREE(word);
@@ -362,6 +407,8 @@ disassemble_status (char * params, struct multipath * mpp)
 
 	p = params;
 
+	condlog(3, "%s: disassemble status [%s]", mpp->alias, params);
+
 	/*
 	 * features
 	 */
diff --git a/libmultipath/dmparser.h b/libmultipath/dmparser.h
index bf4b2c3..1b45df0 100644
--- a/libmultipath/dmparser.h
+++ b/libmultipath/dmparser.h
@@ -1,3 +1,3 @@
-int assemble_map (struct multipath *);
+int assemble_map (struct multipath *, char *, int);
 int disassemble_map (vector, char *, struct multipath *);
 int disassemble_status (char *, struct multipath *);
diff --git a/libmultipath/hwtable.c b/libmultipath/hwtable.c
index e4fe380..b8a62dd 100644
--- a/libmultipath/hwtable.c
+++ b/libmultipath/hwtable.c
@@ -35,6 +35,7 @@ static struct hwentry default_hw[] = {
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_QUEUE,
 		.minio         = DEFAULT_MINIO,
+		.minio_rq      = DEFAULT_MINIO_RQ,
 		.checker_name  = TUR,
 		.prio_name     = DEFAULT_PRIO,
 		.prio_args     = NULL,
@@ -57,6 +58,7 @@ static struct hwentry default_hw[] = {
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_UNDEF,
 		.minio         = DEFAULT_MINIO,
+		.minio_rq      = DEFAULT_MINIO_RQ,
 		.checker_name  = DEFAULT_CHECKER,
 		.prio_name     = DEFAULT_PRIO,
 		.prio_args     = NULL,
@@ -79,6 +81,7 @@ static struct hwentry default_hw[] = {
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_UNDEF,
 		.minio         = DEFAULT_MINIO,
+		.minio_rq      = DEFAULT_MINIO_RQ,
 		.checker_name  = DEFAULT_CHECKER,
 		.prio_name     = DEFAULT_PRIO,
 		.prio_args     = NULL,
@@ -95,6 +98,7 @@ static struct hwentry default_hw[] = {
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_UNDEF,
 		.minio         = DEFAULT_MINIO,
+		.minio_rq      = DEFAULT_MINIO_RQ,
 		.checker_name  = HP_SW,
 		.prio_name     = PRIO_HP_SW,
 		.prio_args     = NULL,
@@ -111,6 +115,7 @@ static struct hwentry default_hw[] = {
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = 12,
 		.minio         = DEFAULT_MINIO,
+		.minio_rq      = DEFAULT_MINIO_RQ,
 		.checker_name  = DIRECTIO,
 		.prio_name     = DEFAULT_PRIO,
 		.prio_args     = NULL,
@@ -232,10 +237,29 @@ static struct hwentry default_hw[] = {
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = 12,
 		.minio         = DEFAULT_MINIO,
-		.checker_name  = CCISS_TUR,
+		.minio_rq      = DEFAULT_MINIO_RQ,
+		.checker_name  = TUR,
 		.prio_name     = DEFAULT_PRIO,
 		.prio_args     = NULL,
 	},
+	{
+		/* HP P2000 family arrays */
+		.vendor        = "HP",
+		.product       = "P2000 G3 FC|P2000G3 FC/iSCSI|P2000 G3 SAS|P2000 G3 iSCSI",
+		.getuid        = DEFAULT_GETUID,
+		.features      = DEFAULT_FEATURES,
+		.hwhandler     = DEFAULT_HWHANDLER,
+		.selector      = DEFAULT_SELECTOR,
+		.pgpolicy      = GROUP_BY_PRIO,
+		.pgfailback    = -FAILBACK_IMMEDIATE,
+		.rr_weight     = RR_WEIGHT_NONE,
+		.no_path_retry = 18,
+		.minio         = 100,
+		.minio_rq      = DEFAULT_MINIO_RQ,
+		.checker_name  = TUR,
+		.prio_name     = PRIO_ALUA,
+		.prio_args     = NULL,
+	},
 	/*
 	 * DDN controller family
 	 *
@@ -254,6 +278,7 @@ static struct hwentry default_hw[] = {
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_UNDEF,
 		.minio         = DEFAULT_MINIO,
+		.minio_rq      = DEFAULT_MINIO_RQ,
 		.checker_name  = DIRECTIO,
 		.prio_name     = DEFAULT_PRIO,
 		.prio_args     = NULL,
@@ -274,9 +299,10 @@ static struct hwentry default_hw[] = {
 		.pgpolicy      = MULTIBUS,
 		.pgfailback    = FAILBACK_UNDEF,
 		.rr_weight     = RR_WEIGHT_NONE,
-		.no_path_retry = NO_PATH_RETRY_UNDEF,
+		.no_path_retry = 6,
 		.minio         = DEFAULT_MINIO,
-		.checker_name  = DIRECTIO,
+		.minio_rq      = DEFAULT_MINIO_RQ,
+		.checker_name  = TUR,
 		.prio_name     = DEFAULT_PRIO,
 		.prio_args     = NULL,
 	},
@@ -293,6 +319,7 @@ static struct hwentry default_hw[] = {
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = (300 / DEFAULT_CHECKINT),
 		.minio         = DEFAULT_MINIO,
+		.minio_rq      = DEFAULT_MINIO_RQ,
 		.checker_name  = EMC_CLARIION,
 		.prio_name     = PRIO_EMC,
 		.prio_args     = NULL,
@@ -310,6 +337,8 @@ static struct hwentry default_hw[] = {
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = 5,
 		.minio         = DEFAULT_MINIO,
+		.minio_rq      = DEFAULT_MINIO_RQ,
+		.checker_name  = TUR,
 		.prio_name     = DEFAULT_PRIO,
 		.prio_args     = NULL,
 	},
@@ -331,25 +360,25 @@ static struct hwentry default_hw[] = {
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_UNDEF,
 		.minio         = DEFAULT_MINIO,
+		.minio_rq      = DEFAULT_MINIO_RQ,
 		.checker_name  = DIRECTIO,
 		.prio_name     = DEFAULT_PRIO,
 		.prio_args     = NULL,
 	},
 	{
-		.vendor        = "EMC",
-		.product       = "Invista",
-		.bl_product    = "LUNZ",
+		.vendor        = "FUJITSU",
+		.product       = "ETERNUS_DX(L|400|8000)",
 		.getuid        = DEFAULT_GETUID,
-		.features      = DEFAULT_FEATURES,
+		.features      = "1 queue_if_no_path",
 		.hwhandler     = DEFAULT_HWHANDLER,
 		.selector      = DEFAULT_SELECTOR,
-		.pgpolicy      = FAILOVER,
-		.pgfailback    = FAILBACK_UNDEF,
+		.pgpolicy      = GROUP_BY_PRIO,
+		.pgfailback    = -FAILBACK_IMMEDIATE,
 		.rr_weight     = RR_WEIGHT_NONE,
-		.no_path_retry = 5,
+		.no_path_retry = 10,
 		.minio         = DEFAULT_MINIO,
 		.checker_name  = TUR,
-		.prio_name     = DEFAULT_PRIO,
+		.prio_name     = PRIO_ALUA,
 		.prio_args     = NULL,
 	},
 	/*
@@ -370,6 +399,7 @@ static struct hwentry default_hw[] = {
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_UNDEF,
 		.minio         = DEFAULT_MINIO,
+		.minio_rq      = DEFAULT_MINIO_RQ,
 		.checker_name  = TUR,
 		.prio_name     = DEFAULT_PRIO,
 		.prio_args     = NULL,
@@ -386,6 +416,7 @@ static struct hwentry default_hw[] = {
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_UNDEF,
 		.minio         = DEFAULT_MINIO,
+		.minio_rq      = DEFAULT_MINIO_RQ,
 		.checker_name  = TUR,
 		.prio_name     = PRIO_HDS,
 		.prio_args     = NULL,
@@ -408,6 +439,7 @@ static struct hwentry default_hw[] = {
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_UNDEF,
 		.minio         = DEFAULT_MINIO,
+		.minio_rq      = DEFAULT_MINIO_RQ,
 		.checker_name  = DIRECTIO,
 		.prio_name     = DEFAULT_PRIO,
 		.prio_args     = NULL,
@@ -415,7 +447,7 @@ static struct hwentry default_hw[] = {
 	{
 		/* IBM FAStT 1722-600 */
 		.vendor        = "IBM",
-		.product       = "1722-600",
+		.product       = "^1722-600",
 		.getuid        = DEFAULT_GETUID,
 		.features      = "1 queue_if_no_path",
 		.hwhandler     = "1 rdac",
@@ -425,6 +457,7 @@ static struct hwentry default_hw[] = {
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = 300,
 		.minio         = DEFAULT_MINIO,
+		.minio_rq      = DEFAULT_MINIO_RQ,
 		.checker_name  = RDAC,
 		.prio_name     = PRIO_RDAC,
 		.prio_args     = NULL,
@@ -432,7 +465,7 @@ static struct hwentry default_hw[] = {
 	{
 		/* IBM DS4100 */
 		.vendor        = "IBM",
-		.product       = "1724",
+		.product       = "^1724",
 		.getuid        = DEFAULT_GETUID,
 		.features      = "1 queue_if_no_path",
 		.hwhandler     = "1 rdac",
@@ -442,6 +475,7 @@ static struct hwentry default_hw[] = {
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = 300,
 		.minio         = DEFAULT_MINIO,
+		.minio_rq      = DEFAULT_MINIO_RQ,
 		.checker_name  = RDAC,
 		.prio_name     = PRIO_RDAC,
 		.prio_args     = NULL,
@@ -449,7 +483,7 @@ static struct hwentry default_hw[] = {
 	{
 		/* IBM DS3200 / DS3300 / DS3400 */
 		.vendor        = "IBM",
-		.product       = "1726",
+		.product       = "^1726",
 		.getuid        = DEFAULT_GETUID,
 		.features      = "1 queue_if_no_path",
 		.hwhandler     = "1 rdac",
@@ -459,6 +493,7 @@ static struct hwentry default_hw[] = {
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = 300,
 		.minio         = DEFAULT_MINIO,
+		.minio_rq      = DEFAULT_MINIO_RQ,
 		.checker_name  = RDAC,
 		.prio_name     = PRIO_RDAC,
 		.prio_args     = NULL,
@@ -466,7 +501,7 @@ static struct hwentry default_hw[] = {
 	{
 		/* IBM DS4400 / DS4500 / FAStT700 */
 		.vendor        = "IBM",
-		.product       = "1742",
+		.product       = "^1742",
 		.getuid        = DEFAULT_GETUID,
 		.features      = DEFAULT_FEATURES,
 		.hwhandler     = "1 rdac",
@@ -476,13 +511,14 @@ static struct hwentry default_hw[] = {
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_QUEUE,
 		.minio         = DEFAULT_MINIO,
+		.minio_rq      = DEFAULT_MINIO_RQ,
 		.checker_name  = RDAC,
 		.prio_name     = PRIO_RDAC,
 		.prio_args     = NULL,
 	},
 	{
 		.vendor        = "IBM",
-		.product       = "1745|1746",
+		.product       = "^1745|^1746",
 		.getuid        = DEFAULT_GETUID,
 		.features      = "2 pg_init_retries 50",
 		.hwhandler     = "1 rdac",
@@ -492,6 +528,7 @@ static struct hwentry default_hw[] = {
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = 15,
 		.minio         = DEFAULT_MINIO,
+		.minio_rq      = DEFAULT_MINIO_RQ,
 		.checker_name  = RDAC,
 		.prio_name     = PRIO_RDAC,
 		.prio_args     = NULL,
@@ -499,7 +536,7 @@ static struct hwentry default_hw[] = {
 	{
 	    /* IBM DS4700 */
 		.vendor        = "IBM",
-		.product       = "1814",
+		.product       = "^1814",
 		.getuid        = DEFAULT_GETUID,
 		.features      = DEFAULT_FEATURES,
 		.hwhandler     = "1 rdac",
@@ -509,6 +546,7 @@ static struct hwentry default_hw[] = {
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_QUEUE,
 		.minio         = DEFAULT_MINIO,
+		.minio_rq      = DEFAULT_MINIO_RQ,
 		.checker_name  = RDAC,
 		.prio_name     = PRIO_RDAC,
 		.prio_args     = NULL,
@@ -516,7 +554,7 @@ static struct hwentry default_hw[] = {
 	{
 	    /* IBM DS4800 */
 		.vendor        = "IBM",
-		.product       = "1815",
+		.product       = "^1815",
 		.getuid        = DEFAULT_GETUID,
 		.features      = DEFAULT_FEATURES,
 		.hwhandler     = "1 rdac",
@@ -526,6 +564,7 @@ static struct hwentry default_hw[] = {
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_QUEUE,
 		.minio         = DEFAULT_MINIO,
+		.minio_rq      = DEFAULT_MINIO_RQ,
 		.checker_name  = RDAC,
 		.prio_name     = PRIO_RDAC,
 		.prio_args     = NULL,
@@ -533,7 +572,7 @@ static struct hwentry default_hw[] = {
 	{
 	    /* IBM DS5000 */
 		.vendor        = "IBM",
-		.product       = "1818",
+		.product       = "^1818",
 		.getuid        = DEFAULT_GETUID,
 		.features      = DEFAULT_FEATURES,
 		.hwhandler     = "1 rdac",
@@ -543,6 +582,7 @@ static struct hwentry default_hw[] = {
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_QUEUE,
 		.minio         = DEFAULT_MINIO,
+		.minio_rq      = DEFAULT_MINIO_RQ,
 		.checker_name  = RDAC,
 		.prio_name     = PRIO_RDAC,
 		.prio_args     = NULL,
@@ -550,7 +590,7 @@ static struct hwentry default_hw[] = {
 	{
 		/* IBM Netfinity Fibre Channel RAID Controller Unit */
 		.vendor        = "IBM",
-		.product       = "3526",
+		.product       = "^3526",
 		.getuid        = DEFAULT_GETUID,
 		.features      = DEFAULT_FEATURES,
 		.hwhandler     = "1 rdac",
@@ -560,6 +600,7 @@ static struct hwentry default_hw[] = {
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_QUEUE,
 		.minio         = DEFAULT_MINIO,
+		.minio_rq      = DEFAULT_MINIO_RQ,
 		.checker_name  = RDAC,
 		.prio_name     = PRIO_RDAC,
 		.prio_args     = NULL,
@@ -567,7 +608,7 @@ static struct hwentry default_hw[] = {
 	{
 		/* IBM DS4200 / FAStT200 */
 		.vendor        = "IBM",
-		.product       = "3542",
+		.product       = "^3542",
 		.getuid        = DEFAULT_GETUID,
 		.features      = DEFAULT_FEATURES,
 		.hwhandler     = DEFAULT_HWHANDLER,
@@ -577,6 +618,7 @@ static struct hwentry default_hw[] = {
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_UNDEF,
 		.minio         = DEFAULT_MINIO,
+		.minio_rq      = DEFAULT_MINIO_RQ,
 		.checker_name  = TUR,
 		.prio_name     = DEFAULT_PRIO,
 		.prio_args     = NULL,
@@ -584,7 +626,7 @@ static struct hwentry default_hw[] = {
 	{
 		/* IBM ESS F20 aka Shark */
 		.vendor        = "IBM",
-		.product       = "2105800",
+		.product       = "^2105800",
 		.getuid        = DEFAULT_GETUID,
 		.features      = "1 queue_if_no_path",
 		.hwhandler     = DEFAULT_HWHANDLER,
@@ -594,6 +636,7 @@ static struct hwentry default_hw[] = {
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_UNDEF,
 		.minio         = DEFAULT_MINIO,
+		.minio_rq      = DEFAULT_MINIO_RQ,
 		.checker_name  = TUR,
 		.prio_name     = DEFAULT_PRIO,
 		.prio_args     = NULL,
@@ -601,7 +644,7 @@ static struct hwentry default_hw[] = {
 	{
 		/* IBM ESS F20 aka Shark */
 		.vendor        = "IBM",
-		.product       = "2105F20",
+		.product       = "^2105F20",
 		.getuid        = DEFAULT_GETUID,
 		.features      = "1 queue_if_no_path",
 		.hwhandler     = DEFAULT_HWHANDLER,
@@ -611,6 +654,7 @@ static struct hwentry default_hw[] = {
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_UNDEF,
 		.minio         = DEFAULT_MINIO,
+		.minio_rq      = DEFAULT_MINIO_RQ,
 		.checker_name  = TUR,
 		.prio_name     = DEFAULT_PRIO,
 		.prio_args     = NULL,
@@ -618,7 +662,7 @@ static struct hwentry default_hw[] = {
 	{
 		/* IBM DS6000 */
 		.vendor        = "IBM",
-		.product       = "1750500",
+		.product       = "^1750500",
 		.getuid        = DEFAULT_GETUID,
 		.features      = "1 queue_if_no_path",
 		.hwhandler     = DEFAULT_HWHANDLER,
@@ -628,6 +672,7 @@ static struct hwentry default_hw[] = {
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_UNDEF,
 		.minio         = DEFAULT_MINIO,
+		.minio_rq      = DEFAULT_MINIO_RQ,
 		.checker_name  = TUR,
 		.prio_name     = PRIO_ALUA,
 		.prio_args     = NULL,
@@ -635,7 +680,7 @@ static struct hwentry default_hw[] = {
 	{
 		/* IBM DS8000 */
 		.vendor        = "IBM",
-		.product       = "2107900",
+		.product       = "^2107900",
 		.getuid        = DEFAULT_GETUID,
 		.features      = "1 queue_if_no_path",
 		.hwhandler     = DEFAULT_HWHANDLER,
@@ -645,6 +690,7 @@ static struct hwentry default_hw[] = {
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_UNDEF,
 		.minio         = DEFAULT_MINIO,
+		.minio_rq      = DEFAULT_MINIO_RQ,
 		.checker_name  = TUR,
 		.prio_name     = DEFAULT_PRIO,
 		.prio_args     = NULL,
@@ -652,7 +698,7 @@ static struct hwentry default_hw[] = {
 	{
 		/* IBM SAN Volume Controller */
 		.vendor        = "IBM",
-		.product       = "2145",
+		.product       = "^2145",
 		.getuid        = DEFAULT_GETUID,
 		.features      = "1 queue_if_no_path",
 		.hwhandler     = DEFAULT_HWHANDLER,
@@ -662,6 +708,7 @@ static struct hwentry default_hw[] = {
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_UNDEF,
 		.minio         = DEFAULT_MINIO,
+		.minio_rq      = DEFAULT_MINIO_RQ,
 		.checker_name  = TUR,
 		.prio_name     = PRIO_ALUA,
 		.prio_args     = NULL,
@@ -680,6 +727,7 @@ static struct hwentry default_hw[] = {
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_UNDEF,
 		.minio         = DEFAULT_MINIO,
+		.minio_rq      = DEFAULT_MINIO_RQ,
 		.checker_name  = DIRECTIO,
 		.prio_name     = DEFAULT_PRIO,
 		.prio_args     = NULL,
@@ -698,6 +746,7 @@ static struct hwentry default_hw[] = {
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_UNDEF,
 		.minio         = DEFAULT_MINIO,
+		.minio_rq      = DEFAULT_MINIO_RQ,
 		.checker_name  = DIRECTIO,
 		.prio_name     = DEFAULT_PRIO,
 		.prio_args     = NULL,
@@ -705,7 +754,7 @@ static struct hwentry default_hw[] = {
 	{
 		/* IBM IPR */
 		.vendor        = "IBM",
-		.product       = "IPR.*",
+		.product       = "^IPR.*",
 		.getuid        = DEFAULT_GETUID,
 		.features      = "1 queue_if_no_path",
 		.hwhandler     = "1 alua",
@@ -715,10 +764,47 @@ static struct hwentry default_hw[] = {
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_UNDEF,
 		.minio         = DEFAULT_MINIO,
+		.minio_rq      = DEFAULT_MINIO_RQ,
+		.checker_name  = TUR,
+		.prio_name     = PRIO_ALUA,
+		.prio_args     = NULL,
+	},
+	{
+		/* IBM RSSM */
+		.vendor        = "IBM",
+		.product       = "1820N00",
+		.getuid        = DEFAULT_GETUID,
+		.features      = DEFAULT_FEATURES,
+		.hwhandler     = DEFAULT_HWHANDLER,
+		.selector      = DEFAULT_SELECTOR,
+		.pgpolicy      = GROUP_BY_PRIO,
+		.pgfailback    = -FAILBACK_IMMEDIATE,
+		.rr_weight     = RR_WEIGHT_NONE,
+		.no_path_retry = NO_PATH_RETRY_QUEUE,
+		.minio         = 100,
+		.minio_rq      = DEFAULT_MINIO_RQ,
 		.checker_name  = TUR,
 		.prio_name     = PRIO_ALUA,
 		.prio_args     = NULL,
 	},
+        {
+                /* IBM XIV Storage System */
+                .vendor        = "IBM",
+                .product       = "2810XIV",
+                .getuid        = DEFAULT_GETUID,
+                .features      = "1 queue_if_no_path",
+                .hwhandler     = DEFAULT_HWHANDLER,
+                .selector      = DEFAULT_SELECTOR,
+                .pgpolicy      = MULTIBUS,
+                .pgfailback    = 15,
+                .rr_weight     = RR_WEIGHT_NONE,
+                .no_path_retry = NO_PATH_RETRY_UNDEF,
+                .minio         = 15,
+                .minio_rq      = DEFAULT_MINIO_RQ,
+                .checker_name  = TUR,
+                .prio_name     = DEFAULT_PRIO,
+                .prio_args     = NULL,
+        },
 	/*
 	 * IBM Power Virtual SCSI Devices
 	 *
@@ -738,6 +824,7 @@ static struct hwentry default_hw[] = {
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = (300 / DEFAULT_CHECKINT),
 		.minio         = DEFAULT_MINIO,
+		.minio_rq      = DEFAULT_MINIO_RQ,
 		.checker_name  = DIRECTIO,
 		.prio_name     = DEFAULT_PRIO,
 		.prio_args     = NULL,
@@ -755,11 +842,29 @@ static struct hwentry default_hw[] = {
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = (300 / DEFAULT_CHECKINT),
 		.minio         = DEFAULT_MINIO,
+		.minio_rq      = DEFAULT_MINIO_RQ,
 		.checker_name  = TUR,
 		.prio_name     = DEFAULT_PRIO,
 		.prio_args     = NULL,
 	},
-
+	{
+		/* AIX NVDISK */
+		.vendor        = "AIX",
+		.product       = "NVDISK",
+		.getuid        = DEFAULT_GETUID,
+		.features      = DEFAULT_FEATURES,
+		.hwhandler     = "1 alua",
+		.selector      = DEFAULT_SELECTOR,
+		.pgpolicy      = GROUP_BY_PRIO,
+		.pgfailback    = -FAILBACK_IMMEDIATE,
+		.rr_weight     = RR_WEIGHT_NONE,
+		.no_path_retry = (300 / DEFAULT_CHECKINT),
+		.minio         = DEFAULT_MINIO,
+		.minio_rq      = DEFAULT_MINIO_RQ,
+		.checker_name  = TUR,
+		.prio_name     = PRIO_ALUA,
+		.prio_args     = NULL,
+	},
 	{
 		/* DELL MD3000 */
 		.vendor        = "DELL",
@@ -773,6 +878,7 @@ static struct hwentry default_hw[] = {
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = 15,
 		.minio         = DEFAULT_MINIO,
+		.minio_rq      = DEFAULT_MINIO_RQ,
 		.checker_name  = RDAC,
 		.prio_name     = PRIO_RDAC,
 		.prio_args     = NULL,
@@ -790,6 +896,7 @@ static struct hwentry default_hw[] = {
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = 15,
 		.minio         = DEFAULT_MINIO,
+		.minio_rq      = DEFAULT_MINIO_RQ,
 		.checker_name  = RDAC,
 		.prio_name     = PRIO_RDAC,
 		.prio_args     = NULL,
@@ -807,6 +914,7 @@ static struct hwentry default_hw[] = {
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = 15,
 		.minio         = DEFAULT_MINIO,
+		.minio_rq      = DEFAULT_MINIO_RQ,
 		.checker_name  = RDAC,
 		.prio_name     = PRIO_RDAC,
 		.prio_args     = NULL,
@@ -824,6 +932,7 @@ static struct hwentry default_hw[] = {
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = 15,
 		.minio         = DEFAULT_MINIO,
+		.minio_rq      = DEFAULT_MINIO_RQ,
 		.checker_name  = RDAC,
 		.prio_name     = PRIO_RDAC,
 		.prio_args     = NULL,
@@ -846,8 +955,8 @@ static struct hwentry default_hw[] = {
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_UNDEF,
 		.minio         = 128,
-		.checker_name  = DIRECTIO,
-		.prio_name     = PRIO_NETAPP,
+		.checker_name  = TUR,
+		.prio_name     = PRIO_ONTAP,
 		.prio_args     = NULL,
 	},
 	/*
@@ -891,7 +1000,7 @@ static struct hwentry default_hw[] = {
 		.no_path_retry = NO_PATH_RETRY_UNDEF,
 		.minio         = 128,
 		.checker_name  = DIRECTIO,
-		.prio_name     = PRIO_NETAPP,
+		.prio_name     = PRIO_ONTAP,
 		.prio_args     = NULL,
 	},
 	/*
@@ -912,10 +1021,12 @@ static struct hwentry default_hw[] = {
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_UNDEF,
 		.minio         = DEFAULT_MINIO,
+		.minio_rq      = DEFAULT_MINIO_RQ,
 		.checker_name  = TUR,
 		.prio_name     = PRIO_ALUA,
 		.prio_args     = NULL,
 	},
+
 	/*
 	 * SGI arrays
 	 *
@@ -934,6 +1045,7 @@ static struct hwentry default_hw[] = {
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_UNDEF,
 		.minio         = DEFAULT_MINIO,
+		.minio_rq      = DEFAULT_MINIO_RQ,
 		.checker_name  = DIRECTIO,
 		.prio_name     = DEFAULT_PRIO,
 		.prio_args     = NULL,
@@ -950,6 +1062,7 @@ static struct hwentry default_hw[] = {
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_QUEUE,
 		.minio         = DEFAULT_MINIO,
+		.minio_rq      = DEFAULT_MINIO_RQ,
 		.checker_name  = RDAC,
 		.prio_name     = PRIO_RDAC,
 		.prio_args     = NULL,
@@ -958,18 +1071,37 @@ static struct hwentry default_hw[] = {
 		.vendor        = "SGI",
 		.product       = "IS.*",
 		.getuid        = DEFAULT_GETUID,
-		.features      = DEFAULT_FEATURES,
+		.features      = "2 pg_init_retries 50",
 		.hwhandler     = "1 rdac",
 		.selector      = DEFAULT_SELECTOR,
 		.pgpolicy      = GROUP_BY_PRIO,
 		.pgfailback    = -FAILBACK_IMMEDIATE,
 		.rr_weight     = RR_WEIGHT_NONE,
-		.no_path_retry = NO_PATH_RETRY_QUEUE,
+		.no_path_retry = 15,
 		.minio         = DEFAULT_MINIO,
+		.minio_rq      = DEFAULT_MINIO_RQ,
 		.checker_name  = RDAC,
 		.prio_name     = PRIO_RDAC,
 		.prio_args     = NULL,
 	},
+	/* NEC Storage M Series */
+	{
+		.vendor        = "NEC",
+		.product       = "DISK ARRAY",
+		.getuid        = DEFAULT_GETUID,
+		.features      = DEFAULT_FEATURES,
+		.hwhandler     = "1 alua",
+		.selector      = DEFAULT_SELECTOR,
+		.pgpolicy      = GROUP_BY_PRIO,
+		.pgfailback    = -FAILBACK_IMMEDIATE,
+		.rr_weight     = RR_WEIGHT_NONE,
+		.no_path_retry = NO_PATH_RETRY_UNDEF,
+		.minio         = DEFAULT_MINIO,
+		.minio_rq      = DEFAULT_MINIO_RQ,
+		.checker_name  = TUR,
+		.prio_name     = PRIO_ALUA,
+		.prio_args     = NULL,
+	},
 	/*
 	 * STK arrays
 	 *
@@ -988,6 +1120,7 @@ static struct hwentry default_hw[] = {
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_UNDEF,
 		.minio         = DEFAULT_MINIO,
+		.minio_rq      = DEFAULT_MINIO_RQ,
 		.checker_name  = TUR,
 		.prio_name     = PRIO_RDAC,
 		.prio_args     = NULL,
@@ -1010,10 +1143,28 @@ static struct hwentry default_hw[] = {
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_UNDEF,
 		.minio         = DEFAULT_MINIO,
+		.minio_rq      = DEFAULT_MINIO_RQ,
 		.checker_name  = DIRECTIO,
 		.prio_name     = DEFAULT_PRIO,
 		.prio_args     = NULL,
 	},
+	{
+		.vendor        = "EUROLOGC",
+		.product       = "FC2502",
+		.getuid        ="/lib/udev/scsi_id --page=0x80 --whitelisted --device=/dev/%n",
+		.features      = DEFAULT_FEATURES,
+		.hwhandler     = DEFAULT_HWHANDLER,
+		.selector      = DEFAULT_SELECTOR,
+		.pgpolicy      = GROUP_BY_PRIO,
+		.pgfailback    = FAILBACK_UNDEF,
+		.rr_weight     = RR_WEIGHT_NONE,
+		.no_path_retry = NO_PATH_RETRY_UNDEF,
+		.minio         = DEFAULT_MINIO,
+		.minio_rq      = DEFAULT_MINIO_RQ,
+		.checker_name  = DEFAULT_CHECKER,
+		.prio_name     = DEFAULT_PRIO,
+		.prio_args     = NULL,
+	},
 	/*
 	 * Pivot3 RAIGE
 	 *
@@ -1048,6 +1199,7 @@ static struct hwentry default_hw[] = {
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_QUEUE,
 		.minio         = DEFAULT_MINIO,
+		.minio_rq      = DEFAULT_MINIO_RQ,
 		.checker_name  = RDAC,
 		.prio_name     = PRIO_RDAC,
 		.prio_args     = NULL,
@@ -1065,11 +1217,12 @@ static struct hwentry default_hw[] = {
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_QUEUE,
 		.minio         = DEFAULT_MINIO,
+		.minio_rq      = DEFAULT_MINIO_RQ,
 		.checker_name  = RDAC,
 		.prio_name     = PRIO_RDAC,
 		.prio_args     = NULL,
 	},
-	/* LSI Generic rdac storage */
+	/* LSI/Engenio/NetApp E-Series RDAC storage */
 	{
 		.vendor        = "(LSI|ENGENIO)",
 		.product       = "INF-01-00",
@@ -1082,6 +1235,7 @@ static struct hwentry default_hw[] = {
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = 15,
 		.minio         = DEFAULT_MINIO,
+		.minio_rq      = DEFAULT_MINIO_RQ,
 		.checker_name  = RDAC,
 		.prio_name     = PRIO_RDAC,
 		.prio_args     = NULL,
@@ -1099,6 +1253,7 @@ static struct hwentry default_hw[] = {
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_QUEUE,
 		.minio         = DEFAULT_MINIO,
+		.minio_rq      = DEFAULT_MINIO_RQ,
 		.checker_name  = RDAC,
 		.prio_name     = PRIO_RDAC,
 		.prio_args     = NULL,
@@ -1118,6 +1273,7 @@ static struct hwentry default_hw[] = {
 		.rr_weight     = 0,
 		.no_path_retry = 0,
 		.minio         = 0,
+		.minio_rq      = 0,
 		.checker_name  = NULL,
 		.prio_name     = NULL,
 		.prio_args     = NULL,
diff --git a/libmultipath/log.c b/libmultipath/log.c
index e56e46b..57b7696 100644
--- a/libmultipath/log.c
+++ b/libmultipath/log.c
@@ -142,7 +142,7 @@ int log_enqueue (int prio, const char * fmt, va_list ap)
 	la->empty = 0;
 	msg = (struct logmsg *)la->tail;
 	msg->prio = prio;
-	strcpy((void *)&msg->str, buff);
+	memcpy((void *)&msg->str, buff, strlen(buff) + 1);
 	lastmsg->next = la->tail;
 	msg->next = la->head;
 
diff --git a/libmultipath/log.h b/libmultipath/log.h
index c697118..6634c83 100644
--- a/libmultipath/log.h
+++ b/libmultipath/log.h
@@ -1,8 +1,8 @@
 #ifndef LOG_H
 #define LOG_H
 
-#define DEFAULT_AREA_SIZE 8192
-#define MAX_MSG_SIZE 128
+#define DEFAULT_AREA_SIZE 16384
+#define MAX_MSG_SIZE 256
 
 #ifndef LOGLEVEL
 #define LOGLEVEL 5
@@ -17,7 +17,7 @@
 struct logmsg {
 	short int prio;
 	void * next;
-	char * str;
+	char str[0];
 };
 
 struct logarea {
diff --git a/libmultipath/log_pthread.c b/libmultipath/log_pthread.c
index ed7b200..d701ba1 100644
--- a/libmultipath/log_pthread.c
+++ b/libmultipath/log_pthread.c
@@ -87,6 +87,7 @@ void log_thread_stop (void)
 	pthread_mutex_lock(logq_lock);
 	pthread_cancel(log_thr);
 	pthread_mutex_unlock(logq_lock);
+	pthread_join(log_thr, NULL);
 
 	flush_logqueue();
 
diff --git a/libmultipath/parser.c b/libmultipath/parser.c
index eb3815e..79c2d22 100644
--- a/libmultipath/parser.c
+++ b/libmultipath/parser.c
@@ -21,11 +21,13 @@
 
 #include "parser.h"
 #include "memory.h"
+#include "debug.h"
 
 /* local vars */
 static int sublevel = 0;
-vector keywords = NULL;
-vector *keywords_addr = NULL;
+static vector keywords = NULL;
+static vector *keywords_addr = NULL;
+static int line_nr;
 
 void set_current_keywords (vector *k)
 {
@@ -35,7 +37,7 @@ void set_current_keywords (vector *k)
 
 int
 keyword_alloc(vector keywords, char *string, int (*handler) (vector),
-		int (*print) (char *, int, void *))
+		int (*print) (char *, int, void *), int unique)
 {
 	struct keyword *keyword;
 
@@ -51,6 +53,7 @@ keyword_alloc(vector keywords, char *string, int (*handler) (vector),
 	keyword->string = string;
 	keyword->handler = handler;
 	keyword->print = print;
+	keyword->unique = unique;
 
 	vector_set_slot(keywords, keyword);
 
@@ -60,7 +63,7 @@ keyword_alloc(vector keywords, char *string, int (*handler) (vector),
 int
 install_keyword_root(char *string, int (*handler) (vector))
 {
-	int r = keyword_alloc(keywords, string, handler, NULL);
+	int r = keyword_alloc(keywords, string, handler, NULL, 1);
 	if (!r)
 		*keywords_addr = keywords;
 	return r;
@@ -79,8 +82,8 @@ install_sublevel_end(void)
 }
 
 int
-install_keyword(char *string, int (*handler) (vector),
-		int (*print) (char *, int, void *))
+_install_keyword(char *string, int (*handler) (vector),
+		int (*print) (char *, int, void *), int unique)
 {
 	int i = 0;
 	struct keyword *keyword;
@@ -101,7 +104,7 @@ install_keyword(char *string, int (*handler) (vector),
 		return 1;
 
 	/* add new sub keyword */
-	return keyword_alloc(keyword->sub, string, handler, print);
+	return keyword_alloc(keyword->sub, string, handler, print, unique);
 }
 
 void
@@ -384,12 +387,19 @@ void *
 set_value(vector strvec)
 {
 	char *str = VECTOR_SLOT(strvec, 1);
-	int size = strlen(str);
+	size_t size;
 	int i = 0;
 	int len = 0;
 	char *alloc = NULL;
 	char *tmp;
 
+	if (!str)
+		return NULL;
+
+	size = strlen(str);
+	if (size == 0)
+		return NULL;
+
 	if (*str == '"') {
 		for (i = 2; i < VECTOR_SIZE(strvec); i++) {
 			str = VECTOR_SLOT(strvec, i);
@@ -419,6 +429,39 @@ set_value(vector strvec)
 
 /* non-recursive configuration stream handler */
 static int kw_level = 0;
+
+int warn_on_duplicates(vector uniques, char *str)
+{
+	char *tmp;
+	int i;
+
+	vector_foreach_slot(uniques, tmp, i) {
+		if (!strcmp(str, tmp)) {
+			condlog(1, "multipath.conf line %d, duplicate keyword: %s", line_nr, str);
+			return 0;
+		}
+	}
+	tmp = strdup(str);
+	if (!tmp)
+		return 1;
+	if (!vector_alloc_slot(uniques)) {
+		free(tmp);
+		return 1;
+	}
+	vector_set_slot(uniques, tmp);
+	return 0;
+}
+
+void free_uniques(vector uniques)
+{
+	char *tmp;
+	int i;
+
+	vector_foreach_slot(uniques, tmp, i)
+		free(tmp);
+	vector_free(uniques);
+}
+
 int
 process_stream(vector keywords)
 {
@@ -428,13 +471,21 @@ process_stream(vector keywords)
 	char *str;
 	char *buf;
 	vector strvec;
+	vector uniques;
+
+	uniques = vector_alloc();
+	if (!uniques)
+		return 1;
 
 	buf = MALLOC(MAXBUF);
 
-	if (!buf)
+	if (!buf) {
+		vector_free(uniques);
 		return 1;
+	}
 
 	while (read_line(buf, MAXBUF)) {
+		line_nr++;
 		strvec = alloc_strvec(buf);
 		memset(buf,0, MAXBUF);
 
@@ -452,6 +503,12 @@ process_stream(vector keywords)
 			keyword = VECTOR_SLOT(keywords, i);
 
 			if (!strcmp(keyword->string, str)) {
+				if (keyword->unique &&
+				    warn_on_duplicates(uniques, str)) {
+						r = 1;
+						free_strvec(strvec);
+						goto out;
+				}
 				if (keyword->handler)
 					r += (*keyword->handler) (strvec);
 
@@ -463,24 +520,36 @@ process_stream(vector keywords)
 				break;
 			}
 		}
+		if (i >= VECTOR_SIZE(keywords))
+			condlog(1, "multipath.conf +%d, invalid keyword: %s",
+				line_nr, str);
 
 		free_strvec(strvec);
 	}
 
+out:
 	FREE(buf);
+	free_uniques(uniques);
 	return r;
 }
 
+int alloc_keywords(void)
+{
+	if (!keywords)
+		keywords = vector_alloc();
+
+	if (!keywords)
+		return 1;
+
+	return 0;
+}
+
 /* Data initialization */
 int
 init_data(char *conf_file, void (*init_keywords) (void))
 {
 	int r;
 
-	if (!keywords)
-		keywords = vector_alloc();
-	if (!keywords)
-		return 1;
 	stream = fopen(conf_file, "r");
 	if (!stream) {
 		syslog(LOG_WARNING, "Configuration file open problem");
@@ -496,6 +565,7 @@ init_data(char *conf_file, void (*init_keywords) (void))
 */
 
 	/* Stream handling */
+	line_nr = 0;
 	r = process_stream(keywords);
 	fclose(stream);
 	//free_keywords(keywords);
diff --git a/libmultipath/parser.h b/libmultipath/parser.h
index 95d4e6f..8bf1c76 100644
--- a/libmultipath/parser.h
+++ b/libmultipath/parser.h
@@ -44,6 +44,7 @@ struct keyword {
 	int (*handler) (vector);
 	int (*print) (char *, int, void *);
 	vector sub;
+	int unique;
 };
 
 /* global var exported */
@@ -60,12 +61,14 @@ FILE *stream;
 
 /* Prototypes */
 extern int keyword_alloc(vector keywords, char *string, int (*handler) (vector),
-			 int (*print) (char *, int, void *));
+			 int (*print) (char *, int, void *), int unique);
 extern int install_keyword_root(char *string, int (*handler) (vector));
 extern void install_sublevel(void);
 extern void install_sublevel_end(void);
-extern int install_keyword(char *string, int (*handler) (vector),
-			   int (*print) (char *, int, void *));
+extern int _install_keyword(char *string, int (*handler) (vector),
+			    int (*print) (char *, int, void *), int unique);
+#define install_keyword(str, vec, pri) _install_keyword(str, vec, pri, 1)
+#define install_keyword_multi(str, vec, pri) _install_keyword(str, vec, pri, 0)
 extern void dump_keywords(vector keydump, int level);
 extern void free_keywords(vector keywords);
 extern vector alloc_strvec(char *string);
@@ -74,6 +77,7 @@ extern vector read_value_block(void);
 extern int alloc_value_block(vector strvec, void (*alloc_func) (vector));
 extern void *set_value(vector strvec);
 extern int process_stream(vector keywords);
+extern int alloc_keywords(void);
 extern int init_data(char *conf_file, void (*init_keywords) (void));
 extern struct keyword * find_keyword(vector v, char * name);
 void set_current_keywords (vector *k);
diff --git a/libmultipath/pgpolicies.c b/libmultipath/pgpolicies.c
index cfaf1c3..f76ad60 100644
--- a/libmultipath/pgpolicies.c
+++ b/libmultipath/pgpolicies.c
@@ -11,6 +11,7 @@
 #include "vector.h"
 #include "structs.h"
 #include "pgpolicies.h"
+#include "switchgroup.h"
 
 extern int
 get_pgpolicy_id (char * str)
@@ -57,6 +58,34 @@ get_pgpolicy_name (char * buff, int len, int id)
 	return snprintf(buff, POLICY_NAME_SIZE, "%s", s);
 }
 
+
+void
+sort_pathgroups (struct multipath *mp) {
+	int i, j;
+	struct pathgroup * pgp1, * pgp2;
+
+	if (!mp->pg)
+		return;
+
+	vector_foreach_slot(mp->pg, pgp1, i) {
+		path_group_prio_update(pgp1);
+		for (j = i - 1; j >= 0; j--) {
+			pgp2 = VECTOR_SLOT(mp->pg, j);
+			if (!pgp2)
+				continue;
+			if (pgp2->priority > pgp1->priority ||
+			    (pgp2->priority == pgp1->priority &&
+			     pgp2->enabled_paths >= pgp1->enabled_paths)) {
+				vector_move_up(mp->pg, i, j + 1);
+				break;
+			}
+		}
+		if (j < 0 && i != 0)
+		vector_move_up(mp->pg, i, 0);
+	}
+}
+
+
 /*
  * One path group per unique tgt_node_name present in the path vector
  */
@@ -119,6 +148,7 @@ group_by_node_name (struct multipath * mp) {
 		}
 	}
 	FREE(bitmap);
+	sort_pathgroups(mp);
 	free_pathvec(mp->paths, KEEP_PATHS);
 	mp->paths = NULL;
 	return 0;
@@ -191,6 +221,7 @@ group_by_serial (struct multipath * mp) {
 		}
 	}
 	FREE(bitmap);
+	sort_pathgroups(mp);
 	free_pathvec(mp->paths, KEEP_PATHS);
 	mp->paths = NULL;
 	return 0;
@@ -228,6 +259,7 @@ one_path_per_group (struct multipath * mp)
 		if (store_path(pgp->paths, pp))
 			goto out;
 	}
+	sort_pathgroups(mp);
 	free_pathvec(mp->paths, KEEP_PATHS);
 	mp->paths = NULL;
 	return 0;
diff --git a/libmultipath/print.c b/libmultipath/print.c
index 4279fe9..ba4210e 100644
--- a/libmultipath/print.c
+++ b/libmultipath/print.c
@@ -1352,11 +1352,11 @@ print_pathgroup (struct pathgroup * pgp, char * style)
 }
 
 extern void
-print_map (struct multipath * mpp)
+print_map (struct multipath * mpp, char * params)
 {
-	if (mpp->size && mpp->params)
+	if (mpp->size && params)
 		printf("0 %llu %s %s\n",
-			 mpp->size, TGT_MPATH, mpp->params);
+			 mpp->size, TGT_MPATH, params);
 	return;
 }
 
diff --git a/libmultipath/print.h b/libmultipath/print.h
index 47f4257..aef182b 100644
--- a/libmultipath/print.h
+++ b/libmultipath/print.h
@@ -55,7 +55,7 @@ void print_multipath_topology (struct multipath * mpp, int verbosity);
 void print_path (struct path * pp, char * style);
 void print_multipath (struct multipath * mpp, char * style);
 void print_pathgroup (struct pathgroup * pgp, char * style);
-void print_map (struct multipath * mpp);
+void print_map (struct multipath * mpp, char * params);
 void print_all_paths (vector pathvec, int banner);
 void print_all_paths_custo (vector pathvec, int banner, char *fmt);
 void print_hwtable (vector hwtable);
diff --git a/libmultipath/prio.c b/libmultipath/prio.c
index 7491682..61c19b7 100644
--- a/libmultipath/prio.c
+++ b/libmultipath/prio.c
@@ -2,6 +2,7 @@
 #include <string.h>
 #include <stddef.h>
 #include <dlfcn.h>
+#include <sys/stat.h>
 
 #include "debug.h"
 #include "prio.h"
@@ -18,11 +19,24 @@ int init_prio (void)
 
 static struct prio * alloc_prio (void)
 {
-	return MALLOC(sizeof(struct prio));
+	struct prio *p;
+
+	p = MALLOC(sizeof(struct prio));
+	if (p)
+		INIT_LIST_HEAD(&p->node);
+	return p;
 }
 
 void free_prio (struct prio * p)
 {
+	condlog(3, "unloading %s prioritizer", p->name);
+	list_del(&p->node);
+	if (p->handle) {
+		if (dlclose(p->handle) != 0) {
+			condlog(0, "Cannot unload prioritizer %s: %s",
+				p->name, dlerror());
+		}
+	}
 	FREE(p);
 }
 
@@ -32,7 +46,6 @@ void cleanup_prio(void)
 	struct prio * prio_temp;
 
 	list_for_each_entry_safe(prio_loop, prio_temp, &prioritizers, node) {
-		list_del(&prio_loop->node);
 		free_prio(prio_loop);
 	}
 }
@@ -56,7 +69,7 @@ int prio_set_args (struct prio * p, char * args)
 struct prio * add_prio (char * name)
 {
 	char libname[LIB_PRIO_NAMELEN];
-	void * handle;
+	struct stat stbuf;
 	struct prio * p;
 	char *errstr;
 
@@ -65,17 +78,23 @@ struct prio * add_prio (char * name)
 		return NULL;
 	snprintf(libname, LIB_PRIO_NAMELEN, "%s/libprio%s.so",
 		 conf->multipath_dir, name);
+	if (stat(libname,&stbuf) < 0) {
+		condlog(0,"Prioritizer '%s' not found in %s",
+			name, conf->multipath_dir);
+		goto out;
+	}
 	condlog(3, "loading %s prioritizer", libname);
-	handle = dlopen(libname, RTLD_NOW);
-	errstr = dlerror();
-	if (errstr != NULL)
-	condlog(0, "A dynamic linking error occurred: (%s)", errstr);
-	if (!handle)
+	p->handle = dlopen(libname, RTLD_NOW);
+	if (!p->handle) {
+		if ((errstr = dlerror()) != NULL)
+			condlog(0, "A dynamic linking error occurred: (%s)",
+				errstr);
 		goto out;
-	p->getprio = (int (*)(struct path *, char *)) dlsym(handle, "getprio");
+	}
+	p->getprio = (int (*)(struct path *, char *)) dlsym(p->handle, "getprio");
 	errstr = dlerror();
 	if (errstr != NULL)
-	condlog(0, "A dynamic linking error occurred: (%s)", errstr);
+		condlog(0, "A dynamic linking error occurred: (%s)", errstr);
 	if (!p->getprio)
 		goto out;
 	snprintf(p->name, PRIO_NAME_LEN, "%s", name);
diff --git a/libmultipath/prio.h b/libmultipath/prio.h
index fd4a326..36929fb 100644
--- a/libmultipath/prio.h
+++ b/libmultipath/prio.h
@@ -21,10 +21,11 @@
 #define PRIO_EMC "emc"
 #define PRIO_HDS "hds"
 #define PRIO_HP_SW "hp_sw"
-#define PRIO_NETAPP "netapp"
+#define PRIO_ONTAP "ontap"
 #define PRIO_RANDOM "random"
 #define PRIO_RDAC "rdac"
 #define PRIO_DATACORE "datacore"
+#define PRIO_WEIGHTED_PATH "weightedpath"
 
 /*
  * Value used to mark the fact prio was not defined
@@ -39,6 +40,7 @@
 #define PRIO_ARGS_LEN 255
 
 struct prio {
+	void *handle;
 	struct list_head node;
 	char name[PRIO_NAME_LEN];
 	char args[PRIO_ARGS_LEN];
diff --git a/libmultipath/prioritizers/Makefile b/libmultipath/prioritizers/Makefile
index 132b39e..6cfac88 100644
--- a/libmultipath/prioritizers/Makefile
+++ b/libmultipath/prioritizers/Makefile
@@ -11,19 +11,21 @@ LIBS = \
 	libprioemc.so \
 	libpriordac.so \
 	libprioalua.so \
-	libprionetapp.so \
+	libprioontap.so \
 	libpriodatacore.so \
-	libpriohds.so
+	libpriohds.so \
+	libprioweightedpath.so \
+	libprioiet.so
 
 CFLAGS += -I..
 
 all: $(LIBS)
 
 libprioalua.so: alua.o alua_rtpg.o
-	$(CC) $(SHARED_FLAGS) -o $@ $^
+	$(CC) $(LDFLAGS) $(SHARED_FLAGS) -o $@ $^
 
 libprio%.so: %.o
-	$(CC) $(SHARED_FLAGS) -o $@ $^
+	$(CC) $(LDFLAGS) $(SHARED_FLAGS) -o $@ $^
 
 install: $(LIBS)
 	$(INSTALL_PROGRAM) -m 755 libprio*.so $(DESTDIR)$(libdir)
diff --git a/libmultipath/prioritizers/alua.c b/libmultipath/prioritizers/alua.c
index e33e17c..4da3ee7 100644
--- a/libmultipath/prioritizers/alua.c
+++ b/libmultipath/prioritizers/alua.c
@@ -25,16 +25,33 @@
 #define ALUA_PRIO_TPGS_FAILED			4
 #define ALUA_PRIO_NO_INFORMATION		5
 
+static const char * aas_string[] = {
+	[AAS_OPTIMIZED]		= "active/optimized",
+	[AAS_NON_OPTIMIZED]	= "active/non-optimized",
+	[AAS_STANDBY]		= "standby",
+	[AAS_UNAVAILABLE]	= "unavailable",
+	[AAS_LBA_DEPENDENT]	= "lba dependent",
+	[AAS_RESERVED]		= "invalid/reserved",
+	[AAS_OFFLINE]		= "offline",
+	[AAS_TRANSITIONING]	= "transitioning between states",
+};
+
+static const char *aas_print_string(int rc)
+{
+	rc &= 0x7f;
+
+	if (rc & 0x70)
+		return aas_string[AAS_RESERVED];
+	rc &= 0x0f;
+	if (rc > AAS_RESERVED && rc < AAS_OFFLINE)
+		return aas_string[AAS_RESERVED];
+	else
+		return aas_string[rc];
+}
+
 int
 get_alua_info(int fd)
 {
-	char *	aas_string[] = {
-		[AAS_OPTIMIZED]		= "active/optimized",
-		[AAS_NON_OPTIMIZED]	= "active/non-optimized",
-		[AAS_STANDBY]		= "standby",
-		[AAS_UNAVAILABLE]	= "unavailable",
-		[AAS_TRANSITIONING]	= "transitioning between states",
-	};
 	int	rc;
 	int	tpg;
 	int	aas;
@@ -56,8 +73,8 @@ get_alua_info(int fd)
 		return -ALUA_PRIO_GETAAS_FAILED;
 	aas = (rc & 0x0f);
 
-	condlog(3, "aas = [%s]",
-		(aas < 4) ? aas_string[aas] : "invalid/reserved");
+	condlog(3, "aas = %02x [%s]%s", rc, aas_print_string(rc),
+		(rc & 0x80) ? " [preferred]" : "");
 	return rc;
 }
 
@@ -81,6 +98,9 @@ int getprio (struct path * pp, char * args)
 			case AAS_NON_OPTIMIZED:
 				rc = 10;
 				break;
+			case AAS_LBA_DEPENDENT:
+				rc = 5;
+				break;
 			case AAS_STANDBY:
 				rc = 1;
 				break;
diff --git a/libmultipath/prioritizers/alua_rtpg.c b/libmultipath/prioritizers/alua_rtpg.c
index 0531052..981ba06 100644
--- a/libmultipath/prioritizers/alua_rtpg.c
+++ b/libmultipath/prioritizers/alua_rtpg.c
@@ -24,7 +24,7 @@
 #include "alua_rtpg.h"
 
 #define SENSE_BUFF_LEN  32
-#define DEF_TIMEOUT     300000
+#define DEF_TIMEOUT     60000
 
 /*
  * Macro used to print debug messaged.
@@ -172,41 +172,62 @@ get_target_port_group_support(int fd)
 int
 get_target_port_group(int fd)
 {
-	unsigned char		buf[128];
+	unsigned char		*buf;
 	struct vpd83_data *	vpd83;
 	struct vpd83_dscr *	dscr;
 	int			rc;
+	int			buflen, scsi_buflen;
 
-	memset(buf, 0, sizeof(buf));
-	rc = do_inquiry(fd, 1, 0x83, buf, sizeof(buf));
-	if (!rc) {
-		vpd83 = (struct vpd83_data *) buf;
-
-		rc = -RTPG_NO_TPG_IDENTIFIER;
-		FOR_EACH_VPD83_DSCR(vpd83, dscr) {
-			if ((((char *) dscr) - ((char *) vpd83)) > sizeof(buf))
-				break;
+	buflen = 128; /* Lets start from 128 */
+	buf = (unsigned char *)malloc(buflen);
+	if (!buf) {
+		PRINT_DEBUG("malloc failed: could not allocate"
+			     "%u bytes\n", buflen);
+		return -RTPG_RTPG_FAILED;
+	}
 
-			if (vpd83_dscr_istype(dscr, IDTYPE_TARGET_PORT_GROUP)) {
-				struct vpd83_tpg_dscr *	p;
+	memset(buf, 0, buflen);
+	rc = do_inquiry(fd, 1, 0x83, buf, buflen);
+	if (rc < 0)
+		goto out;
 
-				if (rc != -RTPG_NO_TPG_IDENTIFIER) {
-					PRINT_DEBUG("get_target_port_group: "
-						"more than one TPG identifier "
-						"found!\n");
-					continue;
-				}
+	scsi_buflen = (buf[2] << 8 | buf[3]) + 4;
+	if (buflen < scsi_buflen) {
+		free(buf);
+		buf = (unsigned char *)malloc(scsi_buflen);
+		if (!buf) {
+			PRINT_DEBUG("malloc failed: could not allocate"
+				     "%u bytes\n", scsi_buflen);
+			return -RTPG_RTPG_FAILED;
+		}
+		buflen = scsi_buflen;
+		memset(buf, 0, buflen);
+		rc = do_inquiry(fd, 1, 0x83, buf, buflen);
+		if (rc < 0)
+			goto out;
+	}
 
-				p  = (struct vpd83_tpg_dscr *) dscr->data;
-				rc = get_uint16(p->tpg);
+	vpd83 = (struct vpd83_data *) buf;
+	rc = -RTPG_NO_TPG_IDENTIFIER;
+	FOR_EACH_VPD83_DSCR(vpd83, dscr) {
+		if (vpd83_dscr_istype(dscr, IDTYPE_TARGET_PORT_GROUP)) {
+			struct vpd83_tpg_dscr *p;
+			if (rc != -RTPG_NO_TPG_IDENTIFIER) {
+				PRINT_DEBUG("get_target_port_group: more "
+					    "than one TPG identifier found!\n");
+				continue;
 			}
-		}
-		if (rc == -RTPG_NO_TPG_IDENTIFIER) {
-			PRINT_DEBUG("get_target_port_group: "
-				"no TPG identifier found!\n");
+			p  = (struct vpd83_tpg_dscr *)dscr->data;
+			rc = get_uint16(p->tpg);
 		}
 	}
 
+	if (rc == -RTPG_NO_TPG_IDENTIFIER) {
+		PRINT_DEBUG("get_target_port_group: "
+			    "no TPG identifier found!\n");
+	}
+out:
+	free(buf);
 	return rc;
 }
 
@@ -266,7 +287,7 @@ get_asymmetric_access_state(int fd, unsigned int tpg)
 	memset(buf, 0, buflen);
 	rc = do_rtpg(fd, buf, buflen);
 	if (rc < 0)
-		return rc;
+		goto out;
 	scsi_buflen = (buf[0] << 24 | buf[1] << 16 | buf[2] << 8 | buf[3]) + 4;
 	if (buflen < scsi_buflen) {
 		free(buf);
diff --git a/libmultipath/prioritizers/alua_spc3.h b/libmultipath/prioritizers/alua_spc3.h
index 4bbdded..e78b6c3 100644
--- a/libmultipath/prioritizers/alua_spc3.h
+++ b/libmultipath/prioritizers/alua_spc3.h
@@ -273,6 +273,9 @@ struct rtpg_tp_dscr {
 #define AAS_NON_OPTIMIZED		0x1
 #define AAS_STANDBY			0x2
 #define AAS_UNAVAILABLE			0x3
+#define AAS_LBA_DEPENDENT		0x4
+#define AAS_RESERVED			0x5
+#define AAS_OFFLINE			0xe
 #define AAS_TRANSITIONING		0xf
 
 #define TPG_STATUS_NONE			0x0
@@ -283,7 +286,8 @@ struct rtpg_tpg_dscr {
 	unsigned char	b0;		/* x....... = pref(ered) port        */
 					/* .xxx.... = reserved               */
 					/* ....xxxx = asymetric access state */
-	unsigned char	b1;		/* xxxx.... = reserved               */
+	unsigned char	b1;		/* xxx..... = reserved               */
+					/* ...x.... = LBA dependent support  */
 					/* ....x... = unavailable support    */
 					/* .....x.. = standby support        */
 					/* ......x. = non-optimized support  */
diff --git a/libmultipath/prioritizers/datacore.c b/libmultipath/prioritizers/datacore.c
index 6b7b202..2c16c6c 100644
--- a/libmultipath/prioritizers/datacore.c
+++ b/libmultipath/prioritizers/datacore.c
@@ -94,7 +94,7 @@ int datacore_prio (const char *dev, int sg_fd, char * args)
 	if ((io_hdr.info & SG_INFO_OK_MASK) != SG_INFO_OK)
 		return 0;
 
-	snprintf(vendor, 9, "%.8s\n", inqBuffp + 8);
+	snprintf(vendor, 8, "%.8s\n", inqBuffp + 8);
 	snprintf(product, 17, "%.16s", inqBuffp + 16);
 	snprintf(luname, 21, "%.19s", inqBuffp + 36);
 	snprintf(wwpn, 17, "%.16s", inqBuffp + 96);
diff --git a/libmultipath/prioritizers/emc.c b/libmultipath/prioritizers/emc.c
index bbf5750..20d727e 100644
--- a/libmultipath/prioritizers/emc.c
+++ b/libmultipath/prioritizers/emc.c
@@ -18,9 +18,10 @@ int emc_clariion_prio(const char *dev, int fd)
 	unsigned char inqCmdBlk[INQUIRY_CMDLEN] = {INQUIRY_CMD, 1, 0xC0, 0,
 						sizeof(sb), 0};
 	struct sg_io_hdr io_hdr;
-	int ret = 0;
+	int ret = PRIO_UNDEF;
 
 	memset(&io_hdr, 0, sizeof (struct sg_io_hdr));
+	memset(&sense_buffer, 0, 256);
 	io_hdr.interface_id = 'S';
 	io_hdr.cmd_len = sizeof (inqCmdBlk);
 	io_hdr.mx_sb_len = sizeof (sb);
@@ -45,9 +46,9 @@ int emc_clariion_prio(const char *dev, int fd)
 		pp_emc_log(0, "path unit report page in unknown format");
 		goto out;
 	}
-	
+
 	if ( /* Effective initiator type */
-	    	sense_buffer[27] != 0x03
+		sense_buffer[27] != 0x03
 		/*
 		 * Failover mode should be set to 1 (PNR failover mode)
 		 * or 4 (ALUA failover mode).
@@ -57,18 +58,24 @@ int emc_clariion_prio(const char *dev, int fd)
 		/* Arraycommpath should be set to 1 */
 		|| (sense_buffer[30] & 0x04) != 0x04) {
 		pp_emc_log(0, "path not correctly configured for failover");
+		goto out;
 	}
 
 	if ( /* LUN operations should indicate normal operations */
 		sense_buffer[48] != 0x00) {
 		pp_emc_log(0, "path not available for normal operations");
+		goto out;
 	}
 
+	/* LUN state: unbound, bound, or owned */
+	ret = sense_buffer[4];
+
 	/* Is the default owner equal to this path? */
 	/* Note this will switch to the default priority group, even if
 	 * it is not the currently active one. */
-	ret = (sense_buffer[5] == sense_buffer[8]) ? 1 : 0;
-	
+	if (sense_buffer[5] == sense_buffer[8])
+		ret+=2;
+
 out:
 	return(ret);
 }
diff --git a/libmultipath/prioritizers/hds.c b/libmultipath/prioritizers/hds.c
index 7b354b2..4789340 100644
--- a/libmultipath/prioritizers/hds.c
+++ b/libmultipath/prioritizers/hds.c
@@ -123,7 +123,7 @@ int hds_modular_prio (const char *dev, int fd)
 		return -1;
 	}
 
-	snprintf (vendor, 9, "%.8s", inqBuffp + 8);
+	snprintf (vendor, 8, "%.8s", inqBuffp + 8);
 	snprintf (product, 17, "%.16s", inqBuffp + 16);
 	snprintf (serial, 5, "%.4s", inqBuffp + 40);
 	snprintf (ldev, 5, "%.4s", inqBuffp + 44);
diff --git a/libmultipath/prioritizers/iet.c b/libmultipath/prioritizers/iet.c
new file mode 100644
index 0000000..59bdee4
--- /dev/null
+++ b/libmultipath/prioritizers/iet.c
@@ -0,0 +1,124 @@
+#include <dirent.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <stdio.h>
+#include <string.h>
+#include <regex.h>
+#include <prio.h>
+#include <debug.h>
+#include <unistd.h>
+
+#define dc_log(prio, msg) condlog(prio, "%s: iet prio: " msg, dev)
+//
+// name: find_regex
+// @param string: string you want to search into
+// @param regex: the pattern used
+// @return result: string finded in string with regex, "none" if none
+char *find_regex(char * string, char * regex)
+{
+	int err;
+	regex_t preg;
+	err = regcomp(&preg, regex, REG_EXTENDED);
+
+	if (err == 0) {
+		int match;
+		size_t nmatch = 0;
+		regmatch_t *pmatch = NULL;
+		nmatch = preg.re_nsub;
+		pmatch = malloc(sizeof(*pmatch) * nmatch);
+
+		if (pmatch) {
+			match = regexec(&preg, string, nmatch, pmatch, 0);
+			regfree(&preg);
+
+			if (match == 0) {
+				char *result = NULL;
+				int start = pmatch[0].rm_so;
+				int end = pmatch[0].rm_eo;
+				size_t size = end - start;
+				result = malloc (sizeof(*result) * (size + 1));
+
+				if (result) {
+					strncpy(result, &string[start], size);
+					result[size] = '\0';
+					return result;
+				}
+			}
+			else return NULL;
+		}
+	}
+	return NULL;
+}
+
+//
+// name: inet_prio
+// @param
+// @return prio
+int iet_prio(const char *dev, char * args)
+{
+	char preferredip_buff[255] = "";
+	char *preferredip = &preferredip_buff[0];
+	// Phase 1 : checks. If anyone fails, return prio 0.
+	// check if args exists
+	if (!args) {
+		dc_log(0, "need prio_args with preferredip set");
+		return 0;
+	}
+	// check if args format is OK
+	if (sscanf(args, "preferredip=%s", preferredip) ==1) {}
+	else {
+		dc_log(0, "unexpected prio_args format");
+		return 0;
+	}
+	// check if ip is not too short
+	if (strlen(preferredip) <= 7) {
+		dc_log(0, "prio args: preferredip too short");
+		return 0;
+	}
+	// Phase 2 : find device in /dev/disk/by-path to match device/ip
+	DIR           *dir_p;
+	struct dirent *dir_entry_p;
+	enum { BUFFERSIZE = 1024 };
+	char buffer[BUFFERSIZE];
+	char fullpath[BUFFERSIZE] = "/dev/disk/by-path/";
+	dir_p = opendir(fullpath);
+
+	// loop to find device in /dev/disk/by-path
+	while( NULL != (dir_entry_p = readdir(dir_p))) {
+		if (dir_entry_p->d_name[0] != '.') {
+			char path[BUFFERSIZE] = "/dev/disk/by-path/";
+			strcat(path,dir_entry_p->d_name);
+			ssize_t nchars = readlink(path, buffer, sizeof(buffer)-1);
+			if (nchars != -1) {
+				char *device;
+				device = find_regex(buffer,"(sd[a-z]+)");
+				// if device parsed is the right one
+				if (device!=NULL && strncmp(device, dev, strlen(device)) == 0) {
+					char *ip;
+					ip = find_regex(dir_entry_p->d_name,"([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3})");
+					// if prefferedip and ip fetched matches
+					if (ip!=NULL && strncmp(ip, preferredip, strlen(ip)) == 0) {
+						// high prio
+						free(ip);
+						closedir(dir_p);
+						return 10;
+					}
+					free(ip);
+				}
+				free(device);
+			}
+			else {
+				printf("error\n");
+			}
+		}
+	}
+	// nothing found, low prio
+	closedir(dir_p);
+	return 20;
+}
+
+int getprio(struct path * pp, char * args)
+{
+	return iet_prio(pp->dev, args);
+}
diff --git a/libmultipath/prioritizers/netapp.c b/libmultipath/prioritizers/netapp.c
deleted file mode 100644
index c695cd3..0000000
--- a/libmultipath/prioritizers/netapp.c
+++ /dev/null
@@ -1,243 +0,0 @@
-/* 
- * Copyright 2005 Network Appliance, Inc., All Rights Reserved
- * Author:  David Wysochanski available at davidw@netapp.com
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of 
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- * General Public License v2 for more details.
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <sys/ioctl.h>
-#include <errno.h>
-#include <assert.h>
-
-#include <sg_include.h>
-#include <debug.h>
-#include <prio.h>
-
-#define INQUIRY_CMD	0x12
-#define INQUIRY_CMDLEN	6
-#define DEFAULT_PRIOVAL	10
-#define RESULTS_MAX	256
-#define SG_TIMEOUT	30000
-
-#define pp_netapp_log(prio, fmt, args...) \
-        condlog(prio, "%s: netapp prio: " fmt, dev, ##args)
-
-static void dump_cdb(unsigned char *cdb, int size)
-{
-	int i;
-	char buf[10*5+1];
-	char * p = &buf[0];
-	
-	condlog(0, "- SCSI CDB: ");
-	for (i=0; i<size; i++) {
-		p += snprintf(p, 10*(size-i), "0x%02x ", cdb[i]);
-	}
-	condlog(0, "%s", buf);
-}
-
-static void process_sg_error(struct sg_io_hdr *io_hdr)
-{
-	int i;
-	char buf[128*5+1];
-	char * p = &buf[0];
-	
-	condlog(0, "- masked_status=0x%02x, host_status=0x%02x, "
-		"driver_status=0x%02x", io_hdr->masked_status,
-		io_hdr->host_status, io_hdr->driver_status);
-	if (io_hdr->sb_len_wr > 0) {
-		condlog(0, "- SCSI sense data: ");
-		for (i=0; i<io_hdr->sb_len_wr; i++) {
-			p += snprintf(p, 128*(io_hdr->sb_len_wr-i), "0x%02x ",
-				      io_hdr->sbp[i]);
-		}
-		condlog(0, "%s", buf);
-	}
-}
-
-/*
- * Returns:
- * -1: error, errno set
- *  0: success
- */
-static int send_gva(const char *dev, int fd, unsigned char pg,
-		    unsigned char *results, int *results_size)
-{
-	unsigned char sb[128];
-	unsigned char cdb[10] = {0xc0, 0, 0x1, 0xa, 0x98, 0xa,
-				 pg, sizeof(sb), 0, 0};
-	struct sg_io_hdr io_hdr;
-	int ret = -1;
-
-	memset(&io_hdr, 0, sizeof (struct sg_io_hdr));
-	io_hdr.interface_id = 'S';
-	io_hdr.cmd_len = sizeof (cdb);
-	io_hdr.mx_sb_len = sizeof (sb);
-	io_hdr.dxfer_direction = SG_DXFER_FROM_DEV;
-	io_hdr.dxfer_len = *results_size;
-	io_hdr.dxferp = results;
-	io_hdr.cmdp = cdb;
-	io_hdr.sbp = sb;
-	io_hdr.timeout = SG_TIMEOUT;
-	io_hdr.pack_id = 0;
-	if (ioctl(fd, SG_IO, &io_hdr) < 0) {
-		pp_netapp_log(0, "SG_IO ioctl failed, errno=%d", errno);
-		dump_cdb(cdb, sizeof(cdb));
-		goto out;
-	}
-	if (io_hdr.info & SG_INFO_OK_MASK) {
-		pp_netapp_log(0, "SCSI error");
-		dump_cdb(cdb, sizeof(cdb));
-		process_sg_error(&io_hdr);
-		goto out;
-	}
-
-	if (results[4] != 0x0a || results[5] != 0x98 ||
-	    results[6] != 0x0a ||results[7] != 0x01) {
-		dump_cdb(cdb, sizeof(cdb));
-		pp_netapp_log(0, "GVA return wrong format ");
-		pp_netapp_log(0, "results[4-7] = 0x%02x 0x%02x 0x%02x 0x%02x",
-			results[4], results[5], results[6], results[7]);
-		goto out;
-	}
-	ret = 0;
- out:
-	return(ret);
-}
-
-/*
- * Retuns:
- * -1: Unable to obtain proxy info
- *  0: Device _not_ proxy path
- *  1: Device _is_ proxy path
- */
-static int get_proxy(const char *dev, int fd)
-{
-	unsigned char results[256];
-	unsigned char sb[128];
-	unsigned char cdb[INQUIRY_CMDLEN] = {INQUIRY_CMD, 1, 0xc1, 0,
-						   sizeof(sb), 0};
-	struct sg_io_hdr io_hdr;
-	int ret = -1;
-
-	memset(&results, 0, sizeof (results));
-	memset(&io_hdr, 0, sizeof (struct sg_io_hdr));
-	io_hdr.interface_id = 'S';
-	io_hdr.cmd_len = sizeof (cdb);
-	io_hdr.mx_sb_len = sizeof (sb);
-	io_hdr.dxfer_direction = SG_DXFER_FROM_DEV;
-	io_hdr.dxfer_len = sizeof (results);
-	io_hdr.dxferp = results;
-	io_hdr.cmdp = cdb;
-	io_hdr.sbp = sb;
-	io_hdr.timeout = SG_TIMEOUT;
-	io_hdr.pack_id = 0;
-	if (ioctl(fd, SG_IO, &io_hdr) < 0) {
-		pp_netapp_log(0, "ioctl sending inquiry command failed, "
-			"errno=%d", errno);
-		dump_cdb(cdb, sizeof(cdb));
-		goto out;
-	}
-	if (io_hdr.info & SG_INFO_OK_MASK) {
-		pp_netapp_log(0, "SCSI error");
-		dump_cdb(cdb, sizeof(cdb));
-		process_sg_error(&io_hdr);
-		goto out;
-	}
-
-	if (results[1] != 0xc1 || results[8] != 0x0a ||
-	    results[9] != 0x98 || results[10] != 0x0a ||
-	    results[11] != 0x0 || results[12] != 0xc1 ||
-	    results[13] != 0x0) {
-		pp_netapp_log(0,"proxy info page in unknown format - ");
-		pp_netapp_log(0,"results[8-13]=0x%02x 0x%02x 0x%02x 0x%02x "
-			"0x%02x 0x%02x",
-			results[8], results[9], results[10],
-			results[11], results[12], results[13]);
-		dump_cdb(cdb, sizeof(cdb));
-		goto out;
-	}
-	ret = (results[19] & 0x02) >> 1;
-
- out:
-	return(ret);
-}
-
-/*
- * Returns priority of device based on device info.
- *
- * 4: FCP non-proxy, FCP proxy unknown, or unable to determine protocol
- * 3: iSCSI HBA
- * 2: iSCSI software
- * 1: FCP proxy
- */
-static int netapp_prio(const char *dev, int fd)
-{
-	unsigned char results[RESULTS_MAX];
-	int results_size=RESULTS_MAX;
-	int rc;
-	int is_proxy;
-	int is_iscsi_software;
-	int is_iscsi_hardware;
-	int tot_len;
-
-	is_iscsi_software = is_iscsi_hardware = is_proxy = 0;
-
-	memset(&results, 0, sizeof (results));
-	rc = send_gva(dev, fd, 0x41, results, &results_size);
-	if (rc == 0) {
-		tot_len = results[0] << 24 | results[1] << 16 |
-			  results[2] << 8 | results[3];
-		if (tot_len <= 8) {
-			goto try_fcp_proxy;
-		}
-		if (results[8] != 0x41) {
-			pp_netapp_log(0, "GVA page 0x41 error - "
-				"results[8] = 0x%x", results[8]);
-			goto try_fcp_proxy;
-		}
-		if ((strncmp((char *)&results[12], "ism_sw", 6) == 0) ||
-		    (strncmp((char *)&results[12], "iswt", 4) == 0)) {
-			is_iscsi_software = 1;
-			goto prio_select;
-		}
-		else if (strncmp((char *)&results[12], "ism_sn", 6) == 0) {
-			is_iscsi_hardware = 1;
-			goto prio_select;
-		}
-	}
-	
- try_fcp_proxy:	
-	rc = get_proxy(dev, fd);
-	if (rc >= 0) {
-		is_proxy = rc;
-	}
-
- prio_select:
-	if (is_iscsi_hardware) {
-		return 3;
-	} else if (is_iscsi_software) {
-		return 2;
-	} else {
-		if (is_proxy) {
-			return 1;
-		} else {
-			/* Either non-proxy, or couldn't get proxy info */
-			return 4;
-		}
-	}
-}
-
-int getprio (struct path * pp, char * args)
-{
-	return netapp_prio(pp->dev, pp->fd);
-}
diff --git a/libmultipath/prioritizers/ontap.c b/libmultipath/prioritizers/ontap.c
new file mode 100644
index 0000000..6e6e3d3
--- /dev/null
+++ b/libmultipath/prioritizers/ontap.c
@@ -0,0 +1,245 @@
+/*
+ * Copyright 2005 Network Appliance, Inc., All Rights Reserved
+ * Author:  David Wysochanski available at davidw@netapp.com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License v2 for more details.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <errno.h>
+#include <assert.h>
+
+#include <sg_include.h>
+#include <debug.h>
+#include <prio.h>
+
+#define INQUIRY_CMD	0x12
+#define INQUIRY_CMDLEN	6
+#define DEFAULT_PRIOVAL	10
+#define RESULTS_MAX	256
+#define SG_TIMEOUT	60000
+
+#define pp_ontap_log(prio, fmt, args...) \
+        condlog(prio, "%s: ontap prio: " fmt, dev, ##args)
+
+static void dump_cdb(unsigned char *cdb, int size)
+{
+	int i;
+	char buf[10*5+1];
+	char * p = &buf[0];
+
+	condlog(0, "- SCSI CDB: ");
+	for (i=0; i<size; i++) {
+		p += snprintf(p, 10*(size-i), "0x%02x ", cdb[i]);
+	}
+	condlog(0, "%s", buf);
+}
+
+static void process_sg_error(struct sg_io_hdr *io_hdr)
+{
+	int i;
+	char buf[128*5+1];
+	char * p = &buf[0];
+
+	condlog(0, "- masked_status=0x%02x, host_status=0x%02x, "
+		"driver_status=0x%02x", io_hdr->masked_status,
+		io_hdr->host_status, io_hdr->driver_status);
+	if (io_hdr->sb_len_wr > 0) {
+		condlog(0, "- SCSI sense data: ");
+		for (i=0; i<io_hdr->sb_len_wr; i++) {
+			p += snprintf(p, 128*(io_hdr->sb_len_wr-i), "0x%02x ",
+				      io_hdr->sbp[i]);
+		}
+		condlog(0, "%s", buf);
+	}
+}
+
+/*
+ * Returns:
+ * -1: error, errno set
+ *  0: success
+ */
+static int send_gva(const char *dev, int fd, unsigned char pg,
+		    unsigned char *results, int *results_size)
+{
+	unsigned char sb[128];
+	unsigned char cdb[10] = {0xc0, 0, 0x1, 0xa, 0x98, 0xa,
+				 pg, sizeof(sb), 0, 0};
+	struct sg_io_hdr io_hdr;
+	int ret = -1;
+
+	memset(&io_hdr, 0, sizeof (struct sg_io_hdr));
+	io_hdr.interface_id = 'S';
+	io_hdr.cmd_len = sizeof (cdb);
+	io_hdr.mx_sb_len = sizeof (sb);
+	io_hdr.dxfer_direction = SG_DXFER_FROM_DEV;
+	io_hdr.dxfer_len = *results_size;
+	io_hdr.dxferp = results;
+	io_hdr.cmdp = cdb;
+	io_hdr.sbp = sb;
+	io_hdr.timeout = SG_TIMEOUT;
+	io_hdr.pack_id = 0;
+	if (ioctl(fd, SG_IO, &io_hdr) < 0) {
+		pp_ontap_log(0, "SG_IO ioctl failed, errno=%d", errno);
+		dump_cdb(cdb, sizeof(cdb));
+		goto out;
+	}
+	if (io_hdr.info & SG_INFO_OK_MASK) {
+		pp_ontap_log(0, "SCSI error");
+		dump_cdb(cdb, sizeof(cdb));
+		process_sg_error(&io_hdr);
+		goto out;
+	}
+
+	if (results[4] != 0x0a || results[5] != 0x98 ||
+	    results[6] != 0x0a ||results[7] != 0x01) {
+		dump_cdb(cdb, sizeof(cdb));
+		pp_ontap_log(0, "GVA return wrong format ");
+		pp_ontap_log(0, "results[4-7] = 0x%02x 0x%02x 0x%02x 0x%02x",
+			results[4], results[5], results[6], results[7]);
+		goto out;
+	}
+	ret = 0;
+ out:
+	return(ret);
+}
+
+/*
+ * Retuns:
+ * -1: Unable to obtain proxy info
+ *  0: Device _not_ proxy path
+ *  1: Device _is_ proxy path
+ */
+static int get_proxy(const char *dev, int fd)
+{
+	unsigned char results[256];
+	unsigned char sb[128];
+	unsigned char cdb[INQUIRY_CMDLEN] = {INQUIRY_CMD, 1, 0xc1, 0,
+						   sizeof(sb), 0};
+	struct sg_io_hdr io_hdr;
+	int ret = -1;
+
+	memset(&results, 0, sizeof (results));
+	memset(&io_hdr, 0, sizeof (struct sg_io_hdr));
+	io_hdr.interface_id = 'S';
+	io_hdr.cmd_len = sizeof (cdb);
+	io_hdr.mx_sb_len = sizeof (sb);
+	io_hdr.dxfer_direction = SG_DXFER_FROM_DEV;
+	io_hdr.dxfer_len = sizeof (results);
+	io_hdr.dxferp = results;
+	io_hdr.cmdp = cdb;
+	io_hdr.sbp = sb;
+	io_hdr.timeout = SG_TIMEOUT;
+	io_hdr.pack_id = 0;
+	if (ioctl(fd, SG_IO, &io_hdr) < 0) {
+		pp_ontap_log(0, "ioctl sending inquiry command failed, "
+			"errno=%d", errno);
+		dump_cdb(cdb, sizeof(cdb));
+		goto out;
+	}
+	if (io_hdr.info & SG_INFO_OK_MASK) {
+		pp_ontap_log(0, "SCSI error");
+		dump_cdb(cdb, sizeof(cdb));
+		process_sg_error(&io_hdr);
+		goto out;
+	}
+
+	if (results[1] != 0xc1 || results[8] != 0x0a ||
+	    results[9] != 0x98 || results[10] != 0x0a ||
+	    results[11] != 0x0 || results[12] != 0xc1 ||
+	    results[13] != 0x0) {
+		pp_ontap_log(0,"proxy info page in unknown format - ");
+		pp_ontap_log(0,"results[8-13]=0x%02x 0x%02x 0x%02x 0x%02x "
+			"0x%02x 0x%02x",
+			results[8], results[9], results[10],
+			results[11], results[12], results[13]);
+		dump_cdb(cdb, sizeof(cdb));
+		goto out;
+	}
+	ret = (results[19] & 0x02) >> 1;
+
+ out:
+	return(ret);
+}
+
+/*
+ * Returns priority of device based on device info.
+ *
+ * 4: FCP non-proxy, FCP proxy unknown, or unable to determine protocol
+ * 3: iSCSI HBA
+ * 2: iSCSI software
+ * 1: FCP proxy
+ */
+static int ontap_prio(const char *dev, int fd)
+{
+	unsigned char results[RESULTS_MAX];
+	int results_size=RESULTS_MAX;
+	int rc;
+	int is_proxy;
+	int is_iscsi_software;
+	int is_iscsi_hardware;
+	int tot_len;
+
+	is_iscsi_software = is_iscsi_hardware = is_proxy = 0;
+
+	memset(&results, 0, sizeof (results));
+	rc = send_gva(dev, fd, 0x41, results, &results_size);
+	if (rc >= 0) {
+		tot_len = results[0] << 24 | results[1] << 16 |
+			  results[2] << 8 | results[3];
+		if (tot_len <= 8) {
+			goto try_fcp_proxy;
+		}
+		if (results[8] != 0x41) {
+			pp_ontap_log(0, "GVA page 0x41 error - "
+				"results[8] = 0x%x", results[8]);
+			goto try_fcp_proxy;
+		}
+		if ((strncmp((char *)&results[12], "ism_sw", 6) == 0) ||
+		    (strncmp((char *)&results[12], "iswt", 4) == 0)) {
+			is_iscsi_software = 1;
+			goto prio_select;
+		}
+		else if (strncmp((char *)&results[12], "ism_sn", 6) == 0) {
+			is_iscsi_hardware = 1;
+			goto prio_select;
+		}
+	} else {
+		return 0;
+	}
+
+ try_fcp_proxy:
+	rc = get_proxy(dev, fd);
+	if (rc >= 0) {
+		is_proxy = rc;
+	}
+
+ prio_select:
+	if (is_iscsi_hardware) {
+		return 3;
+	} else if (is_iscsi_software) {
+		return 2;
+	} else {
+		if (is_proxy) {
+			return 1;
+		} else {
+			/* Either non-proxy, or couldn't get proxy info */
+			return 4;
+		}
+	}
+}
+
+int getprio (struct path * pp, char * args)
+{
+	return ontap_prio(pp->dev, pp->fd);
+}
diff --git a/libmultipath/prioritizers/rdac.c b/libmultipath/prioritizers/rdac.c
index 27d51ab..41ea887 100644
--- a/libmultipath/prioritizers/rdac.c
+++ b/libmultipath/prioritizers/rdac.c
@@ -81,6 +81,10 @@ int rdac_prio(const char *dev, int fd)
 		break;
 	}
 
+	/* For ioship mode set the bit 3 (00001000) */
+	if ((sense_buffer[8] >> 5) & 0x01)
+		ret |= 0x08;
+
 out:
 	return(ret);
 }
diff --git a/libmultipath/prioritizers/weightedpath.c b/libmultipath/prioritizers/weightedpath.c
new file mode 100644
index 0000000..d6c81f0
--- /dev/null
+++ b/libmultipath/prioritizers/weightedpath.c
@@ -0,0 +1,99 @@
+/*
+ *
+ *  (C)  Copyright 2008 Hewlett-Packard Development Company, L.P
+ *
+ *  This file is released under the GPL
+ */
+
+/*
+ * Prioritizer for device mapper multipath, where specific paths and the
+ * corresponding priority values are provided as arguments.
+ *
+ * This prioritizer assigns the priority value provided in the configuration
+ * file based on the comparison made between the specified paths and the path
+ * instance for which this is called.
+ * Paths can be specified as a regular expression of devname of the path or
+ * as hbtl information of the path.
+ *
+ * Examples:
+ *	prio            "weightedpath hbtl 1:.:.:. 2 4:.:.:. 4"
+ *	prio            "weightedpath devname sda 10 sde 20"
+ *
+ * Returns zero as the default priority.
+ */
+
+#include <stdio.h>
+#include <string.h>
+
+#include <prio.h>
+#include "weightedpath.h"
+#include <config.h>
+#include <structs.h>
+#include <memory.h>
+#include <debug.h>
+#include <regex.h>
+
+char *get_next_string(char **temp, char *split_char)
+{
+	char *token = NULL;
+	token = strsep(temp, split_char);
+	while (token != NULL && !strcmp(token, ""))
+		token = strsep(temp, split_char);
+	return token;
+}
+
+/* main priority routine */
+int prio_path_weight(struct path *pp, char *prio_args)
+{
+	char path[FILE_NAME_SIZE];
+	char *arg;
+	char *temp, *regex, *prio;
+	char split_char[] = " \t";
+	int priority = DEFAULT_PRIORITY, path_found = 0;
+	regex_t pathe;
+
+	/* Return default priority if there is no argument */
+	if (!prio_args)
+		return priority;
+
+	arg = temp = STRDUP(prio_args);
+
+	regex = get_next_string(&temp, split_char);
+
+	if (!strcmp(regex, HBTL)) {
+		sprintf(path, "%d:%d:%d:%d", pp->sg_id.host_no,
+			pp->sg_id.channel, pp->sg_id.scsi_id, pp->sg_id.lun);
+	} else if (!strcmp(regex, DEV_NAME)) {
+		strcpy(path, pp->dev);
+	} else {
+		condlog(0, "%s: %s - Invalid arguments", pp->dev,
+			pp->prio->name);
+		return priority;
+	}
+
+	while (!path_found) {
+		if (!temp)
+			break;
+		if (!(regex = get_next_string(&temp, split_char)))
+			break;
+		if (!(prio = get_next_string(&temp, split_char)))
+			break;
+
+		if (!regcomp(&pathe, regex, REG_EXTENDED|REG_NOSUB)) {
+			if (!regexec(&pathe, path, 0, NULL, 0)) {
+				path_found = 1;
+				priority = atoi(prio);
+			}
+			regfree(&pathe);
+		}
+	}
+
+	FREE(arg);
+	return priority;
+}
+
+int getprio(struct path *pp, char *args)
+{
+	return prio_path_weight(pp, args);
+}
+
diff --git a/libmultipath/prioritizers/weightedpath.h b/libmultipath/prioritizers/weightedpath.h
new file mode 100644
index 0000000..509f215
--- /dev/null
+++ b/libmultipath/prioritizers/weightedpath.h
@@ -0,0 +1,11 @@
+#ifndef _WEIGHTED_PATH_H
+#define _WEIGHTED_PATH_H
+
+#define PRIO_WEIGHTED_PATH "weightedpath"
+#define HBTL "hbtl"
+#define DEV_NAME "devname"
+#define DEFAULT_PRIORITY 0
+
+int prio_path_weight(struct path *pp, char *prio_args);
+
+#endif
diff --git a/libmultipath/propsel.c b/libmultipath/propsel.c
index 2187558..10aec29 100644
--- a/libmultipath/propsel.c
+++ b/libmultipath/propsel.c
@@ -16,6 +16,8 @@
 #include "defaults.h"
 #include "devmapper.h"
 #include "prio.h"
+#include "discovery.h"
+#include <inttypes.h>
 
 pgpolicyfn *pgpolicies[] = {
 	NULL,
@@ -215,50 +217,74 @@ select_selector (struct multipath * mp)
 	return 0;
 }
 
+static void
+select_alias_prefix (struct multipath * mp)
+{
+	if (mp->hwe && mp->hwe->alias_prefix) {
+		mp->alias_prefix = mp->hwe->alias_prefix;
+		condlog(3, "%s: alias_prefix = %s (controller setting)",
+			mp->wwid, mp->alias_prefix);
+		return;
+	}
+	if (conf->alias_prefix) {
+		mp->alias_prefix = conf->alias_prefix;
+		condlog(3, "%s: alias_prefix = %s (config file default)",
+			mp->wwid, mp->alias_prefix);
+		return;
+	}
+	mp->alias_prefix = set_default(DEFAULT_ALIAS_PREFIX);
+	condlog(3, "%s: alias_prefix = %s (internal default)",
+		mp->wwid, mp->alias_prefix);
+}
+
 extern int
 select_alias (struct multipath * mp)
 {
 	if (mp->mpe && mp->mpe->alias)
-		mp->alias = mp->mpe->alias;
+		mp->alias = STRDUP(mp->mpe->alias);
 	else {
 		mp->alias = NULL;
-		if (conf->user_friendly_names)
+		if (conf->user_friendly_names) {
+			select_alias_prefix(mp);
 			mp->alias = get_user_friendly_alias(mp->wwid,
-					conf->bindings_file);
-		if (mp->alias == NULL){
-			char *alias;
-			if ((alias = MALLOC(WWID_SIZE)) != NULL){
-				if (dm_get_name(mp->wwid, alias) == 1)
-					mp->alias = alias;
-				else
-					FREE(alias);
-			}
+					conf->bindings_file, mp->alias_prefix, conf->bindings_read_only);
 		}
 		if (mp->alias == NULL)
-			mp->alias = mp->wwid;
+			mp->alias = dm_get_name(mp->wwid);
+		if (mp->alias == NULL)
+			mp->alias = STRDUP(mp->wwid);
 	}
 
-	return 0;
+	return mp->alias ? 0 : 1;
 }
 
 extern int
 select_features (struct multipath * mp)
 {
-	if (mp->hwe && mp->hwe->features) {
-		mp->features = mp->hwe->features;
-		condlog(3, "%s: features = %s (controller setting)",
-			mp->alias, mp->features);
-		return 0;
-	}
-	if (conf->features) {
-		mp->features = conf->features;
-		condlog(3, "%s: features = %s (config file default)",
-			mp->alias, mp->features);
-		return 0;
+	struct mpentry * mpe;
+	char *origin;
+
+	if ((mpe = find_mpe(mp->wwid)) && mpe->features) {
+		mp->features = STRDUP(mpe->features);
+		origin = "LUN setting";
+	} else if (mp->hwe && mp->hwe->features) {
+		mp->features = STRDUP(mp->hwe->features);
+		origin = "controller setting";
+	} else {
+		mp->features = STRDUP(conf->features);
+		origin = "internal default";
+	}
+	condlog(3, "%s: features = %s (%s)",
+		mp->alias, mp->features, origin);
+	if (strstr(mp->features, "queue_if_no_path")) {
+		if (mp->no_path_retry == NO_PATH_RETRY_UNDEF)
+			mp->no_path_retry = NO_PATH_RETRY_QUEUE;
+		else if (mp->no_path_retry == NO_PATH_RETRY_FAIL) {
+			condlog(1, "%s: config error, overriding 'no_path_retry' value",
+				mp->alias);
+			mp->no_path_retry = NO_PATH_RETRY_QUEUE;
+		}
 	}
-	mp->features = set_default(DEFAULT_FEATURES);
-	condlog(3, "%s: features = %s (internal default)",
-		mp->alias, mp->features);
 	return 0;
 }
 
@@ -292,17 +318,31 @@ select_checker(struct path *pp)
 		checker_get(c, pp->hwe->checker_name);
 		condlog(3, "%s: path checker = %s (controller setting)",
 			pp->dev, checker_name(c));
-		return 0;
+		goto out;
 	}
 	if (conf->checker_name) {
 		checker_get(c, conf->checker_name);
 		condlog(3, "%s: path checker = %s (config file default)",
 			pp->dev, checker_name(c));
-		return 0;
+		goto out;
 	}
 	checker_get(c, DEFAULT_CHECKER);
 	condlog(3, "%s: path checker = %s (internal default)",
 		pp->dev, checker_name(c));
+out:
+	if (conf->checker_timeout) {
+		c->timeout = conf->checker_timeout * 1000;
+		condlog(3, "%s: checker timeout = %u ms (config file default)",
+				pp->dev, c->timeout);
+	}
+	else if (sysfs_get_timeout(pp->sysdev, &c->timeout) == 0)
+		condlog(3, "%s: checker timeout = %u ms (sysfs setting)",
+				pp->dev, c->timeout);
+	else {
+		c->timeout = DEF_TIMEOUT;
+		condlog(3, "%s: checker timeout = %u ms (internal default)",
+				pp->dev, c->timeout);
+	}
 	return 0;
 }
 
@@ -330,6 +370,18 @@ select_getuid (struct path * pp)
 extern int
 select_prio (struct path * pp)
 {
+	struct mpentry * mpe;
+
+	if ((mpe = find_mpe(pp->wwid))) {
+		if (mpe->prio_name) {
+			pp->prio = prio_lookup(mpe->prio_name);
+			prio_set_args(pp->prio, mpe->prio_args);
+			condlog(3, "%s: prio = %s (LUN setting)",
+				pp->dev, pp->prio->name);
+			return 0;
+		}
+	}
+
 	if (pp->hwe && pp->hwe->prio_name) {
 		pp->prio = prio_lookup(pp->hwe->prio_name);
 		prio_set_args(pp->prio, pp->hwe->prio_args);
@@ -349,7 +401,7 @@ select_prio (struct path * pp)
 		return 0;
 	}
 	pp->prio = prio_lookup(DEFAULT_PRIO);
-        prio_set_args(pp->prio, DEFAULT_PRIO_ARGS);
+	prio_set_args(pp->prio, DEFAULT_PRIO_ARGS);
 	condlog(3, "%s: prio = %s (internal default)",
 		pp->dev, DEFAULT_PRIO);
 	condlog(3, "%s: prio = %s (internal default)",
@@ -382,14 +434,44 @@ select_no_path_retry(struct multipath *mp)
 			mp->alias, mp->no_path_retry);
 		return 0;
 	}
-	mp->no_path_retry = NO_PATH_RETRY_UNDEF;
-	condlog(3, "%s: no_path_retry = NONE (internal default)",
-		mp->alias);
+	if (mp->no_path_retry != NO_PATH_RETRY_UNDEF)
+		condlog(3, "%s: no_path_retry = %i (inherited setting)",
+			mp->alias, mp->no_path_retry);
+	else
+		condlog(3, "%s: no_path_retry = %i (internal default)",
+			mp->alias, mp->no_path_retry);
 	return 0;
 }
 
-extern int
-select_minio (struct multipath * mp)
+int
+select_minio_rq (struct multipath * mp)
+{
+	if (mp->mpe && mp->mpe->minio_rq) {
+		mp->minio = mp->mpe->minio_rq;
+		condlog(3, "%s: minio = %i rq (LUN setting)",
+			mp->alias, mp->minio);
+		return 0;
+	}
+	if (mp->hwe && mp->hwe->minio_rq) {
+		mp->minio = mp->hwe->minio_rq;
+		condlog(3, "%s: minio = %i rq (controller setting)",
+			mp->alias, mp->minio);
+		return 0;
+	}
+	if (conf->minio) {
+		mp->minio = conf->minio_rq;
+		condlog(3, "%s: minio = %i rq (config file default)",
+			mp->alias, mp->minio);
+		return 0;
+	}
+	mp->minio = DEFAULT_MINIO_RQ;
+	condlog(3, "%s: minio = %i rq (internal default)",
+		mp->alias, mp->minio);
+	return 0;
+}
+
+int
+select_minio_bio (struct multipath * mp)
 {
 	if (mp->mpe && mp->mpe->minio) {
 		mp->minio = mp->mpe->minio;
@@ -416,6 +498,15 @@ select_minio (struct multipath * mp)
 }
 
 extern int
+select_minio (struct multipath * mp)
+{
+	if (conf->dmrq)
+		return select_minio_rq(mp);
+	else
+		return select_minio_bio(mp);
+}
+
+extern int
 select_pg_timeout(struct multipath *mp)
 {
 	if (mp->mpe && mp->mpe->pg_timeout != PGTIMEOUT_UNDEF) {
@@ -450,7 +541,7 @@ select_pg_timeout(struct multipath *mp)
 		return 0;
 	}
 	mp->pg_timeout = PGTIMEOUT_UNDEF;
-	condlog(3, "pg_timeout = NONE (internal default)");
+	condlog(3, "%s: pg_timeout = NONE (internal default)", mp->alias);
 	return 0;
 }
 
@@ -459,18 +550,20 @@ select_fast_io_fail(struct multipath *mp)
 {
 	if (mp->hwe && mp->hwe->fast_io_fail) {
 		mp->fast_io_fail = mp->hwe->fast_io_fail;
-		if (mp->fast_io_fail == -1)
+		if (mp->fast_io_fail == MP_FAST_IO_FAIL_OFF)
 			condlog(3, "%s: fast_io_fail_tmo = off (controller default)", mp->alias);
 		else
-			condlog(3, "%s: fast_io_fail_tmo = %d (controller default)", mp->alias, mp->fast_io_fail);
+			condlog(3, "%s: fast_io_fail_tmo = %d (controller default)", mp->alias,
+				mp->fast_io_fail == MP_FAST_IO_FAIL_ZERO ? 0 : mp->fast_io_fail);
 		return 0;
 	}
 	if (conf->fast_io_fail) {
 		mp->fast_io_fail = conf->fast_io_fail;
-		if (mp->fast_io_fail == -1)
+		if (mp->fast_io_fail == MP_FAST_IO_FAIL_OFF)
 			condlog(3, "%s: fast_io_fail_tmo = off (config file default)", mp->alias);
 		else
-			condlog(3, "%s: fast_io_fail_tmo = %d (config file default)", mp->alias, mp->fast_io_fail);
+			condlog(3, "%s: fast_io_fail_tmo = %d (config file default)", mp->alias,
+				mp->fast_io_fail == MP_FAST_IO_FAIL_ZERO ? 0 : mp->fast_io_fail);
 		return 0;
 	}
 	mp->fast_io_fail = 0;
@@ -523,3 +616,48 @@ select_flush_on_last_del(struct multipath *mp)
 	condlog(3, "flush_on_last_del = DISABLED (internal default)");
 	return 0;
 }
+
+extern int
+select_reservation_key (struct multipath * mp)
+{
+	int j;
+	unsigned char *keyp;
+	uint64_t prkey = 0;
+
+	mp->reservation_key = NULL;
+
+	if (mp->mpe && mp->mpe->reservation_key) {
+		keyp =  mp->mpe->reservation_key;
+		for (j = 0; j < 8; ++j) {
+			if (j > 0)
+				prkey <<= 8;
+			prkey |= *keyp;
+			++keyp;
+		}
+
+		condlog(3, "%s: reservation_key = 0x%" PRIx64 " "
+				"(multipath setting)",  mp->alias, prkey);
+
+		mp->reservation_key = mp->mpe->reservation_key;
+		return 0;
+	}
+
+	if (conf->reservation_key) {
+		keyp = conf->reservation_key;
+		for (j = 0; j < 8; ++j) {
+			if (j > 0)
+				prkey <<= 8;
+			prkey |= *keyp;
+			++keyp;
+		}
+
+		condlog(3, "%s: reservation_key  = 0x%" PRIx64
+				" (config file default)", mp->alias, prkey);
+
+		mp->reservation_key = conf->reservation_key;
+		return 0;
+	}
+
+	return 0;
+}
+
diff --git a/libmultipath/propsel.h b/libmultipath/propsel.h
index 57bea5b..4e931d4 100644
--- a/libmultipath/propsel.h
+++ b/libmultipath/propsel.h
@@ -17,3 +17,4 @@ int select_uid(struct multipath *mp);
 int select_gid(struct multipath *mp);
 int select_fast_io_fail(struct multipath *mp);
 int select_dev_loss(struct multipath *mp);
+int select_reservation_key(struct multipath *mp);
diff --git a/libmultipath/structs.c b/libmultipath/structs.c
index a4b86d2..280d2eb 100644
--- a/libmultipath/structs.c
+++ b/libmultipath/structs.c
@@ -15,7 +15,6 @@
 #include "debug.h"
 #include "structs_vec.h"
 #include "blacklist.h"
-#include "waiter.h"
 #include "prio.h"
 
 struct path *
@@ -52,7 +51,7 @@ free_path (struct path * pp)
 }
 
 void
-free_pathvec (vector vec, int free_paths)
+free_pathvec (vector vec, enum free_path_mode free_paths)
 {
 	int i;
 	struct path * pp;
@@ -60,7 +59,7 @@ free_pathvec (vector vec, int free_paths)
 	if (!vec)
 		return;
 
-	if (free_paths)
+	if (free_paths == FREE_PATHS)
 		vector_foreach_slot(vec, pp, i)
 			free_path(pp);
 
@@ -88,7 +87,7 @@ alloc_pathgroup (void)
 }
 
 void
-free_pathgroup (struct pathgroup * pgp, int free_paths)
+free_pathgroup (struct pathgroup * pgp, enum free_path_mode free_paths)
 {
 	if (!pgp)
 		return;
@@ -98,7 +97,7 @@ free_pathgroup (struct pathgroup * pgp, int free_paths)
 }
 
 void
-free_pgvec (vector pgvec, int free_paths)
+free_pgvec (vector pgvec, enum free_path_mode free_paths)
 {
 	int i;
 	struct pathgroup * pgp;
@@ -122,6 +121,7 @@ alloc_multipath (void)
 	if (mpp) {
 		mpp->bestpg = 1;
 		mpp->mpcontext = NULL;
+		mpp->no_path_retry = NO_PATH_RETRY_UNDEF;
 	}
 	return mpp;
 }
@@ -140,9 +140,7 @@ free_multipath_attributes (struct multipath * mpp)
 		mpp->selector = NULL;
 	}
 
-	if (mpp->features &&
-	    mpp->features != conf->features &&
-	    (!mpp->hwe || (mpp->hwe && mpp->features != mpp->hwe->features))) {
+	if (mpp->features) {
 		FREE(mpp->features);
 		mpp->features = NULL;
 	}
@@ -156,16 +154,14 @@ free_multipath_attributes (struct multipath * mpp)
 }
 
 void
-free_multipath (struct multipath * mpp, int free_paths)
+free_multipath (struct multipath * mpp, enum free_path_mode free_paths)
 {
 	if (!mpp)
 		return;
 
 	free_multipath_attributes(mpp);
 
-	if (mpp->alias &&
-	    (!mpp->mpe || (mpp->mpe && mpp->alias != mpp->mpe->alias)) &&
-	    (mpp->wwid && mpp->alias != mpp->wwid)) {
+	if (mpp->alias) {
 		FREE(mpp->alias);
 		mpp->alias = NULL;
 	}
@@ -175,12 +171,6 @@ free_multipath (struct multipath * mpp, int free_paths)
 		mpp->dmi = NULL;
 	}
 
-	/*
-	 * better own vecs->lock here
-	 */
-	if (mpp->waiter)
-		((struct event_thread *)mpp->waiter)->mpp = NULL;
-
 	free_pathvec(mpp->paths, free_paths);
 	free_pgvec(mpp->pg, free_paths);
 	FREE_PTR(mpp->mpcontext);
@@ -188,7 +178,7 @@ free_multipath (struct multipath * mpp, int free_paths)
 }
 
 void
-drop_multipath (vector mpvec, char * wwid, int free_paths)
+drop_multipath (vector mpvec, char * wwid, enum free_path_mode free_paths)
 {
 	int i;
 	struct multipath * mpp;
@@ -206,7 +196,7 @@ drop_multipath (vector mpvec, char * wwid, int free_paths)
 }
 
 void
-free_multipathvec (vector mpvec, int free_paths)
+free_multipathvec (vector mpvec, enum free_path_mode free_paths)
 {
 	int i;
 	struct multipath * mpp;
@@ -321,7 +311,7 @@ find_path_by_dev (vector pathvec, char * dev)
 		return NULL;
 
 	vector_foreach_slot (pathvec, pp, i)
-		if (!strcmp_chomp(pp->dev, dev))
+		if (!strcmp(pp->dev, dev))
 			return pp;
 
 	condlog(3, "%s: not found in pathvec", dev);
@@ -338,7 +328,7 @@ find_path_by_devt (vector pathvec, char * dev_t)
 		return NULL;
 
 	vector_foreach_slot (pathvec, pp, i)
-		if (!strcmp_chomp(pp->dev_t, dev_t))
+		if (!strcmp(pp->dev_t, dev_t))
 			return pp;
 
 	condlog(3, "%s: not found in pathvec", dev_t);
@@ -373,6 +363,26 @@ pathcount (struct multipath * mpp, int state)
 	return count;
 }
 
+extern int
+pathcmp (struct pathgroup *pgp, struct pathgroup *cpgp)
+{
+	int i, j;
+	struct path *pp, *cpp;
+	int pnum = 0, found = 0;
+
+	vector_foreach_slot(pgp->paths, pp, i) {
+		pnum++;
+		vector_foreach_slot(cpgp->paths, cpp, j) {
+			if ((long)pp == (long)cpp) {
+				found++;
+				break;
+			}
+		}
+	}
+
+	return pnum - found;
+}
+
 struct path *
 first_path (struct multipath * mpp)
 {
@@ -387,6 +397,187 @@ first_path (struct multipath * mpp)
 extern void
 setup_feature(struct multipath * mpp, char *feature)
 {
-	if (!strncmp(feature, "queue_if_no_path", 16))
-		mpp->no_path_retry = NO_PATH_RETRY_QUEUE;
+	if (!strncmp(feature, "queue_if_no_path", 16)) {
+		if (mpp->no_path_retry <= NO_PATH_RETRY_UNDEF)
+			mpp->no_path_retry = NO_PATH_RETRY_QUEUE;
+	}
 }
+
+extern int
+add_feature (char **f, char *n)
+{
+	int c = 0, d, l;
+	char *e, *p, *t;
+
+	if (!f)
+		return 1;
+
+	/* Nothing to do */
+	if (!n || *n == '0')
+		return 0;
+
+	/* Check if feature is already present */
+	if (strstr(*f, n))
+		return 0;
+
+	/* Get feature count */
+	c = strtoul(*f, &e, 10);
+	if (*f == e)
+		/* parse error */
+		return 1;
+
+	/* Check if we need to increase feature count space */
+	l = strlen(*f) + strlen(n) + 1;
+
+	/* Count new features */
+	if ((c % 10) == 9)
+		l++;
+	c++;
+	p = n;
+	while (*p != '\0') {
+		if (*p == ' ' && p[1] != '\0' && p[1] != ' ') {
+			if ((c % 10) == 9)
+				l++;
+			c++;
+		}
+		p++;
+	}
+
+	t = MALLOC(l + 1);
+	if (!t)
+		return 1;
+
+	memset(t, 0, l + 1);
+
+	/* Update feature count */
+	d = c;
+	l = 1;
+	while (d > 9) {
+		d /= 10;
+		l++;
+	}
+	p = t;
+	snprintf(p, l + 2, "%0d ", c);
+
+	/* Copy the feature string */
+	p = strchr(*f, ' ');
+	if (p) {
+		while (*p == ' ')
+			p++;
+		strcat(t, p);
+		strcat(t, " ");
+	} else {
+		p = t + strlen(t);
+	}
+	strcat(t, n);
+
+	FREE(*f);
+	*f = t;
+
+	return 0;
+}
+
+extern int
+remove_feature(char **f, char *o)
+{
+	int c = 0, d, l;
+	char *e, *p, *n;
+
+	if (!f || !*f)
+		return 1;
+
+	/* Nothing to do */
+	if (!o || *o == '\0')
+		return 0;
+
+	/* Check if not present */
+	if (!strstr(*f, o))
+		return 0;
+
+	/* Get feature count */
+	c = strtoul(*f, &e, 10);
+	if (*f == e)
+		/* parse error */
+		return 1;
+
+	/* Normalize features */
+	while (*o == ' ') {
+		o++;
+	}
+	/* Just spaces, return */
+	if (*o == '\0')
+		return 0;
+	e = o + strlen(o);
+	while (*e == ' ')
+		e--;
+	d = (int)(e - o);
+
+	/* Update feature count */
+	c--;
+	p = o;
+	while (p[0] != '\0') {
+		if (p[0] == ' ' && p[1] != ' ' && p[1] != '\0')
+			c--;
+		p++;
+	}
+
+	/* Quick exit if all features have been removed */
+	if (c == 0) {
+		n = MALLOC(2);
+		if (!n)
+			return 1;
+		strcpy(n, "0");
+		goto out;
+	}
+
+	/* Search feature to be removed */
+	e = strstr(*f, o);
+	if (!e)
+		/* Not found, return */
+		return 0;
+
+	/* Update feature count space */
+	l = strlen(*f) - d;
+	n =  MALLOC(l + 1);
+	if (!n)
+		return 1;
+
+	/* Copy the feature count */
+	sprintf(n, "%0d", c);
+	/*
+	 * Copy existing features up to the feature
+	 * about to be removed
+	 */
+	p = strchr(*f, ' ');
+	while (*p == ' ')
+		p++;
+	p--;
+	if (e != p) {
+		do {
+			e--;
+			d++;
+		} while (*e == ' ');
+		e++; d--;
+		strncat(n, p, (size_t)(e - p));
+		p += (size_t)(e - p);
+	}
+	/* Skip feature to be removed */
+	p += d;
+
+	/* Copy remaining features */
+	if (strlen(p)) {
+		while (*p == ' ')
+			p++;
+		if (strlen(p)) {
+			p--;
+			strcat(n, p);
+		}
+	}
+
+out:
+	FREE(*f);
+	*f = n;
+
+	return 0;
+}
+
diff --git a/libmultipath/structs.h b/libmultipath/structs.h
index c559838..010be5d 100644
--- a/libmultipath/structs.h
+++ b/libmultipath/structs.h
@@ -4,12 +4,12 @@
 #include <sys/types.h>
 
 #define WWID_SIZE		128
-#define SERIAL_SIZE		64
-#define NODE_NAME_SIZE		19
-#define PATH_STR_SIZE  		16
+#define SERIAL_SIZE		65
+#define NODE_NAME_SIZE		224
+#define PATH_STR_SIZE		16
 #define PARAMS_SIZE		1024
 #define FILE_NAME_SIZE		256
-#define CALLOUT_MAX_SIZE	128
+#define CALLOUT_MAX_SIZE	256
 #define BLK_DEV_SIZE		33
 #define PATH_SIZE		512
 #define NAME_SIZE		512
@@ -25,7 +25,7 @@
 #define NO_PATH_RETRY_QUEUE	-2
 
 
-enum free_path_switch {
+enum free_path_mode {
 	KEEP_PATHS,
 	FREE_PATHS
 };
@@ -87,6 +87,11 @@ enum flush_states {
 	FLUSH_IN_PROGRESS,
 };
 
+enum log_checker_err_states {
+	LOG_CHKR_ERR_ALWAYS,
+	LOG_CHKR_ERR_ONCE,
+};
+
 struct scsi_idlun {
 	int dev_id;
 	int host_unique_id;
@@ -113,18 +118,26 @@ struct scsi_dev {
 struct sysfs_device {
 	struct sysfs_device *parent;		/* parent device */
 	char devpath[PATH_SIZE];
-	char subsystem[NAME_SIZE];		/* $class, $bus, drivers, module */
 	char kernel[NAME_SIZE];			/* device instance name */
-	char kernel_number[NAME_SIZE];
-	char driver[NAME_SIZE];			/* device driver name */
 };
 
+# ifndef HDIO_GETGEO
+#  define HDIO_GETGEO	0x0301	/* get device geometry */
+
+struct hd_geometry {
+      unsigned char heads;
+      unsigned char sectors;
+      unsigned short cylinders;
+      unsigned long start;
+};
+#endif
 struct path {
 	char dev[FILE_NAME_SIZE];
 	char dev_t[BLK_DEV_SIZE];
 	struct sysfs_device *sysdev;
 	struct scsi_idlun scsi_id;
 	struct sg_id sg_id;
+	struct hd_geometry geom;
 	char wwid[WWID_SIZE];
 	char vendor_id[SCSI_VENDOR_SIZE];
 	char product_id[SCSI_PRODUCT_SIZE];
@@ -146,7 +159,7 @@ struct path {
 	struct checker checker;
 	struct multipath * mpp;
 	int fd;
-	
+
 	/* configlet pointers */
 	struct hwentry * hwe;
 };
@@ -180,12 +193,11 @@ struct multipath {
 	unsigned long long size;
 	vector paths;
 	vector pg;
-	char params[PARAMS_SIZE];
-	char status[PARAMS_SIZE];
 	struct dm_info * dmi;
 
 	/* configlet pointers */
 	char * alias;
+	char * alias_prefix;
 	char * selector;
 	char * features;
 	char * hwhandler;
@@ -193,7 +205,7 @@ struct multipath {
 	struct hwentry * hwe;
 
 	/* threads */
-	void * waiter;
+	pthread_t waiter;
 
 	/* stats */
 	unsigned int stat_switchgroup;
@@ -204,6 +216,10 @@ struct multipath {
 
 	/* checkers shared data */
 	void * mpcontext;
+	
+	/* persistent management data*/
+	unsigned char * reservation_key;
+	unsigned char prflag;
 };
 
 struct pathgroup {
@@ -219,13 +235,13 @@ struct path * alloc_path (void);
 struct pathgroup * alloc_pathgroup (void);
 struct multipath * alloc_multipath (void);
 void free_path (struct path *);
-void free_pathvec (vector vec, int free_paths);
-void free_pathgroup (struct pathgroup * pgp, int free_paths);
-void free_pgvec (vector pgvec, int free_paths);
-void free_multipath (struct multipath *, int free_paths);
+void free_pathvec (vector vec, enum free_path_mode free_paths);
+void free_pathgroup (struct pathgroup * pgp, enum free_path_mode free_paths);
+void free_pgvec (vector pgvec, enum free_path_mode free_paths);
+void free_multipath (struct multipath *, enum free_path_mode free_paths);
 void free_multipath_attributes (struct multipath *);
-void drop_multipath (vector mpvec, char * wwid, int free_paths);
-void free_multipathvec (vector mpvec, int free_paths);
+void drop_multipath (vector mpvec, char * wwid, enum free_path_mode free_paths);
+void free_multipathvec (vector mpvec, enum free_path_mode free_paths);
 
 int store_path (vector pathvec, struct path * pp);
 int store_pathgroup (vector pgvec, struct pathgroup * pgp);
@@ -241,7 +257,10 @@ struct path * first_path (struct multipath * mpp);
 
 int pathcountgr (struct pathgroup *, int);
 int pathcount (struct multipath *, int);
+int pathcmp (struct pathgroup *, struct pathgroup *);
 void setup_feature(struct multipath *, char *);
+int add_feature (char **, char *);
+int remove_feature (char **, char *);
 
 extern char sysfs_path[PATH_SIZE];
 
diff --git a/libmultipath/structs_vec.c b/libmultipath/structs_vec.c
index 699efa1..f4bae10 100644
--- a/libmultipath/structs_vec.c
+++ b/libmultipath/structs_vec.c
@@ -46,7 +46,7 @@ update_mpp_paths(struct multipath * mpp, vector pathvec)
 }
 
 extern int
-adopt_paths (vector pathvec, struct multipath * mpp)
+adopt_paths (vector pathvec, struct multipath * mpp, int get_info)
 {
 	int i;
 	struct path * pp;
@@ -69,7 +69,9 @@ adopt_paths (vector pathvec, struct multipath * mpp)
 			if (!find_path_by_dev(mpp->paths, pp->dev) &&
 			    store_path(mpp->paths, pp))
 					return 1;
-			pathinfo(pp, conf->hwtable, DI_PRIO | DI_CHECKER);
+			if (get_info)
+				pathinfo(pp, conf->hwtable,
+					 DI_PRIO | DI_CHECKER);
 		}
 	}
 	return 0;
@@ -240,13 +242,15 @@ extract_hwe_from_path(struct multipath * mpp)
 static int
 update_multipath_table (struct multipath *mpp, vector pathvec)
 {
+	char params[PARAMS_SIZE] = {0};
+
 	if (!mpp)
 		return 1;
 
-	if (dm_get_map(mpp->alias, &mpp->size, mpp->params))
+	if (dm_get_map(mpp->alias, &mpp->size, params))
 		return 1;
 
-	if (disassemble_map(pathvec, mpp->params, mpp))
+	if (disassemble_map(pathvec, params, mpp))
 		return 1;
 
 	return 0;
@@ -255,13 +259,15 @@ update_multipath_table (struct multipath *mpp, vector pathvec)
 static int
 update_multipath_status (struct multipath *mpp)
 {
+	char status[PARAMS_SIZE] = {0};
+
 	if (!mpp)
 		return 1;
 
-	if(dm_get_status(mpp->alias, mpp->status))
+	if(dm_get_status(mpp->alias, status))
 		return 1;
 
-	if (disassemble_status(mpp->status, mpp))
+	if (disassemble_status(status, mpp))
 		return 1;
 
 	return 0;
@@ -270,6 +276,9 @@ update_multipath_status (struct multipath *mpp)
 extern int
 update_multipath_strings (struct multipath *mpp, vector pathvec)
 {
+	if (!mpp)
+		return 1;
+
 	condlog(4, "%s: %s", mpp->alias, __FUNCTION__);
 
 	free_multipath_attributes(mpp);
@@ -315,9 +324,8 @@ set_no_path_retry(struct multipath *mpp)
 }
 
 extern int
-setup_multipath (struct vectors * vecs, struct multipath * mpp)
+__setup_multipath (struct vectors * vecs, struct multipath * mpp, int reset)
 {
-retry:
 	if (dm_get_info(mpp->alias, &mpp->dmi)) {
 		/* Error accessing table */
 		condlog(3, "%s: cannot access table", mpp->alias);
@@ -335,38 +343,23 @@ retry:
 	condlog(3, "%s: discover", mpp->alias);
 
 	if (update_multipath_strings(mpp, vecs->pathvec)) {
-		char new_alias[WWID_SIZE];
-
-		/*
-		 * detect an external rename of the multipath device
-		 */
-		if (dm_get_name(mpp->wwid, new_alias)) {
-			condlog(3, "%s multipath mapped device name has "
-				"changed from %s to %s", mpp->wwid,
-				mpp->alias, new_alias);
-			strcpy(mpp->alias, new_alias);
-
-			if (mpp->waiter)
-				strncpy(((struct event_thread *)mpp->waiter)->mapname,
-					new_alias, WWID_SIZE);
-			goto retry;
-		}
 		condlog(0, "%s: failed to setup multipath", mpp->alias);
 		goto out;
 	}
 
-	//adopt_paths(vecs->pathvec, mpp);
 	if (!mpp->hwe)
 		mpp->hwe = extract_hwe_from_path(mpp);
 	if (!mpp->hwe) {
 		condlog(3, "%s: no hardware entry found, using defaults",
 			mpp->alias);
 	}
-	select_rr_weight(mpp);
-	select_pgfailback(mpp);
-	set_no_path_retry(mpp);
-	select_pg_timeout(mpp);
-	select_flush_on_last_del(mpp);
+	if (reset) {
+		select_rr_weight(mpp);
+		select_pgfailback(mpp);
+		set_no_path_retry(mpp);
+		select_pg_timeout(mpp);
+		select_flush_on_last_del(mpp);
+	}
 
 	return 0;
 out:
@@ -375,22 +368,19 @@ out:
 }
 
 extern struct multipath *
-add_map_without_path (struct vectors * vecs,
-		      int minor, char * alias)
+add_map_without_path (struct vectors * vecs, char * alias)
 {
 	struct multipath * mpp = alloc_multipath();
 
-	if (!mpp)
+	if (!mpp || !alias)
 		return NULL;
 
-	mpp->alias = alias;
+	mpp->alias = STRDUP(alias);
 
-	if (setup_multipath(vecs, mpp)) {
-		mpp->alias = NULL;
+	if (setup_multipath(vecs, mpp))
 		return NULL; /* mpp freed in setup_multipath */
-	}
 
-	if (adopt_paths(vecs->pathvec, mpp))
+	if (adopt_paths(vecs->pathvec, mpp, 1))
 		goto out;
 
 	if (!vector_alloc_slot(vecs->mpvec))
@@ -420,10 +410,11 @@ add_map_with_path (struct vectors * vecs,
 	mpp->hwe = pp->hwe;
 
 	strcpy(mpp->wwid, pp->wwid);
-	select_alias(mpp);
+	if (select_alias(mpp))
+		goto out;
 	mpp->size = pp->size;
 
-	if (adopt_paths(vecs->pathvec, mpp))
+	if (adopt_paths(vecs->pathvec, mpp, 1))
 		goto out;
 
 	if (add_vec) {
@@ -456,8 +447,15 @@ verify_paths(struct multipath * mpp, struct vectors * vecs, vector rpvec)
 		 */
 		if (!pp->sysdev || sysfs_get_dev(pp->sysdev,
 						 pp->dev_t, BLK_DEV_SIZE)) {
-			condlog(0, "%s: failed to access path %s", mpp->alias,
-				pp->sysdev ? pp->sysdev->devpath : pp->dev_t);
+			if (pp->state != PATH_DOWN) {
+				condlog(1, "%s: removing valid path %s in state %d",
+					mpp->alias,
+					pp->sysdev?pp->sysdev->devpath:pp->dev_t, pp->state);
+			} else {
+				condlog(3, "%s: failed to access path %s",
+					mpp->alias,
+					pp->sysdev ? pp->sysdev->devpath : pp->dev_t);
+			}
 			count++;
 			vector_del_slot(mpp->paths, i);
 			i--;
@@ -478,7 +476,7 @@ verify_paths(struct multipath * mpp, struct vectors * vecs, vector rpvec)
 	return count;
 }
 
-int update_multipath (struct vectors *vecs, char *mapname)
+int update_multipath (struct vectors *vecs, char *mapname, int reset)
 {
 	struct multipath *mpp;
 	struct pathgroup  *pgp;
@@ -495,9 +493,10 @@ int update_multipath (struct vectors *vecs, char *mapname)
 	free_pgvec(mpp->pg, KEEP_PATHS);
 	mpp->pg = NULL;
 
-	if (setup_multipath(vecs, mpp))
+	if (__setup_multipath(vecs, mpp, reset))
 		return 1; /* mpp freed in setup_multipath */
 
+	adopt_paths(vecs->pathvec, mpp, 0);
 	/*
 	 * compare checkers states with DM states
 	 */
diff --git a/libmultipath/structs_vec.h b/libmultipath/structs_vec.h
index 78e468a..a907e85 100644
--- a/libmultipath/structs_vec.h
+++ b/libmultipath/structs_vec.h
@@ -15,13 +15,15 @@ struct vectors {
 
 void set_no_path_retry(struct multipath *mpp);
 
-int adopt_paths (vector pathvec, struct multipath * mpp);
+int adopt_paths (vector pathvec, struct multipath * mpp, int get_info);
 void orphan_paths (vector pathvec, struct multipath * mpp);
 void orphan_path (struct path * pp);
 
 int verify_paths(struct multipath * mpp, struct vectors * vecs, vector rpvec);
 int update_mpp_paths(struct multipath * mpp, vector pathvec);
-int setup_multipath (struct vectors * vecs, struct multipath * mpp);
+int __setup_multipath (struct vectors * vecs, struct multipath * mpp,
+		       int reset);
+#define setup_multipath(vecs, mpp) __setup_multipath(vecs, mpp, 1)
 int update_multipath_strings (struct multipath *mpp, vector pathvec);
 	
 void remove_map (struct multipath * mpp, struct vectors * vecs, int purge_vec);
@@ -29,11 +31,10 @@ void remove_map_and_stop_waiter (struct multipath * mpp, struct vectors * vecs,
 void remove_maps (struct vectors * vecs);
 void remove_maps_and_stop_waiters (struct vectors * vecs);
 
-struct multipath * add_map_without_path (struct vectors * vecs,
-				int minor, char * alias);
+struct multipath * add_map_without_path (struct vectors * vecs, char * alias);
 struct multipath * add_map_with_path (struct vectors * vecs,
 				struct path * pp, int add_vec);
-int update_multipath (struct vectors *vecs, char *mapname);
+int update_multipath (struct vectors *vecs, char *mapname, int reset);
 void update_queue_mode_del_path(struct multipath *mpp);
 void update_queue_mode_add_path(struct multipath *mpp);
 
diff --git a/libmultipath/switchgroup.c b/libmultipath/switchgroup.c
index d995cd3..031c3d7 100644
--- a/libmultipath/switchgroup.c
+++ b/libmultipath/switchgroup.c
@@ -20,19 +20,23 @@ path_group_prio_update (struct pathgroup * pgp)
 		return;
 	}
 	vector_foreach_slot (pgp->paths, pp, i) {
-		if (pp->state != PATH_DOWN) {
+		if (pp->state == PATH_UP ||
+		    pp->state == PATH_GHOST) {
 			priority += pp->priority;
 			pgp->enabled_paths++;
 		}
 	}
-	pgp->priority = priority;
+	if (pgp->enabled_paths)
+		pgp->priority = priority / pgp->enabled_paths;
+	else
+		pgp->priority = 0;
 }
 
 extern int
 select_path_group (struct multipath * mpp)
 {
 	int i;
-	int max_priority = 0, avg_priority;
+	int max_priority = 0;
 	int bestpg = 1;
 	int max_enabled_paths = 1;
 	struct pathgroup * pgp;
@@ -46,12 +50,11 @@ select_path_group (struct multipath * mpp)
 
 		path_group_prio_update(pgp);
 		if (pgp->enabled_paths) {
-			avg_priority = pgp->priority / pgp->enabled_paths;
-			if (avg_priority > max_priority) {
-				max_priority = avg_priority;
+			if (pgp->priority > max_priority) {
+				max_priority = pgp->priority;
 				max_enabled_paths = pgp->enabled_paths;
 				bestpg = i + 1;
-			} else if (avg_priority == max_priority) {
+			} else if (pgp->priority == max_priority) {
 				if (pgp->enabled_paths > max_enabled_paths) {
 					max_enabled_paths = pgp->enabled_paths;
 					bestpg = i + 1;
diff --git a/libmultipath/sysfs.c b/libmultipath/sysfs.c
index efbe7c1..16dce4a 100644
--- a/libmultipath/sysfs.c
+++ b/libmultipath/sysfs.c
@@ -26,6 +26,7 @@
 #include <errno.h>
 #include <sys/stat.h>
 #include <string.h>
+#include <dirent.h>
 
 #include "checkers.h"
 #include "vector.h"
@@ -34,23 +35,16 @@
 #include "list.h"
 #include "util.h"
 #include "debug.h"
+#include "devmapper.h"
 
 char sysfs_path[PATH_SIZE];
 
-/* attribute value cache */
-static LIST_HEAD(attr_list);
-struct sysfs_attr {
-	struct list_head node;
-	char path[PATH_SIZE];
-	char *value;			/* points to value_local if value is cached */
-	char value_local[NAME_SIZE];
-};
-
 /* list of sysfs devices */
 static LIST_HEAD(sysfs_dev_list);
 struct sysfs_dev {
 	struct list_head node;
 	struct sysfs_device dev;
+	int refcount;
 };
 
 int sysfs_init(char *path, size_t len)
@@ -62,40 +56,26 @@ int sysfs_init(char *path, size_t len)
 		strlcpy(sysfs_path, "/sys", sizeof(sysfs_path));
 	dbg("sysfs_path='%s'", sysfs_path);
 
-	INIT_LIST_HEAD(&attr_list);
 	INIT_LIST_HEAD(&sysfs_dev_list);
 	return 0;
 }
 
 void sysfs_cleanup(void)
 {
-	struct sysfs_attr *attr_loop;
-	struct sysfs_attr *attr_temp;
-
 	struct sysfs_dev *sysdev_loop;
 	struct sysfs_dev *sysdev_temp;
 
-	list_for_each_entry_safe(attr_loop, attr_temp, &attr_list, node) {
-		list_del(&attr_loop->node);
-		free(attr_loop);
-	}
-
 	list_for_each_entry_safe(sysdev_loop, sysdev_temp, &sysfs_dev_list, node) {
 		list_del(&sysdev_loop->node);
 		free(sysdev_loop);
 	}
 }
 
-void sysfs_device_set_values(struct sysfs_device *dev, const char *devpath,
-			     const char *subsystem, const char *driver)
+void sysfs_device_set_values(struct sysfs_device *dev, const char *devpath)
 {
 	char *pos;
 
 	strlcpy(dev->devpath, devpath, sizeof(dev->devpath));
-	if (subsystem != NULL)
-		strlcpy(dev->subsystem, subsystem, sizeof(dev->subsystem));
-	if (driver != NULL)
-		strlcpy(dev->driver, driver, sizeof(dev->driver));
 
 	/* set kernel name */
 	pos = strrchr(dev->devpath, '/');
@@ -111,13 +91,6 @@ void sysfs_device_set_values(struct sysfs_device *dev, const char *devpath,
 			pos[0] = '/';
 		pos++;
 	}
-
-	/* get kernel number */
-	pos = &dev->kernel[strlen(dev->kernel)];
-	while (isdigit(pos[-1]))
-		pos--;
-	strlcpy(dev->kernel_number, pos, sizeof(dev->kernel_number));
-	dbg("kernel_number='%s'", dev->kernel_number);
 }
 
 int sysfs_resolve_link(char *devpath, size_t size)
@@ -152,6 +125,10 @@ int sysfs_resolve_link(char *devpath, size_t size)
 	return 0;
 }
 
+/*
+ * Caution: this routine is called extremely often.
+ * Should be as efficient as possible.
+ */
 struct sysfs_device *sysfs_device_get(const char *devpath)
 {
 	char path[PATH_SIZE];
@@ -159,22 +136,6 @@ struct sysfs_device *sysfs_device_get(const char *devpath)
 	struct sysfs_device *dev = NULL;
 	struct sysfs_dev *sysdev_loop, *sysdev;
 	struct stat statbuf;
-	char link_path[PATH_SIZE];
-	char link_target[PATH_SIZE];
-	int len;
-	char *pos;
-
-	/* we handle only these devpathes */
-	if (devpath != NULL &&
-	    strncmp(devpath, "/devices/", 9) != 0 &&
-	    strncmp(devpath, "/subsystem/", 11) != 0 &&
-	    strncmp(devpath, "/module/", 8) != 0 &&
-	    strncmp(devpath, "/bus/", 5) != 0 &&
-	    strncmp(devpath, "/class/", 7) != 0 &&
-	    strncmp(devpath, "/block/", 7) != 0) {
-		dbg("invalid devpath '%s'", devpath);
-		return NULL;
-	}
 
 	dbg("open '%s'", devpath);
 	strlcpy(devpath_real, devpath, sizeof(devpath_real));
@@ -192,6 +153,7 @@ struct sysfs_device *sysfs_device_get(const char *devpath)
 			if (strcmp(sysdev_loop->dev.devpath, devpath_real) == 0) {
 				dbg("found vanished dev in cache '%s'",
 				    sysdev_loop->dev.devpath);
+				sysdev_loop->refcount++;
 				return &sysdev_loop->dev;
 			}
 		}
@@ -207,6 +169,7 @@ struct sysfs_device *sysfs_device_get(const char *devpath)
 		if (strcmp(sysdev_loop->dev.devpath, devpath_real) == 0) {
 			dbg("found dev in cache '%s'", sysdev_loop->dev.devpath);
 			dev = &sysdev_loop->dev;
+			sysdev_loop->refcount++;
 		}
 	}
 
@@ -217,57 +180,12 @@ struct sysfs_device *sysfs_device_get(const char *devpath)
 		if (sysdev == NULL)
 			return NULL;
 		memset(sysdev, 0x00, sizeof(struct sysfs_dev));
+		sysdev->refcount = 1;
 		list_add(&sysdev->node, &sysfs_dev_list);
 		dev = &sysdev->dev;
 	}
 
-	sysfs_device_set_values(dev, devpath_real, NULL, NULL);
-
-	/* get subsystem name */
-	strlcpy(link_path, sysfs_path, sizeof(link_path));
-	strlcat(link_path, dev->devpath, sizeof(link_path));
-	strlcat(link_path, "/subsystem", sizeof(link_path));
-	len = readlink(link_path, link_target, sizeof(link_target));
-	if (len > 0) {
-		/* get subsystem from "subsystem" link */
-		link_target[len] = '\0';
-		dbg("subsystem link '%s' points to '%s'", link_path, link_target);
-		pos = strrchr(link_target, '/');
-		if (pos != NULL)
-			strlcpy(dev->subsystem, &pos[1], sizeof(dev->subsystem));
-	} else if (strstr(dev->devpath, "/drivers/") != NULL) {
-		strlcpy(dev->subsystem, "drivers", sizeof(dev->subsystem));
-	} else if (strncmp(dev->devpath, "/module/", 8) == 0) {
-		strlcpy(dev->subsystem, "module", sizeof(dev->subsystem));
-	} else if (strncmp(dev->devpath, "/subsystem/", 11) == 0) {
-		pos = strrchr(dev->devpath, '/');
-		if (pos == &dev->devpath[10])
-			strlcpy(dev->subsystem, "subsystem",
-				sizeof(dev->subsystem));
-	} else if (strncmp(dev->devpath, "/class/", 7) == 0) {
-		pos = strrchr(dev->devpath, '/');
-		if (pos == &dev->devpath[6])
-			strlcpy(dev->subsystem, "subsystem",
-				sizeof(dev->subsystem));
-	} else if (strncmp(dev->devpath, "/bus/", 5) == 0) {
-		pos = strrchr(dev->devpath, '/');
-		if (pos == &dev->devpath[4])
-			strlcpy(dev->subsystem, "subsystem",
-				sizeof(dev->subsystem));
-	}
-
-	/* get driver name */
-	strlcpy(link_path, sysfs_path, sizeof(link_path));
-	strlcat(link_path, dev->devpath, sizeof(link_path));
-	strlcat(link_path, "/driver", sizeof(link_path));
-	len = readlink(link_path, link_target, sizeof(link_target));
-	if (len > 0) {
-		link_target[len] = '\0';
-		dbg("driver link '%s' points to '%s'", link_path, link_target);
-		pos = strrchr(link_target, '/');
-		if (pos != NULL)
-			strlcpy(dev->driver, &pos[1], sizeof(dev->driver));
-	}
+	sysfs_device_set_values(dev, devpath_real);
 
 	return dev;
 }
@@ -324,16 +242,19 @@ device_link:
 	return dev->parent;
 }
 
-struct sysfs_device *sysfs_device_get_parent_with_subsystem(struct sysfs_device *dev, const char *subsystem)
+struct sysfs_device *sysfs_device_verify(struct sysfs_device *dev)
 {
-	struct sysfs_device *dev_parent;
+	char path[PATH_SIZE];
+	struct stat statbuf;
+
+	if (!dev->devpath)
+		return NULL;
+	strlcpy(path, sysfs_path, sizeof(path));
+	strlcat(path, dev->devpath, sizeof(path));
+	if (stat(dev->devpath, &statbuf) == 0 &&
+	    S_ISDIR(statbuf.st_mode))
+		return dev;
 
-	dev_parent = sysfs_device_get_parent(dev);
-	while (dev_parent != NULL) {
-		if (strcmp(dev_parent->subsystem, subsystem) == 0)
-			return dev_parent;
-		dev_parent = sysfs_device_get_parent(dev_parent);
-	}
 	return NULL;
 }
 
@@ -343,88 +264,41 @@ void sysfs_device_put(struct sysfs_device *dev)
 
 	list_for_each_entry(sysdev_loop, &sysfs_dev_list, node) {
 		if (&sysdev_loop->dev == dev) {
-			dbg("removed dev '%s' from cache",
-			    sysdev_loop->dev.devpath);
-			list_del(&sysdev_loop->node);
-			free(sysdev_loop);
+			sysdev_loop->refcount--;
+			if (!sysdev_loop->refcount) {
+				dbg("removed dev '%s' from cache",
+				    sysdev_loop->dev.devpath);
+				list_del(&sysdev_loop->node);
+				free(sysdev_loop);
+			} else {
+				dbg("dev '%s' still in cache, refcount %d",
+				    sysdev_loop->dev.devpath,
+				    sysdev_loop->refcount);
+			}
 			return;
 		}
 	}
-	dbg("dev '%s' not found in cache",
-	    sysdev_loop->dev.devpath);
+	dbg("dev '%s' not found in cache", dev->devpath);
 
 	return;
 }
 
-int
-sysfs_attr_set_value(const char *devpath, const char *attr_name,
-		     const char *value)
-{
-	char path_full[PATH_SIZE];
-	int sysfs_len;
-	struct stat statbuf;
-	int fd, value_len, ret = -1;
-
-	dbg("open '%s'/'%s'", devpath, attr_name);
-	sysfs_len = snprintf(path_full, PATH_SIZE, "%s%s/%s", sysfs_path,
-			     devpath, attr_name);
-	if (sysfs_len >= PATH_SIZE || sysfs_len < 0) {
-		if (sysfs_len < 0)
-			dbg("cannot copy sysfs path %s%s/%s : %s", sysfs_path,
-			    devpath, attr_name, strerror(errno));
-		else
-			dbg("sysfs_path %s%s/%s too large", sysfs_path,
-			    devpath, attr_name);
-		goto out;
-	}
-
-	if (stat(path_full, &statbuf) != 0) {
-		dbg("stat '%s' failed: %s" path_full, strerror(errno));
-		goto out;
-	}
-
-	/* skip directories */
-        if (S_ISDIR(statbuf.st_mode))
-                goto out;
-
-	if ((statbuf.st_mode & S_IWUSR) == 0)
-		goto out;
-
-	fd = open(path_full, O_WRONLY);
-	if (fd < 0) {
-		dbg("attribute '%s' can not be opened: %s",
-		    path_full, strerror(errno));
-		goto out;
-	}
-	value_len = strlen(value) + 1;
-	ret = write(fd, value, value_len);
-	if (ret == value_len)
-		ret = 0;
-	else if (ret < 0)
-		dbg("write to %s failed: %s", path_full, strerror(errno));
-	else {
-		dbg("tried to write %d to %s. Wrote %d\n", value_len,
-		    path_full, ret);
-		ret = -1;
-	}
-	close(fd);
-out:
-	return ret;
-}
-
-
-char *sysfs_attr_get_value(const char *devpath, const char *attr_name)
+size_t sysfs_attr_get_value(const char *devpath, const char *attr_name,
+			    char *attr_value, int attr_len)
 {
 	char path_full[PATH_SIZE];
 	const char *path;
-	char value[NAME_SIZE];
-	struct sysfs_attr *attr_loop;
-	struct sysfs_attr *attr = NULL;
 	struct stat statbuf;
 	int fd;
 	ssize_t size;
 	size_t sysfs_len;
 
+	if (!attr_value || !attr_len)
+		return 0;
+
+	attr_value[0] = '\0';
+	size = 0;
+
 	dbg("open '%s'/'%s'", devpath, attr_name);
 	sysfs_len = strlcpy(path_full, sysfs_path, sizeof(path_full));
 	if(sysfs_len >= sizeof(path_full))
@@ -434,55 +308,11 @@ char *sysfs_attr_get_value(const char *devpath, const char *attr_name)
 	strlcat(path_full, "/", sizeof(path_full));
 	strlcat(path_full, attr_name, sizeof(path_full));
 
-	/* look for attribute in cache */
-	list_for_each_entry(attr_loop, &attr_list, node) {
-		if (strcmp(attr_loop->path, path) == 0) {
-			dbg("found in cache '%s'", attr_loop->path);
-			attr = attr_loop;
-		}
-	}
-	if (!attr) {
-		/* store attribute in cache */
-		dbg("new uncached attribute '%s'", path_full);
-		attr = malloc(sizeof(struct sysfs_attr));
-		if (attr == NULL)
-			return NULL;
-		memset(attr, 0x00, sizeof(struct sysfs_attr));
-		strlcpy(attr->path, path, sizeof(attr->path));
-		dbg("add to cache '%s'", path_full);
-		list_add(&attr->node, &attr_list);
-	} else {
-		/* clear old value */
-		if(attr->value)
-			memset(attr->value, 0x00, sizeof(attr->value));
-	}
-
-	if (lstat(path_full, &statbuf) != 0) {
+	if (stat(path_full, &statbuf) != 0) {
 		dbg("stat '%s' failed: %s", path_full, strerror(errno));
 		goto out;
 	}
 
-	if (S_ISLNK(statbuf.st_mode)) {
-		/* links return the last element of the target path */
-		char link_target[PATH_SIZE];
-		int len;
-		const char *pos;
-
-		len = readlink(path_full, link_target, sizeof(link_target));
-		if (len > 0) {
-			link_target[len] = '\0';
-			pos = strrchr(link_target, '/');
-			if (pos != NULL) {
-				dbg("cache '%s' with link value '%s'",
-				    path_full, value);
-				strlcpy(attr->value_local, &pos[1],
-					sizeof(attr->value_local));
-				attr->value = attr->value_local;
-			}
-		}
-		goto out;
-	}
-
 	/* skip directories */
 	if (S_ISDIR(statbuf.st_mode))
 		goto out;
@@ -498,114 +328,131 @@ char *sysfs_attr_get_value(const char *devpath, const char *attr_name)
 		    path_full, strerror(errno));
 		goto out;
 	}
-	size = read(fd, value, sizeof(value));
+	size = read(fd, attr_value, attr_len);
 	close(fd);
 	if (size < 0)
 		goto out;
-	if (size == sizeof(value)) {
+	if (size == attr_len) {
 		dbg("overflow in attribute '%s', truncating", path_full);
 		size--;
 	}
 
 	/* got a valid value, store and return it */
-	value[size] = '\0';
-	remove_trailing_chars(value, '\n');
-	dbg("cache '%s' with attribute value '%s'", path_full, value);
-	strlcpy(attr->value_local, value, sizeof(attr->value_local));
-	attr->value = attr->value_local;
+	attr_value[size] = '\0';
+	remove_trailing_chars(attr_value, '\n');
 
 out:
-	return attr && attr->value && strlen(attr->value) ? attr->value : NULL;
+	return size;
 }
 
-int sysfs_lookup_devpath_by_subsys_id(char *devpath_full, size_t len,
-				      const char *subsystem, const char *id)
+ssize_t sysfs_attr_set_value(const char *devpath, const char *attr_name,
+			     const char *value, int value_len)
 {
-	size_t sysfs_len;
 	char path_full[PATH_SIZE];
-	char *path;
 	struct stat statbuf;
+	int fd;
+	ssize_t size = -1;
+	size_t sysfs_len;
 
-	sysfs_len = strlcpy(path_full, sysfs_path, sizeof(path_full));
-	path = &path_full[sysfs_len];
-
-	if (strcmp(subsystem, "subsystem") == 0) {
-		strlcpy(path, "/subsystem/", sizeof(path_full) - sysfs_len);
-		strlcat(path, id, sizeof(path_full) - sysfs_len);
-		if (stat(path_full, &statbuf) == 0)
-			goto found;
+	if (!attr_name || !value || !value_len)
+		return 0;
 
-		strlcpy(path, "/bus/", sizeof(path_full) - sysfs_len);
-		strlcat(path, id, sizeof(path_full) - sysfs_len);
-		if (stat(path_full, &statbuf) == 0)
-			goto found;
+	dbg("open '%s'/'%s'", devpath, attr_name);
+	sysfs_len = snprintf(path_full, PATH_SIZE, "%s%s/%s", sysfs_path,
+			     devpath, attr_name);
+	if (sysfs_len >= PATH_SIZE || sysfs_len < 0) {
+		if (sysfs_len < 0)
+			dbg("cannot copy sysfs path %s%s/%s : %s", sysfs_path,
+			    devpath, attr_name, strerror(errno));
+		else
+			dbg("sysfs_path %s%s/%s too large", sysfs_path,
+			    devpath, attr_name);
 		goto out;
-
-		strlcpy(path, "/class/", sizeof(path_full) - sysfs_len);
-		strlcat(path, id, sizeof(path_full) - sysfs_len);
-		if (stat(path_full, &statbuf) == 0)
-			goto found;
 	}
 
-	if (strcmp(subsystem, "module") == 0) {
-		strlcpy(path, "/module/", sizeof(path_full) - sysfs_len);
-		strlcat(path, id, sizeof(path_full) - sysfs_len);
-		if (stat(path_full, &statbuf) == 0)
-			goto found;
+	if (stat(path_full, &statbuf) != 0) {
+		dbg("stat '%s' failed: %s", path_full, strerror(errno));
 		goto out;
 	}
 
-	if (strcmp(subsystem, "drivers") == 0) {
-		char subsys[NAME_SIZE];
-		char *driver;
-
-		strlcpy(subsys, id, sizeof(subsys));
-		driver = strchr(subsys, ':');
-		if (driver != NULL) {
-			driver[0] = '\0';
-			driver = &driver[1];
-			strlcpy(path, "/subsystem/", sizeof(path_full) - sysfs_len);
-			strlcat(path, subsys, sizeof(path_full) - sysfs_len);
-			strlcat(path, "/drivers/", sizeof(path_full) - sysfs_len);
-			strlcat(path, driver, sizeof(path_full) - sysfs_len);
-			if (stat(path_full, &statbuf) == 0)
-				goto found;
-
-			strlcpy(path, "/bus/", sizeof(path_full) - sysfs_len);
-			strlcat(path, subsys, sizeof(path_full) - sysfs_len);
-			strlcat(path, "/drivers/", sizeof(path_full) - sysfs_len);
-			strlcat(path, driver, sizeof(path_full) - sysfs_len);
-			if (stat(path_full, &statbuf) == 0)
-				goto found;
-		}
+	/* skip directories */
+	if (S_ISDIR(statbuf.st_mode))
 		goto out;
+
+	/* skip non-writeable files */
+	if ((statbuf.st_mode & S_IWUSR) == 0)
+		goto out;
+
+	/* write attribute value */
+	fd = open(path_full, O_WRONLY);
+	if (fd < 0) {
+		dbg("attribute '%s' can not be opened: %s",
+		    path_full, strerror(errno));
+		goto out;
+	}
+	size = write(fd, value, value_len);
+	if (size < 0)
+		dbg("write to %s failed: %s", path_full, strerror(errno));
+	else if (size < value_len) {
+		dbg("tried to write %d to %s. Wrote %d\n", value_len,
+		    path_full, size);
+		size = -1;
 	}
 
-	strlcpy(path, "/subsystem/", sizeof(path_full) - sysfs_len);
-	strlcat(path, subsystem, sizeof(path_full) - sysfs_len);
-	strlcat(path, "/devices/", sizeof(path_full) - sysfs_len);
-	strlcat(path, id, sizeof(path_full) - sysfs_len);
-	if (stat(path_full, &statbuf) == 0)
-		goto found;
-
-	strlcpy(path, "/bus/", sizeof(path_full) - sysfs_len);
-	strlcat(path, subsystem, sizeof(path_full) - sysfs_len);
-	strlcat(path, "/devices/", sizeof(path_full) - sysfs_len);
-	strlcat(path, id, sizeof(path_full) - sysfs_len);
-	if (stat(path_full, &statbuf) == 0)
-		goto found;
-
-	strlcpy(path, "/class/", sizeof(path_full) - sysfs_len);
-	strlcat(path, subsystem, sizeof(path_full) - sysfs_len);
-	strlcat(path, "/", sizeof(path_full) - sysfs_len);
-	strlcat(path, id, sizeof(path_full) - sysfs_len);
-	if (stat(path_full, &statbuf) == 0)
-		goto found;
+	close(fd);
 out:
+
+	return size;
+}
+
+int sysfs_check_holders(char * check_devt, char * new_devt)
+{
+	unsigned int major, new_minor, table_minor;
+	char path[PATH_SIZE], check_dev[PATH_SIZE];
+	char * table_name;
+	DIR *dirfd;
+	struct dirent *holder;
+
+	if (sscanf(new_devt,"%d:%d", &major, &new_minor) != 2) {
+		condlog(1, "invalid device number %s", new_devt);
+		return 0;
+	}
+
+	if (devt2devname(check_dev, PATH_SIZE, check_devt))
+		return 0;
+
+	condlog(3, "%s: checking holder", check_dev);
+
+	snprintf(path, PATH_SIZE, "/sys/block/%s/holders", check_dev);
+	dirfd = opendir(path);
+	if (dirfd == NULL) {
+		condlog(3, "%s: failed to open directory %s (%d)",
+			check_dev, path, errno);
+		return 0;
+	}
+	while ((holder = readdir(dirfd)) != NULL) {
+		if ((strcmp(holder->d_name,".") == 0) ||
+		    (strcmp(holder->d_name,"..") == 0))
+			continue;
+
+		if (sscanf(holder->d_name, "dm-%d", &table_minor) != 1) {
+			condlog(3, "%s: %s is not a dm-device",
+				check_dev, holder->d_name);
+			continue;
+		}
+		if (table_minor == new_minor) {
+			condlog(3, "%s: holder already correct", check_dev);
+			continue;
+		}
+		table_name = dm_mapname(major, table_minor);
+
+		condlog(3, "%s: reassign table %s old %s new %s", check_dev,
+			table_name, check_devt, new_devt);
+
+		dm_reassign_table(table_name, check_devt, new_devt);
+		FREE(table_name);
+	}
+	closedir(dirfd);
+
 	return 0;
-found:
-	if (S_ISLNK(statbuf.st_mode))
-		sysfs_resolve_link(path, sizeof(path_full) - sysfs_len);
-	strlcpy(devpath_full, path, len);
-	return 1;
 }
diff --git a/libmultipath/sysfs.h b/libmultipath/sysfs.h
index 57d4cb1..a84857d 100644
--- a/libmultipath/sysfs.h
+++ b/libmultipath/sysfs.h
@@ -13,15 +13,16 @@
 
 int sysfs_init(char *path, size_t len);
 void sysfs_cleanup(void);
-void sysfs_device_set_values(struct sysfs_device *dev, const char *devpath,
-			     const char *subsystem, const char *driver);
+void sysfs_device_set_values(struct sysfs_device *dev, const char *devpath);
 struct sysfs_device *sysfs_device_get(const char *devpath);
 struct sysfs_device *sysfs_device_get_parent(struct sysfs_device *dev);
-struct sysfs_device *sysfs_device_get_parent_with_subsystem(struct sysfs_device *dev, const char *subsystem);
 void sysfs_device_put(struct sysfs_device *dev);
-char *sysfs_attr_get_value(const char *devpath, const char *attr_name);
+struct sysfs_device *sysfs_device_verify(struct sysfs_device *dev);
+size_t sysfs_attr_get_value(const char *devpath, const char *attr_name,
+			    char *attr_value, int attr_len);
+ssize_t sysfs_attr_set_value(const char *devpath, const char *attr_name,
+			     const char *value, int value_len);
 int sysfs_resolve_link(char *path, size_t size);
 int sysfs_get_size (struct sysfs_device * dev, unsigned long long * size);
-int sysfs_attr_set_value(const char *devpath, const char *attr_name,
-			 const char *value);
+int sysfs_check_holders(char * check_devt, char * new_devt);
 #endif
diff --git a/libmultipath/uevent.c b/libmultipath/uevent.c
index d8f3647..e6674ee 100644
--- a/libmultipath/uevent.c
+++ b/libmultipath/uevent.c
@@ -37,18 +37,20 @@
 #include <linux/types.h>
 #include <linux/netlink.h>
 #include <pthread.h>
+#include <limits.h>
 #include <sys/mman.h>
+#include <errno.h>
 
 #include "memory.h"
 #include "debug.h"
+#include "list.h"
 #include "uevent.h"
 
 typedef int (uev_trigger)(struct uevent *, void * trigger_data);
 
 pthread_t uevq_thr;
-struct uevent *uevqhp, *uevqtp;
+LIST_HEAD(uevq);
 pthread_mutex_t uevq_lock, *uevq_lockp = &uevq_lock;
-pthread_mutex_t uevc_lock, *uevc_lockp = &uevc_lock;
 pthread_cond_t  uev_cond,  *uev_condp  = &uev_cond;
 uev_trigger *my_uev_trigger;
 void * my_trigger_data;
@@ -56,64 +58,110 @@ int servicing_uev;
 
 int is_uevent_busy(void)
 {
-	return (uevqhp != NULL || servicing_uev);
+	int empty;
+
+	pthread_mutex_lock(uevq_lockp);
+	empty = list_empty(&uevq);
+	pthread_mutex_unlock(uevq_lockp);
+	return (!empty || servicing_uev);
 }
 
-static struct uevent * alloc_uevent (void)
+struct uevent * alloc_uevent (void)
 {
-	return (struct uevent *)MALLOC(sizeof(struct uevent));
+	struct uevent *uev = MALLOC(sizeof(struct uevent));
+
+	if (uev)
+		INIT_LIST_HEAD(&uev->node);
+
+	return uev;
 }
 
 void
-service_uevq(void)
+setup_thread_attr(pthread_attr_t *attr, size_t stacksize, int detached)
 {
-	int empty;
-	struct uevent *uev;
+	if (pthread_attr_init(attr)) {
+		fprintf(stderr, "can't initialize thread attr: %s\n",
+			strerror(errno));
+		exit(1);
+	}
+	if (stacksize < PTHREAD_STACK_MIN)
+		stacksize = PTHREAD_STACK_MIN;
 
-	do {
-		pthread_mutex_lock(uevq_lockp);
-		empty = (uevqhp == NULL);
-		if (!empty) {
-			uev = uevqhp;
-			uevqhp = uev->next;
-			if (uevqtp == uev)
-				uevqtp = uev->next;
-			pthread_mutex_unlock(uevq_lockp);
-
-			if (my_uev_trigger && my_uev_trigger(uev,
-							my_trigger_data))
-				condlog(0, "uevent trigger error");
-
-			FREE(uev);
-		}
-		else {
-			pthread_mutex_unlock(uevq_lockp);
-		}
-	} while (empty == 0);
+	if (pthread_attr_setstacksize(attr, stacksize)) {
+		fprintf(stderr, "can't set thread stack size to %lu: %s\n",
+			(unsigned long)stacksize, strerror(errno));
+		exit(1);
+	}
+	if (detached && pthread_attr_setdetachstate(attr,
+						    PTHREAD_CREATE_DETACHED)) {
+		fprintf(stderr, "can't set thread to detached: %s\n",
+			strerror(errno));
+		exit(1);
+	}
+}
+
+/*
+ * Called with uevq_lockp held
+ */
+void
+service_uevq(struct list_head *tmpq)
+{
+	struct uevent *uev, *tmp;
+
+	list_for_each_entry_safe(uev, tmp, tmpq, node) {
+		list_del_init(&uev->node);
+
+		if (my_uev_trigger && my_uev_trigger(uev, my_trigger_data))
+			condlog(0, "uevent trigger error");
+
+		FREE(uev);
+	}
+}
+
+static void uevq_stop(void *arg)
+{
+	condlog(3, "Stopping uev queue");
+	pthread_mutex_lock(uevq_lockp);
+	my_uev_trigger = NULL;
+	pthread_cond_signal(uev_condp);
+	pthread_mutex_unlock(uevq_lockp);
 }
 
 /*
  * Service the uevent queue.
  */
-static void *
-uevq_thread(void * et)
+int uevent_dispatch(int (*uev_trigger)(struct uevent *, void * trigger_data),
+		    void * trigger_data)
 {
+	my_uev_trigger = uev_trigger;
+	my_trigger_data = trigger_data;
+
 	mlockall(MCL_CURRENT | MCL_FUTURE);
 
 	while (1) {
-		pthread_mutex_lock(uevc_lockp);
+		LIST_HEAD(uevq_tmp);
+
+		pthread_mutex_lock(uevq_lockp);
 		servicing_uev = 0;
-		pthread_cond_wait(uev_condp, uevc_lockp);
+		/*
+		 * Condition signals are unreliable,
+		 * so make sure we only wait if we have to.
+		 */
+		if (list_empty(&uevq)) {
+			pthread_cond_wait(uev_condp, uevq_lockp);
+		}
 		servicing_uev = 1;
-		pthread_mutex_unlock(uevc_lockp);
-
-		service_uevq();
+		list_splice_init(&uevq, &uevq_tmp);
+		pthread_mutex_unlock(uevq_lockp);
+		if (!my_uev_trigger)
+			break;
+		service_uevq(&uevq_tmp);
 	}
-	return NULL;
+	condlog(3, "Terminating uev service queue");
+	return 0;
 }
 
-int uevent_listen(int (*uev_trigger)(struct uevent *, void * trigger_data),
-		  void * trigger_data)
+int uevent_listen(void)
 {
 	int sock;
 	struct sockaddr_nl snl;
@@ -124,27 +172,20 @@ int uevent_listen(int (*uev_trigger)(struct uevent *, void * trigger_data),
 	int rcvsz = 0;
 	int rcvszsz = sizeof(rcvsz);
 	unsigned int *prcvszsz = (unsigned int *)&rcvszsz;
-	pthread_attr_t attr;
 	const int feature_on = 1;
 
-	my_uev_trigger = uev_trigger;
-	my_trigger_data = trigger_data;
-
 	/*
 	 * Queue uevents for service by dedicated thread so that the uevent
 	 * listening thread does not block on multipathd locks (vecs->lock)
 	 * thereby not getting to empty the socket's receive buffer queue
 	 * often enough.
 	 */
-	uevqhp = uevqtp = NULL;
+	INIT_LIST_HEAD(&uevq);
 
 	pthread_mutex_init(uevq_lockp, NULL);
-	pthread_mutex_init(uevc_lockp, NULL);
 	pthread_cond_init(uev_condp, NULL);
 
-	pthread_attr_init(&attr);
-	pthread_attr_setstacksize(&attr, 64 * 1024);
-	pthread_create(&uevq_thr, &attr, uevq_thread, NULL);
+	pthread_cleanup_push(uevq_stop, NULL);
 
 	/*
 	 * First check whether we have a udev socket
@@ -243,7 +284,7 @@ int uevent_listen(int (*uev_trigger)(struct uevent *, void * trigger_data),
 		buflen = recvmsg(sock, &smsg, 0);
 		if (buflen < 0) {
 			if (errno != EINTR)
-				condlog(0, "error receiving message");
+				condlog(0, "error receiving message, errno %d", errno);
 			continue;
 		}
 
@@ -271,6 +312,10 @@ int uevent_listen(int (*uev_trigger)(struct uevent *, void * trigger_data),
 			condlog(3, "unrecognized message header");
 			continue;
 		}
+		if ((size_t)buflen > sizeof(buf)-1) {
+			condlog(2, "buffer overflow for received uevent");
+			buflen = sizeof(buf)-1;
+		}
 
 		uev = alloc_uevent();
 
@@ -318,38 +363,107 @@ int uevent_listen(int (*uev_trigger)(struct uevent *, void * trigger_data),
 		uev->envp[i] = NULL;
 
 		condlog(3, "uevent '%s' from '%s'", uev->action, uev->devpath);
+		uev->kernel = strrchr(uev->devpath, '/');
+		if (uev->kernel)
+			uev->kernel++;
 
 		/* print payload environment */
 		for (i = 0; uev->envp[i] != NULL; i++)
-			condlog(3, "%s", uev->envp[i]);
+			condlog(5, "%s", uev->envp[i]);
 
 		/*
 		 * Queue uevent and poke service pthread.
 		 */
 		pthread_mutex_lock(uevq_lockp);
-		if (uevqtp)
-			uevqtp->next = uev;
-		else
-			uevqhp = uev;
-		uevqtp = uev;
-		uev->next = NULL;
-		pthread_mutex_unlock(uevq_lockp);
-
-		pthread_mutex_lock(uevc_lockp);
+		list_add_tail(&uev->node, &uevq);
 		pthread_cond_signal(uev_condp);
-		pthread_mutex_unlock(uevc_lockp);
+		pthread_mutex_unlock(uevq_lockp);
 	}
 
 exit:
 	close(sock);
 
-	pthread_mutex_lock(uevq_lockp);
-	pthread_cancel(uevq_thr);
-	pthread_mutex_unlock(uevq_lockp);
+	pthread_cleanup_pop(1);
 
 	pthread_mutex_destroy(uevq_lockp);
-	pthread_mutex_destroy(uevc_lockp);
 	pthread_cond_destroy(uev_condp);
 
 	return 1;
 }
+
+extern int
+uevent_get_major(struct uevent *uev)
+{
+	char *p, *q;
+	int i, major = -1;
+
+	for (i = 0; uev->envp[i] != NULL; i++) {
+		if (!strncmp(uev->envp[i], "MAJOR", 5) && strlen(uev->envp[i]) > 6) {
+			p = uev->envp[i] + 6;
+			major = strtoul(p, &q, 10);
+			if (p == q) {
+				condlog(2, "invalid major '%s'", p);
+				major = -1;
+			}
+			break;
+		}
+	}
+	return major;
+}
+
+extern int
+uevent_get_minor(struct uevent *uev)
+{
+	char *p, *q;
+	int i, minor = -1;
+
+	for (i = 0; uev->envp[i] != NULL; i++) {
+		if (!strncmp(uev->envp[i], "MINOR", 5) && strlen(uev->envp[i]) > 6) {
+			p = uev->envp[i] + 6;
+			minor = strtoul(p, &q, 10);
+			if (p == q) {
+				condlog(2, "invalid minor '%s'", p);
+				minor = -1;
+			}
+			break;
+		}
+	}
+	return minor;
+}
+
+extern int
+uevent_get_disk_ro(struct uevent *uev)
+{
+	char *p, *q;
+	int i, ro = -1;
+
+	for (i = 0; uev->envp[i] != NULL; i++) {
+		if (!strncmp(uev->envp[i], "DISK_RO", 6) && strlen(uev->envp[i]) > 7) {
+			p = uev->envp[i] + 8;
+			ro = strtoul(p, &q, 10);
+			if (p == q) {
+				condlog(2, "invalid read_only setting '%s'", p);
+				ro = -1;
+			}
+			break;
+		}
+	}
+	return ro;
+}
+
+extern char *
+uevent_get_dm_name(struct uevent *uev)
+{
+	char *p = NULL;
+	int i;
+
+	for (i = 0; uev->envp[i] != NULL; i++) {
+		if (!strncmp(uev->envp[i], "DM_NAME", 6) &&
+		    strlen(uev->envp[i]) > 7) {
+			p = MALLOC(strlen(uev->envp[i] + 8) + 1);
+			strcpy(p, uev->envp[i] + 8);
+			break;
+		}
+	}
+	return p;
+}
diff --git a/libmultipath/uevent.h b/libmultipath/uevent.h
index e1a1254..46596fd 100644
--- a/libmultipath/uevent.h
+++ b/libmultipath/uevent.h
@@ -1,5 +1,11 @@
-/* environment buffer, the kernel's size in lib/kobject_uevent.c should fit in */
-#define HOTPLUG_BUFFER_SIZE		1024
+#ifndef _UEVENT_H
+#define _UEVENT_H
+
+/*
+ * buffer for environment variables, the kernel's size in
+ * lib/kobject_uevent.c should fit in
+*/
+#define HOTPLUG_BUFFER_SIZE		2048
 #define HOTPLUG_NUM_ENVP		32
 #define OBJECT_SIZE			512
 
@@ -8,13 +14,23 @@
 #endif
 
 struct uevent {
-	void *next;
+	struct list_head node;
 	char buffer[HOTPLUG_BUFFER_SIZE + OBJECT_SIZE];
 	char *devpath;
 	char *action;
+	char *kernel;
 	char *envp[HOTPLUG_NUM_ENVP];
 };
 
-int uevent_listen(int (*store_uev)(struct uevent *, void * trigger_data),
-		  void * trigger_data);
 int is_uevent_busy(void);
+void setup_thread_attr(pthread_attr_t *attr, size_t stacksize, int detached);
+
+int uevent_listen(void);
+int uevent_dispatch(int (*store_uev)(struct uevent *, void * trigger_data),
+		    void * trigger_data);
+int uevent_get_major(struct uevent *uev);
+int uevent_get_minor(struct uevent *uev);
+int uevent_get_disk_ro(struct uevent *uev);
+char *uevent_get_dm_name(struct uevent *uev);
+
+#endif /* _UEVENT_H */
diff --git a/libmultipath/util.c b/libmultipath/util.c
index ebe06dc..62b1aa1 100644
--- a/libmultipath/util.c
+++ b/libmultipath/util.c
@@ -6,28 +6,9 @@
 
 #include "debug.h"
 #include "memory.h"
-
-#define PARAMS_SIZE 255
-
-int
-strcmp_chomp(char *str1, char *str2)
-{
-	int i;
-	char s1[PARAMS_SIZE],s2[PARAMS_SIZE];
-
-	if(!str1 || !str2)
-		return 1;
-
-	strncpy(s1, str1, PARAMS_SIZE);
-	strncpy(s2, str2, PARAMS_SIZE);
-
-	for (i=strlen(s1)-1; i >=0 && isspace(s1[i]); --i) ;
-	s1[++i] = '\0';
-	for (i=strlen(s2)-1; i >=0 && isspace(s2[i]); --i) ;
-	s2[++i] = '\0';
-
-	return(strcmp(s1,s2));
-}
+#include "checkers.h"
+#include "vector.h"
+#include "structs.h"
 
 void
 strchop(char *str)
@@ -38,10 +19,21 @@ strchop(char *str)
 	str[++i] = '\0';
 }
 
-void
-basenamecpy (char * str1, char * str2)
+int
+basenamecpy (char * str1, char * str2, int str2len)
 {
-	char *p = str1 + (strlen(str1) - 1);
+	char *p;
+
+	if (!str1 || !strlen(str1))
+		return 0;
+
+	if (strlen(str1) > str2len)
+		return 0;
+
+	if (!str2)
+		return 0;
+
+	p = str1 + (strlen(str1) - 1);
 
 	while (*--p != '/' && p != str1)
 		continue;
@@ -49,7 +41,10 @@ basenamecpy (char * str1, char * str2)
 	if (p != str1)
 		p++;
 
-	strcpy(str2, p);
+	strncpy(str2, p, str2len);
+	str2[str2len - 1] = '\0';
+	strchop(str2);
+	return strlen(str2);
 }
 
 int
@@ -156,3 +151,86 @@ void remove_trailing_chars(char *path, char c)
 		path[--len] = '\0';
 }
 
+extern int
+devt2devname (char *devname, int devname_len, char *devt)
+{
+	FILE *fd;
+	unsigned int tmpmaj, tmpmin, major, minor;
+	char dev[FILE_NAME_SIZE];
+	char block_path[PATH_SIZE];
+	struct stat statbuf;
+
+	memset(block_path, 0, sizeof(block_path));
+	if (sscanf(devt, "%u:%u", &major, &minor) != 2) {
+		condlog(0, "Invalid device number %s", devt);
+		return 1;
+	}
+
+	if (devname_len > FILE_NAME_SIZE)
+		devname_len = FILE_NAME_SIZE;
+
+	if (stat("/sys/dev/block", &statbuf) == 0) {
+		/* Newer kernels have /sys/dev/block */
+		sprintf(block_path,"/sys/dev/block/%u:%u", major, minor);
+		if (stat(block_path, &statbuf) == 0) {
+			if (S_ISLNK(statbuf.st_mode) &&
+			    readlink(block_path, dev, FILE_NAME_SIZE) > 0) {
+				char *p = strrchr(dev, '/');
+
+				if (!p) {
+					condlog(0, "No sysfs entry for %s\n",
+						block_path);
+					return 1;
+				}
+				p++;
+				strncpy(devname, p, devname_len);
+				return 0;
+			}
+		}
+		goto skip_proc;
+	}
+	memset(block_path, 0, sizeof(block_path));
+
+	if (!(fd = fopen("/proc/partitions", "r"))) {
+		condlog(0, "Cannot open /proc/partitions");
+		return 1;
+	}
+
+	while (!feof(fd)) {
+		int r = fscanf(fd,"%u %u %*d %s",&tmpmaj, &tmpmin, dev);
+		if (!r) {
+			r = fscanf(fd,"%*s\n");
+			continue;
+		}
+		if (r != 3)
+			continue;
+
+		if ((major == tmpmaj) && (minor == tmpmin)) {
+			if (snprintf(block_path, sizeof(block_path),
+				     "/sys/block/%s", dev) >= sizeof(block_path)) {
+				condlog(0, "device name %s is too long\n", dev);
+				fclose(fd);
+				return 1;
+			}
+			break;
+		}
+	}
+	fclose(fd);
+skip_proc:
+	if (strncmp(block_path,"/sys/block", 10)) {
+		condlog(3, "No device found for %u:%u\n", major, minor);
+		return 1;
+	}
+
+	if (stat(block_path, &statbuf) < 0) {
+		condlog(0, "No sysfs entry for %s\n", block_path);
+		return 1;
+	}
+
+	if (S_ISDIR(statbuf.st_mode) == 0) {
+		condlog(0, "sysfs entry %s is not a directory\n", block_path);
+		return 1;
+	}
+	basenamecpy(block_path, devname, devname_len);
+	return 0;
+}
diff --git a/libmultipath/util.h b/libmultipath/util.h
index 52f2578..72de319 100644
--- a/libmultipath/util.h
+++ b/libmultipath/util.h
@@ -1,14 +1,14 @@
 #ifndef _UTIL_H
 #define _UTIL_H
 
-int strcmp_chomp(char *, char *);
 void strchop(char *);
-void basenamecpy (char * src, char * dst);
+int basenamecpy (char * src, char * dst, int);
 int filepresent (char * run);
 int get_word (char * sentence, char ** word);
 size_t strlcpy(char *dst, const char *src, size_t size);
 size_t strlcat(char *dst, const char *src, size_t size);
 void remove_trailing_chars(char *path, char c);
+int devt2devname (char *, int, char *);
 
 #define safe_sprintf(var, format, args...)	\
 	snprintf(var, sizeof(var), format, ##args) >= sizeof(var)
diff --git a/libmultipath/uxsock.c b/libmultipath/uxsock.c
index d5d1be9..e786899 100644
--- a/libmultipath/uxsock.c
+++ b/libmultipath/uxsock.c
@@ -152,12 +152,22 @@ int send_packet(int fd, const char *buf, size_t len)
  */
 int recv_packet(int fd, char **buf, size_t *len)
 {
-	if (read_all(fd, len, sizeof(*len)) != sizeof(*len)) return -1;
+	if (read_all(fd, len, sizeof(*len)) != sizeof(*len)) {
+		(*buf) = NULL;
+		*len = 0;
+		return -1;
+	}
+	if (len == 0) {
+		(*buf) = NULL;
+		return 0;
+	}
 	(*buf) = MALLOC(*len);
 	if (!*buf)
 		return -1;
 	if (read_all(fd, *buf, *len) != *len) {
 		FREE(*buf);
+		(*buf) = NULL;
+		*len = 0;
 		return -1;
 	}
 	return 0;
diff --git a/libmultipath/vector.c b/libmultipath/vector.c
index 3415461..652f118 100644
--- a/libmultipath/vector.c
+++ b/libmultipath/vector.c
@@ -38,18 +38,41 @@ vector_alloc(void)
 void *
 vector_alloc_slot(vector v)
 {
+	void *new_slot = NULL;
+
+	if (!v)
+		return NULL;
+
 	v->allocated += VECTOR_DEFAULT_SIZE;
 	if (v->slot)
-		v->slot = REALLOC(v->slot, sizeof (void *) * v->allocated);
+		new_slot = REALLOC(v->slot, sizeof (void *) * v->allocated);
 	else
-		v->slot = (void *) MALLOC(sizeof (void *) * v->allocated);
+		new_slot = (void *) MALLOC(sizeof (void *) * v->allocated);
 
-	if (!v->slot)
+	if (!new_slot)
 		v->allocated -= VECTOR_DEFAULT_SIZE;
+	else
+		v->slot = new_slot;
 
 	return v->slot;
 }
 
+int
+vector_move_up(vector v, int src, int dest)
+{
+	void *value;
+	int i;
+	if (dest == src)
+		return 0;
+	if (dest > src || src >= v->allocated)
+		return -1;
+	value = v->slot[src];
+	for (i = src - 1; i >= dest; i--)
+		v->slot[i + 1] = v->slot[i];
+	v->slot[dest] = value;
+	return 0;
+}
+
 void *
 vector_insert_slot(vector v, int slot, void *value)
 {
@@ -83,7 +106,7 @@ vector_del_slot(vector v, int slot)
 {
 	int i;
 
-	if (!v->allocated || slot < 0 || slot > VECTOR_SIZE(v))
+	if (!v || !v->allocated || slot < 0 || slot > VECTOR_SIZE(v))
 		return;
 
 	for (i = slot + 1; i < (v->allocated / VECTOR_DEFAULT_SIZE); i++)
@@ -94,9 +117,16 @@ vector_del_slot(vector v, int slot)
 	if (!v->allocated) {
 		FREE(v->slot);
 		v->slot = NULL;
+		v->allocated = 0;
+	} else {
+		void *new_slot;
+
+		new_slot = REALLOC(v->slot, sizeof (void *) * v->allocated);
+		if (!new_slot)
+			v->allocated += VECTOR_DEFAULT_SIZE;
+		else
+			v->slot = new_slot;
 	}
-	else
-		v = REALLOC(v->slot, sizeof (void *) * v->allocated);
 }
 
 void
@@ -104,7 +134,7 @@ vector_repack(vector v)
 {
 	int i;
 
-	if (!v->allocated)
+	if (!v || !v->allocated)
 		return;
 
 	for (i = 0; i < (v->allocated / VECTOR_DEFAULT_SIZE); i++)
@@ -122,6 +152,8 @@ vector_free(vector v)
 	if (v->slot)
 		FREE(v->slot);
 
+	v->allocated = 0;
+	v->slot = NULL;
 	FREE(v);
 }
 
@@ -145,7 +177,11 @@ free_strvec(vector strvec)
 void
 vector_set_slot(vector v, void *value)
 {
-	unsigned int i = v->allocated - 1;
+	unsigned int i;
+
+	if (!v)
+		return;
 
+	i = VECTOR_SIZE(v) - 1;
 	v->slot[i] = value;
 }
diff --git a/libmultipath/vector.h b/libmultipath/vector.h
index 59cfd27..ca42be1 100644
--- a/libmultipath/vector.h
+++ b/libmultipath/vector.h
@@ -39,6 +39,8 @@ typedef struct _vector *vector;
 	for (i = 0; (v) && i < (v)->allocated && ((p) = (v)->slot[i]); i++)
 #define vector_foreach_slot_after(v,p,i) \
 	for (; (v) && i < (v)->allocated && ((p) = (v)->slot[i]); i++)
+#define vector_foreach_slot_backwards(v,p,i) \
+	for (i = VECTOR_SIZE(v); i > 0 && ((p) = (v)->slot[i-1]); i--)
 
 /* Prototypes */
 extern vector vector_alloc(void);
@@ -52,5 +54,5 @@ int find_slot(vector v, void * addr);
 extern void vector_repack(vector v);
 extern void vector_dump(vector v);
 extern void dump_strvec(vector strvec);
-
+extern int vector_move_up(vector v, int src, int dest);
 #endif
diff --git a/libmultipath/waiter.c b/libmultipath/waiter.c
index 4fb2cff..974593c 100644
--- a/libmultipath/waiter.c
+++ b/libmultipath/waiter.c
@@ -28,54 +28,38 @@ struct event_thread *alloc_waiter (void)
 	struct event_thread *wp;
 
 	wp = (struct event_thread *)MALLOC(sizeof(struct event_thread));
+	memset(wp, 0, sizeof(struct event_thread));
+	pthread_mutex_init(&wp->lock, NULL);
 
 	return wp;
 }
 
-void free_waiter (void *data)
+void signal_waiter (void *data)
 {
-	sigset_t old;
 	struct event_thread *wp = (struct event_thread *)data;
 
-	/*
-	 * indicate in mpp that the wp is already freed storage
-	 */
-	block_signal(SIGHUP, &old);
-	lock(wp->vecs->lock);
-
-	if (wp->mpp)
-		/*
-		 * be careful, mpp may already be freed -- null if so
-		 */
-		wp->mpp->waiter = NULL;
-	else
-		/*
-		* This is OK condition during shutdown.
-		*/
-		condlog(3, "free_waiter, mpp freed before wp=%p (%s).", wp, wp->mapname);
-
-	unlock(wp->vecs->lock);
-	pthread_sigmask(SIG_SETMASK, &old, NULL);
-
-	if (wp->dmt)
-		dm_task_destroy(wp->dmt);
+	pthread_mutex_lock(&wp->lock);
+	memset(wp->mapname, 0, WWID_SIZE);
+	pthread_mutex_unlock(&wp->lock);
+}
 
+void free_waiter (struct event_thread *wp)
+{
+	pthread_mutex_destroy(&wp->lock);
 	FREE(wp);
 }
 
 void stop_waiter_thread (struct multipath *mpp, struct vectors *vecs)
 {
-	struct event_thread *wp = (struct event_thread *)mpp->waiter;
-	pthread_t thread;
-
-	if (!wp) {
-		condlog(3, "%s: no waiter thread", mpp->alias);
+	if (mpp->waiter == (pthread_t)0) {
+		condlog(3, "%s: event checker thread already stopped",
+			mpp->alias);
 		return;
 	}
-	thread = wp->thread;
-	condlog(2, "%s: stop event checker thread (%lu)", wp->mapname, thread);
-
-	pthread_kill(thread, SIGUSR1);
+	condlog(2, "%s: stop event checker thread (%lu)", mpp->alias,
+		mpp->waiter);
+	pthread_kill(mpp->waiter, SIGUSR1);
+	mpp->waiter = (pthread_t)0;
 }
 
 static sigset_t unblock_signals(void)
@@ -96,49 +80,61 @@ static sigset_t unblock_signals(void)
 int waiteventloop (struct event_thread *waiter)
 {
 	sigset_t set;
+	struct dm_task *dmt = NULL;
 	int event_nr;
 	int r;
 
+	pthread_mutex_lock(&waiter->lock);
 	if (!waiter->event_nr)
 		waiter->event_nr = dm_geteventnr(waiter->mapname);
 
-	if (!(waiter->dmt = dm_task_create(DM_DEVICE_WAITEVENT))) {
+	if (!(dmt = dm_task_create(DM_DEVICE_WAITEVENT))) {
 		condlog(0, "%s: devmap event #%i dm_task_create error",
 				waiter->mapname, waiter->event_nr);
+		pthread_mutex_unlock(&waiter->lock);
 		return 1;
 	}
 
-	if (!dm_task_set_name(waiter->dmt, waiter->mapname)) {
+	if (!dm_task_set_name(dmt, waiter->mapname)) {
 		condlog(0, "%s: devmap event #%i dm_task_set_name error",
 				waiter->mapname, waiter->event_nr);
-		dm_task_destroy(waiter->dmt);
+		dm_task_destroy(dmt);
+		pthread_mutex_unlock(&waiter->lock);
 		return 1;
 	}
 
-	if (waiter->event_nr && !dm_task_set_event_nr(waiter->dmt,
+	if (waiter->event_nr && !dm_task_set_event_nr(dmt,
 						      waiter->event_nr)) {
 		condlog(0, "%s: devmap event #%i dm_task_set_event_nr error",
 				waiter->mapname, waiter->event_nr);
-		dm_task_destroy(waiter->dmt);
+		dm_task_destroy(dmt);
+		pthread_mutex_unlock(&waiter->lock);
 		return 1;
 	}
+	pthread_mutex_unlock(&waiter->lock);
 
-	dm_task_no_open_count(waiter->dmt);
+	dm_task_no_open_count(dmt);
 
 	/* accept wait interruption */
 	set = unblock_signals();
 
 	/* wait */
-	r = dm_task_run(waiter->dmt);
+	r = dm_task_run(dmt);
 
 	/* wait is over : event or interrupt */
 	pthread_sigmask(SIG_SETMASK, &set, NULL);
 
-	if (!r) /* wait interrupted by signal */
+	dm_task_destroy(dmt);
+
+	if (!r)	/* wait interrupted by signal */
 		return -1;
 
-	dm_task_destroy(waiter->dmt);
-	waiter->dmt = NULL;
+	pthread_mutex_lock(&waiter->lock);
+	if (!strlen(waiter->mapname)) {
+		/* waiter should exit */
+		pthread_mutex_unlock(&waiter->lock);
+		return -1;
+	}
 	waiter->event_nr++;
 
 	/*
@@ -161,22 +157,27 @@ int waiteventloop (struct event_thread *waiter)
 		 */
 		pthread_cleanup_push(cleanup_lock, &waiter->vecs->lock);
 		lock(waiter->vecs->lock);
-		r = update_multipath(waiter->vecs, waiter->mapname);
+		pthread_testcancel();
+		r = update_multipath(waiter->vecs, waiter->mapname, 1);
 		lock_cleanup_pop(waiter->vecs->lock);
 
 		if (r) {
 			condlog(2, "%s: event checker exit",
 				waiter->mapname);
+			pthread_mutex_unlock(&waiter->lock);
 			return -1; /* stop the thread */
 		}
 
 		event_nr = dm_geteventnr(waiter->mapname);
 
-		if (waiter->event_nr == event_nr)
+		if (waiter->event_nr == event_nr) {
+			pthread_mutex_unlock(&waiter->lock);
 			return 1; /* upon problem reschedule 1s later */
+		}
 
 		waiter->event_nr = event_nr;
 	}
+	pthread_mutex_unlock(&waiter->lock);
 	return -1; /* never reach there */
 }
 
@@ -188,7 +189,7 @@ void *waitevent (void *et)
 	mlockall(MCL_CURRENT | MCL_FUTURE);
 
 	waiter = (struct event_thread *)et;
-	pthread_cleanup_push(free_waiter, et);
+	pthread_cleanup_push(signal_waiter, et);
 
 	block_signal(SIGUSR1, NULL);
 	block_signal(SIGHUP, NULL);
@@ -202,6 +203,7 @@ void *waitevent (void *et)
 	}
 
 	pthread_cleanup_pop(1);
+	free_waiter(waiter);
 	return NULL;
 }
 
@@ -217,21 +219,22 @@ int start_waiter_thread (struct multipath *mpp, struct vectors *vecs)
 	if (!wp)
 		goto out;
 
-	mpp->waiter = (void *)wp;
+	pthread_mutex_lock(&wp->lock);
 	strncpy(wp->mapname, mpp->alias, WWID_SIZE);
 	wp->vecs = vecs;
-	wp->mpp = mpp;
+	pthread_mutex_unlock(&wp->lock);
 
 	if (pthread_create(&wp->thread, &waiter_attr, waitevent, wp)) {
 		condlog(0, "%s: cannot create event checker", wp->mapname);
 		goto out1;
 	}
+	mpp->waiter = wp->thread;
 	condlog(2, "%s: event checker started", wp->mapname);
 
 	return 0;
 out1:
 	free_waiter(wp);
-	mpp->waiter = NULL;
+	mpp->waiter = (pthread_t)0;
 out:
 	condlog(0, "failed to start waiter thread");
 	return 1;
diff --git a/libmultipath/waiter.h b/libmultipath/waiter.h
index ab362d1..28a6974 100644
--- a/libmultipath/waiter.h
+++ b/libmultipath/waiter.h
@@ -4,16 +4,15 @@
 extern pthread_attr_t waiter_attr;
 
 struct event_thread {
-	struct dm_task *dmt;
 	pthread_t thread;
+	pthread_mutex_t lock;
 	int event_nr;
 	char mapname[WWID_SIZE];
 	struct vectors *vecs;
-	struct multipath *mpp;
 };
 
 struct event_thread * alloc_waiter (void);
-void free_waiter (void *data);
+void signal_waiter (void *data);
 void stop_waiter_thread (struct multipath *mpp, struct vectors *vecs);
 int start_waiter_thread (struct multipath *mpp, struct vectors *vecs);
 int waiteventloop (struct event_thread *waiter);
diff --git a/mpathpersist/Makefile b/mpathpersist/Makefile
new file mode 100644
index 0000000..2a8efe6
--- /dev/null
+++ b/mpathpersist/Makefile
@@ -0,0 +1,30 @@
+# Makefile
+#
+include ../Makefile.inc
+
+OBJS = main.o 
+
+CFLAGS += -I$(multipathdir) -I$(mpathpersistdir) 
+LDFLAGS += -lpthread -ldevmapper -L$(mpathpersistdir) -lmpathpersist -L$(multipathdir) -lmultipath 
+
+EXEC = mpathpersist
+
+all: $(EXEC)
+
+$(EXEC): $(OBJS)
+	$(CC) -g $(OBJS) -o $(EXEC) $(LDFLAGS) $(CFLAGS)
+	$(GZIP) $(EXEC).8 > $(EXEC).8.gz
+	
+install:
+	install -d $(DESTDIR)$(bindir)
+	install -m 755 $(EXEC) $(DESTDIR)$(bindir)/
+	install -d $(DESTDIR)$(mandir)
+	install -m 644 $(EXEC).8.gz $(DESTDIR)$(mandir)
+	
+clean:
+	rm -f *.o $(EXEC)
+	rm -f mpathpersist.8.gz
+
+uninstall:
+	rm $(DESTDIR)$(bindir)/$(EXEC)
+	rm $(DESTDIR)$(mandir)/$(EXEC).8.gz
diff --git a/mpathpersist/main.c b/mpathpersist/main.c
new file mode 100644
index 0000000..33dad90
--- /dev/null
+++ b/mpathpersist/main.c
@@ -0,0 +1,818 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <fcntl.h>
+#include <checkers.h>
+#include <vector.h>
+#include <structs.h>
+#include <getopt.h>
+#include <mpath_persist.h>
+#include "main.h"
+#include <pthread.h>
+#include <ctype.h>
+#include <string.h>
+
+static const char * pr_type_strs[] = {
+	"obsolete [0]",
+	"Write Exclusive",
+	"obsolete [2]",
+	"Exclusive Access",
+	"obsolete [4]",
+	"Write Exclusive, registrants only",
+	"Exclusive Access, registrants only",
+	"Write Exclusive, all registrants",
+	"Exclusive Access, all registrants",
+	"obsolete [9]", "obsolete [0xa]", "obsolete [0xb]", "obsolete [0xc]",
+	"obsolete [0xd]", "obsolete [0xe]", "obsolete [0xf]",
+};
+
+int get_transportids_length(unsigned char * transportid_arr, int max_transportid, int num_transportids);
+void mpath_print_buf_readcap(struct prin_resp *pr_buff); 
+void mpath_print_buf_readfullstat(struct prin_resp *pr_buff);
+void mpath_print_buf_readresv(struct prin_resp *pr_buff);
+void mpath_print_buf_readkeys(struct prin_resp *pr_buff);
+void dumpHex(const char* str, int len, int no_ascii);
+void * mpath_alloc_prin_response(int prin_sa);	
+void mpath_print_transport_id(struct prin_fulldescr *fdesc);
+int construct_transportid(const char * inp, struct transportid transid[], int num_transportids);
+
+int logsink;
+unsigned int mpath_mx_alloc_len;
+
+int main (int argc, char * argv[])
+{
+	int fd, c, res;
+	const char *device_name = NULL;
+	int num_prin_sa = 0;
+	int num_prout_sa = 0;
+	int num_prout_param = 0;
+	int prin_flag = 0;
+	int prout_flag = 0;
+	int ret = 0;
+	int hex = 0;
+	uint64_t param_sark = 0;
+	unsigned int prout_type = 0;
+	int param_alltgpt = 0;
+	int param_aptpl = 0;
+	uint64_t param_rk = 0;
+	unsigned int param_rtp = 0;
+	int num_transportids = 0;
+	struct transportid transportids[MPATH_MX_TIDS];
+	int prout = 1;
+	int prin = 1;
+	int prin_sa = -1;
+	int prout_sa = -1;
+	int verbose = 0;
+	int loglevel = 0;
+	int noisy = 0;
+	int num_transport =0;
+	void *resp = NULL;
+	struct transportid * tmp; 
+
+	if (optind == argc)
+	{
+
+		fprintf (stderr, "No parameter used\n");
+		usage ();
+		exit (1);
+	}
+
+	if (getuid () != 0)
+	{
+		fprintf (stderr, "need to be root\n");
+		exit (1);
+	}
+
+
+	mpath_lib_init();
+	memset(transportids,0,MPATH_MX_TIDS);
+
+	while (1)
+	{
+		int option_index = 0;
+
+		c = getopt_long (argc, argv, "v:Cd:hHioZK:S:PAT:skrGILcRX:l:",
+				long_options, &option_index);
+		if (c == -1)
+			break;
+
+		switch (c)
+		{
+			case 'v':
+				if (1 != sscanf (optarg, "%d", &loglevel))
+				{
+					fprintf (stderr, "bad argument to '--verbose'\n");
+					return MPATH_PR_SYNTAX_ERROR;
+				}
+				break;
+
+			case 'C':
+				prout_sa = MPATH_PROUT_CLEAR_SA;
+				++num_prout_sa;
+				break;
+
+			case 'd':
+				device_name = optarg;
+				break;
+
+			case 'h':
+				usage ();
+				return 0;
+
+			case 'H':
+				hex=1;
+				break;
+
+			case 'i':
+				prin_flag = 1;
+				break;
+
+			case 'o':
+				prout_flag = 1;
+				break;
+
+			case 'Z':
+				param_aptpl = 1;
+				++num_prout_param;
+				break;
+			case 'K':
+				if (1 != sscanf (optarg, "%" SCNx64 "", &param_rk))
+				{
+					fprintf (stderr, "bad argument to '--param-rk'\n");
+					return MPATH_PR_SYNTAX_ERROR;
+				}
+				++num_prout_param;
+				break;
+
+			case 'S':
+				if (1 != sscanf (optarg, "%" SCNx64 "", &param_sark))
+				{
+					fprintf (stderr, "bad argument to '--param-sark'\n");
+					return MPATH_PR_SYNTAX_ERROR;
+				}
+				++num_prout_param;
+				break;
+
+			case 'P':
+				prout_sa = MPATH_PROUT_PREE_SA;
+				++num_prout_sa;
+				break;
+
+			case 'A':
+				prout_sa = MPATH_PROUT_PREE_AB_SA;
+				++num_prout_sa;
+				break;
+
+			case 'T':
+				if (1 != sscanf (optarg, "%x", &prout_type))
+				{
+					fprintf (stderr, "bad argument to '--prout-type'\n");
+					return MPATH_PR_SYNTAX_ERROR;
+				}
+				++num_prout_param;
+				break;
+
+			case 's':
+				prin_sa = MPATH_PRIN_RFSTAT_SA;
+				++num_prin_sa;
+				break;
+
+			case 'k':
+				prin_sa = MPATH_PRIN_RKEY_SA;
+				++num_prin_sa;
+				break;
+
+			case 'r':
+				prin_sa = MPATH_PRIN_RRES_SA;
+				++num_prin_sa;
+				break;
+
+			case 'G':
+				prout_sa = MPATH_PROUT_REG_SA;
+				++num_prout_sa;
+				break;
+
+			case 'I':
+				prout_sa = MPATH_PROUT_REG_IGN_SA;
+				++num_prout_sa;
+				break;
+
+			case 'L':
+				prout_sa = MPATH_PROUT_REL_SA;
+				++num_prout_sa;
+				break;
+
+			case 'c':
+				prin_sa = MPATH_PRIN_RCAP_SA;
+				++num_prin_sa;
+				break;
+
+			case 'R':
+				prout_sa = MPATH_PROUT_RES_SA;
+				++num_prout_sa;
+				break;
+
+			case 'X':
+				if (0 != construct_transportid(optarg, transportids, num_transport)) {
+					fprintf(stderr, "bad argument to '--transport-id'\n");
+					return MPATH_PR_SYNTAX_ERROR;
+				}
+
+				++num_transport;
+				break;
+
+			case 'l':
+                                if (1 != sscanf(optarg, "%u", &mpath_mx_alloc_len)) {
+                                        fprintf(stderr, "bad argument to '--alloc-length'\n");
+                                        return MPATH_PR_SYNTAX_ERROR;
+                                } else if (MPATH_MAX_PARAM_LEN < mpath_mx_alloc_len) {
+                                        fprintf(stderr, "'--alloc-length' argument exceeds maximum"
+                                                        " limit(%d)\n", MPATH_MAX_PARAM_LEN);
+                                        return MPATH_PR_SYNTAX_ERROR;
+                                }
+                                break;
+
+			default:
+				fprintf(stderr, "unrecognised switch " "code 0x%x ??\n", c);	
+				usage ();
+				ret = MPATH_PR_SYNTAX_ERROR;
+				goto out;
+		}
+	}
+
+	if (optind < argc)
+	{
+
+		if (NULL == device_name)
+		{
+			device_name = argv[optind];
+			++optind;
+		}
+		if (optind < argc)
+		{
+			for (; optind < argc; ++optind)
+				fprintf (stderr, "Unexpected extra argument: %s\n", argv[optind]);
+			usage ();
+			ret = MPATH_PR_SYNTAX_ERROR;
+			goto out;
+		}
+	}
+
+	/* set verbosity */
+	noisy = (loglevel >= 3) ? 1 : hex;
+	verbose	= (loglevel >= 3)? 3: loglevel;
+
+	if ((prout_flag + prin_flag) == 0)
+	{
+		fprintf (stderr, "choose either '--in' or '--out' \n");
+		usage ();
+		ret = MPATH_PR_SYNTAX_ERROR;
+		goto out;
+	}
+	if ((prout_flag + prin_flag) > 1)
+	{
+		fprintf (stderr, "choose either '--in' or '--out' \n");
+		usage ();
+		ret = MPATH_PR_SYNTAX_ERROR;
+		goto out;
+	}
+	else if (prout_flag)
+	{				/* syntax check on PROUT arguments */
+		prin = 0;
+		if ((1 != num_prout_sa) || (0 != num_prin_sa))
+		{
+			fprintf (stderr, " For Persistent Reserve Out only one "
+					"appropriate\n service action must be "
+					"chosen \n");
+			ret = MPATH_PR_SYNTAX_ERROR;
+			goto out;
+		}
+	}
+	else if (prin_flag)
+	{				/* syntax check on PRIN arguments */
+		prout = 0;
+		if (num_prout_sa > 0)
+		{
+			fprintf (stderr, " When a service action for Persistent "
+					"Reserve Out is chosen the\n"
+					" '--out' option must be given \n");
+			ret = MPATH_PR_SYNTAX_ERROR;
+			goto out;
+		}
+		if (0 == num_prin_sa)
+		{
+			fprintf (stderr,
+					" No service action given for Persistent Reserve IN\n");
+			usage();
+			ret = MPATH_PR_SYNTAX_ERROR;
+		}
+		else if (num_prin_sa > 1)
+		{
+			fprintf (stderr, " Too many service actions given; choose "
+					"one only\n");
+			usage();
+			ret = MPATH_PR_SYNTAX_ERROR;
+		}
+	}
+	else
+	{
+		usage ();
+		ret = MPATH_PR_SYNTAX_ERROR;
+		goto out;
+	}
+
+	if ((param_rtp) && (MPATH_PROUT_REG_MOV_SA != prout_sa))
+	{
+		fprintf (stderr, " --relative-target-port"
+				" only useful with --register-move\n");
+		usage ();
+		ret = MPATH_PR_SYNTAX_ERROR;
+		goto out;
+	}
+
+	if (((MPATH_PROUT_RES_SA == prout_sa) ||
+				(MPATH_PROUT_REL_SA == prout_sa) ||
+				(MPATH_PROUT_PREE_SA == prout_sa) ||
+				(MPATH_PROUT_PREE_AB_SA == prout_sa)) &&
+			(0 == prout_type)) {
+		fprintf(stderr, "Warning: --prout-type probably needs to be "
+				"given\n");
+	}
+	if ((verbose > 2) && num_transportids)
+	{
+		fprintf (stderr, "number of tranport-ids decoded from "
+				"command line : %d\n", num_transportids);
+	}
+
+	if (device_name == NULL)
+	{
+		fprintf (stderr, "No device name given \n");
+		usage ();
+		ret = MPATH_PR_SYNTAX_ERROR;
+		goto out;
+	}
+
+	/* open device */
+	if ((fd = open (device_name, O_WRONLY)) < 0)
+	{
+		fprintf (stderr, "%s: error opening file (rw) fd=%d\n",
+				device_name, fd);
+		ret = MPATH_PR_FILE_ERROR;
+		goto out;
+	}
+
+
+	if (prin)
+	{
+		resp = mpath_alloc_prin_response(prin_sa);
+		if (!resp)
+		{
+			fprintf (stderr, "failed to allocate PRIN response buffer\n");
+			ret = MPATH_PR_OTHER;
+			goto out;
+		}
+
+		ret = mpath_persistent_reserve_in (fd, prin_sa, resp, noisy, verbose);
+		if (ret != MPATH_PR_SUCCESS )
+		{
+			fprintf (stderr, "Persistent Reserve IN command failed\n");
+			goto out;	
+		}
+
+		switch(prin_sa)
+		{			
+			case MPATH_PRIN_RKEY_SA: 
+				mpath_print_buf_readkeys(resp);		
+				break;
+			case MPATH_PRIN_RRES_SA: 
+				mpath_print_buf_readresv(resp);
+				break;
+			case MPATH_PRIN_RCAP_SA:
+				mpath_print_buf_readcap(resp);		
+				break;
+			case MPATH_PRIN_RFSTAT_SA:
+				mpath_print_buf_readfullstat(resp);		
+				break;
+		}
+		free(resp);
+	}
+	else if (prout)
+	{
+		int j; 
+		struct prout_param_descriptor *paramp;
+
+		paramp= malloc(sizeof(struct prout_param_descriptor) + (sizeof(struct transportid *)*(MPATH_MX_TIDS )));
+		
+		memset(paramp, 0, sizeof(struct prout_param_descriptor) + (sizeof(struct transportid *)*(MPATH_MX_TIDS)));
+
+		for (j = 7; j >= 0; --j) {
+			paramp->key[j] = (param_rk & 0xff);
+			param_rk >>= 8;
+		}
+
+		for (j = 7; j >= 0; --j) {
+			paramp->sa_key[j] = (param_sark & 0xff);
+			param_sark >>= 8;
+		}
+
+		if (param_alltgpt)
+			paramp->sa_flags |= 0x4;
+		if (param_aptpl)
+			paramp->sa_flags |= 0x1;
+
+		if (num_transport) 
+		{
+			paramp->sa_flags |= MPATH_F_SPEC_I_PT_MASK;
+			paramp->num_transportid = num_transport;
+			for (j = 0 ; j < num_transport; j++)
+			{
+				paramp->trnptid_list[j] = (struct transportid *)malloc(sizeof(struct transportid));
+				memcpy(paramp->trnptid_list[j], &transportids[j],sizeof(struct transportid));
+			}
+		}
+
+		/* PROUT commands other than 'register and move' */
+		ret = mpath_persistent_reserve_out (fd, prout_sa, 0, prout_type,
+				paramp, noisy, verbose);
+		for (j = 0 ; j < num_transport; j++)
+		{
+			tmp = paramp->trnptid_list[j];
+			free(tmp);
+		}
+		free(paramp);
+	}
+
+	if (ret != MPATH_PR_SUCCESS)
+	{
+		switch(ret)
+		{
+			case MPATH_PR_SENSE_UNIT_ATTENTION:
+				printf("persistent reserve out: scsi status: Unit Attention\n");
+				break;
+			case MPATH_PR_RESERV_CONFLICT:
+				printf("persistent reserve out: scsi status: Reservation Conflict\n");
+				break;
+		}
+		printf("PR out: command failed\n");
+	}
+
+	res = close (fd);
+	if (res < 0)
+	{
+		mpath_lib_exit();
+		return MPATH_PR_FILE_ERROR;
+	}
+
+out :
+	mpath_lib_exit();
+
+	return (ret >= 0) ? ret : MPATH_PR_OTHER;
+}
+
+int
+get_transportids_length(unsigned char * transportid_arr, int max_transportid, int num_transportids)
+{
+	int compact_len = 0;
+	unsigned char * ucp = transportid_arr;
+	int k, off, protocol_id, len;
+	for (k = 0, off = 0; ((k < num_transportids) && (k < max_transportid));
+			++k, off += MPATH_MX_TID_LEN) {
+		protocol_id = ucp[off] & 0xf;
+		if (5 == protocol_id) {
+			len = (ucp[off + 2] << 8) + ucp[off + 3] + 4;
+			if (len < 24)
+				len = 24;
+			if (off > compact_len)
+				memmove(ucp + compact_len, ucp + off, len);
+			compact_len += len;
+
+		} else {
+			if (off > compact_len)
+				memmove(ucp + compact_len, ucp + off, 24);
+			compact_len += 24;
+		}
+	}
+
+	return compact_len;
+}
+
+void mpath_print_buf_readkeys( struct prin_resp *pr_buff)
+{
+	int i,j,k, num;
+	unsigned char *keyp;
+	uint64_t prkey;
+	printf("  PR generation=0x%x, ", pr_buff->prin_descriptor.prin_readkeys.prgeneration);
+
+	num = pr_buff->prin_descriptor.prin_readkeys.additional_length / 8;
+	if (0 == num) {
+		printf("	0 registered reservation key.\n");
+		return;
+	}
+	else if (1 == num)
+		printf("	1 registered reservation key follows:\n");
+	else
+		printf("	%d registered reservation keys follow:\n", num);
+
+
+	keyp = (unsigned char *)&pr_buff->prin_descriptor.prin_readkeys.key_list[0];
+	for (i = 0; i < num ; i++)
+	{
+		prkey = 0;
+		for (j = 0; j < 8; ++j) {
+
+			if (j > 0)
+				prkey <<= 8;
+			prkey |= keyp[j];
+		}
+		printf("    0x%" PRIx64 "\n", prkey);
+		k=8*i+j;
+		keyp = (unsigned char *)&pr_buff->prin_descriptor.prin_readkeys.key_list[k];
+	}
+}
+
+void mpath_print_buf_readresv( struct prin_resp *pr_buff)
+{
+	int j, num, scope=0, type=0;
+	unsigned char *keyp;
+	uint64_t prkey;	
+
+	num = pr_buff->prin_descriptor.prin_readresv.additional_length / 8;
+	if (0 == num)
+	{
+		printf("  PR generation=0x%x, there is NO reservation held \n", pr_buff->prin_descriptor.prin_readresv.prgeneration);
+		return ;
+	}
+	else
+		printf("  PR generation=0x%x, Reservation follows:\n", pr_buff->prin_descriptor.prin_readresv.prgeneration);
+	keyp = (unsigned  char *)&pr_buff->prin_descriptor.prin_readkeys.key_list[0]; 
+	prkey = 0;
+	for (j = 0; j < 8; ++j) {
+		if (j > 0)
+			prkey <<= 8;
+		prkey |= keyp[j];
+	}
+
+	printf("   Key = 0x%" PRIx64 "\n", prkey);
+
+	scope = (pr_buff->prin_descriptor.prin_readresv.scope_type >> 4) &  0x0f;
+	type = pr_buff->prin_descriptor.prin_readresv.scope_type & 0x0f;
+
+	if (scope == 0)	
+		printf("  scope = LU_SCOPE, type = %s", pr_type_strs[type]);
+	else
+		printf("  scope = %d, type = %s", scope, pr_type_strs[type]);
+
+	printf("\n");
+
+}
+
+void mpath_print_buf_readcap( struct prin_resp *pr_buff)
+{
+	if ( pr_buff->prin_descriptor.prin_readcap.length <= 2 ) {
+		fprintf(stderr, "Unexpected response for PRIN Report "
+				"Capabilities\n");
+		return; //MALFORMED;
+	}
+
+	printf("Report capabilities response:\n");
+
+	printf("  Compatible Reservation Handling(CRH): %d\n", !!(pr_buff->prin_descriptor.prin_readcap.flags[0] & 0x10));
+	printf("  Specify Initiator Ports Capable(SIP_C): %d\n",!!(pr_buff->prin_descriptor.prin_readcap.flags[0] & 0x8));
+	printf("  All Target Ports Capable(ATP_C): %d\n",!!(pr_buff->prin_descriptor.prin_readcap.flags[0] & 0x4 ));
+	printf("  Persist Through Power Loss Capable(PTPL_C): %d\n",!!(pr_buff->prin_descriptor.prin_readcap.flags[0]));
+	printf("  Type Mask Valid(TMV): %d\n", !!(pr_buff->prin_descriptor.prin_readcap.flags[1] & 0x80));
+	printf("  Allow Commands: %d\n", !!(( pr_buff->prin_descriptor.prin_readcap.flags[1] >> 4) & 0x7));
+	printf("  Persist Through Power Loss Active(PTPL_A): %d\n",
+			!!(pr_buff->prin_descriptor.prin_readcap.flags[1] & 0x1));
+
+	if(pr_buff->prin_descriptor.prin_readcap.flags[1] & 0x80)
+	{
+		printf("    Support indicated in Type mask:\n");
+
+		printf("      %s: %d\n", pr_type_strs[7], pr_buff->prin_descriptor.prin_readcap.pr_type_mask & 0x80);
+		printf("      %s: %d\n", pr_type_strs[6], pr_buff->prin_descriptor.prin_readcap.pr_type_mask & 0x40);
+		printf("      %s: %d\n", pr_type_strs[5], pr_buff->prin_descriptor.prin_readcap.pr_type_mask & 0x20);
+		printf("      %s: %d\n", pr_type_strs[3], pr_buff->prin_descriptor.prin_readcap.pr_type_mask & 0x8);
+		printf("      %s: %d\n", pr_type_strs[1], pr_buff->prin_descriptor.prin_readcap.pr_type_mask & 0x2);
+		printf("      %s: %d\n", pr_type_strs[8], pr_buff->prin_descriptor.prin_readcap.pr_type_mask & 0x100);
+	}
+}
+
+void mpath_print_buf_readfullstat( struct prin_resp *pr_buff)
+{
+
+	int i,j, num;
+	uint64_t  prkey;
+	uint16_t  rel_pt_addr;
+	unsigned char * keyp;
+
+	num = pr_buff->prin_descriptor.prin_readfd.number_of_descriptor;	
+	if (0 == num)
+	{
+		printf("  PR generation=0x%x \n", pr_buff->prin_descriptor.prin_readfd.prgeneration);
+		return ;
+	}
+	else
+		printf("  PR generation=0x%x \n", pr_buff->prin_descriptor.prin_readfd.prgeneration);
+
+	for (i = 0 ; i < num; i++)
+	{
+		keyp = (unsigned  char *)&pr_buff->prin_descriptor.prin_readfd.descriptors[i]->key;
+
+		prkey = 0;
+		for (j = 0; j < 8; ++j) {
+			if (j > 0)
+				prkey <<= 8;
+			prkey |= *keyp;
+			++keyp;
+		}
+		printf("   Key = 0x%" PRIx64 "\n", prkey);
+
+		if (pr_buff->prin_descriptor.prin_readfd.descriptors[i]->flag & 0x02)	
+			printf("      All target ports bit set\n");
+		else {
+			printf("      All target ports bit clear\n");
+
+			rel_pt_addr = pr_buff->prin_descriptor.prin_readfd.descriptors[i]->rtpi;
+			printf("      Relative port address: 0x%x\n",
+					rel_pt_addr);
+		}
+
+		if (pr_buff->prin_descriptor.prin_readfd.descriptors[i]->flag & 0x1) {
+			printf("      << Reservation holder >>\n");
+			j = ((pr_buff->prin_descriptor.prin_readfd.descriptors[i]->scope_type>> 4) & 0xf);
+			if (0 == j)
+				printf("      scope: LU_SCOPE, ");
+			else
+				printf("      scope: %d ", j);
+			j = (pr_buff->prin_descriptor.prin_readfd.descriptors[i]->scope_type & 0xf);
+			printf(" type: %s\n", pr_type_strs[j]);
+		} else
+			printf("      not reservation holder\n");
+		mpath_print_transport_id(pr_buff->prin_descriptor.prin_readfd.descriptors[i]);
+	}
+}
+
+static void usage()
+{
+	fprintf(stderr,
+			"Usage: mpathpersist [OPTIONS] [DEVICE]\n"
+			" Options:\n"
+			"    --verbose|-v level         verbosity level\n"
+			"                   0           Critical messages\n"
+			"                   1           Error messages\n"
+			"                   2           Warning messages\n"
+			"                   3           Informational messages\n"
+			"                   4           Informational messages with trace enabled\n"
+			"    --clear|-C                 PR Out: Clear\n"
+			"    --device=DEVICE|-d DEVICE  query or change DEVICE\n"
+			"    --help|-h                  output this usage message\n"
+			"    --hex|-H                   output response in hex\n"
+			"    --in|-i                    request PR In command \n"
+			"    --out|-o                   request PR Out command\n"
+			"    --param-aptpl|-Z           PR Out parameter 'APTPL'\n"
+			"    --read-keys|-k             PR In: Read Keys\n"
+			"    --param-sark=SARK|-S SARK  PR Out parameter service "
+			"action\n"
+			"                               reservation key (SARK is in "
+			"hex)\n"
+			"    --preempt|-P               PR Out: Preempt\n"
+			"    --preempt-abort|-A         PR Out: Preempt and Abort\n"
+			"    --prout-type=TYPE|-T TYPE  PR Out command type\n"
+			"    --read-full-status|-s      PR In: Read Full Status\n"
+			"    --read-keys|-k             PR In: Read Keys\n"
+			"    --read-reservation|-r      PR In: Read Reservation\n"
+			"    --register|-G              PR Out: Register\n"
+			"    --register-ignore|-I       PR Out: Register and Ignore\n"
+			"    --release|-L               PR Out: Release\n"
+			"    --report-capabilities|-c   PR In: Report Capabilities\n"
+			"    --reserve|-R               PR Out: Reserve\n"
+			"    --transport-id=TIDS|-X TIDS  TransportIDs can be mentioned \n"
+			"                               in several forms\n"
+			" Examples:\n"
+			"     mpathpersist --out --register --param-sark=123abc --prout-type=5 /dev/mapper/mpath9\n"
+			"     mpathpersist -i -k /dev/mapper/mpath9\n"	);
+}
+
+void
+mpath_print_transport_id(struct prin_fulldescr *fdesc)
+{
+	switch (fdesc->trnptid.protocol_id) {
+		case MPATH_PROTOCOL_ID_FC:
+			printf("   FCP-2 ");
+			if (0 != fdesc->trnptid.format_code)
+				printf(" [Unexpected format code: %d]\n", 
+						fdesc->trnptid.format_code);
+			dumpHex((const char *)fdesc->trnptid.n_port_name, 8, 0);
+			break;
+		case MPATH_PROTOCOL_ID_ISCSI:
+			printf("   iSCSI ");
+			if (0 == fdesc->trnptid.format_code) {
+				printf("name: %.*s\n", (int)sizeof(fdesc->trnptid.iscsi_name),
+					fdesc->trnptid.iscsi_name);
+			}else if (1 == fdesc->trnptid.format_code){
+				printf("world wide unique port id: %.*s\n",
+						(int)sizeof(fdesc->trnptid.iscsi_name),
+						fdesc->trnptid.iscsi_name);
+			}else {
+				printf("  [Unexpected format code: %d]\n", fdesc->trnptid.format_code);
+				dumpHex((const char *)fdesc->trnptid.iscsi_name,
+					 (int)sizeof(fdesc->trnptid.iscsi_name), 0);
+			}
+			break;
+		case MPATH_PROTOCOL_ID_SAS:
+			printf("   SAS ");
+			 if (0 != fdesc->trnptid.format_code)
+                                printf(" [Unexpected format code: %d]\n",
+                                                fdesc->trnptid.format_code);
+                        dumpHex((const char *)fdesc->trnptid.sas_address, 8, 0);
+			break;
+		default:
+			return;
+	}
+}
+
+int
+construct_transportid(const char * lcp, struct transportid transid[], int num_transportids)
+{
+	unsigned char * tidp;
+	int k = 0;
+	int j, n, b, c, len, alen;
+	const char * ecp;
+	const char * isip;
+
+	if ((0 == memcmp("fcp,", lcp, 4)) ||
+			(0 == memcmp("FCP,", lcp, 4))) {
+		lcp += 4;
+		k = strspn(lcp, "0123456789aAbBcCdDeEfF");
+
+		len = strlen(lcp);
+		if (len != k) {
+			fprintf(stderr, "badly formed symbolic FCP TransportID: %s\n",
+					lcp);
+			return 1;
+		}
+		transid[num_transportids].format_code = MPATH_PROTOCOL_ID_FC;
+		transid[num_transportids].protocol_id = MPATH_WWUI_DEVICE_NAME;
+		for (k = 0, j = 0, b = 0; k < 16; ++k) {
+			c = lcp[k];
+			if (isdigit(c))
+				n = c - 0x30;
+			else if (isupper(c))
+				n = c - 0x37;
+			else
+				n = c - 0x57;
+			if (k & 1) {
+				transid[num_transportids].n_port_name[j] = b | n;
+				++j;
+			} else
+				b = n << 4;
+		}
+		goto my_cont_b;
+	}
+	if ((0 == memcmp("sas,", lcp, 4)) || (0 == memcmp("SAS,", lcp, 4))) {
+		lcp += 4;
+		k = strspn(lcp, "0123456789aAbBcCdDeEfF");
+		len =strlen(lcp);
+		if (len != k) {
+			fprintf(stderr, "badly formed symbolic SAS TransportID: %s\n",
+					lcp);
+			return 1;
+		}
+		transid[num_transportids].format_code = MPATH_PROTOCOL_ID_SAS;
+		transid[num_transportids].protocol_id = MPATH_WWUI_DEVICE_NAME;
+		memcpy(&transid[num_transportids].sas_address, lcp, 8);
+
+		goto my_cont_b;
+	}
+	if (0 == memcmp("iqn.", lcp, 4)) {
+		ecp = strpbrk(lcp, " \t");
+		isip = strstr(lcp, ",i,0x");
+		if (ecp && (isip > ecp))
+			isip = NULL;
+		len = ecp ? (ecp - lcp) : (int)strlen(lcp);
+		memset(&tidp, 0, 24);
+		transid[num_transportids].format_code = (isip ? MPATH_WWUI_PORT_IDENTIFIER:MPATH_WWUI_DEVICE_NAME);
+		transid[num_transportids].protocol_id = MPATH_PROTOCOL_ID_ISCSI;
+		alen = len + 1; /* at least one trailing null */
+		if (alen < 20)
+			alen = 20;
+		else if (0 != (alen % 4))
+			alen = ((alen / 4) + 1) * 4;
+		if (alen > 241) { /* sam5r02.pdf A.2 (Annex) */
+			fprintf(stderr, "iSCSI name too long, alen=%d\n", alen);
+			return 0;
+		}
+		transid[num_transportids].iscsi_name[1] = alen & 0xff;
+		memcpy(&transid[num_transportids].iscsi_name[2], lcp, len);
+		goto my_cont_b;
+	}
+my_cont_b:
+	if (k >= MPATH_MAX_PARAM_LEN) {
+		fprintf(stderr, "build_transportid: array length exceeded\n");
+		return 1;
+	}
+	return 0;
+}
+
diff --git a/mpathpersist/main.h b/mpathpersist/main.h
new file mode 100644
index 0000000..64686ec
--- /dev/null
+++ b/mpathpersist/main.h
@@ -0,0 +1,29 @@
+static struct option long_options[] = {
+	{"verbose", 1, 0, 'v'},
+	{"clear", 0, 0, 'C'},
+	{"device", 1, 0, 'd'},
+	{"help", 0, 0, 'h'},
+	{"hex", 0, 0, 'H'},
+	{"in", 0, 0, 'i'},
+	{"out", 0, 0, 'o'},
+	{"param-aptpl", 0, 0, 'Z'},
+	{"param-rk", 1, 0, 'K'},
+	{"param-sark", 1, 0, 'S'},
+	{"preempt", 0, 0, 'P'},
+	{"preempt-abort", 0, 0, 'A'},
+	{"prout-type", 1, 0, 'T'},
+	{"read-full-status", 0, 0, 's'},
+	{"read-keys", 0, 0, 'k'},
+	{"read-reservation", 0, 0, 'r'},
+	{"register", 0, 0, 'G'},
+	{"register-ignore", 0, 0, 'I'},
+	{"release", 0, 0, 'L'},
+	{"report-capabilities", 0, 0, 'c'},		
+	{"reserve", 0, 0, 'R'},
+	{"transport-id", 1, 0, 'X'},
+	{"alloc-length", 1, 0, 'l'},
+	{0, 0, 0, 0}
+};
+
+static void usage(void);
+
diff --git a/mpathpersist/mpathpersist.8 b/mpathpersist/mpathpersist.8
new file mode 100644
index 0000000..a47a82a
--- /dev/null
+++ b/mpathpersist/mpathpersist.8
@@ -0,0 +1,96 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.39.2.
+.TH MPATHPERSIST  "8" "April 2011" "mpathpersist" "User Commands"
+.SH NAME
+mpathpersist
+.SH SYNOPSIS
+.B mpathpersist
+[\fIOPTIONS\fR] [\fIDEVICE\fR]
+.SH DESCRIPTION
+.IP
+Options:
+.TP
+\fB\-\-verbose\fR|\-v level
+verbosity level
+.TP
+0
+Critical and error messages
+.TP
+1
+Warning messages
+.TP
+2
+Informational messages
+.TP
+3
+Informational messages with trace enabled
+.TP
+\fB\-\-clear\fR|\-C
+PR Out: Clear
+.TP
+\fB\-\-device\fR=\fIDEVICE\fR|\-d DEVICE
+query or change DEVICE
+.TP
+\fB\-\-help\fR|\-h
+output this usage message
+.TP
+\fB\-\-hex\fR|\-H
+output response in hex
+.TP
+\fB\-\-in\fR|\-i
+request PR In command
+.TP
+\fB\-\-out\fR|\-o
+request PR Out command
+.TP
+\fB\-\-param\-aptpl\fR|\-Z
+PR Out parameter 'APTPL'
+.TP
+\fB\-\-read\-keys\fR|\-k
+PR In: Read Keys
+.TP
+\fB\-\-param\-sark\fR=\fISARK\fR|\-S SARK
+PR Out parameter service action
+reservation key (SARK is in hex)
+.TP
+\fB\-\-preempt\fR|\-P
+PR Out: Preempt
+.TP
+\fB\-\-preempt\-abort\fR|\-A
+PR Out: Preempt and Abort
+.TP
+\fB\-\-prout\-type\fR=\fITYPE\fR|\-T TYPE
+PR Out command type
+.TP
+\fB\-\-read\-status\fR|\-s
+PR In: Read Full Status
+.TP
+\fB\-\-read\-keys\fR|\-k
+PR In: Read Keys
+.TP
+\fB\-\-read\-reservation\fR|\-r
+PR In: Read Reservation
+.TP
+\fB\-\-register\fR|\-G
+PR Out: Register
+.TP
+\fB\-\-register\-ignore\fR|\-I
+PR Out: Register and Ignore
+.TP
+\fB\-\-release\fR|\-L
+PR Out: Release
+.TP
+\fB\-\-report\-capabilities\fR|\-c
+PR In: Report Capabilities
+.TP
+\fB\-\-reserve\fR|\-R
+PR Out: Reserve
+.TP
+\fB\-\-transport\-id\fR=\fITIDS\fR|\-X TIDS
+TransportIDs can be mentioned
+in several forms
+.IP
+Examples:
+.IP
+mpathpersist \fB\-\-out\fR \fB\-\-register\fR \fB\-\-param\-sark\fR=\fI123abc\fR \fB\-\-prout\-type\fR=\fI5\fR /dev/mapper/mpath9
+mpathpersist \fB\-i\fR \fB\-k\fR /dev/mapper/mpath9
+.PP
diff --git a/multipath.conf.annotated b/multipath.conf.annotated
index 9be7a2d..c8e8218 100644
--- a/multipath.conf.annotated
+++ b/multipath.conf.annotated
@@ -27,14 +27,14 @@
 #	polling_interval 10
 #
 #	#
-#	# name    : selector
+#	# name    : path_selector
 #	# scope   : multipath & multipathd
 #	# desc    : the default path selector algorithm to use
 #	#           these algorithms are offered by the kernel multipath target
 #	# values  : "round-robin 0"
 #	# default : "round-robin 0"
 #	#
-#	selector	"round-robin 0"
+#	path_selector	"round-robin 0"
 #
 #	#
 #	# name    : path_grouping_policy
@@ -67,7 +67,7 @@
 #	# desc    : the default function to call to obtain a path 
 #	#           priority value. The ALUA bits in SPC-3 provide an
 #	#           exploitable prio value for example.
-#	# default : (null)
+#	# default : const
 #	#
 #	prio	"alua"
 #
@@ -211,6 +211,15 @@
 #	gid disk
 #
 #	#
+#	# name    : checker_timeout
+#	# scope   : multipath & multipathd
+#	# desc    : The timeout to use for path checkers that issue scsi
+#	#           commands with an explicit timeout, in seconds.
+#	# values  : n > 0
+#	# default : taken from /sys/block/sd<x>/device/timeout
+#	checker_timeout 60
+#
+#	#
 #	# name    : fast_io_fail_tmo
 #	# scope   : multipath & multipathd
 #	# desc    : The number of seconds the scsi layer will wait after a
@@ -229,6 +238,14 @@
 #	# values  : n > 0
 #	# default : determined by the OS
 #	dev_loss_tmo 600
+#	# name    : bindings_file
+#	# scope   : multipath
+#	# desc    : The location of the bindings file that is used with
+#	#           the user_friendly_names option.
+#	# values  : <full_pathname>
+#	# default : "/var/lib/multipath/bindings"
+#	bindings_file "/etc/multipath_bindings"
+#
 #}
 #	
 ##
diff --git a/multipath.conf.defaults b/multipath.conf.defaults
index 886a678..cbe7254 100644
--- a/multipath.conf.defaults
+++ b/multipath.conf.defaults
@@ -4,7 +4,7 @@
 #defaults {
 #	udev_dir		/dev
 #	polling_interval	5
-#	selector		"round-robin 0"
+#	path_selector		"round-robin 0"
 #	path_grouping_policy	failover
 #	getuid_callout		"/lib/udev/scsi_id --whitelisted --device=/dev/%n"
 #	prio			const
@@ -266,6 +266,22 @@
 #		prio_args		""
 #	}
 #	device {
+#		vendor			"FUJITSU"
+#		product			"ETERNUS_DX(L|400|8000)"
+#		getuid_callout		"/lib/udev/scsi_id --whitelisted --device=/dev/%n"
+#		features		"1 queue_if_no_path"
+#		hardware_handler	"0"
+#		path_selector		"round-robin 0"
+#		path_grouping_policy	group_by_prio
+#		failback		immediate
+#		rr_weight		uniform
+#		no_path_retry		10
+#		rr_min_io		1000
+#		path_checker		tur
+#		prio			alua
+#		prio_args		""
+#	}
+#	device {
 #		vendor			"(HITACHI|HP)"
 #		product			"OPEN-.*"
 #		getuid_callout		"/lib/udev/scsi_id --whitelisted --device=/dev/%n"
@@ -503,7 +519,7 @@
 #		rr_weight		uniform
 #		rr_min_io		128
 #		path_checker		directio
-#		prio			netapp
+#		prio			ontap
 #		prio_args		""
 #	}
 #	device {
@@ -534,7 +550,7 @@
 #		rr_weight		uniform
 #		rr_min_io		128
 #		path_checker		directio
-#		prio			netapp
+#		prio			ontap
 #		prio_args		""
 #	}
 #	device {
@@ -552,6 +568,47 @@
 #		prio_args		""
 #	}
 #	device {
+#		vendor			"IBM"
+#		product			"3303      NVDISK"
+#		getuid_callout		"/lib/udev/scsi_id --whitelisted --device=/dev/%n"
+#		features		"0"
+#		hardware_handler	"0"
+#               path_grouping_policy    failover
+#		failback		immediate
+#		no_path_retry		60
+#		rr_weight		uniform
+#		rr_min_io		1000
+#               path_checker            tur
+#	}
+#	device {
+#		vendor			"AIX"
+#		product			"VDASD"
+#		getuid_callout		"/lib/udev/scsi_id --whitelisted --device=/dev/%n"
+#		features		"0"
+#		hardware_handler	"0"
+#               path_grouping_policy    multibus
+#		failback		immediate
+#		no_path_retry		60
+#		rr_weight		uniform
+#		rr_min_io		1000
+#               path_checker            directio
+#	}
+#	device {
+#		vendor			"AIX"
+#		product			"NVDISK"
+#		getuid_callout		"/lib/udev/scsi_id --whitelisted --device=/dev/%n"
+#		features		"0"
+#		hardware_handler	"1 alua"
+#               path_grouping_policy    group_by_prio
+#		failback		immediate
+#		no_path_retry		60
+#		rr_weight		uniform
+#		rr_min_io		1000
+#		path_checker            tur
+#		prio			alua
+#		prio_args		""
+#	}
+#	device {
 #		vendor			"SGI"
 #		product			"TP9[13]00"
 #		getuid_callout		"/lib/udev/scsi_id --whitelisted --device=/dev/%n"
@@ -585,13 +642,13 @@
 #		vendor			"SGI"
 #		product			"IS.*"
 #		getuid_callout		"/lib/udev/scsi_id --whitelisted --device=/dev/%n"
-#		features		"0"
+#		features		"2 pg_init_retries 50"
 #		hardware_handler	"1 rdac"
 #		path_selector		"round-robin 0"
 #		path_grouping_policy	group_by_prio
 #		failback		immediate
 #		rr_weight		uniform
-#		no_path_retry		queue
+#		no_path_retry		15
 #		rr_min_io		1000
 #		path_checker		rdac
 #		prio			rdac
@@ -689,4 +746,31 @@
 #		prio			rdac
 #		prio_args		""
 #	}
+#	device {
+#		vendor			"EUROLOGC"
+#		product			"FC2502"
+#		getuid_callout		"/lib/udev/scsi_id --page=0x80 --whitelisted --device=/dev/%n"
+#		features                "0"
+#		hardware_handler        "0"
+#		path_selector           "round-robin 0"
+#		path_grouping_policy    group_by_prio
+#		rr_weight               uniform
+#		rr_min_io               1000
+#		path_checker		directio
+#		prio			const
+#	}
+#	device {
+#		vendor                  "NEC"
+#		product                 "DISK ARRAY"
+#		getuid_callout          "/lib/udev/scsi_id --whitelisted --device=/dev/%n"
+#		features                "0"
+#		hardware_handler        "1 alua"
+#		path_selector           "round-robin 0"
+#		path_grouping_policy    group_by_prio
+#		failback                immediate
+#		rr_weight               uniform
+#		rr_min_io               1000
+#		path_checker            tur
+#		prio                    alua
+#	}
 #}
diff --git a/multipath.conf.synthetic b/multipath.conf.synthetic
index 44d1329..bda1b75 100644
--- a/multipath.conf.synthetic
+++ b/multipath.conf.synthetic
@@ -5,7 +5,7 @@
 #defaults {
 #	udev_dir		/dev
 #	polling_interval 	10
-#	selector		"round-robin 0"
+#	path_selector		"round-robin 0"
 #	path_grouping_policy	multibus
 #	getuid_callout		"/lib/udev/scsi_id --whitelisted --device=/dev/%n"
 #	prio			const
diff --git a/multipath/Makefile b/multipath/Makefile
index 5cbab2f..f748417 100644
--- a/multipath/Makefile
+++ b/multipath/Makefile
@@ -7,7 +7,7 @@ include ../Makefile.inc
 OBJS = main.o
 
 CFLAGS += -I$(multipathdir)
-LDFLAGS += -lpthread -ldevmapper -ldl -lmultipath -L$(multipathdir)
+LDFLAGS += -lpthread -ldevmapper -ldl -L$(multipathdir) -lmultipath
 
 EXEC = multipath
 
diff --git a/multipath/dev_t.h b/multipath/dev_t.h
index 90c64f3..aa80d5e 100644
--- a/multipath/dev_t.h
+++ b/multipath/dev_t.h
@@ -1,15 +1,3 @@
-#define MINORBITS       20
-#define MINORMASK       ((1U << MINORBITS) - 1)
-
-#define MAJOR(dev)      ((unsigned int) ((dev) >> MINORBITS))
-#define MINOR(dev)      ((unsigned int) ((dev) & MINORMASK))
-#define MKDEV(ma,mi)    (((ma) << MINORBITS) | (mi))
-
-#define print_dev_t(buffer, dev)                                        \
-	sprintf((buffer), "%u:%u\n", MAJOR(dev), MINOR(dev))
-
-#define format_dev_t(buffer, dev)                                       \
-	({                                                              \
-		sprintf(buffer, "%u:%u", MAJOR(dev), MINOR(dev));       \
-		buffer;                                                 \
-	})
+#define MAJOR(dev)      ((dev & 0xfff00) >> 8)
+#define MINOR(dev)      ((dev & 0xff) | ((dev >> 12) & 0xfff00))
+#define MKDEV(ma,mi)    ((mi & 0xff) | (ma << 8) | ((mi & ~0xff) << 12))
diff --git a/multipath/main.c b/multipath/main.c
index 1689efd..2078fe3 100644
--- a/multipath/main.c
+++ b/multipath/main.c
@@ -22,6 +22,8 @@
  * Copyright (c) 2005 Edward Goggin, EMC
  */
 
+#include <sys/types.h>
+#include <sys/stat.h>
 #include <stdio.h>
 #include <unistd.h>
 #include <ctype.h>
@@ -51,6 +53,7 @@
 #include <errno.h>
 #include <sys/time.h>
 #include <sys/resource.h>
+#include "dev_t.h"
 
 int logsink;
 
@@ -79,9 +82,10 @@ usage (char * progname)
 {
 	fprintf (stderr, VERSION_STRING);
 	fprintf (stderr, "Usage:\n");
-	fprintf (stderr, "  %s [-d] [-r] [-v lvl] [-p pol] [-b fil] [dev]\n", progname);
+	fprintf (stderr, "  %s [-d] [-r] [-v lvl] [-p pol] [-b fil] [-q] [dev]\n", progname);
 	fprintf (stderr, "  %s -l|-ll|-f [-v lvl] [-b fil] [dev]\n", progname);
 	fprintf (stderr, "  %s -F [-v lvl]\n", progname);
+	fprintf (stderr, "  %s -t\n", progname);
 	fprintf (stderr, "  %s -h\n", progname);
 	fprintf (stderr,
 		"\n"
@@ -91,7 +95,9 @@ usage (char * progname)
 		"  -ll     show multipath topology (maximum info)\n" \
 		"  -f      flush a multipath device map\n" \
 		"  -F      flush all multipath device maps\n" \
+		"  -q      allow queue_if_no_path when multipathd is not running\n"\
 		"  -d      dry run, do not create or update devmaps\n" \
+		"  -t      dump internal hardware table\n" \
 		"  -r      force devmap reload\n" \
 		"  -p      policy failover|multibus|group_by_serial|group_by_prio\n" \
 		"  -b fil  bindings file location\n" \
@@ -113,7 +119,6 @@ usage (char * progname)
 		"          . multipath including the path with maj:min 'dev' (ex: 8:0)\n" \
 		);
 
-	exit(1);
 }
 
 static int
@@ -132,7 +137,8 @@ update_paths (struct multipath * mpp)
 
 		vector_foreach_slot (pgp->paths, pp, j) {
 			if (!strlen(pp->dev)) {
-				if (devt2devname(pp->dev, pp->dev_t)) {
+				if (devt2devname(pp->dev, FILE_NAME_SIZE,
+						 pp->dev_t)) {
 					/*
 					 * path is not in sysfs anymore
 					 */
@@ -160,6 +166,7 @@ get_dm_mpvec (vector curmp, vector pathvec, char * refwwid)
 {
 	int i;
 	struct multipath * mpp;
+	char params[PARAMS_SIZE], status[PARAMS_SIZE];
 
 	if (dm_get_maps(curmp))
 		return 1;
@@ -177,10 +184,12 @@ get_dm_mpvec (vector curmp, vector pathvec, char * refwwid)
 			continue;
 		}
 
-		condlog(3, "params = %s", mpp->params);
-		condlog(3, "status = %s", mpp->status);
+		dm_get_map(mpp->alias, &mpp->size, params);
+		condlog(3, "params = %s", params);
+		dm_get_status(mpp->alias, status);
+		condlog(3, "status = %s", status);
 
-		disassemble_map(pathvec, mpp->params, mpp);
+		disassemble_map(pathvec, params, mpp);
 
 		/*
 		 * disassemble_map() can add new paths to pathvec.
@@ -193,7 +202,7 @@ get_dm_mpvec (vector curmp, vector pathvec, char * refwwid)
 		if (conf->list > 1)
 			mpp->bestpg = select_path_group(mpp);
 
-		disassemble_status(mpp->status, mpp);
+		disassemble_status(status, mpp);
 
 		if (conf->list)
 			print_multipath_topology(mpp, conf->verbosity);
@@ -245,14 +254,14 @@ configure (void)
 		else
 			dev = conf->dev;
 	}
-	
+
 	/*
 	 * if we have a blacklisted device parameter, exit early
 	 */
-	if (dev && 
+	if (dev &&
 	    (filter_devnode(conf->blist_devnode, conf->elist_devnode, dev) > 0))
 			goto out;
-	
+
 	/*
 	 * scope limiting must be translated into a wwid
 	 * failing the translation is fatal (by policy)
@@ -319,13 +328,78 @@ out:
 	return r;
 }
 
+static int
+dump_config (void)
+{
+	char * c;
+	char * reply;
+	unsigned int maxlen = 256;
+	int again = 1;
+
+	reply = MALLOC(maxlen);
+
+	while (again) {
+		if (!reply)
+			return 1;
+		c = reply;
+		c += snprint_defaults(c, reply + maxlen - c);
+		again = ((c - reply) == maxlen);
+		if (again) {
+			reply = REALLOC(reply, maxlen *= 2);
+			continue;
+		}
+		c += snprint_blacklist(c, reply + maxlen - c);
+		again = ((c - reply) == maxlen);
+		if (again) {
+			reply = REALLOC(reply, maxlen *= 2);
+			continue;
+		}
+		c += snprint_blacklist_except(c, reply + maxlen - c);
+		again = ((c - reply) == maxlen);
+		if (again) {
+			reply = REALLOC(reply, maxlen *= 2);
+			continue;
+		}
+		c += snprint_hwtable(c, reply + maxlen - c, conf->hwtable);
+		again = ((c - reply) == maxlen);
+		if (again) {
+			reply = REALLOC(reply, maxlen *= 2);
+			continue;
+		}
+		c += snprint_mptable(c, reply + maxlen - c, conf->mptable);
+		again = ((c - reply) == maxlen);
+		if (again)
+			reply = REALLOC(reply, maxlen *= 2);
+	}
+
+	printf("%s", reply);
+	FREE(reply);
+	return 0;
+}
+
+static int
+get_dev_type(char *dev) {
+	struct stat buf;
+	int i;
+
+	if (stat(dev, &buf) == 0 && S_ISBLK(buf.st_mode)) {
+		if (dm_is_dm_major(MAJOR(buf.st_rdev)))
+			return DEV_DEVMAP;
+		return DEV_DEVNODE;
+	}
+	else if (sscanf(dev, "%d:%d", &i, &i) == 2)
+		return DEV_DEVT;
+	else
+		return DEV_DEVMAP;
+}
+
 int
 main (int argc, char *argv[])
 {
 	int arg;
 	extern char *optarg;
 	extern int optind;
-	int i, r = 1;
+	int r = 1;
 
 	if (getuid() != 0) {
 		fprintf(stderr, "need to be root\n");
@@ -338,31 +412,31 @@ main (int argc, char *argv[])
 	if (load_config(DEFAULT_CONFIGFILE))
 		exit(1);
 
-	if (init_checkers()) {
-		condlog(0, "failed to initialize checkers");
-		exit(1);
-	}
-	if (init_prio()) {
-		condlog(0, "failed to initialize prioritizers");
-		exit(1);
-	}
 	if (sysfs_init(conf->sysfs_dir, FILE_NAME_SIZE)) {
 		condlog(0, "multipath tools need sysfs mounted");
 		exit(1);
 	}
-	while ((arg = getopt(argc, argv, ":dhl::FfM:v:p:b:r")) != EOF ) {
+	while ((arg = getopt(argc, argv, ":dhl::FfM:v:p:b:Brtq")) != EOF ) {
 		switch(arg) {
 		case 1: printf("optarg : %s\n",optarg);
 			break;
 		case 'v':
 			if (sizeof(optarg) > sizeof(char *) ||
-			    !isdigit(optarg[0]))
+			    !isdigit(optarg[0])) {
 				usage (argv[0]);
+				exit(1);
+			}
 
 			conf->verbosity = atoi(optarg);
 			break;
 		case 'b':
-			conf->bindings_file = optarg;
+			conf->bindings_file = strdup(optarg);
+			break;
+		case 'B':
+			conf->bindings_read_only = 1;
+			break;
+		case 'q':
+			conf->allow_queueing = 1;
 			break;
 		case 'd':
 			conf->dry_run = 1;
@@ -391,23 +465,31 @@ main (int argc, char *argv[])
 			if (conf->pgpolicy_flag == -1) {
 				printf("'%s' is not a valid policy\n", optarg);
 				usage(argv[0]);
-			}                
+				exit(1);
+			}
 			break;
 		case 'r':
 			conf->force_reload = 1;
 			break;
+		case 't':
+			r = dump_config();
+			goto out;
 		case 'h':
 			usage(argv[0]);
+			exit(0);
 		case ':':
 			fprintf(stderr, "Missing option arguement\n");
-			usage(argv[0]);        
+			usage(argv[0]);
+			exit(1);
 		case '?':
 			fprintf(stderr, "Unknown switch: %s\n", optarg);
 			usage(argv[0]);
+			exit(1);
 		default:
 			usage(argv[0]);
+			exit(1);
 		}
-	}        
+	}
 	if (optind < argc) {
 		conf->dev = MALLOC(FILE_NAME_SIZE);
 
@@ -415,14 +497,7 @@ main (int argc, char *argv[])
 			goto out;
 
 		strncpy(conf->dev, argv[optind], FILE_NAME_SIZE);
-
-		if (filepresent(conf->dev))
-			conf->dev_type = DEV_DEVNODE;
-		else if (sscanf(conf->dev, "%d:%d", &i, &i) == 2)
-			conf->dev_type = DEV_DEVT;
-		else
-			conf->dev_type = DEV_DEVMAP;
-
+		conf->dev_type = get_dev_type(conf->dev);
 	}
 	conf->daemon = 0;
 
@@ -436,6 +511,14 @@ main (int argc, char *argv[])
 				conf->max_fds, strerror(errno));
 	}
 
+	if (init_checkers()) {
+		condlog(0, "failed to initialize checkers");
+		exit(1);
+	}
+	if (init_prio()) {
+		condlog(0, "failed to initialize prioritizers");
+		exit(1);
+	}
 	dm_init();
 
 	if (conf->remove == FLUSH_ONE) {
@@ -452,9 +535,9 @@ main (int argc, char *argv[])
 	}
 	while ((r = configure()) < 0)
 		condlog(3, "restart multipath configuration process");
-	
+
 out:
-	dm_udev_wait(conf->cookie);
+	udev_wait(conf->cookie);
 
 	sysfs_cleanup();
 	dm_lib_release();
diff --git a/multipath/multipath.8 b/multipath/multipath.8
index 7ba7126..a112df7 100644
--- a/multipath/multipath.8
+++ b/multipath/multipath.8
@@ -6,7 +6,7 @@ multipath \- Device mapper target autoconfig
 .RB [\| \-v\ \c
 .IR verbosity \|]
 .RB [\| \-d \|]
-.RB [\| \-h | \-l | \-ll | \-f | \-F \|]
+.RB [\| \-h | \-l | \-ll | \-f | \-t | \-F \| \-B \|]
 .RB [\| \-p\ \c
 .BR failover | multibus | group_by_serial | group_by_prio | group_by_node_name \|]
 .RB [\| device \|]
@@ -47,8 +47,17 @@ flush a multipath device map specified as parameter, if unused
 .B \-F
 flush all unused multipath device maps
 .TP
+.B \-t
+print internal hardware table to stdout
+.TP
+.B \-r
+force devmap reload
+.TP
+.B \-B
+treat the bindings file as read only
+.TP
 .BI \-p " policy"
-force maps to specified policy:
+force new maps to use the specified policy:
 .RS 1.2i
 .TP 1.2i
 .B failover
@@ -64,8 +73,11 @@ all paths in 1 priority group
 1 priority group per priority value. Priorities are determined by callout programs specified as a global, per-controller or per-multipath option in the configuration file
 .TP
 .B group_by_node_name
-1 priority group per target node name. Target node names are fetched in /sys/class/fc_transport/target*/node_name.
+1 priority group per target node name. Target node names are fetched
+in /sys/class/fc_transport/target*/node_name.
+.TP
 .RE
+Existing maps are not modified.
 .TP
 .BI device
 update only the devmap the path pointed by
@@ -76,6 +88,9 @@ is in the /dev/sdb (as shown by udev in the $DEVNAME variable) or major:minor fo
 .I device
 may alternatively be a multipath mapname
 .SH "SEE ALSO"
+.BR multipathd (8),
+.BR multipath.conf (5),
+.BR kpartx (8),
 .BR udev (8),
 .BR dmsetup (8)
 .BR hotplug (8)
diff --git a/multipath/multipath.conf.5 b/multipath/multipath.conf.5
index 165982e..dfaf532 100644
--- a/multipath/multipath.conf.5
+++ b/multipath/multipath.conf.5
@@ -40,7 +40,8 @@ The following \fIsection\fP keywords are recognized:
 .TP 17
 .B defaults
 This section defines default values for attributes which are used
-whenever no specific setting is given.
+whenever no values are given in the appropriate device or multipath
+sections.
 .TP
 .B blacklist
 This section defines which devices should be excluded from the
@@ -67,24 +68,53 @@ The
 section recognizes the following keywords:
 .TP 17
 .B polling_interval
-interval between two path checks in seconds For properly functioning paths,
-the interval between checks will gradually increase to (4 * polling_interval);
+interval between two path checks in seconds. For properly functioning paths,
+the interval between checks will gradually increase to
+.B max_polling_interval;
 default is
 .I 5
 .TP
+.B max_polling_interval
+maximal interval between two path checks in seconds; default is
+.I 4 * polling_interval
+.TP
 .B udev_dir
 directory where udev creates its device nodes; default is
 .I /dev
 .TP
+.B multipath_dir
+directory where the dynamic shared objects are stored; default is system
+dependent, commonly
+.I /lib/multipath
+.TP
 .B verbosity
 default verbosity. Higher values increase the verbosity level. Valid
 levels are between 0 and 6; default is
 .I 2
 .TP
-.B selector
+.B reassign_maps
+enable reassigning of device-mapper maps. With this option multipathd
+will remap existing device-mapper maps to always point to multipath
+device, not the underlying block devices. Possible values are
+\fIyes\fR and \fIno\fR. Default is
+.I yes
+.TP
+.B path_selector
 The default path selector algorithm to use; they are offered by the
-kernel multipath target. The only currently implemented is
-.I "round-robin 0"
+kernel multipath target. There are three selector algorithms.
+.RS
+.TP 12
+.B "round-robin 0"
+Loop through every path in the path group, sending the same amount of IO to
+each.
+.TP
+.B "queue-length 0"
+Send the next bunch of IO down the path with the least amount of outstanding IO.
+.TP
+.B "service-time 0"
+Choose the path for the next bunch of IO based on the amount of outstanding IO
+to the path and its relative throughput.
+.RE
 .TP
 .B path_grouping_policy
 The default path grouping policy to apply to unspecified
@@ -116,58 +146,85 @@ Default value is \fImultibus\fR.
 The default program and args to callout to obtain a unique path
 identifier. Should be specified with an absolute path. Default value
 is
-.I /lib/udev/scsi_id --whitelisted --device=/dev/%n
-.TP
-.B prio_callout
-The default program and args to callout to obtain a path priority
-value. The specified program will be executed and should return a
-numeric value specifying the relative priority of this path. Higher
-number have a higher priority. A '%n' in the command line will be expanded
-to the device name, a '%b' will be expanded to the device number in
-.I major:minor
-format.
+.I /lib/udev/scsi_id --whitelisted --replace-whitespace --device=/dev/%n
+.TP
+.B prio
+The name of the path priority routine. The specified routine
+should return a numeric value specifying the relative priority
+of this path. Higher number have a higher priority.
 .I "none"
-is a valid value. Currently the following path priority programs are
-implemented:
+is a valid value. Currently the following path priority routines
+are implemented:
 .RS
 .TP 12
-.B mpath_prio_emc /dev/%n
-Generate the path priority for EMC arrays
+.B const
+Return a constant priority of \fI1\fR.
+.TP
+.B emc
+Generate the path priority for EMC arrays.
 .TP
-.B mpath_prio_alua /dev/%n
+.B alua
 Generate the path priority based on the SCSI-3 ALUA settings.
 .TP
-.B mpath_prio_netapp /dev/%n
+.B ontap
 Generate the path priority for NetApp arrays.
 .TP
-.B mpath_prio_rdac /dev/%n
-Generate the path priority for LSI/Engenio RDAC controller.
+.B rdac
+Generate the path priority for LSI/Engenio/NetApp E-Series RDAC controller.
 .TP
-.B mpath_prio_hp_sw /dev/%n
+.B hp_sw
 Generate the path priority for Compaq/HP controller in
 active/standby mode.
 .TP
-.B mpath_prio_hds_modular %b
+.B hds
 Generate the path priority for Hitachi HDS Modular storage arrays.
 .TP
+.B random
+Generate a random priority between 1 and 10.
+.TP 12
+.B weightedpath
+Generate the path priority based on the regular expression and the 
+priority provided as argument. requires prio_args keyword.
+.TP
 Default value is \fBnone\fR.
 .RE
 .TP
+.B prio_args
+Arguments to pass to to the prio function.  Currently only used with
+.I weighted, which needs a value of the form
+.I "<hbtl|devname> <regex1> <prio1> <regex2> <prio2> ..."
+.I hbtl
+regex can be of SCSI H:B:T:L format  Ex: 1:0:.:. , *:0:0:.
+.I devname
+regex can be of device name format  Ex: sda , sd.e
+.TP
 .B features
-Specify any device-mapper features to be used. The most common of
-these features is
-.I "1 queue_if_no_path" 
-Note that this can also be set via the
+Specify any device-mapper features to be used. Syntax is
+.I num list
+where
+.I num
+is the number of features in
+.I list.
+Possible values for the feature list are
+.RS
+.TP 12
+.B queue_if_no_path
+Queue IO if no path is active; identical to the
 .I no_path_retry
 keyword.
 .TP
+.B no_partitions
+Disable automatic partitions generation via kpartx.
+.RE
+.TP
 .B path_checker
-The default method used to determine the paths' state. Possible values
+The default method used to determine the paths state. Possible values
 are
 .RS
 .TP 12
 .B readsector0
-Read the first sector of the device
+(Deprecated) Read the first sector of the device. This checker is being
+deprecated, please use \fIdirectio\fR instead
 .TP
 .B tur
 Issue a
@@ -182,28 +239,42 @@ state.
 Check the path state for HP storage arrays with Active/Standby firmware.
 .TP
 .B rdac
-Check the path state for LSI/Engenio RDAC storage controller.
+Check the path state for LSI/Engenio/NetApp E-Series RDAC storage controller.
 .TP
 .B directio
 Read the first sector with direct I/O.
 .TP
-Default value is \fIreadsector0\fR.
+Default value is \fIdirectio\fR.
 .RE
 .TP
 .B failback
-Tell the daemon to manage path group failback, or not to. 0 or
-.I immediate
-means immediate failback, values >0 means deferred failback (in
-seconds).
-.I manual
-means no failback. Default value is
-.I manual
+Tell multipathd how to manage path group failback.
+.RS
+.TP 12
+.B immediate
+Immediately failback to the highest priority pathgroup that contains
+active paths.
+.TP
+.B manual
+Do not perform automatic failback.
+.TP
+.B values > 0
+deferred failback (time to defer in seconds)
+.TP
+Default value is \fImanual\fR.
+.RE
 .TP
 .B  rr_min_io
 The number of IO to route to a path before switching to the next in
-the same path group. Default is
+the same path group. This is only for BIO based multipath. Default is
 .I 1000
 .TP
+.B rr_min_io_q
+The number of IO requests to route to a path before switching to the
+next in the same path group. This is only for request based multipath.
+Default is
+.I 1
+.TP
 .B rr_weight
 If set to \fIpriorities\fR the multipath configurator will assign
 path weights as "path prio * rr_min_io". Possible values are
@@ -233,6 +304,13 @@ be overriden by any specific aliases in the \fImultipaths\fR section.
 Default is
 .I no
 .TP
+.B flush_on_last_del
+If set to
+.I yes
+, multipathd will disable queueing when the last path to a device has been
+deleted. Default is
+.I no
+.TP
 .B max_fds
 Specify the maximum number of file descriptors that can be opened by multipath
 and multipathd.  This is equivalent to ulimit -n. A value of \fImax\fR will set
@@ -241,6 +319,11 @@ maximum number of open fds is taken from the calling process. It is usually
 1024. To be safe, this should be set to the maximum number of paths plus 32,
 if that number is greated than 1024.
 .TP
+.B checker_timeout
+Specify the timeout to user for path checkers that issue scsi commands with an
+explict timeout, in seconds; default taken from
+.I /sys/block/sd<x>/device/timeout
+.TP
 .B fast_io_fail_tmo
 Specify the number of seconds the scsi layer will wait after a problem has been
 detected on a FC remote port before failing IO to devices on that remote port.
@@ -250,7 +333,9 @@ will disable the timeout.
 .TP
 .B dev_loss_tmo
 Specify the number of seconds the scsi layer will wait after a problem has
-been detected on a FC remote port before removing it from the system.
+been detected on a FC remote port before removing it from the system. This
+can be set to "infinity" which sets it to the max value of 2147483647
+seconds, or 68 years.
 .TP
 .B queue_without_daemon
 If set to
@@ -264,6 +349,19 @@ cannot be told to stop queueing IO. Setting queue_without_daemon to
 .I no
 , avoids this problem. Default is
 .I yes
+.TP
+.B bindings_file
+The full pathname of the binding file to be used when the user_friendly_names option is set. Defaults to
+.I /var/lib/multipath/bindings
+.TP
+.B log_checker_err
+If set to
+.I once
+, multipathd logs the first path checker error at logging level 2. Any later
+errors are logged at level 3 until the device is restored. If set to
+.I always
+, multipathd always logs the path checker error at logging level 2. Default is
+.I always
 .
 .SH "blacklist section"
 The
@@ -335,6 +433,8 @@ Index of the container. Mandatory for this subsection.
 The following attributes are optional; if not set the default values
 are taken from the
 .I defaults
+or
+.I devices
 section:
 .sp 1
 .PD .1v
@@ -344,11 +444,23 @@ section:
 .TP
 .B path_selector
 .TP
+.B prio
+.TP
+.B prio_args
+.TP
 .B failback
 .TP
+.B rr_weight
+.TP
+.B flush_on_last_del
+.TP
 .B no_path_retry
 .TP
 .B rr_min_io
+.TP
+.B rr_min_io_q
+.TP
+.B features
 .RE
 .PD
 .LP
@@ -369,8 +481,15 @@ subsection recognizes the following attributes:
 .B product
 (Mandatory) Product identifier
 .TP
+.B revision
+(Optional) Revision identfier
+.TP
 .B product_blacklist
-Product strings to blacklist for this vendor
+(Optional) Product strings to blacklist for this vendor
+.TP
+.B alias_prefix
+(Optional) The user_friendly_names prefix to use for this
+device type, instead of the default "mpath"
 .TP
 .B hardware_handler
 (Optional) The hardware handler to use for this device type.
@@ -379,6 +498,16 @@ The following hardware handler are implemented:
 .TP 12
 .B 1 emc
 Hardware handler for EMC storage arrays.
+.TP
+.B 1 rdac
+Hardware handler for LSI/Engenio/NetApp E-Series RDAC storage controller.
+.TP
+.B 1 hp_sw
+Hardware handler for Compaq/HP storage arrays in active/standby
+mode.
+.TP
+.B 1 alua
+Hardware handler for SCSI-3 ALUA compatible arrays.
 .RE
 .LP
 The following attributes are optional; if not set the default values
@@ -397,9 +526,11 @@ section:
 .TP
 .B path_checker
 .TP
-.B features
+.B prio
 .TP
-.B prio_callout
+.B prio_args
+.TP
+.B features
 .TP
 .B failback
 .TP
@@ -409,9 +540,13 @@ section:
 .TP
 .B rr_min_io
 .TP
+.B rr_min_io_rq
+.TP
 .B fast_io_fail_tmo
 .TP
 .B dev_loss_tmo
+.TP
+.B flush_on_last_del
 .RE
 .PD
 .LP
@@ -424,6 +559,20 @@ processes being hung and not killable in situations where all the paths to the L
 It is advisable to use the
 .B no_path_retry
 option instead.
+.P
+The use of
+.B queue_if_no_path
+or
+.B no_path_retry
+might lead to a deadlock if the
+.B dev_loss_tmo
+setting results in a device being removed while I/O is still queued.
+The multipath daemon will update the
+.B dev_loss_tmo
+setting accordingly to avoid this deadlock. Hence if both values are
+specified the order of precedence is
+.I no_path_retry, queue_if_no_path, dev_loss_tmo
+
 .SH "SEE ALSO"
 .BR udev (8),
 .BR dmsetup (8)
diff --git a/multipath/multipath.init.suse b/multipath/multipath.init.suse
new file mode 100644
index 0000000..cc7c04b
--- /dev/null
+++ b/multipath/multipath.init.suse
@@ -0,0 +1,158 @@
+#! /bin/sh
+# Copyright (c) 2005 SuSE GmbH Nuernberg, Germany.
+#
+# Author: Hannes Reinecke <feedback@suse.de>
+#
+# init.d/boot.multipath
+#
+### BEGIN INIT INFO
+# Provides:          boot.multipath
+# Required-Start:    boot.device-mapper boot.udev
+# Required-Stop:     boot.device-mapper boot.udev
+# Should-Start:      boot.xdrsetsite
+# Should-Stop:       boot.xdrsetsite
+# Default-Start:     B
+# Default-Stop:
+# Short-Description:       Create multipath device targets
+# Description:       Setup initial multipath device-mapper targets
+### END INIT INFO
+
+PATH=/bin:/usr/bin:/sbin:/usr/sbin
+PROGRAM=/sbin/multipath
+
+# Set the maximum number of open files
+MAX_OPEN_FDS=4096
+
+# Number of seconds to wait for disks and partitions
+MPATH_DEVICE_TIMEOUT=30
+
+test -x $PROGRAM || exit 5
+
+# Shell functions sourced from /etc/rc.status:
+#      rc_check         check and set local and overall rc status
+#      rc_status        check and set local and overall rc status
+#      rc_status -v     ditto but be verbose in local rc status
+#      rc_status -v -r  ditto and clear the local rc status
+#      rc_failed        set local and overall rc status to failed
+#      rc_reset         clear local rc status (overall remains)
+#      rc_exit          exit appropriate to overall rc status
+. /etc/rc.status
+
+# First reset status of this service
+rc_reset
+
+# Return values acc. to LSB for all commands but status:
+# 0 - success
+# 1 - misc error
+# 2 - invalid or excess args
+# 3 - unimplemented feature (e.g. reload)
+# 4 - insufficient privilege
+# 5 - program not installed
+# 6 - program not configured
+# 7 - program is not running
+# 
+# Note that starting an already running service, stopping
+# or restarting a not-running service as well as the restart
+# with force-reload (in case signalling is not supported) are
+# considered a success.
+
+case "$1" in
+    start)
+	# Check for existing multipath mappings
+	if dmsetup table --target multipath | grep -q multipath ; then
+	    # Multipath active, start daemon
+	    exec /etc/init.d/multipathd $1
+	fi
+
+	echo -n "Creating multipath targets:"
+	# Check whether multipath daemon is already running
+	if /sbin/multipathd -k"list paths" > /dev/null 2>&1 ; then
+	    echo -n " (multipathd running)"
+	    rc_status -v
+	    rc_exit
+	fi
+	# Load prerequisite module
+	modprobe dm-multipath
+	
+	# Set the maximum number of open files
+	if [ -n "$MAX_OPEN_FDS" ] ; then
+	    ulimit -n $MAX_OPEN_FDS
+	fi
+
+	# Start the program directly as checkproc doesn't work here
+	$PROGRAM -v 0
+	echo -n " (waiting for udev)"
+	# Wait for all multipathed devices to appear
+	maplist=$(/sbin/dmsetup ls --target multipath | sed '/No devices/d' | sed -n 's/\(^[^ ()]*\)[\t ]*.*/\1/p')
+	wait=$MPATH_DEVICE_TIMEOUT
+	while [ $wait -gt 0 ] ; do
+	    num=0
+	    for map in $maplist; do
+		[ -e /dev/disk/by-id/dm-name-$map ] && continue
+		num=$((num + 1))
+	    done
+	    [ $num -eq 0 ] && break
+	    wait=$((wait - 1))
+	    sleep 1;
+	done
+	if [ $wait -le 0 ] ; then
+	    echo -n " timeout: $num devices left"
+	    rc_failed 1
+	else
+	    # Reset to wait for partitions
+	    wait=$MPATH_DEVICE_TIMEOUT
+	fi
+        # Wait for all partitions on multipathed devices
+	while [ $wait -gt 0 ] ; do
+	    num=0
+	    for map in $maplist ; do
+		[ -e /dev/disk/by-id/dm-name-$map ] || continue
+		partlist=$(/sbin/kpartx -l -p _part /dev/disk/by-id/dm-name-$map | sed 's/\([^ ]*\) :.*/\1/p')
+		for part in $partlist; do
+		    [ -e /dev/disk/by-id/dm-name-$part ] && continue
+		    num$((num + 1))
+		done
+	    done
+	    [ $num -eq 0 ] && break
+	    wait=$((wait - 1))
+	    sleep 1;
+	done
+	if [ $wait -le 0 ] ; then
+	    echo -n "timeout: $num partitions left"
+	    rc_failed 1
+	fi
+
+	# Remember status and be verbose
+	rc_status -v
+	;;
+    stop)
+	echo -n "Removing multipath targets:"
+
+	# Flush all existing maps
+	$PROGRAM -F
+
+	rc_failed 0
+	rc_status -v
+	;;
+    status)
+	echo -n "Checking multipath targets: "
+	# Display active multipath tables
+	tblnum=$(/sbin/dmsetup ls --target multipath | sed '/No devices/d' | wc --lines)
+	if [ "$tblnum" ] && [ $tblnum -gt 0 ] ; then
+	    echo -n "($tblnum multipath devices) "
+	    rc_failed 0
+	else
+	    rc_failed 3
+	fi
+	rc_status -v
+	;;
+    reload)
+	$0 stop
+	$0 start
+	;;
+    *)
+	echo "Usage: $0 {start|stop|status}"
+	exit 1
+	;;
+esac
+rc_exit
diff --git a/multipathd/Makefile b/multipathd/Makefile
index 32d9ef5..1d4ea14 100644
--- a/multipathd/Makefile
+++ b/multipathd/Makefile
@@ -5,9 +5,9 @@ include ../Makefile.inc
 #
 # basic flags setting
 #
-CFLAGS += -I$(multipathdir)
+CFLAGS += -I$(multipathdir) -I$(mpathpersistdir)
 LDFLAGS += -lpthread -ldevmapper -lreadline -lncurses -ldl \
-	   -lmultipath -L$(multipathdir)
+	   -L$(multipathdir) -lmultipath -L$(mpathpersistdir) -lmpathpersist
 
 #
 # debuging stuff
@@ -28,13 +28,15 @@ OBJS = main.o pidfile.o uxlsnr.o uxclnt.o cli.o cli_handlers.o
 all : $(EXEC)
 
 $(EXEC): $(OBJS)
-	$(CC) $(CFLAGS) $(LDFLAGS) -o $(EXEC) $(OBJS)
+	$(CC) $(CFLAGS) $(OBJS) $(LDFLAGS) -o $(EXEC)
 	$(GZIP) $(EXEC).8 > $(EXEC).8.gz
 
 install:
 	$(INSTALL_PROGRAM) -d $(DESTDIR)$(bindir)
 	$(INSTALL_PROGRAM) -m 755 $(EXEC) $(DESTDIR)$(bindir)
 	$(INSTALL_PROGRAM) -d $(DESTDIR)$(rcdir)
+	$(INSTALL_PROGRAM) -d $(DESTDIR)$(unitdir)
+	$(INSTALL_PROGRAM) -m 644 $(EXEC).service $(DESTDIR)$(unitdir)
 	$(INSTALL_PROGRAM) -d $(DESTDIR)$(mandir)
 	$(INSTALL_PROGRAM) -m 644 $(EXEC).8.gz $(DESTDIR)$(mandir)
 
@@ -42,6 +44,7 @@ uninstall:
 	rm -f $(DESTDIR)$(bindir)/$(EXEC)
 	rm -f $(DESTDIR)$(rcdir)/$(EXEC)
 	rm -f $(DESTDIR)$(mandir)/$(EXEC).8.gz
+	rm -f $(DESTDIR)$(unitdir)/$(EXEC).service
 
 clean:
 	rm -f core *.o $(EXEC) *.gz
diff --git a/multipathd/cli.c b/multipathd/cli.c
index 208a0ad..d95cba0 100644
--- a/multipathd/cli.c
+++ b/multipathd/cli.c
@@ -10,6 +10,9 @@
 
 #include "cli.h"
 
+static vector keys;
+static vector handlers;
+
 static struct key *
 alloc_key (void)
 {
@@ -23,7 +26,7 @@ alloc_handler (void)
 }
 
 static int
-add_key (vector vec, char * str, int code, int has_param)
+add_key (vector vec, char * str, unsigned long code, int has_param)
 {
 	struct key * kw;
 
@@ -54,7 +57,7 @@ out:
 }
 
 int
-add_handler (int fp, int (*fn)(void *, char **, int *, void *))
+add_handler (unsigned long fp, int (*fn)(void *, char **, int *, void *))
 {
 	struct handler * h;
 
@@ -76,7 +79,7 @@ add_handler (int fp, int (*fn)(void *, char **, int *, void *))
 }
 
 static struct handler *
-find_handler (int fp)
+find_handler (unsigned long fp)
 {
 	int i;
 	struct handler *h;
@@ -89,7 +92,7 @@ find_handler (int fp)
 }
 
 int
-set_handler_callback (int fp, int (*fn)(void *, char **, int *, void *))
+set_handler_callback (unsigned long fp, int (*fn)(void *, char **, int *, void *))
 {
 	struct handler * h = find_handler(fp);
 
@@ -124,15 +127,16 @@ free_keys (vector vec)
 }
 
 void
-free_handlers (vector vec)
+free_handlers (void)
 {
 	int i;
 	struct handler * h;
 
-	vector_foreach_slot (vec, h, i)
+	vector_foreach_slot (handlers, h, i)
 		FREE(h);
 
-	vector_free(vec);
+	vector_free(handlers);
+	handlers = NULL;
 }
 
 int
@@ -156,6 +160,8 @@ load_keys (void)
 	r += add_key(keys, "reinstate", REINSTATE, 0);
 	r += add_key(keys, "fail", FAIL, 0);
 	r += add_key(keys, "resize", RESIZE, 0);
+	r += add_key(keys, "reset", RESET, 0);
+	r += add_key(keys, "reload", RELOAD, 0);
 	r += add_key(keys, "disablequeueing", DISABLEQ, 0);
 	r += add_key(keys, "restorequeueing", RESTOREQ, 0);
 	r += add_key(keys, "paths", PATHS, 0);
@@ -166,6 +172,7 @@ load_keys (void)
 	r += add_key(keys, "multipath", MAP, 1);
 	r += add_key(keys, "group", GROUP, 1);
 	r += add_key(keys, "reconfigure", RECONFIGURE, 0);
+	r += add_key(keys, "daemon", DAEMON, 0);
 	r += add_key(keys, "status", STATUS, 0);
 	r += add_key(keys, "stats", STATS, 0);
 	r += add_key(keys, "topology", TOPOLOGY, 0);
@@ -176,6 +183,10 @@ load_keys (void)
 	r += add_key(keys, "wildcards", WILDCARDS, 0);
 	r += add_key(keys, "quit", QUIT, 0);
 	r += add_key(keys, "exit", QUIT, 0);
+	r += add_key(keys, "shutdown", SHUTDOWN, 0);
+	r += add_key(keys, "getprstatus", GETPRSTATUS, 0);
+	r += add_key(keys, "setprstatus", SETPRSTATUS, 0);
+	r += add_key(keys, "unsetprstatus", UNSETPRSTATUS, 0);
 
 	if (r) {
 		free_keys(keys);
@@ -228,10 +239,9 @@ get_cmdvec (char * cmd, vector *v)
 
 	strvec = alloc_strvec(cmd);
 	if (!strvec)
-		return 0;
+		return E_NOMEM;
 
 	cmdvec = vector_alloc();
-	*v = cmdvec;
 
 	if (!cmdvec) {
 		free_strvec(strvec);
@@ -271,21 +281,21 @@ get_cmdvec (char * cmd, vector *v)
 		r = E_NOPARM;
 		goto out;
 	}
+	*v = cmdvec;
 	free_strvec(strvec);
 	return 0;
 
 out:
 	free_strvec(strvec);
 	free_keys(cmdvec);
-	*v = NULL;
 	return r;
 }
 
-static int 
+static unsigned long 
 fingerprint(vector vec)
 {
 	int i;
-	int fp = 0;
+	unsigned long fp = 0;
 	struct key * kw;
 
 	if (!vec)
@@ -325,7 +335,7 @@ static char *
 genhelp_handler (void)
 {
 	int i, j;
-	int fp;
+	unsigned long fp;
 	struct handler * h;
 	struct key * kw;
 	char * reply;
@@ -363,13 +373,11 @@ parse_cmd (char * cmd, char ** reply, int * len, void * data)
 {
 	int r;
 	struct handler * h;
-	vector cmdvec;
+	vector cmdvec = NULL;
 
 	r = get_cmdvec(cmd, &cmdvec);
 
 	if (r) {
-		if (cmdvec)
-			free_keys(cmdvec);
 		*reply = genhelp_handler();
 		*len = strlen(*reply) + 1;
 		return 0;
@@ -377,7 +385,7 @@ parse_cmd (char * cmd, char ** reply, int * len, void * data)
 
 	h = find_handler(fingerprint(cmdvec));
 
-	if (!h) {
+	if (!h || !h->fn) {
 		*reply = genhelp_handler();
 		*len = strlen(*reply) + 1;
 		free_keys(cmdvec);
@@ -394,7 +402,7 @@ parse_cmd (char * cmd, char ** reply, int * len, void * data)
 }
 
 char *
-get_keyparam (vector v, int code)
+get_keyparam (vector v, unsigned long code)
 {
 	struct key * kw;
 	int i;
@@ -417,6 +425,7 @@ cli_init (void) {
 	add_handler(LIST+PATHS, NULL);
 	add_handler(LIST+PATHS+FMT, NULL);
 	add_handler(LIST+STATUS, NULL);
+	add_handler(LIST+DAEMON, NULL);
 	add_handler(LIST+MAPS, NULL);
 	add_handler(LIST+MAPS+STATUS, NULL);
 	add_handler(LIST+MAPS+STATS, NULL);
@@ -437,6 +446,8 @@ cli_init (void) {
 	add_handler(SUSPEND+MAP, NULL);
 	add_handler(RESUME+MAP, NULL);
 	add_handler(RESIZE+MAP, NULL);
+	add_handler(RESET+MAP, NULL);
+	add_handler(RELOAD+MAP, NULL);
 	add_handler(DISABLEQ+MAP, NULL);
 	add_handler(RESTOREQ+MAP, NULL);
 	add_handler(DISABLEQ+MAPS, NULL);
@@ -444,12 +455,23 @@ cli_init (void) {
 	add_handler(REINSTATE+PATH, NULL);
 	add_handler(FAIL+PATH, NULL);
 	add_handler(QUIT, NULL);
+	add_handler(SHUTDOWN, NULL);
+	add_handler(GETPRSTATUS+MAP, NULL);
+	add_handler(SETPRSTATUS+MAP, NULL);
+	add_handler(UNSETPRSTATUS+MAP, NULL);
 
 	return 0;
 }
 
+void cli_exit(void)
+{
+	free_handlers();
+	free_keys(keys);
+	keys = NULL;
+}
+
 static int
-key_match_fingerprint (struct key * kw, int fp)
+key_match_fingerprint (struct key * kw, unsigned long fp)
 {
 	if (!fp)
 		return 0;
@@ -463,11 +485,12 @@ key_match_fingerprint (struct key * kw, int fp)
 char *
 key_generator (const char * str, int state)
 {
-	static int index, len, rlfp, has_param;
+	static int index, len, has_param;
+	static unsigned long rlfp;	
 	struct key * kw;
 	int i;
 	struct handler *h;
-	vector v;
+	vector v = NULL;
 
 	if (!state) {
 		index = 0;
@@ -533,7 +556,7 @@ key_generator (const char * str, int state)
 			 * nfp is the candidate fingerprint we try to
 			 * validate against all known command fingerprints.
 			 */
-			int nfp = rlfp | kw->code;
+			unsigned long nfp = rlfp | kw->code;
 			vector_foreach_slot(handlers, h, i) {
 				if (!rlfp || ((h->fingerprint & nfp) == nfp)) {
 					/*
diff --git a/multipathd/cli.h b/multipathd/cli.h
index 1a19e4c..6b288d4 100644
--- a/multipathd/cli.h
+++ b/multipathd/cli.h
@@ -8,6 +8,8 @@ enum {
 	__REINSTATE,
 	__FAIL,
 	__RESIZE,
+	__RESET,
+	__RELOAD,
 	__DISABLEQ,
 	__RESTOREQ,
 	__PATHS,
@@ -16,6 +18,7 @@ enum {
 	__MAP,
 	__GROUP,
 	__RECONFIGURE,
+	__DAEMON,
 	__STATUS,
 	__STATS,
 	__TOPOLOGY,
@@ -25,6 +28,10 @@ enum {
 	__FMT,
 	__WILDCARDS,
 	__QUIT,
+	__SHUTDOWN,
+	__GETPRSTATUS,
+	__SETPRSTATUS,
+	__UNSETPRSTATUS,
 };
 
 #define LIST		(1 << __LIST)
@@ -36,6 +43,8 @@ enum {
 #define REINSTATE	(1 << __REINSTATE)
 #define FAIL		(1 << __FAIL)
 #define RESIZE		(1 << __RESIZE)
+#define RESET		(1 << __RESET)
+#define RELOAD		(1 << __RELOAD)
 #define DISABLEQ	(1 << __DISABLEQ)
 #define RESTOREQ	(1 << __RESTOREQ)
 #define PATHS		(1 << __PATHS)
@@ -44,23 +53,28 @@ enum {
 #define MAP		(1 << __MAP)
 #define GROUP		(1 << __GROUP)
 #define RECONFIGURE	(1 << __RECONFIGURE)
+#define DAEMON		(1 << __DAEMON)
 #define STATUS		(1 << __STATUS)
 #define STATS		(1 << __STATS)
 #define TOPOLOGY	(1 << __TOPOLOGY)
 #define CONFIG		(1 << __CONFIG)
 #define BLACKLIST	(1 << __BLACKLIST)
-#define DEVICES  	(1 << __DEVICES)
-#define FMT 	 	(1 << __FMT)
+#define DEVICES		(1 << __DEVICES)
+#define FMT		(1 << __FMT)
 #define COUNT		(1 << __COUNT)
 #define WILDCARDS	(1 << __WILDCARDS)
 #define QUIT		(1 << __QUIT)
+#define SHUTDOWN	(1 << __SHUTDOWN)
+#define GETPRSTATUS	(1UL << __GETPRSTATUS)
+#define SETPRSTATUS	(1UL << __SETPRSTATUS)
+#define UNSETPRSTATUS	(1UL << __UNSETPRSTATUS)
 
-#define INITIAL_REPLY_LEN 1000
+#define INITIAL_REPLY_LEN	1100
 
 struct key {
 	char * str;
 	char * param;
-	int code;
+	unsigned long code;
 	int has_param;
 };
 
@@ -69,16 +83,14 @@ struct handler {
 	int (*fn)(void *, char **, int *, void *);
 };
 
-vector keys;
-vector handlers;
-
 int alloc_handlers (void);
-int add_handler (int fp, int (*fn)(void *, char **, int *, void *));
-int set_handler_callback (int fp, int (*fn)(void *, char **, int *, void *));
+int add_handler (unsigned long fp, int (*fn)(void *, char **, int *, void *));
+int set_handler_callback (unsigned long fp, int (*fn)(void *, char **, int *, void *));
 int parse_cmd (char * cmd, char ** reply, int * len, void *);
 int load_keys (void);
-char * get_keyparam (vector v, int code);
+char * get_keyparam (vector v, unsigned long code);
 void free_keys (vector vec);
-void free_handlers (vector vec);
+void free_handlers (void);
 int cli_init (void);
+void cli_exit(void);
 char * key_generator (const char * str, int state);
diff --git a/multipathd/cli_handlers.c b/multipathd/cli_handlers.c
index 71a73ff..9e0e2ee 100644
--- a/multipathd/cli_handlers.c
+++ b/multipathd/cli_handlers.c
@@ -18,6 +18,18 @@
 
 #include "main.h"
 #include "cli.h"
+#include "uevent.h"
+
+#define REALLOC_REPLY(r, a, m)					\
+	do {							\
+		if ((a)) {					\
+			(r) = REALLOC((r), (m) * 2);		\
+			if ((r)) {				\
+				memset((r) + (m), 0, (m));	\
+				(m) *= 2;			\
+			}					\
+		}						\
+	} while (0)
 
 int
 show_paths (char ** r, int * len, struct vectors * vecs, char * style)
@@ -48,9 +60,7 @@ show_paths (char ** r, int * len, struct vectors * vecs, char * style)
 
 		again = ((c - reply) == (maxlen - 1));
 
-		if (again)
-			reply = REALLOC(reply, maxlen *= 2);
-
+		REALLOC_REPLY(reply, again, maxlen);
 	}
 	*r = reply;
 	*len = (int)(c - reply + 1);
@@ -58,13 +68,16 @@ show_paths (char ** r, int * len, struct vectors * vecs, char * style)
 }
 
 int
-show_map_topology (char ** r, int * len, struct multipath * mpp)
+show_map_topology (char ** r, int * len, struct multipath * mpp,
+		   struct vectors * vecs)
 {
 	char * c;
 	char * reply;
 	unsigned int maxlen = INITIAL_REPLY_LEN;
 	int again = 1;
 
+	if (update_multipath(vecs, mpp->alias, 0))
+		return 1;
 	reply = MALLOC(maxlen);
 
 	while (again) {
@@ -76,9 +89,7 @@ show_map_topology (char ** r, int * len, struct multipath * mpp)
 		c += snprint_multipath_topology(c, reply + maxlen - c, mpp, 2);
 		again = ((c - reply) == (maxlen - 1));
 
-		if (again)
-			reply = REALLOC(reply, maxlen *= 2);
-
+		REALLOC_REPLY(reply, again, maxlen);
 	}
 	*r = reply;
 	*len = (int)(c - reply + 1);
@@ -104,15 +115,18 @@ show_maps_topology (char ** r, int * len, struct vectors * vecs)
 
 		c = reply;
 
-		vector_foreach_slot(vecs->mpvec, mpp, i)
+		vector_foreach_slot(vecs->mpvec, mpp, i) {
+			if (update_multipath(vecs, mpp->alias, 0)) {
+				i--;
+				continue;
+			}
 			c += snprint_multipath_topology(c, reply + maxlen - c,
 							mpp, 2);
+		}
 
 		again = ((c - reply) == (maxlen - 1));
 
-		if (again)
-			reply = REALLOC(reply, maxlen *= 2);
-
+		REALLOC_REPLY(reply, again, maxlen);
 	}
 	*r = reply;
 	*len = (int)(c - reply + 1);
@@ -136,31 +150,46 @@ show_config (char ** r, int * len)
 		c += snprint_defaults(c, reply + maxlen - c);
 		again = ((c - reply) == maxlen);
 		if (again) {
-			reply = REALLOC(reply, maxlen *= 2);
+			reply = REALLOC(reply, maxlen * 2);
+			if (!reply)
+				return 1;
+			memset(reply + maxlen, 0, maxlen);
+			maxlen *= 2;
 			continue;
 		}
 		c += snprint_blacklist(c, reply + maxlen - c);
 		again = ((c - reply) == maxlen);
 		if (again) {
-			reply = REALLOC(reply, maxlen *= 2);
+			reply = REALLOC(reply, maxlen * 2);
+			if (!reply)
+				return 1;
+			memset(reply + maxlen, 0, maxlen);
+			maxlen *= 2;
 			continue;
 		}
 		c += snprint_blacklist_except(c, reply + maxlen - c);
 		again = ((c - reply) == maxlen);
 		if (again) {
-			reply = REALLOC(reply, maxlen *= 2);
+			reply = REALLOC(reply, maxlen * 2);
+			if (!reply)
+				return 1;
+			memset(reply + maxlen, 0, maxlen);
+			maxlen *= 2;
 			continue;
 		}
 		c += snprint_hwtable(c, reply + maxlen - c, conf->hwtable);
 		again = ((c - reply) == maxlen);
 		if (again) {
-			reply = REALLOC(reply, maxlen *= 2);
+			reply = REALLOC(reply, maxlen * 2);
+			if (!reply)
+				return 1;
+			memset(reply + maxlen, 0, maxlen);
+			maxlen *= 2;
 			continue;
 		}
 		c += snprint_mptable(c, reply + maxlen - c, conf->mptable);
 		again = ((c - reply) == maxlen);
-		if (again)
-			reply = REALLOC(reply, maxlen *= 2);
+		REALLOC_REPLY(reply, again, maxlen);
 	}
 	*r = reply;
 	*len = (int)(c - reply + 1);
@@ -211,7 +240,7 @@ cli_list_map_topology (void * v, char ** reply, int * len, void * data)
 
 	condlog(3, "list multipath %s (operator)", param);
 
-	return show_map_topology(reply, len, mpp);
+	return show_map_topology(reply, len, mpp, vecs);
 }
 
 int
@@ -262,6 +291,27 @@ show_status (char ** r, int *len, struct vectors * vecs)
 }
 
 int
+show_daemon (char ** r, int *len)
+{
+	char * c;
+	char * reply;
+
+	unsigned int maxlen = INITIAL_REPLY_LEN;
+	reply = MALLOC(maxlen);
+
+	if (!reply)
+		return 1;
+
+	c = reply;
+	c += snprintf(c, INITIAL_REPLY_LEN, "pid %d %s\n",
+		      daemon_pid, daemon_status());
+
+	*r = reply;
+	*len = (int)(c - reply + 1);
+	return 0;
+}
+
+int
 show_maps (char ** r, int *len, struct vectors * vecs, char * style)
 {
 	int i;
@@ -289,8 +339,7 @@ show_maps (char ** r, int *len, struct vectors * vecs, char * style)
 
 		again = ((c - reply) == (maxlen - 1));
 
-		if (again)
-			reply = REALLOC(reply, maxlen *= 2);
+		REALLOC_REPLY(reply, again, maxlen);
 	}
 	*r = reply;
 	*len = (int)(c - reply + 1);
@@ -349,6 +398,14 @@ cli_list_maps_stats (void * v, char ** reply, int * len, void * data)
 }
 
 int
+cli_list_daemon (void * v, char ** reply, int * len, void * data)
+{
+	condlog(3, "list daemon (operator)");
+
+	return show_daemon(reply, len);
+}
+
+int
 cli_add_path (void * v, char ** reply, int * len, void * data)
 {
 	struct vectors * vecs = (struct vectors *)data;
@@ -383,9 +440,10 @@ cli_add_map (void * v, char ** reply, int * len, void * data)
 {
 	struct vectors * vecs = (struct vectors *)data;
 	char * param = get_keyparam(v, MAP);
-	int minor;
+	int major, minor;
 	char dev_path[PATH_SIZE];
-	struct sysfs_device *sysdev;
+	char *alias;
+	int rc;
 
 	condlog(2, "%s: add map (operator)", param);
 
@@ -400,13 +458,21 @@ cli_add_map (void * v, char ** reply, int * len, void * data)
 		condlog(2, "%s: not a device mapper table", param);
 		return 0;
 	}
-	sprintf(dev_path,"/block/dm-%d", minor);
-	sysdev = sysfs_device_get(dev_path);
-	if (!sysdev) {
-		condlog(2, "%s: not found in sysfs", param);
+	major = dm_get_major(param);
+	if (major < 0) {
+		condlog(2, "%s: not a device mapper table", param);
 		return 0;
 	}
-	return ev_add_map(sysdev, vecs);
+	sprintf(dev_path,"dm-%d", minor);
+	alias = dm_mapname(major, minor);
+	if (!alias) {
+		condlog(2, "%s: mapname not found for %d:%d",
+			param, major, minor);
+		return 0;
+	}
+	rc = ev_add_map(dev_path, alias, vecs);
+	FREE(alias);
+	return rc;
 }
 
 int
@@ -414,20 +480,66 @@ cli_del_map (void * v, char ** reply, int * len, void * data)
 {
 	struct vectors * vecs = (struct vectors *)data;
 	char * param = get_keyparam(v, MAP);
+	int major, minor;
+	char dev_path[PATH_SIZE];
+	char *alias;
+	int rc;
 
 	condlog(2, "%s: remove map (operator)", param);
+	minor = dm_get_minor(param);
+	if (minor < 0) {
+		condlog(2, "%s: not a device mapper table", param);
+		return 0;
+	}
+	major = dm_get_major(param);
+	if (major < 0) {
+		condlog(2, "%s: not a device mapper table", param);
+		return 0;
+	}
+	sprintf(dev_path,"dm-%d", minor);
+	alias = dm_mapname(major, minor);
+	if (!alias) {
+		condlog(2, "%s: mapname not found for %d:%d",
+			param, major, minor);
+		return 0;
+	}
+	rc = ev_remove_map(param, alias, minor, vecs);
+	FREE(alias);
+	return rc;
+}
 
-	return ev_remove_map(param, vecs);
+int
+cli_reload(void *v, char **reply, int *len, void *data)
+{
+	struct vectors * vecs = (struct vectors *)data;
+	char * mapname = get_keyparam(v, MAP);
+	struct multipath *mpp;
+	int minor;
+
+	condlog(2, "%s: reload map (operator)", mapname);
+	if (sscanf(mapname, "dm-%d", &minor) == 1)
+		mpp = find_mp_by_minor(vecs->mpvec, minor);
+	else
+		mpp = find_mp_by_alias(vecs->mpvec, mapname);
+
+	if (!mpp) {
+		condlog(0, "%s: invalid map name. cannot reload", mapname);
+		return 1;
+	}
+
+	return reload_map(vecs, mpp);
 }
 
 int resize_map(struct multipath *mpp, unsigned long long size,
 	       struct vectors * vecs)
 {
+	char params[PARAMS_SIZE] = {0};
+
 	mpp->size = size;
 	update_mpp_paths(mpp, vecs->pathvec);
-	setup_map(mpp);
+	setup_map(mpp, params, PARAMS_SIZE);
 	mpp->action = ACT_RESIZE;
-	if (domap(mpp) <= 0) {
+	if (domap(mpp, params) <= 0) {
 		condlog(0, "%s: failed to resize map : %s", mpp->alias,
 			strerror(errno));
 		return 1;
@@ -658,6 +770,17 @@ cli_reinstate(void * v, char ** reply, int * len, void * data)
 }
 
 int
+cli_reassign (void * v, char ** reply, int * len, void * data)
+{
+	char * param = get_keyparam(v, MAP);
+
+	condlog(3, "%s: reset devices (operator)", param);
+
+	dm_reassign(param);
+	return 0;
+}
+
+int
 cli_fail(void * v, char ** reply, int * len, void * data)
 {
 	struct vectors * vecs = (struct vectors *)data;
@@ -693,19 +816,16 @@ show_blacklist (char ** r, int * len)
 	unsigned int maxlen = INITIAL_REPLY_LEN;
 	int again = 1;
 
+	reply = MALLOC(maxlen);
+
 	while (again) {
-		reply = MALLOC(maxlen);
 		if (!reply)
 			return 1;
 
 		c = reply;
 		c += snprint_blacklist_report(c, maxlen);
 		again = ((c - reply) == maxlen);
-		if (again) {
-			maxlen  *= 2;
-			FREE(reply);
-			continue;
-		}
+		REALLOC_REPLY(reply, again, maxlen);
 	}
 
 	*r = reply;
@@ -730,19 +850,16 @@ show_devices (char ** r, int * len, struct vectors *vecs)
 	unsigned int maxlen = INITIAL_REPLY_LEN;
 	int again = 1;
 
+	reply = MALLOC(maxlen);
+
 	while (again) {
-		reply = MALLOC(maxlen);
 		if (!reply)
 			return 1;
 
 		c = reply;
 		c += snprint_devices(c, maxlen, vecs);
 		again = ((c - reply) == maxlen);
-		if (again) {
-			maxlen  *= 2;
-			FREE(reply);
-			continue;
-		}
+		REALLOC_REPLY(reply, again, maxlen);
 	}
 
 	*r = reply;
@@ -766,3 +883,83 @@ cli_quit (void * v, char ** reply, int * len, void * data)
 {
 	return 0;
 }
+
+int
+cli_shutdown (void * v, char ** reply, int * len, void * data)
+{
+	condlog(3, "shutdown (operator)");
+
+	return exit_daemon(0);
+}
+
+int
+cli_getprstatus (void * v, char ** reply, int * len, void * data)
+{
+	struct multipath * mpp;
+	struct vectors * vecs = (struct vectors *)data;
+	char * param = get_keyparam(v, MAP);
+
+	get_path_layout(vecs->pathvec, 0);
+	mpp = find_mp_by_str(vecs->mpvec, param);
+
+	if (!mpp)
+		return 1;
+
+	condlog(3, "%s: prflag = %u", param, (unsigned int)mpp->prflag);
+
+	*reply =(char *)malloc(2);
+	*len = 2;
+	memset(*reply,0,2);
+
+
+	sprintf(*reply,"%d",mpp->prflag);
+	*reply[1]='\0';
+
+
+	condlog(3, "%s: reply = %s", param, *reply);
+
+	return 0;
+}
+
+int
+cli_setprstatus(void * v, char ** reply, int * len, void * data)
+{
+	struct multipath * mpp;
+	struct vectors * vecs = (struct vectors *)data;
+	char * param = get_keyparam(v, MAP);
+
+	get_path_layout(vecs->pathvec, 0);
+	mpp = find_mp_by_str(vecs->mpvec, param);
+
+	if (!mpp)
+		return 1;
+
+	if (!mpp->prflag) {
+		mpp->prflag = 1;
+		condlog(2, "%s: prflag set", param);
+	}
+
+
+	return 0;
+}
+
+int
+cli_unsetprstatus(void * v, char ** reply, int * len, void * data)
+{
+	struct multipath * mpp;
+	struct vectors * vecs = (struct vectors *)data;
+	char * param = get_keyparam(v, MAP);
+
+	get_path_layout(vecs->pathvec, 0);
+	mpp = find_mp_by_str(vecs->mpvec, param);
+
+	if (!mpp)
+		return 1;
+
+	if (mpp->prflag) {
+		mpp->prflag = 0;
+		condlog(2, "%s: prflag unset", param);
+	}
+
+	return 0;
+}
diff --git a/multipathd/cli_handlers.h b/multipathd/cli_handlers.h
index b3ad377..c62a273 100644
--- a/multipathd/cli_handlers.h
+++ b/multipathd/cli_handlers.h
@@ -1,6 +1,7 @@
 int cli_list_paths (void * v, char ** reply, int * len, void * data);
 int cli_list_paths_fmt (void * v, char ** reply, int * len, void * data);
 int cli_list_status (void * v, char ** reply, int * len, void * data);
+int cli_list_daemon (void * v, char ** reply, int * len, void * data);
 int cli_list_maps (void * v, char ** reply, int * len, void * data);
 int cli_list_maps_fmt (void * v, char ** reply, int * len, void * data);
 int cli_list_maps_status (void * v, char ** reply, int * len, void * data);
@@ -18,6 +19,7 @@ int cli_del_map (void * v, char ** reply, int * len, void * data);
 int cli_switch_group(void * v, char ** reply, int * len, void * data);
 int cli_reconfigure(void * v, char ** reply, int * len, void * data);
 int cli_resize(void * v, char ** reply, int * len, void * data);
+int cli_reload(void * v, char ** reply, int * len, void * data);
 int cli_disable_queueing(void * v, char ** reply, int * len, void * data);
 int cli_disable_all_queueing(void * v, char ** reply, int * len, void * data);
 int cli_restore_queueing(void * v, char ** reply, int * len, void * data);
@@ -27,3 +29,9 @@ int cli_resume(void * v, char ** reply, int * len, void * data);
 int cli_reinstate(void * v, char ** reply, int * len, void * data);
 int cli_fail(void * v, char ** reply, int * len, void * data);
 int cli_quit(void * v, char ** reply, int * len, void * data);
+int cli_shutdown(void * v, char ** reply, int * len, void * data);
+int cli_reassign (void * v, char ** reply, int * len, void * data);
+int cli_getprstatus(void * v, char ** reply, int * len, void * data);
+int cli_setprstatus(void * v, char ** reply, int * len, void * data);
+int cli_unsetprstatus(void * v, char ** reply, int * len, void * data);
+
diff --git a/multipathd/main.c b/multipathd/main.c
index 6ee7903..9cf0a80 100644
--- a/multipathd/main.c
+++ b/multipathd/main.c
@@ -15,6 +15,8 @@
 #include <sys/time.h>
 #include <sys/resource.h>
 #include <limits.h>
+#include <linux/oom.h>
+#include <mpath_persist.h>
 
 /*
  * libcheckers
@@ -47,6 +49,8 @@
 #include <print.h>
 #include <configure.h>
 #include <prio.h>
+#include <pgpolicies.h>
+#include <uevent.h>
 
 #include "main.h"
 #include "pidfile.h"
@@ -60,13 +64,28 @@
 #define FILE_NAME_SIZE 256
 #define CMDSIZE 160
 
-#define LOG_MSG(a,b) \
-	if (strlen(b)) condlog(a, "%s: %s - %s", pp->mpp->alias, pp->dev, b);
+#define LOG_MSG(a, b) \
+do { \
+	if (pp->offline) \
+		condlog(a, "%s: %s - path offline", pp->mpp->alias, pp->dev); \
+	else if (strlen(b)) \
+		condlog(a, "%s: %s - %s", pp->mpp->alias, pp->dev, b); \
+} while(0)
+
+struct mpath_event_param
+{
+	char * devname;
+	struct multipath *mpp;
+};
+
+unsigned int mpath_mx_alloc_len;
 
 pthread_cond_t exit_cond = PTHREAD_COND_INITIALIZER;
 pthread_mutex_t exit_mutex = PTHREAD_MUTEX_INITIALIZER;
 
 int logsink;
+enum daemon_status running_state;
+pid_t daemon_pid;
 
 /*
  * global copy of vecs for use in sig handlers
@@ -143,6 +162,10 @@ coalesce_maps(struct vectors *vecs, vector nmpv)
 				dm_lib_release();
 				condlog(2, "%s devmap removed", ompp->alias);
 			}
+		} else if (conf->reassign_maps) {
+			condlog(3, "%s: Reassign existing device-mapper"
+				" devices", ompp->alias);
+			dm_reassign(ompp->alias);
 		}
 	}
 	return 0;
@@ -213,38 +236,41 @@ flush_map(struct multipath * mpp, struct vectors * vecs)
 }
 
 static int
-uev_add_map (struct sysfs_device * dev, struct vectors * vecs)
+uev_add_map (struct uevent * uev, struct vectors * vecs)
 {
-	condlog(2, "%s: add map (uevent)", dev->kernel);
-	return ev_add_map(dev, vecs);
+	char *alias;
+	int major = -1, minor = -1, rc;
+
+	condlog(3, "%s: add map (uevent)", uev->kernel);
+	alias = uevent_get_dm_name(uev);
+	if (!alias) {
+		condlog(3, "%s: No DM_NAME in uevent", uev->kernel);
+		major = uevent_get_major(uev);
+		minor = uevent_get_minor(uev);
+		alias = dm_mapname(major, minor);
+		if (!alias) {
+			condlog(2, "%s: mapname not found for %d:%d",
+				uev->kernel, major, minor);
+			return 1;
+		}
+	}
+	rc = ev_add_map(uev->kernel, alias, vecs);
+	FREE(alias);
+	return rc;
 }
 
 int
-ev_add_map (struct sysfs_device * dev, struct vectors * vecs)
+ev_add_map (char * dev, char * alias, struct vectors * vecs)
 {
-	char * alias;
-	char *dev_t;
-	int major, minor;
 	char * refwwid;
 	struct multipath * mpp;
 	int map_present;
 	int r = 1;
 
-	dev_t = sysfs_attr_get_value(dev->devpath, "dev");
-
-	if (!dev_t || sscanf(dev_t, "%d:%d", &major, &minor) != 2)
-		return 1;
-
-	alias = dm_mapname(major, minor);
-
-	if (!alias)
-		return 1;
-
 	map_present = dm_map_present(alias);
 
 	if (map_present && dm_type(alias, TGT_MPATH) <= 0) {
 		condlog(4, "%s: not a multipath map", alias);
-		FREE(alias);
 		return 0;
 	}
 
@@ -256,21 +282,24 @@ ev_add_map (struct sysfs_device * dev, struct vectors * vecs)
 		 * if we create a multipath mapped device as a result
 		 * of uev_add_path
 		 */
-		condlog(0, "%s: devmap already registered",
-			dev->kernel);
-		FREE(alias);
+		if (conf->reassign_maps) {
+			condlog(3, "%s: Reassign existing device-mapper devices",
+				alias);
+			dm_reassign(alias);
+		}
 		return 0;
 	}
+	condlog(2, "%s: adding map", alias);
 
 	/*
 	 * now we can register the map
 	 */
-	if (map_present && (mpp = add_map_without_path(vecs, minor, alias))) {
+	if (map_present && (mpp = add_map_without_path(vecs, alias))) {
 		sync_map_state(mpp);
-		condlog(2, "%s: devmap %s added", alias, dev->kernel);
+		condlog(2, "%s: devmap %s registered", alias, dev);
 		return 0;
 	}
-	refwwid = get_refwwid(dev->kernel, DEV_DEVMAP, vecs->pathvec);
+	refwwid = get_refwwid(dev, DEV_DEVMAP, vecs->pathvec);
 
 	if (refwwid) {
 		r = coalesce_paths(vecs, NULL, refwwid, 0);
@@ -278,68 +307,82 @@ ev_add_map (struct sysfs_device * dev, struct vectors * vecs)
 	}
 
 	if (!r)
-		condlog(2, "%s: devmap %s added", alias, dev->kernel);
+		condlog(2, "%s: devmap %s added", alias, dev);
 	else
-		condlog(0, "%s: uev_add_map %s failed", alias, dev->kernel);
+		condlog(0, "%s: uev_add_map %s failed", alias, dev);
 
 	FREE(refwwid);
-	FREE(alias);
 	return r;
 }
 
 static int
-uev_remove_map (struct sysfs_device * dev, struct vectors * vecs)
-{
-	condlog(2, "%s: remove map (uevent)", dev->kernel);
-	return ev_remove_map(dev->kernel, vecs);
-}
-
-int
-ev_remove_map (char * devname, struct vectors * vecs)
+uev_remove_map (struct uevent * uev, struct vectors * vecs)
 {
-	struct multipath * mpp;
+	char *alias;
+	int minor;
+	struct multipath *mpp;
 
-	mpp = find_mp_by_str(vecs->mpvec, devname);
+	condlog(2, "%s: remove map (uevent)", uev->kernel);
+	alias = uevent_get_dm_name(uev);
+	if (!alias) {
+		condlog(3, "%s: No DM_NAME in uevent, ignoring", uev->kernel);
+		return 0;
+	}
+	minor = uevent_get_minor(uev);
+	mpp = find_mp_by_minor(vecs->mpvec, minor);
 
 	if (!mpp) {
 		condlog(2, "%s: devmap not registered, can't remove",
-			devname);
-		return 0;
+			uev->kernel);
+		goto out;
+	}
+	if (strcmp(mpp->alias, alias)) {
+		condlog(2, "%s: minor number mismatch (map %d, event %d)",
+			mpp->alias, mpp->dmi->minor, minor);
+		goto out;
 	}
-	flush_map(mpp, vecs);
 
+	orphan_paths(vecs->pathvec, mpp);
+	remove_map_and_stop_waiter(mpp, vecs, 1);
+out:
+	FREE(alias);
 	return 0;
 }
 
-static int
-uev_umount_map (struct sysfs_device * dev, struct vectors * vecs)
+int
+ev_remove_map (char * devname, char * alias, int minor, struct vectors * vecs)
 {
 	struct multipath * mpp;
 
-	condlog(2, "%s: umount map (uevent)", dev->kernel);
+	mpp = find_mp_by_minor(vecs->mpvec, minor);
 
-	mpp = find_mp_by_str(vecs->mpvec, dev->kernel);
-
-	if (!mpp)
+	if (!mpp) {
+		condlog(2, "%s: devmap not registered, can't remove",
+			devname);
 		return 0;
-
-	update_mpp_paths(mpp, vecs->pathvec);
-	verify_paths(mpp, vecs, NULL);
-
-	if (!VECTOR_SIZE(mpp->paths))
-		flush_map(mpp, vecs);
-
-	return 0;
+	}
+	if (strcmp(mpp->alias, alias)) {
+		condlog(2, "%s: minor number mismatch (map %d, event %d)",
+			mpp->alias, mpp->dmi->minor, minor);
+		return 0;
+	}
+	return flush_map(mpp, vecs);
 }
 
 static int
-uev_add_path (struct sysfs_device * dev, struct vectors * vecs)
+uev_add_path (struct uevent *uev, struct vectors * vecs)
 {
+	struct sysfs_device * dev;
+
+	dev = sysfs_device_get(uev->devpath);
+	if (!dev) {
+		condlog(2, "%s: not found in sysfs", uev->devpath);
+		return 1;
+	}
 	condlog(2, "%s: add path (uevent)", dev->kernel);
 	return (ev_add_path(dev->kernel, vecs) != 1)? 0 : 1;
 }
 
-
 /*
  * returns:
  * 0: added
@@ -352,6 +395,9 @@ ev_add_path (char * devname, struct vectors * vecs)
 	struct multipath * mpp;
 	struct path * pp;
 	char empty_buff[WWID_SIZE] = {0};
+	char params[PARAMS_SIZE] = {0};
+	int retries = 3;
+	int start_waiter = 0;
 
 	if (strstr(devname, "..") != NULL) {
 		/*
@@ -386,7 +432,7 @@ ev_add_path (char * devname, struct vectors * vecs)
 	 */
 	if (memcmp(empty_buff, pp->wwid, WWID_SIZE) == 0) {
 		condlog(0, "%s: failed to get path uid", devname);
-		return 1; /* leave path added to pathvec */
+		goto fail; /* leave path added to pathvec */
 	}
 	if (filter_path(conf, pp) > 0){
 		int i = find_slot(vecs->pathvec, (void *)pp);
@@ -416,8 +462,8 @@ rescan:
 
 		condlog(4,"%s: adopting all paths for path %s",
 			mpp->alias, pp->dev);
-		if (adopt_paths(vecs->pathvec, mpp))
-			return 1; /* leave path added to pathvec */
+		if (adopt_paths(vecs->pathvec, mpp, 1))
+			goto fail; /* leave path added to pathvec */
 
 		verify_paths(mpp, vecs, NULL);
 		mpp->flush_on_last_del = FLUSH_UNDEF;
@@ -435,37 +481,48 @@ rescan:
 		}
 
 		condlog(4,"%s: creating new map", pp->dev);
-		if ((mpp = add_map_with_path(vecs, pp, 1)))
+		if ((mpp = add_map_with_path(vecs, pp, 1))) {
 			mpp->action = ACT_CREATE;
+			/*
+			 * We don't depend on ACT_CREATE, as domap will
+			 * set it to ACT_NOTHING when complete.
+			 */
+			start_waiter = 1;
+		}
 		else
-			return 1; /* leave path added to pathvec */
+			goto fail; /* leave path added to pathvec */
 	}
 
+	/* persistent reseravtion check*/
+	mpath_pr_event_handle(pp);	
+
 	/*
 	 * push the map to the device-mapper
 	 */
-	if (setup_map(mpp)) {
+	if (setup_map(mpp, params, PARAMS_SIZE)) {
 		condlog(0, "%s: failed to setup map for addition of new "
 			"path %s", mpp->alias, devname);
-		goto out;
+		goto fail_map;
 	}
 	/*
 	 * reload the map for the multipath mapped device
 	 */
-	if (domap(mpp) <= 0) {
+	if (domap(mpp, params) <= 0) {
 		condlog(0, "%s: failed in domap for addition of new "
 			"path %s", mpp->alias, devname);
 		/*
 		 * deal with asynchronous uevents :((
 		 */
-		if (mpp->action == ACT_RELOAD) {
+		if (mpp->action == ACT_RELOAD && retries-- > 0) {
 			condlog(0, "%s: uev_add_path sleep", mpp->alias);
 			sleep(1);
 			update_mpp_paths(mpp, vecs->pathvec);
 			goto rescan;
 		}
+		else if (mpp->action == ACT_RELOAD)
+			condlog(0, "%s: giving up reload", mpp->alias);
 		else
-			goto out;
+			goto fail_map;
 	}
 	dm_lib_release();
 
@@ -473,29 +530,43 @@ rescan:
 	 * update our state from kernel regardless of create or reload
 	 */
 	if (setup_multipath(vecs, mpp))
-		goto out;
+		goto fail; /* if setup_multipath fails, it removes the map */
 
 	sync_map_state(mpp);
 
-	if (mpp->action == ACT_CREATE &&
+	if ((mpp->action == ACT_CREATE ||
+	     (mpp->action == ACT_NOTHING && start_waiter && !mpp->waiter)) &&
 	    start_waiter_thread(mpp, vecs))
-			goto out;
+			goto fail_map;
 
-	condlog(2, "%s path added to devmap %s", devname, mpp->alias);
-	return 0;
+	if (retries >= 0) {
+		condlog(2, "%s path added to devmap %s", devname, mpp->alias);
+		return 0;
+	}
+	else
+		return 1;
 
-out:
+fail_map:
 	remove_map(mpp, vecs, 1);
+fail:
+	orphan_path(pp);
 	return 1;
 }
 
 static int
-uev_remove_path (struct sysfs_device * dev, struct vectors * vecs)
+uev_remove_path (struct uevent *uev, struct vectors * vecs)
 {
+	struct sysfs_device * dev;
 	int retval;
 
-	condlog(2, "%s: remove path (uevent)", dev->kernel);
-	retval = ev_remove_path(dev->kernel, vecs);
+	dev = sysfs_device_get(uev->devpath);
+	if (!dev) {
+		condlog(2, "%s: not found in sysfs", uev->devpath);
+		return 1;
+	}
+	condlog(2, "%s: remove path (uevent)", uev->kernel);
+	retval = ev_remove_path(uev->kernel, vecs);
+
 	if (!retval)
 		sysfs_device_put(dev);
 
@@ -508,6 +579,7 @@ ev_remove_path (char * devname, struct vectors * vecs)
 	struct multipath * mpp;
 	struct path * pp;
 	int i, retval = 0;
+	char params[PARAMS_SIZE] = {0};
 
 	pp = find_path_by_dev(vecs->pathvec, devname);
 
@@ -562,7 +634,7 @@ ev_remove_path (char * devname, struct vectors * vecs)
 			 */
 		}
 
-		if (setup_map(mpp)) {
+		if (setup_map(mpp, params, PARAMS_SIZE)) {
 			condlog(0, "%s: failed to setup map for"
 				" removal of path %s", mpp->alias,
 				devname);
@@ -572,7 +644,7 @@ ev_remove_path (char * devname, struct vectors * vecs)
 		 * reload the map
 		 */
 		mpp->action = ACT_RELOAD;
-		if (domap(mpp) <= 0) {
+		if (domap(mpp, params) <= 0) {
 			condlog(0, "%s: failed in domap for "
 				"removal of path %s",
 				mpp->alias, devname);
@@ -605,6 +677,43 @@ fail:
 }
 
 static int
+uev_update_path (struct uevent *uev, struct vectors * vecs)
+{
+	struct sysfs_device * dev;
+	int retval, ro;
+
+	dev = sysfs_device_get(uev->devpath);
+	if (!dev) {
+		condlog(2, "%s: not found in sysfs", uev->devpath);
+		return 1;
+	}
+	ro = uevent_get_disk_ro(uev);
+
+	if (ro >= 0) {
+		struct path * pp;
+
+		condlog(2, "%s: update path write_protect to '%d' (uevent)",
+			uev->kernel, ro);
+		pp = find_path_by_dev(vecs->pathvec, uev->kernel);
+		if (!pp) {
+			condlog(0, "%s: spurious uevent, path not found",
+				uev->kernel);
+			return 1;
+		}
+		if (pp->mpp)
+			retval = reload_map(vecs, pp->mpp);
+
+		condlog(2, "%s: map %s reloaded (retval %d)",
+			uev->kernel, pp->mpp->alias, retval);
+
+	}
+
+	sysfs_device_put(dev);
+
+	return retval;
+}
+
+static int
 map_discovery (struct vectors * vecs)
 {
 	struct multipath * mpp;
@@ -632,6 +741,7 @@ uxsock_trigger (char * str, char ** reply, int * len, void * trigger_data)
 
 	pthread_cleanup_push(cleanup_lock, &vecs->lock);
 	lock(vecs->lock);
+	pthread_testcancel();
 
 	r = parse_cmd(str, reply, len, vecs);
 
@@ -677,7 +787,6 @@ int
 uev_trigger (struct uevent * uev, void * trigger_data)
 {
 	int r = 0;
-	struct sysfs_device *sysdev;
 	struct vectors * vecs;
 
 	vecs = (struct vectors *)trigger_data;
@@ -685,28 +794,22 @@ uev_trigger (struct uevent * uev, void * trigger_data)
 	if (uev_discard(uev->devpath))
 		return 0;
 
-	sysdev = sysfs_device_get(uev->devpath);
-	if(!sysdev)
-		return 0;
-
+	pthread_cleanup_push(cleanup_lock, &vecs->lock);
 	lock(vecs->lock);
+	pthread_testcancel();
 
 	/*
 	 * device map event
 	 * Add events are ignored here as the tables
 	 * are not fully initialised then.
 	 */
-	if (!strncmp(sysdev->kernel, "dm-", 3)) {
+	if (!strncmp(uev->kernel, "dm-", 3)) {
 		if (!strncmp(uev->action, "change", 6)) {
-			r = uev_add_map(sysdev, vecs);
+			r = uev_add_map(uev, vecs);
 			goto out;
 		}
 		if (!strncmp(uev->action, "remove", 6)) {
-			r = uev_remove_map(sysdev, vecs);
-			goto out;
-		}
-		if (!strncmp(uev->action, "umount", 6)) {
-			r = uev_umount_map(sysdev, vecs);
+			r = uev_remove_map(uev, vecs);
 			goto out;
 		}
 		goto out;
@@ -716,20 +819,24 @@ uev_trigger (struct uevent * uev, void * trigger_data)
 	 * path add/remove event
 	 */
 	if (filter_devnode(conf->blist_devnode, conf->elist_devnode,
-			   sysdev->kernel) > 0)
+			   uev->kernel) > 0)
 		goto out;
 
 	if (!strncmp(uev->action, "add", 3)) {
-		r = uev_add_path(sysdev, vecs);
+		r = uev_add_path(uev, vecs);
 		goto out;
 	}
 	if (!strncmp(uev->action, "remove", 6)) {
-		r = uev_remove_path(sysdev, vecs);
+		r = uev_remove_path(uev, vecs);
+		goto out;
+	}
+	if (!strncmp(uev->action, "change", 6)) {
+		r = uev_update_path(uev, vecs);
 		goto out;
 	}
 
 out:
-	unlock(vecs->lock);
+	lock_cleanup_pop(vecs->lock);
 	return r;
 }
 
@@ -739,13 +846,24 @@ ueventloop (void * ap)
 	block_signal(SIGUSR1, NULL);
 	block_signal(SIGHUP, NULL);
 
-	if (uevent_listen(&uev_trigger, ap))
-		fprintf(stderr, "error starting uevent listener");
+	if (uevent_listen())
+		condlog(0, "error starting uevent listener");
 
 	return NULL;
 }
 
 static void *
+uevqloop (void * ap)
+{
+	block_signal(SIGUSR1, NULL);
+	block_signal(SIGHUP, NULL);
+
+	if (uevent_dispatch(&uev_trigger, ap))
+		condlog(0, "error starting uevent dispatcher");
+
+	return NULL;
+}
+static void *
 uxlsnrloop (void * ap)
 {
 	block_signal(SIGUSR1, NULL);
@@ -758,6 +876,7 @@ uxlsnrloop (void * ap)
 	set_handler_callback(LIST+PATHS+FMT, cli_list_paths_fmt);
 	set_handler_callback(LIST+MAPS, cli_list_maps);
 	set_handler_callback(LIST+STATUS, cli_list_status);
+	set_handler_callback(LIST+DAEMON, cli_list_daemon);
 	set_handler_callback(LIST+MAPS+STATUS, cli_list_maps_status);
 	set_handler_callback(LIST+MAPS+STATS, cli_list_maps_stats);
 	set_handler_callback(LIST+MAPS+FMT, cli_list_maps_fmt);
@@ -777,6 +896,8 @@ uxlsnrloop (void * ap)
 	set_handler_callback(SUSPEND+MAP, cli_suspend);
 	set_handler_callback(RESUME+MAP, cli_resume);
 	set_handler_callback(RESIZE+MAP, cli_resize);
+	set_handler_callback(RELOAD+MAP, cli_reload);
+	set_handler_callback(RESET+MAP, cli_reassign);
 	set_handler_callback(REINSTATE+PATH, cli_reinstate);
 	set_handler_callback(FAIL+PATH, cli_fail);
 	set_handler_callback(DISABLEQ+MAP, cli_disable_queueing);
@@ -784,6 +905,10 @@ uxlsnrloop (void * ap)
 	set_handler_callback(DISABLEQ+MAPS, cli_disable_all_queueing);
 	set_handler_callback(RESTOREQ+MAPS, cli_restore_all_queueing);
 	set_handler_callback(QUIT, cli_quit);
+	set_handler_callback(SHUTDOWN, cli_shutdown);
+	set_handler_callback(GETPRSTATUS+MAP, cli_getprstatus);
+	set_handler_callback(SETPRSTATUS+MAP, cli_setprstatus);
+	set_handler_callback(UNSETPRSTATUS+MAP, cli_unsetprstatus);
 
 	umask(077);
 	uxsock_listen(&uxsock_trigger, ap);
@@ -791,7 +916,7 @@ uxlsnrloop (void * ap)
 	return NULL;
 }
 
-static int
+int
 exit_daemon (int status)
 {
 	if (status != 0)
@@ -807,6 +932,24 @@ exit_daemon (int status)
 	return status;
 }
 
+const char *
+daemon_status(void)
+{
+	switch (running_state) {
+	case DAEMON_INIT:
+		return "init";
+	case DAEMON_START:
+		return "startup";
+	case DAEMON_CONFIGURE:
+		return "configure";
+	case DAEMON_RUNNING:
+		return "running";
+	case DAEMON_SHUTDOWN:
+		return "shutdown";
+	}
+	return NULL;
+}
+
 static void
 fail_path (struct path * pp, int del_active)
 {
@@ -917,10 +1060,66 @@ retry_count_tick(vector mpvec)
 	}
 }
 
+int update_prio(struct path *pp, int refresh_all)
+{
+	int oldpriority;
+	struct path *pp1;
+	struct pathgroup * pgp;
+	int i, j, changed = 0;
+
+	if (refresh_all) {
+		vector_foreach_slot (pp->mpp->pg, pgp, i) {
+			vector_foreach_slot (pgp->paths, pp1, j) {
+				oldpriority = pp1->priority;
+				pathinfo(pp1, conf->hwtable, DI_PRIO);
+				if (pp1->priority != oldpriority)
+					changed = 1;
+			}
+		}
+		return changed;
+	}
+	oldpriority = pp->priority;
+	pathinfo(pp, conf->hwtable, DI_PRIO);
+
+	if (pp->priority == oldpriority)
+		return 0;
+	return 1;
+}
+
+int update_path_groups(struct multipath *mpp, struct vectors *vecs, int refresh)
+{
+	int i;
+	struct path * pp;
+	char params[PARAMS_SIZE];
+
+	update_mpp_paths(mpp, vecs->pathvec);
+	if (refresh) {
+		vector_foreach_slot (mpp->paths, pp, i)
+			pathinfo(pp, conf->hwtable, DI_PRIO);
+	}
+	params[0] = '\0';
+	if (setup_map(mpp, params, PARAMS_SIZE))
+		return 1;
+
+	mpp->action = ACT_RELOAD;
+	if (domap(mpp, params) <= 0) {
+		condlog(0, "%s: failed to update map : %s", mpp->alias,
+			strerror(errno));
+		return 1;
+	}
+	dm_lib_release();
+	if (setup_multipath(vecs, mpp) != 0)
+		return 1;
+	sync_map_state(mpp);
+
+	return 0;
+}
+
 void
 check_path (struct vectors * vecs, struct path * pp)
 {
 	int newstate;
+	int new_path_up = 0;
 
 	if (!pp->mpp)
 		return;
@@ -934,7 +1133,9 @@ check_path (struct vectors * vecs, struct path * pp)
 	 */
 	pp->tick = conf->checkint;
 
-	newstate = get_state(pp, 1);
+	newstate = path_offline(pp);
+	if (newstate == PATH_UP)
+		newstate = get_state(pp, 1);
 
 	if (newstate == PATH_WILD || newstate == PATH_UNCHECKED) {
 		condlog(2, "%s: unusable path", pp->dev);
@@ -949,6 +1150,14 @@ check_path (struct vectors * vecs, struct path * pp)
 		pp->tick = 1;
 		return;
 	}
+	/*
+	 * Synchronize with kernel state
+	 */
+	if (update_multipath_strings(pp->mpp, vecs->pathvec)) {
+		condlog(1, "%s: Could not synchronize with kernel state\n",
+			pp->dev);
+		pp->dmstate = PSTATE_UNDEF;
+	}
 	if (newstate != pp->state) {
 		int oldstate = pp->state;
 		pp->state = newstate;
@@ -960,8 +1169,7 @@ check_path (struct vectors * vecs, struct path * pp)
 		 */
 		pp->checkint = conf->checkint;
 
-		if (newstate == PATH_DOWN || newstate == PATH_SHAKY ||
-		    update_multipath_strings(pp->mpp, vecs->pathvec)) {
+		if (newstate == PATH_DOWN || newstate == PATH_SHAKY) {
 			/*
 			 * proactively fail path in the DM
 			 */
@@ -980,6 +1188,17 @@ check_path (struct vectors * vecs, struct path * pp)
 			return;
 		}
 
+		if(newstate == PATH_UP || newstate == PATH_GHOST){
+			if ( pp->mpp && pp->mpp->prflag ){
+				/*
+				 * Check Persistent Reservation.
+				 */
+			condlog(2, "%s: checking persistent reservation "
+				"registration", pp->dev);
+			mpath_pr_event_handle(pp);
+			}
+		}
+
 		/*
 		 * reinstate this path
 		 */
@@ -989,15 +1208,7 @@ check_path (struct vectors * vecs, struct path * pp)
 		else
 			reinstate_path(pp, 0);
 
-		/*
-		 * schedule [defered] failback
-		 */
-		if (pp->mpp->pgfailback > 0)
-			pp->mpp->failback_tick =
-				pp->mpp->pgfailback + 1;
-		else if (pp->mpp->pgfailback == -FAILBACK_IMMEDIATE &&
-		    need_switch_pathgroup(pp->mpp, 1))
-			switch_pathgroup(pp->mpp);
+		new_path_up = 1;
 
 		/*
 		 * if at least one path is up in a group, and
@@ -1007,22 +1218,32 @@ check_path (struct vectors * vecs, struct path * pp)
 			enable_group(pp);
 	}
 	else if (newstate == PATH_UP || newstate == PATH_GHOST) {
-		LOG_MSG(4, checker_message(&pp->checker));
-		/*
-		 * double the next check delay.
-		 * max at conf->max_checkint
-		 */
-		if (pp->checkint < (conf->max_checkint / 2))
-			pp->checkint = 2 * pp->checkint;
-		else
-			pp->checkint = conf->max_checkint;
+		if (pp->dmstate == PSTATE_FAILED ||
+		    pp->dmstate == PSTATE_UNDEF) {
+			/* Clear IO errors */
+			reinstate_path(pp, 0);
+		} else {
+			LOG_MSG(4, checker_message(&pp->checker));
+			/*
+			 * double the next check delay.
+			 * max at conf->max_checkint
+			 */
+			if (pp->checkint < (conf->max_checkint / 2))
+				pp->checkint = 2 * pp->checkint;
+			else
+				pp->checkint = conf->max_checkint;
 
-		pp->tick = pp->checkint;
-		condlog(4, "%s: delay next check %is",
+			pp->tick = pp->checkint;
+			condlog(4, "%s: delay next check %is",
 				pp->dev_t, pp->tick);
+		}
+	}
+	else if (newstate == PATH_DOWN) {
+		if (conf->log_checker_err == LOG_CHKR_ERR_ONCE)
+			LOG_MSG(3, checker_message(&pp->checker));
+		else
+			LOG_MSG(2, checker_message(&pp->checker));
 	}
-	else if (newstate == PATH_DOWN)
-		LOG_MSG(2, checker_message(&pp->checker));
 
 	pp->state = newstate;
 
@@ -1030,18 +1251,17 @@ check_path (struct vectors * vecs, struct path * pp)
 	 * path prio refreshing
 	 */
 	condlog(4, "path prio refresh");
-	pathinfo(pp, conf->hwtable, DI_PRIO);
 
-	/*
-	 * pathgroup failback policy
-	 */
-	if (need_switch_pathgroup(pp->mpp, 0)) {
+	if (update_prio(pp, new_path_up) &&
+	    (pp->mpp->pgpolicyfn == (pgpolicyfn *)group_by_prio) &&
+	     pp->mpp->pgfailback == -FAILBACK_IMMEDIATE)
+		update_path_groups(pp->mpp, vecs, !new_path_up);
+	else if (need_switch_pathgroup(pp->mpp, 0)) {
 		if (pp->mpp->pgfailback > 0 &&
-		    pp->mpp->failback_tick <= 0)
+		    (new_path_up || pp->mpp->failback_tick <= 0))
 			pp->mpp->failback_tick =
 				pp->mpp->pgfailback + 1;
-		else if (pp->mpp->pgfailback ==
-				-FAILBACK_IMMEDIATE)
+		else if (pp->mpp->pgfailback == -FAILBACK_IMMEDIATE)
 			switch_pathgroup(pp->mpp);
 	}
 }
@@ -1070,6 +1290,7 @@ checkerloop (void *ap)
 		block_signal(SIGHUP, &old);
 		pthread_cleanup_push(cleanup_lock, &vecs->lock);
 		lock(vecs->lock);
+		pthread_testcancel();
 		condlog(4, "tick");
 
 		if (vecs->pathvec) {
@@ -1133,7 +1354,7 @@ configure (struct vectors * vecs, int start_waiters)
 	/*
 	 * create new set of maps & push changed ones into dm
 	 */
-	if (coalesce_paths(vecs, mpvec, NULL, 0))
+	if (coalesce_paths(vecs, mpvec, NULL, 1))
 		return 1;
 
 	/*
@@ -1146,6 +1367,9 @@ configure (struct vectors * vecs, int start_waiters)
 	dm_lib_release();
 
 	sync_maps_state(mpvec);
+	vector_foreach_slot(mpvec, mpp, i){
+		update_map_pr(mpp);
+	}
 
 	/*
 	 * purge dm of old maps
@@ -1175,6 +1399,7 @@ int
 reconfigure (struct vectors * vecs)
 {
 	struct config * old = conf;
+	int retval = 1;
 
 	/*
 	 * free old map and path vectors ... they use old conf state
@@ -1188,19 +1413,15 @@ reconfigure (struct vectors * vecs)
 	vecs->pathvec = NULL;
 	conf = NULL;
 
-	if (load_config(DEFAULT_CONFIGFILE))
-		return 1;
-
-	conf->verbosity = old->verbosity;
-
-	if (!conf->checkint) {
-		conf->checkint = DEFAULT_CHECKINT;
-		conf->max_checkint = MAX_CHECKINT(conf->checkint);
+	if (!load_config(DEFAULT_CONFIGFILE)) {
+		conf->verbosity = old->verbosity;
+		conf->daemon = 1;
+		configure(vecs, 1);
+		free_config(old);
+		retval = 0;
 	}
-	conf->daemon = 1;
-	configure(vecs, 1);
-	free_config(old);
-	return 0;
+
+	return retval;
 }
 
 static struct vectors *
@@ -1254,6 +1475,9 @@ sighup (int sig)
 {
 	condlog(2, "reconfigure (SIGHUP)");
 
+	if (running_state != DAEMON_RUNNING)
+		return;
+
 	lock(gvecs->lock);
 	reconfigure(gvecs);
 	unlock(gvecs->lock);
@@ -1301,51 +1525,46 @@ setscheduler (void)
 }
 
 static void
-set_oom_adj (int val)
+set_oom_adj (void)
 {
+	int retry = 1;
+	char *file = "/proc/self/oom_score_adj";
+	int score = OOM_SCORE_ADJ_MIN;
 	FILE *fp;
-
-	fp = fopen("/proc/self/oom_adj", "w");
-
-	if (!fp)
-		return;
-
-	fprintf(fp, "%i", val);
-	fclose(fp);
-}
-
-void
-setup_thread_attr(pthread_attr_t *attr, size_t stacksize, int detached)
-{
-	if (pthread_attr_init(attr)) {
-		fprintf(stderr, "can't initialize thread attr: %s\n",
-			strerror(errno));
-		exit(1);
-	}
-	if (stacksize < PTHREAD_STACK_MIN)
-		stacksize = PTHREAD_STACK_MIN;
-
-	if (pthread_attr_setstacksize(attr, stacksize)) {
-		fprintf(stderr, "can't set thread stack size to %lu: %s\n",
-			(unsigned long)stacksize, strerror(errno));
-		exit(1);
-	}
-	if (detached && pthread_attr_setdetachstate(attr,
-						    PTHREAD_CREATE_DETACHED)) {
-		fprintf(stderr, "can't set thread to detached: %s\n",
-			strerror(errno));
-		exit(1);
-	}
+	struct stat st;
+
+	do {
+		if (stat(file, &st) == 0){
+			fp = fopen(file, "w");
+			if (!fp) {
+				condlog(0, "couldn't fopen %s : %s", file,
+					strerror(errno));
+				return;
+			}
+			fprintf(fp, "%i", score);
+			fclose(fp);
+			return;
+		}
+		if (errno != ENOENT) {
+			condlog(0, "couldn't stat %s : %s", file,
+				strerror(errno));
+			return;
+		}
+		file = "/proc/self/oom_adj";
+		score = OOM_ADJUST_MIN;
+	} while (retry--);
+	condlog(0, "couldn't adjust oom score");
 }
 
 static int
 child (void * param)
 {
-	pthread_t check_thr, uevent_thr, uxlsnr_thr;
+	pthread_t check_thr, uevent_thr, uxlsnr_thr, uevq_thr;
 	pthread_attr_t log_attr, misc_attr;
 	struct vectors * vecs;
 	struct multipath * mpp;
 	int i;
+	int rc;
 
 	mlockall(MCL_CURRENT | MCL_FUTURE);
 
@@ -1358,6 +1577,8 @@ child (void * param)
 		pthread_attr_destroy(&log_attr);
 	}
 
+	running_state = DAEMON_START;
+
 	condlog(2, "--------start up--------");
 	condlog(2, "read " DEFAULT_CONFIGFILE);
 
@@ -1375,33 +1596,35 @@ child (void * param)
 
 	setlogmask(LOG_UPTO(conf->verbosity + 3));
 
-	/*
-	 * fill the voids left in the config file
-	 */
-	if (!conf->checkint) {
-		conf->checkint = DEFAULT_CHECKINT;
-		conf->max_checkint = MAX_CHECKINT(conf->checkint);
-	}
-
 	if (conf->max_fds) {
 		struct rlimit fd_limit;
 
-		fd_limit.rlim_cur = conf->max_fds;
-		fd_limit.rlim_max = conf->max_fds;
-		if (setrlimit(RLIMIT_NOFILE, &fd_limit) < 0)
-			condlog(0, "can't set open fds limit to %d : %s\n",
-				conf->max_fds, strerror(errno));
-	}
-
-	if (pidfile_create(DEFAULT_PIDFILE, getpid())) {
-		if (logsink)
-			log_thread_stop();
+		if (getrlimit(RLIMIT_NOFILE, &fd_limit) < 0) {
+			condlog(0, "can't get open fds limit: %s\n",
+				strerror(errno));
+			fd_limit.rlim_cur = 0;
+			fd_limit.rlim_max = 0;
+		}
+		if (fd_limit.rlim_cur < conf->max_fds) {
+			fd_limit.rlim_cur = conf->max_fds;
+			if (fd_limit.rlim_max < conf->max_fds)
+				fd_limit.rlim_max = conf->max_fds;
+			if (setrlimit(RLIMIT_NOFILE, &fd_limit) < 0) {
+				condlog(0, "can't set open fds limit to "
+					"%lu/%lu : %s\n",
+					fd_limit.rlim_cur, fd_limit.rlim_max,
+					strerror(errno));
+			} else {
+				condlog(3, "set open fds limit to %lu/%lu\n",
+					fd_limit.rlim_cur, fd_limit.rlim_max);
+			}
+		}
 
-		exit(1);
 	}
+
 	signal_init();
 	setscheduler();
-	set_oom_adj(-16);
+	set_oom_adj();
 	vecs = gvecs = init_vecs();
 
 	if (!vecs)
@@ -1412,48 +1635,75 @@ child (void * param)
 		exit(1);
 	}
 	conf->daemon = 1;
-	dm_udev_set_sync_support(0);
+	udev_set_sync_support(0);
+	/*
+	 * Start uevent listener early to catch events
+	 */
+	if ((rc = pthread_create(&uevent_thr, &misc_attr, ueventloop, vecs))) {
+		condlog(0, "failed to create uevent thread: %d", rc);
+		exit(1);
+	}
+	if ((rc = pthread_create(&uxlsnr_thr, &misc_attr, uxlsnrloop, vecs))) {
+		condlog(0, "failed to create cli listener: %d", rc);
+		exit(1);
+	}
 	/*
 	 * fetch and configure both paths and multipaths
 	 */
+	lock(vecs->lock);
+	running_state = DAEMON_CONFIGURE;
+
 	if (configure(vecs, 1)) {
+		unlock(vecs->lock);
 		condlog(0, "failure during configuration");
 		exit(1);
 	}
+	unlock(vecs->lock);
+
 	/*
 	 * start threads
 	 */
-	pthread_create(&check_thr, &misc_attr, checkerloop, vecs);
-	pthread_create(&uevent_thr, &misc_attr, ueventloop, vecs);
-	pthread_create(&uxlsnr_thr, &misc_attr, uxlsnrloop, vecs);
+	if ((rc = pthread_create(&check_thr, &misc_attr, checkerloop, vecs))) {
+		condlog(0,"failed to create checker loop thread: %d", rc);
+		exit(1);
+	}
+	if ((rc = pthread_create(&uevq_thr, &misc_attr, uevqloop, vecs))) {
+		condlog(0, "failed to create uevent dispatcher: %d", rc);
+		exit(1);
+	}
 	pthread_attr_destroy(&misc_attr);
 
 	pthread_mutex_lock(&exit_mutex);
+	/* Startup complete, create logfile */
+	if (pidfile_create(DEFAULT_PIDFILE, daemon_pid))
+		/* Ignore errors, we can live without */
+		condlog(1, "failed to create pidfile");
+
+	running_state = DAEMON_RUNNING;
 	pthread_cond_wait(&exit_cond, &exit_mutex);
 
 	/*
 	 * exit path
 	 */
+	running_state = DAEMON_SHUTDOWN;
 	block_signal(SIGHUP, NULL);
 	lock(vecs->lock);
 	if (conf->queue_without_daemon == QUE_NO_DAEMON_OFF)
 		vector_foreach_slot(vecs->mpvec, mpp, i)
 			dm_queue_if_no_path(mpp->alias, 0);
 	remove_maps_and_stop_waiters(vecs);
-	free_pathvec(vecs->pathvec, FREE_PATHS);
+	unlock(vecs->lock);
 
 	pthread_cancel(check_thr);
 	pthread_cancel(uevent_thr);
 	pthread_cancel(uxlsnr_thr);
+	pthread_cancel(uevq_thr);
 
 	sysfs_cleanup();
 
-	free_keys(keys);
-	keys = NULL;
-	free_handlers(handlers);
-	handlers = NULL;
-	free_polls();
-
+	lock(vecs->lock);
+	free_pathvec(vecs->pathvec, FREE_PATHS);
+	vecs->pathvec = NULL;
 	unlock(vecs->lock);
 	/* Now all the waitevent threads will start rushing in. */
 	while (vecs->lock.depth > 0) {
@@ -1467,16 +1717,21 @@ child (void * param)
 	FREE(vecs);
 	vecs = NULL;
 
+	cleanup_checkers();
+	cleanup_prio();
+
+	dm_lib_release();
+	dm_lib_exit();
+
+	/* We're done here */
+	condlog(3, "unlink pidfile");
+	unlink(DEFAULT_PIDFILE);
+
 	condlog(2, "--------shut down-------");
 
 	if (logsink)
 		log_thread_stop();
 
-	dm_lib_release();
-	dm_lib_exit();
-
-	cleanup_prio();
-	cleanup_checkers();
 	/*
 	 * Freeing config must be done after condlog() and dm_lib_exit(),
 	 * because logging functions like dlog() and dm_write_log()
@@ -1496,7 +1751,7 @@ static int
 daemonize(void)
 {
 	int pid;
-	int in_fd, out_fd;
+	int dev_null_fd;
 
 	if( (pid = fork()) < 0){
 		fprintf(stderr, "Failed first fork : %s\n", strerror(errno));
@@ -1512,31 +1767,24 @@ daemonize(void)
 	else if (pid != 0)
 		_exit(0);
 
-	in_fd = open("/dev/null", O_RDONLY);
-	if (in_fd < 0){
-		fprintf(stderr, "cannot open /dev/null for input : %s\n",
-			strerror(errno));
-		_exit(0);
-	}
-	out_fd = open("/dev/console", O_WRONLY);
-	if (out_fd < 0){
-		fprintf(stderr, "cannot open /dev/console for output : %s\n",
+	if (chdir("/") < 0)
+		fprintf(stderr, "cannot chdir to '/', continuing\n");
+
+	dev_null_fd = open("/dev/null", O_RDWR);
+	if (dev_null_fd < 0){
+		fprintf(stderr, "cannot open /dev/null for input & output : %s\n",
 			strerror(errno));
 		_exit(0);
 	}
 
 	close(STDIN_FILENO);
-	dup(in_fd);
+	dup(dev_null_fd);
 	close(STDOUT_FILENO);
-	dup(out_fd);
+	dup(dev_null_fd);
 	close(STDERR_FILENO);
-	dup(out_fd);
-
-	close(in_fd);
-	close(out_fd);
-	if (chdir("/") < 0)
-		fprintf(stderr, "cannot chdir to '/', continuing\n");
-
+	dup(dev_null_fd);
+	close(dev_null_fd);
+	daemon_pid = getpid();
 	return 0;
 }
 
@@ -1549,6 +1797,7 @@ main (int argc, char *argv[])
 	int err;
 
 	logsink = 1;
+	running_state = DAEMON_INIT;
 	dm_init();
 
 	if (getuid() != 0) {
@@ -1618,3 +1867,116 @@ main (int argc, char *argv[])
 		return (child(NULL));
 }
 
+void *  mpath_pr_event_handler_fn (void * pathp )
+{
+	struct multipath * mpp;
+	int i,j, ret, isFound;
+	struct path * pp = (struct path *)pathp;
+	unsigned char *keyp;
+	uint64_t prkey;
+	struct prout_param_descriptor *param;
+	struct prin_resp *resp;
+
+	mpp = pp->mpp;
+
+	resp = mpath_alloc_prin_response(MPATH_PRIN_RKEY_SA);
+	if (!resp){
+		condlog(0,"%s Alloc failed for prin response \n", pp->dev);
+		return NULL;
+	}
+
+	ret = prin_do_scsi_ioctl(pp->dev, MPATH_PRIN_RKEY_SA, resp, 0);
+	if (ret != MPATH_PR_SUCCESS )
+	{
+		condlog(0,"%s : pr in read keys service action failed. Error=%d\n", pp->dev, ret);
+		goto out;
+	}
+
+	condlog(3, " event pr=%d addlen=%d\n",resp->prin_descriptor.prin_readkeys.prgeneration,
+			resp->prin_descriptor.prin_readkeys.additional_length );
+
+	if (resp->prin_descriptor.prin_readkeys.additional_length == 0 )
+	{
+		condlog(1, "%s: No key found. Device may not be registered.", pp->dev);
+		ret = MPATH_PR_SUCCESS;
+		goto out;
+	}
+	prkey = 0;
+	keyp = (unsigned char *)mpp->reservation_key;
+	for (j = 0; j < 8; ++j) {
+		if (j > 0)
+			prkey <<= 8;
+		prkey |= *keyp;
+		++keyp;
+	}
+	condlog(2, "Multipath  reservation_key: 0x%" PRIx64 " ", prkey);
+
+	isFound =0;
+	for (i = 0; i < resp->prin_descriptor.prin_readkeys.additional_length/8; i++ )
+	{
+		condlog(2, "PR IN READKEYS[%d]  reservation key:\n",i);
+		dumpHex((char *)&resp->prin_descriptor.prin_readkeys.key_list[i*8], 8 , -1);
+		if (!memcmp(mpp->reservation_key, &resp->prin_descriptor.prin_readkeys.key_list[i*8], 8))
+		{
+			condlog(2, "%s: pr key found in prin readkeys response", mpp->alias);
+			isFound =1;
+			break;
+		}
+	}
+	if (!isFound)
+	{
+		condlog(0, "%s: Either device not registered or ", pp->dev);
+		condlog(0, "host is not authorised for registration. Skip path\n");
+		ret = MPATH_PR_OTHER;
+		goto out;
+	}
+
+	param= malloc(sizeof(struct prout_param_descriptor));
+	memset(param, 0 , sizeof(struct prout_param_descriptor));
+
+	for (j = 7; j >= 0; --j) {
+		param->sa_key[j] = (prkey & 0xff);
+		prkey >>= 8;
+	}
+	param->num_transportid = 0;
+
+	condlog(3, "device %s:%s \n", pp->dev, pp->mpp->wwid);
+
+	ret = prout_do_scsi_ioctl(pp->dev, MPATH_PROUT_REG_IGN_SA, 0, 0, param, 0);
+	if (ret != MPATH_PR_SUCCESS )
+	{
+		condlog(0,"%s: Reservation registration failed. Error: %d\n", pp->dev, ret);
+	}
+	mpp->prflag = 1;
+
+	free(param);
+out:
+	free(resp);
+	return NULL;
+}
+
+int mpath_pr_event_handle(struct path *pp)
+{
+	pthread_t thread;
+	int rc;
+	pthread_attr_t attr;
+	struct multipath * mpp;
+
+	mpp = pp->mpp;
+
+	if (!mpp->reservation_key)
+		return -1;
+
+	pthread_attr_init(&attr);
+	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
+
+	rc = pthread_create(&thread, NULL , mpath_pr_event_handler_fn, pp);
+	if (rc) {
+		condlog(0, "%s: ERROR; return code from pthread_create() is %d\n", pp->dev, rc);
+		return -1;
+	}
+	pthread_attr_destroy(&attr);
+	rc = pthread_join(thread, NULL);
+	return 0;
+}
+
diff --git a/multipathd/main.h b/multipathd/main.h
index 136b7e5..0733299 100644
--- a/multipathd/main.h
+++ b/multipathd/main.h
@@ -3,11 +3,37 @@
 
 #define MAPGCINT 5
 
+enum daemon_status {
+    DAEMON_INIT,
+    DAEMON_START,
+    DAEMON_CONFIGURE,
+    DAEMON_RUNNING,
+    DAEMON_SHUTDOWN,
+};
+
+struct prout_param_descriptor;
+struct prin_resp;
+
+extern pid_t daemon_pid;
+
+int exit_daemon(int);
+const char * daemon_status(void);
 int reconfigure (struct vectors *);
 int ev_add_path (char *, struct vectors *);
 int ev_remove_path (char *, struct vectors *);
-int ev_add_map (struct sysfs_device *, struct vectors *);
-int ev_remove_map (char *, struct vectors *);
+int ev_add_map (char *, char *, struct vectors *);
+int ev_remove_map (char *, char *, int, struct vectors *);
 void sync_map_state (struct multipath *);
+void * mpath_alloc_prin_response(int prin_sa);
+int prin_do_scsi_ioctl(char *, int rq_servact, struct prin_resp * resp,
+       int noisy);
+void dumpHex(const char * , int len, int no_ascii);
+int prout_do_scsi_ioctl(char * , int rq_servact, int rq_scope,
+       unsigned int rq_type, struct prout_param_descriptor *param,
+       int noisy);
+int mpath_pr_event_handle(struct path *pp);
+void * mpath_pr_event_handler_fn (void * );
+int update_map_pr(struct multipath *mpp);
+void * mpath_pr_event_handler_fn (void * pathp );
 
 #endif /* MAIN_H */
diff --git a/multipathd/multipathd.8 b/multipathd/multipathd.8
index c63185c..cbc40a4 100644
--- a/multipathd/multipathd.8
+++ b/multipathd/multipathd.8
@@ -35,9 +35,17 @@ The following commands can be used in interactive mode:
 .B list|show paths
 Show the paths that multipathd is monitoring, and their state. 
 .TP
+.B list|show paths format $format
+Show the paths that multipathd is monitoring, using a format string with path
+format wildcards.
+.TP
 .B list|show maps|multipaths
 Show the multipath devices that the multipathd is monitoring. 
 .TP
+.B list|show maps|multipaths format $format
+Show the status of all multipath devices that the multipathd is monitoring,
+using a format string with multipath format wildcards.
+.TP
 .B list|show maps|multipaths status
 Show the status of all multipath devices that the multipathd is monitoring.
 .TP
@@ -54,6 +62,9 @@ Show the current multipath topology. Same as "multipath -ll".
 Show topology of a single multipath device specified by $map, e.g. 36005076303ffc56200000000000010aa.
 This map could be obtained from "list maps".
 .TP
+.B list|show wildcards
+Show the format wildcards used in interactive commands taking $format
+.TP
 .B list|show config
 Show the currently used configuration, derived from default values and values specified within the configuration file /etc/multipath.conf.
 .TP
@@ -99,11 +110,20 @@ Sets path $path into failed state.
 .B reinstate path $path
 Resumes path $path from failed state.
 .TP
+.B disablequeueing maps|multipaths
+Disable queueing on all multipath devices.
+.TP
+.B restorequeueing maps|multipaths
+Restore queueing on all multipath devices.
+.TP
 .B disablequeueing map|multipath $map
-Disabled queuing on multipathed map $map
+Disable queuing on multipathed map $map
 .TP
 .B restorequeueing map|multipath $map
 Restore queuing on multipahted map $map
+.TP
+.B quit|exit
+End interactive session.
 
 .SH "SEE ALSO"
 .BR multipath (8)
diff --git a/multipathd/multipathd.init.debian b/multipathd/multipathd.init.debian
index f1e2de0..ed23b5b 100644
--- a/multipathd/multipathd.init.debian
+++ b/multipathd/multipathd.init.debian
@@ -2,25 +2,19 @@
 
 PATH=/bin:/usr/bin:/sbin:/usr/sbin
 DAEMON=/usr/bin/multipathd
-PIDFILE=/var/run/multipathd.pid
 
 test -x $DAEMON || exit 0
 
 case "$1" in
   start)
 	echo -n "Starting multipath daemon: multipathd"
-        $DAEMON
+	$DAEMON
 	echo "."
 	;;
   stop)
 	echo -n "Stopping multipath daemon: multipathd"
 	echo "."
-	if [ -f $PIDFILE ]
-	then
-		kill `cat $PIDFILE`
-	else
-		echo "multipathd not running: Nothing to stop..."
-	fi
+	$DAEMON shutdown
 	;;
   force-reload|restart)
 	$0 stop
diff --git a/multipathd/multipathd.init.suse b/multipathd/multipathd.init.suse
index d851354..03a1151 100644
--- a/multipathd/multipathd.init.suse
+++ b/multipathd/multipathd.init.suse
@@ -3,28 +3,30 @@
 #
 # Author: Hannes Reinecke <feedback@suse.de>
 #
-# init.d/routed
-#
-#   and symbolic its link
-#
-# /usr/sbin/rcrouted
+# init.d/multipathd
 #
 ### BEGIN INIT INFO
 # Provides:          multipathd
 # Required-Start:    $syslog
-# Required-Stop:
+# Required-Stop:     $syslog
 # Default-Start:     3 5
 # Default-Stop:	     0 1 2 4 6
-# Description:       Starts multipath daemon
+# Short-Description: Starts multipath daemon
+# Description:       Starts the multipath daemon
 ### END INIT INFO
 
 PATH=/bin:/usr/bin:/sbin:/usr/sbin
 DAEMON=/sbin/multipathd
 PIDFILE=/var/run/multipathd.pid
+MPATH_INIT_TIMEOUT=10
+ARGS=""
 
 # Set the maximum number of open files
 MAX_OPEN_FDS=4096
 
+# Set to enable asynchronous daemon startup
+DAEMON_ASYNC_STARTUP=
+
 test -x $DAEMON || exit 5
 
 . /etc/rc.status
@@ -35,6 +37,12 @@ rc_reset
 case "$1" in
     start)
 	echo -n "Starting multipathd"
+	ulimit -c unlimited
+	if $DAEMON -k"show daemon" > /dev/null 2>&1 ; then
+	    echo -n " (multipathd running)"
+	    rc_status -v
+	    rc_exit
+	fi
 
 	modprobe dm-multipath
 
@@ -43,31 +51,95 @@ case "$1" in
 	    ulimit -n $MAX_OPEN_FDS
 	fi
 
-	if [ -f $PIDFILE ]; then
-		PID="$(cat $PIDFILE)"
-		PROCNAME="$(ps -o cmd --no-headers $PID)"
-	fi
+	$DAEMON $ARGS
 
-	if [ "$PROCNAME" != "$DAEMON" ]; then
-		$DAEMON
+	if [ -n "$DAEMON_ASYNC_STARTUP" ] ; then
+	    rc_status -v
+	    rc_exit
+	fi
+	# Wait for the daemon to start up
+	status=$($DAEMON -k'show daemon' 2> /dev/null)
+	timeout=$MPATH_INIT_TIMEOUT
+	while [ $timeout -gt 0 ] ; do
+	    if [ -n "$status" ] ; then
+		PID=${status##pid }
+		STATUS=${PID##* }
+		# Configuration might be taking some time,
+		# so don't increase the timeout here
+		[ "$STATUS" != "configure" ] && timeout=$(( $timeout - 1 ))
+
+		[ "$STATUS" == "running" ] && break
+	    else
+		timeout=$(( $timeout - 1 ))
+	    fi
+	    sleep 1
+	    status=$($DAEMON -k'show daemon' 2> /dev/null)
+	done
+	if [ -z "$status" ] ; then
+	    rc_failed 7
+	fi
+	if [ $timeout -le 0 ] ; then
+	    rc_failed 1
 	fi
-	
 	# Remember status and be verbose
 	rc_status -v
-	sleep 1
 	;;
     stop)
 	echo -n "Shutting down multipathd"
-	# Because of the way how multipathd sets up its own namespace
-	# and chroots to it, killproc cannot be used with this process.
-	# So implement a cruder version:
-	if [ -f $PIDFILE ]; then
+	STATUS="unknown"
+	# Try to get PID from daemon
+	status=$($DAEMON -k'show daemon' 2> /dev/null)
+	if [ -n "$status" ] ; then
+	    PID=${status##pid }
+	    STATUS=${PID##* }
+	    PID=${PID%% *}
+	fi
+	# Fallback to PID file for older versions
+	if [ -z "$PID" ] || [ "$PID" == "multipath-tools" ] ; then
+	    if [ -f $PIDFILE ]; then
 		PID="$(cat $PIDFILE)"
-		PROCNAME="$(ps -o cmd --no-headers $PID)"
+		STATUS="running"
+	    else
+		rc_failed 7
+		rc_status -v
+		rc_exit
+	    fi
 	fi
-
-	if [ "$PROCNAME" == "$DAEMON" ]; then
-		kill -TERM $PID
+	# Shutdown the daemon via CLI
+	if [ "$STATUS" = "running" ] ; then
+	    status=$($DAEMON -k'shutdown' 2> /dev/null)
+	    if [ "$status" = "ok" ] ; then
+		timeout=$MPATH_INIT_TIMEOUT
+		while [ $timeout -gt 0 ] ; do
+		    PROCNAME="$(ps -p $PID -o comm=)"
+		    if [ "$PROCNAME" != "multipathd" ] &&
+			[ "$PROCNAME" != "multipathd <defunct>" ] ; then
+			STATUS="shutdown"
+			break
+		    fi
+		    sleep 1
+		    timeout=$(( $timeout - 1 ))
+		done
+	    fi
+	fi
+	# Kill the daemon if the above failed
+	if [ -n "$PID" -a "$STATUS" != "shutdown" ] ; then
+	    kill -TERM $PID
+	    timeout=$MPATH_INIT_TIMEOUT
+	    while [ $timeout -gt 0 ] ; do
+		PROCNAME="$(ps -p $PID -o comm=)"
+		if [ "$PROCNAME" != "multipathd" ] &&
+		    [ "$PROCNAME" != "multipathd <defunct>" ] ; then
+		    STATUS="shutdown"
+		    break
+		fi
+		sleep 1
+		timeout=$(( $timeout - 1 ))
+	    done
+	fi
+	if [ $STATUS != "shutdown" ] ; then
+	    echo -n " (still running)"
+	    rc_failed 1
 	fi
 
 	# Remember status and be verbose
@@ -94,8 +166,10 @@ case "$1" in
 	## Like force-reload, but if daemon does not support
 	## signalling, do nothing (!)
 
-	# If it does not support reload:
-	exit 3
+	$DAEMON -k"reconfigure" > /dev/null 2>&1
+
+	# Remember status and be quiet
+	rc_status
 	;;
     status)
 	echo -n "Checking for multipathd: "
@@ -106,18 +180,12 @@ case "$1" in
 	# 2 - service dead, but /var/lock/ lock file exists
 	# 3 - service not running
 
-	if [ -f $PIDFILE ]; then
-		PID="$(cat $PIDFILE)"
-		PROCNAME="$(ps -o cmd --no-headers $PID)"
-		if [ "$PROCNAME" == "$DAEMON" ]; then
-			(exit 0)
-		else
-			(exit 1)
-		fi
+	status=$($DAEMON -k'show daemon' 2> /dev/null)
+	if [ -n "$status" ]; then
+	        (exit 0)
 	else
 		(exit 3)
 	fi
-
 	rc_status -v
 	;;
     probe)
diff --git a/multipathd/multipathd.service b/multipathd/multipathd.service
new file mode 100644
index 0000000..38189c5
--- /dev/null
+++ b/multipathd/multipathd.service
@@ -0,0 +1,14 @@
+[Unit]
+Description=Device-Mapper Multipath Device Controller
+Before=iscsi.service iscsid.service
+After=syslog.target
+
+[Service]
+Type=forking
+PIDFile=/var/run/multipathd.pid
+ExecStart=/sbin/multipathd
+ExecReload=/sbin/multipathd reconfigure
+#ExecStop=/path/to/scrip delete-me if not necessary
+
+[Install]
+WantedBy=multi-user.target
diff --git a/multipathd/uxclnt.c b/multipathd/uxclnt.c
index 2882716..4e3ed26 100644
--- a/multipathd/uxclnt.c
+++ b/multipathd/uxclnt.c
@@ -1,6 +1,6 @@
 /*
  * Original author : tridge@samba.org, January 2002
- * 
+ *
  * Copyright (c) 2005 Christophe Varoqui
  * Copyright (c) 2005 Benjamin Marzinski, Redhat
  */
@@ -33,12 +33,12 @@ static void print_reply(char *s)
 	/* strip ANSI color markers */
 	while (*s != '\0') {
 		if ((*s == 0x1b) && (*(s+1) == '['))
-			while ((*s++ != 'm') && (*s != '\0')) {}; 
+			while ((*s++ != 'm') && (*s != '\0')) {};
 		putchar(*s++);
 	}
 }
 /*
- * process the client 
+ * process the client
  */
 static void process(int fd)
 {
@@ -79,14 +79,18 @@ static void process_req(int fd, char * inbuf)
 	char *reply;
 	size_t len;
 
-	if (send_packet(fd, inbuf, strlen(inbuf) + 1) != 0)
+	if (send_packet(fd, inbuf, strlen(inbuf) + 1) != 0) {
+		printf("cannot send packet\n");
 		return;
-	if (recv_packet(fd, &reply, &len) == 0) {
-		print_reply(reply);
+	}
+	if (recv_packet(fd, &reply, &len) != 0)
+		printf("error receiving packet\n");
+	else {
+		printf("%s", reply);
 		FREE(reply);
 	}
 }
-	
+
 /*
  * entry point
  */
@@ -104,6 +108,6 @@ int uxclnt(char * inbuf)
 		process_req(fd, inbuf);
 	else
 		process(fd);
-	
+
 	return 0;
 }
diff --git a/multipathd/uxlsnr.c b/multipathd/uxlsnr.c
index a05719f..85dbd70 100644
--- a/multipathd/uxlsnr.c
+++ b/multipathd/uxlsnr.c
@@ -29,6 +29,7 @@
 #include <uxsock.h>
 #include <defaults.h>
 
+#include "cli.h"
 #include "uxlsnr.h"
 
 #define SLEEP_TIME 5000
@@ -40,6 +41,7 @@ struct client {
 
 static struct client *clients;
 static unsigned num_clients;
+struct pollfd *polls;
 
 /*
  * handle a new client joining
@@ -81,7 +83,14 @@ static void dead_client(struct client *c)
 
 void free_polls (void)
 {
-	FREE(polls);
+	if (polls)
+		FREE(polls);
+}
+
+void uxsock_cleanup(void *arg)
+{
+	cli_exit();
+	free_polls();
 }
 
 /*
@@ -103,6 +112,8 @@ void * uxsock_listen(int (*uxsock_trigger)(char *, char **, int *, void *),
 		exit(1);
 	}
 
+	pthread_cleanup_push(uxsock_cleanup, NULL);
+
 	polls = (struct pollfd *)MALLOC(0);
 
 	while (1) {
@@ -129,7 +140,7 @@ void * uxsock_listen(int (*uxsock_trigger)(char *, char **, int *, void *),
 
 			/* something went badly wrong! */
 			condlog(0, "poll");
-			exit(1);
+			pthread_exit(NULL);
 		}
 
 		if (poll_count == 0)
@@ -146,13 +157,14 @@ void * uxsock_listen(int (*uxsock_trigger)(char *, char **, int *, void *),
 					inbuf[len - 1] = 0;
 					condlog(4, "Got request [%s]", inbuf);
 					uxsock_trigger(inbuf, &reply, &rlen,
-							trigger_data);
-
+						       trigger_data);
 					if (reply) {
 						if (send_packet(c->fd, reply,
-						     rlen) != 0) {
+								rlen) != 0) {
 							dead_client(c);
 						}
+						condlog(4, "Reply [%d bytes]",
+							rlen);
 						FREE(reply);
 						reply = NULL;
 					}
@@ -168,6 +180,7 @@ void * uxsock_listen(int (*uxsock_trigger)(char *, char **, int *, void *),
 		}
 	}
 
+	pthread_cleanup_pop(1);
 	close(ux_sock);
 	return NULL;
 }
diff --git a/multipathd/uxlsnr.h b/multipathd/uxlsnr.h
index 00d98b0..c646d5d 100644
--- a/multipathd/uxlsnr.h
+++ b/multipathd/uxlsnr.h
@@ -1,7 +1,8 @@
-struct pollfd *polls;
+#ifndef _UXLSNR_H
+#define _UXLSNR_H
 
-void free_polls(void);
 void * uxsock_listen(int (*uxsock_trigger)
 			(char *, char **, int *, void *),
 			void * trigger_data);
+#endif
 

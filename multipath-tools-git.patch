diff --git a/.gitignore b/.gitignore
index 9b3f663..7f25d0e 100644
--- a/.gitignore
+++ b/.gitignore
@@ -5,6 +5,8 @@
 *.so.0
 *.a
 *.gz
-kpartx
-multipath
-multipathd
+kpartx/kpartx
+multipath/multipath
+multipathd/multipathd
+mpathpersist/mpathpersist
+.nfs*
diff --git a/Makefile b/Makefile
index d0063d0..baf7753 100644
--- a/Makefile
+++ b/Makefile
@@ -23,8 +23,10 @@ BUILDDIRS = \
 	libmultipath \
 	libmultipath/prioritizers \
 	libmultipath/checkers \
+	libmpathpersist \
 	multipath \
 	multipathd \
+	mpathpersist \
 	kpartx
 
 ifeq   ($(MULTIPATH_VERSION),)
@@ -64,6 +66,13 @@ install:	recurse_install
 
 uninstall:	recurse_uninstall
 
+.PHONY:	TAGS
+TAGS:
+	etags -a libmultipath/*.c
+	etags -a libmultipath/*.h
+	etags -a multipathd/*.c
+	etags -a multipathd/*.h
+
 release:
 	sed -e "s/__VERSION__/${VERSION}/" \
 	multipath-tools.spec.in > multipath-tools.spec
diff --git a/Makefile.inc b/Makefile.inc
index dbcbc3b..92d2289 100644
--- a/Makefile.inc
+++ b/Makefile.inc
@@ -28,14 +28,21 @@ libudevdir  = ${prefix}/lib/udev
 multipathdir = $(TOPDIR)/libmultipath
 mandir      = $(prefix)/usr/share/man/man8
 man5dir     = $(prefix)/usr/share/man/man5
+man3dir      = $(prefix)/usr/share/man/man3
 rcdir	    = $(prefix)/etc/init.d
 syslibdir   = $(prefix)/$(LIB)
 libdir	    = $(prefix)/$(LIB)/multipath
+unitdir     = $(prefix)/lib/systemd/system
+mpathpersistdir = $(TOPDIR)/libmpathpersist
 
-GZIP        = /bin/gzip -9 -c
+GZIP        = gzip -9 -c
 INSTALL_PROGRAM = install
 
-OPTFLAGS     = -pipe -g -Wall -Wunused -Wstrict-prototypes
+ifndef RPM_OPT_FLAGS
+	RPM_OPT_FLAGS = -O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector --param=ssp-buffer-size=4
+endif
+
+OPTFLAGS     = $(RPM_OPT_FLAGS) -Wunused -Wstrict-prototypes
 CFLAGS	     = $(OPTFLAGS) -fPIC -DLIB_STRING=\"${LIB}\"
 SHARED_FLAGS = -shared
 
diff --git a/kpartx/Makefile b/kpartx/Makefile
index e1e9651..4ba38ba 100644
--- a/kpartx/Makefile
+++ b/kpartx/Makefile
@@ -6,9 +6,15 @@ include ../Makefile.inc
 
 CFLAGS += -I. -D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64
 
+LIBDM_API_COOKIE = $(shell grep -Ecs '^[a-z]*[[:space:]]+dm_task_set_cookie' /usr/include/libdevmapper.h)
+
+ifneq ($(strip $(LIBDM_API_COOKIE)),0)
+	CFLAGS += -DLIBDM_API_COOKIE
+endif
+
 LDFLAGS = -ldevmapper
 OBJS = bsd.o dos.o kpartx.o solaris.o unixware.o dasd.o sun.o \
-       gpt.o mac.o crc32.o lopart.o xstrncpy.o devmapper.o
+       gpt.o mac.o ps3.o crc32.o lopart.o xstrncpy.o devmapper.o
 EXEC = kpartx
 
 all: $(EXEC)
@@ -16,7 +22,7 @@ all: $(EXEC)
 $(EXEC): $(OBJS)
 	$(CC) $(OBJS) -o $(EXEC) $(LDFLAGS)
 	$(GZIP) $(EXEC).8 > $(EXEC).8.gz
-	
+
 install: $(EXEC) $(EXEC).8
 	$(INSTALL_PROGRAM) -d $(DESTDIR)$(bindir)
 	$(INSTALL_PROGRAM) -m 755 $(EXEC) $(DESTDIR)$(bindir)
@@ -30,6 +36,7 @@ install: $(EXEC) $(EXEC).8
 uninstall:
 	rm -f $(DESTDIR)$(bindir)/$(EXEC)
 	rm -f $(DESTDIR)$(mandir)/$(EXEC).8.gz
+	rm -f $(DESTDIR)$(libudevdir)/kpartx_id
 
 clean:
 	rm -f core *.o $(EXEC) *.gz
diff --git a/kpartx/byteorder.h b/kpartx/byteorder.h
index 21962d6..199c66b 100644
--- a/kpartx/byteorder.h
+++ b/kpartx/byteorder.h
@@ -12,12 +12,16 @@
 #  define le16_to_cpu(x) (x)
 #  define be16_to_cpu(x) bswap_16(x)
 #  define le32_to_cpu(x) (x)
+#  define le64_to_cpu(x) (x)
 #  define be32_to_cpu(x) bswap_32(x)
+#  define be64_to_cpu(x) bswap_64(x)
 #elif BYTE_ORDER == BIG_ENDIAN
 #  define le16_to_cpu(x) bswap_16(x)
 #  define be16_to_cpu(x) (x)
 #  define le32_to_cpu(x) bswap_32(x)
+#  define le64_to_cpu(x) bswap_64(x)
 #  define be32_to_cpu(x) (x)
+#  define be64_to_cpu(x) (x)
 #else
 #  error unsupported
 #endif
diff --git a/kpartx/dasd.h b/kpartx/dasd.h
index 0ed7c80..42f94db 100644
--- a/kpartx/dasd.h
+++ b/kpartx/dasd.h
@@ -68,7 +68,7 @@ typedef struct volume_label
 	char res2[4];	        /* reserved                                  */
 	char lvtoc[14];	        /* owner code for LVTOC                      */
 	char res3[28];	        /* reserved                                  */
-	char ldl_version;       /* version number, valid for ldl format      */
+	uint8_t ldl_version;    /* version number, valid for ldl format      */
 	uint64_t formatted_blocks; /* valid when ldl_version >= f2           */
 } __attribute__ ((packed)) volume_label_t;
 
diff --git a/kpartx/devmapper.c b/kpartx/devmapper.c
index f884511..24a43ee 100644
--- a/kpartx/devmapper.c
+++ b/kpartx/devmapper.c
@@ -12,6 +12,14 @@
 
 #define UUID_PREFIX "part%d-"
 #define MAX_PREFIX_LEN 8
+#define PARAMS_SIZE 1024
+
+#ifndef LIBDM_API_COOKIE
+static inline int dm_task_set_cookie(struct dm_task *dmt, uint32_t *c, int a)
+{
+	return 1;
+}
+#endif
 
 extern int
 dm_prereq (char * str, int x, int y, int z)
@@ -70,7 +78,7 @@ dm_simplecmd (int task, const char *name, int no_flush, uint32_t *cookie) {
 	if (no_flush)
 		dm_task_no_flush(dmt);
 
-	if (udev_wait_flag && !dm_task_set_cookie(dmt, cookie, 0))
+	if (udev_wait_flag && !dm_task_set_cookie(dmt, cookie, (udev_sync)? 0 : DM_UDEV_DISABLE_LIBRARY_FALLBACK))
 		goto out;
 	r = dm_task_run(dmt);
 
@@ -81,7 +89,7 @@ dm_simplecmd (int task, const char *name, int no_flush, uint32_t *cookie) {
 
 extern int
 dm_addmap (int task, const char *name, const char *target,
-	   const char *params, uint64_t size, const char *uuid, int part,
+	   const char *params, uint64_t size, int ro, const char *uuid, int part,
 	   mode_t mode, uid_t uid, gid_t gid, uint32_t *cookie) {
 	int r = 0;
 	struct dm_task *dmt;
@@ -96,6 +104,9 @@ dm_addmap (int task, const char *name, const char *target,
 	if (!dm_task_add_target (dmt, 0, size, target, params))
 		goto addout;
 
+	if (ro && !dm_task_set_ro (dmt))
+			goto addout;
+
 	if (task == DM_DEVICE_CREATE && uuid) {
 		prefixed_uuid = malloc(MAX_PREFIX_LEN + strlen(uuid) + 1);
 		if (!prefixed_uuid) {
@@ -117,7 +128,7 @@ dm_addmap (int task, const char *name, const char *target,
 
 	dm_task_no_open_count(dmt);
 
-	if (task == DM_DEVICE_CREATE && !dm_task_set_cookie(dmt, cookie, 0))
+	if (task == DM_DEVICE_CREATE && !dm_task_set_cookie(dmt, cookie, (udev_sync)? 0 : DM_UDEV_DISABLE_LIBRARY_FALLBACK))
 		goto addout;
 	r = dm_task_run (dmt);
 
@@ -268,3 +279,62 @@ out:
 	return r;
 }
 
+int
+dm_get_map(int major, int minor, char * outparams)
+{
+	int r = 1;
+	struct dm_task *dmt;
+	void *next = NULL;
+	uint64_t start, length;
+	char *target_type = NULL;
+	char *params = NULL;
+
+	if (!(dmt = dm_task_create(DM_DEVICE_TABLE)))
+		return 1;
+
+	dm_task_set_major(dmt, major);
+	dm_task_set_minor(dmt, minor);
+	dm_task_no_open_count(dmt);
+
+	if (!dm_task_run(dmt))
+		goto out;
+
+	/* Fetch 1st target */
+	next = dm_get_next_target(dmt, next, &start, &length,
+				  &target_type, &params);
+
+	if (snprintf(outparams, PARAMS_SIZE, "%s", params) <= PARAMS_SIZE)
+		r = 0;
+out:
+	dm_task_destroy(dmt);
+	return r;
+}
+
+#define FEATURE_NO_PART "no_partitions"
+
+int
+dm_no_partitions(int major, int minor)
+{
+	char params[PARAMS_SIZE], *ptr;
+	int i, num_features;
+
+	if (dm_get_map(major, minor, params))
+		return 0;
+
+	ptr = params;
+	num_features = strtoul(params, &ptr, 10);
+	if ((ptr == params) || num_features == 0) {
+		/* No features found, return success */
+		return 0;
+	}
+	for (i = 0; (i < num_features); i++) {
+		if (!ptr || ptr > params + strlen(params))
+			break;
+		/* Skip whitespaces */
+		while(ptr && *ptr == ' ') ptr++;
+		if (!strncmp(ptr, FEATURE_NO_PART, strlen(FEATURE_NO_PART)))
+			return 1;
+		ptr = strchr(ptr, ' ');
+	}
+	return 0;
+}
diff --git a/kpartx/devmapper.h b/kpartx/devmapper.h
index f8692cc..0edc063 100644
--- a/kpartx/devmapper.h
+++ b/kpartx/devmapper.h
@@ -2,12 +2,15 @@
 #define MINOR(dev)      ((dev & 0xff) | ((dev >> 12) & 0xfff00))
 #define MKDEV(ma,mi)    ((mi & 0xff) | (ma << 8) | ((mi & ~0xff) << 12))
 
+extern int udev_sync;
+
 int dm_prereq (char *, int, int, int);
 int dm_simplecmd (int, const char *, int, uint32_t *);
 int dm_addmap (int, const char *, const char *, const char *, uint64_t,
-	       const char *, int, mode_t, uid_t, gid_t, uint32_t *);
+	       int, const char *, int, mode_t, uid_t, gid_t, uint32_t *);
 int dm_map_present (char *);
 char * dm_mapname(int major, int minor);
 dev_t dm_get_first_dep(char *devname);
 char * dm_mapuuid(int major, int minor);
 int dm_devn (char * mapname, int *major, int *minor);
+int dm_no_partitions(int major, int minor);
diff --git a/kpartx/dos.c b/kpartx/dos.c
index 1691105..a1a9961 100644
--- a/kpartx/dos.c
+++ b/kpartx/dos.c
@@ -98,6 +98,8 @@ read_dos_pt(int fd, struct slice all, struct slice *sp, int ns) {
 			break;
 		}
 		if (is_extended(p.sys_type)) {
+			sp[i].size = 2; /* extended partitions only get two
+					   sectors mapped for LILO to install */
 			n += read_extended_partition(fd, &p, i, sp+n, ns-n);
 		}
 	}
diff --git a/kpartx/gpt.c b/kpartx/gpt.c
index 047a829..0a22927 100644
--- a/kpartx/gpt.c
+++ b/kpartx/gpt.c
@@ -358,6 +358,24 @@ is_gpt_valid(int fd, uint64_t lba,
 		return 0;
 	}
 
+	/* Check that sizeof_partition_entry has the correct value */
+	if (__le32_to_cpu((*gpt)->sizeof_partition_entry) != sizeof(gpt_entry)) {
+		// printf("GUID partition entry size check failed.\n");
+		free(*gpt);
+		*gpt = NULL;
+		return 0;
+	}
+
+
+	/* Check that sizeof_partition_entry has the correct value */
+	if (__le32_to_cpu((*gpt)->sizeof_partition_entry) != sizeof(gpt_entry)) {
+		// printf("GUID partition entry size check failed.\n");
+		free(*gpt);
+		*gpt = NULL;
+		return 0;
+	}
+
+
 	if (!(*ptes = alloc_read_gpt_entries(fd, *gpt))) {
 		free(*gpt);
 		*gpt = NULL;
@@ -619,6 +637,7 @@ read_gpt_pt (int fd, struct slice all, struct slice *sp, int ns)
 	uint32_t i;
 	int n = 0;
         int last_used_index=-1;
+	int sector_size_mul = get_sector_size(fd)/512;
 
 	if (!find_valid_gpt (fd, &gpt, &ptes) || !gpt || !ptes) {
 		if (gpt)
@@ -634,9 +653,11 @@ read_gpt_pt (int fd, struct slice all, struct slice *sp, int ns)
 			sp[n].size = 0;
 			n++;
 		} else {
-			sp[n].start = __le64_to_cpu(ptes[i].starting_lba);
-			sp[n].size  = __le64_to_cpu(ptes[i].ending_lba) -
-				__le64_to_cpu(ptes[i].starting_lba) + 1;
+			sp[n].start = sector_size_mul *
+				      __le64_to_cpu(ptes[i].starting_lba);
+			sp[n].size  = sector_size_mul *
+				      (__le64_to_cpu(ptes[i].ending_lba) -
+				       __le64_to_cpu(ptes[i].starting_lba) + 1);
                         last_used_index=n;
 			n++;
 		}
diff --git a/kpartx/kpartx.8 b/kpartx/kpartx.8
index 923be1e..021ddc0 100644
--- a/kpartx/kpartx.8
+++ b/kpartx/kpartx.8
@@ -17,20 +17,52 @@ creation and deletion.
 .B \-a
 Add partition mappings
 .TP
+.B \-r
+Read-only partition mappings
+.TP
 .B \-d
 Delete partition mappings
 .TP
+.B \-u
+Update partition mappings
+.TP
 .B \-l
-List partition mappings that would be added -a
+List partition mappings that would be added \-a
 .TP
 .B \-p
 set device name-partition number delimiter
 .TP
+.B \-f
+force creation of mappings; overrides 'no_partitions' feature
+.TP
 .B \-g
 force GUID partition table (GPT)
 .TP
 .B \-v
 Operate verbosely
+.TP
+.B \-s
+Sync mode. Don't return until the partitions are created
+.SH EXAMPLE
+To mount all the partitions in a raw disk image:
+.IP
+kpartx \-av disk.img
+.PP
+This will output lines such as:
+.IP
+loop3p1 : 0 20964762 /dev/loop3 63
+.PP
+The 
+.I loop3p1
+is the name of a device file under 
+.I /dev/mapper
+which you can use to access the partition, for example to fsck it:
+.IP
+fsck /dev/mapper/loop3p1
+.PP
+When you're done, you need to remove the devices:
+.IP
+kpartx \-d disk.img
 .SH "SEE ALSO"
 .BR multipath (8)
 .BR multipathd (8)
diff --git a/kpartx/kpartx.c b/kpartx/kpartx.c
index 3d33990..98d88c0 100644
--- a/kpartx/kpartx.c
+++ b/kpartx/kpartx.c
@@ -48,7 +48,7 @@
 
 struct slice slices[MAXSLICES];
 
-enum action { LIST, ADD, DELETE };
+enum action { LIST, ADD, DELETE, UPDATE };
 
 struct pt {
 	char *type;
@@ -56,6 +56,7 @@ struct pt {
 } pts[MAXTYPES];
 
 int ptct = 0;
+int udev_sync = 0;
 
 static void
 addpts(char *t, ptreader f)
@@ -80,21 +81,27 @@ initpts(void)
 	addpts("dasd", read_dasd_pt);
 	addpts("mac", read_mac_pt);
 	addpts("sun", read_sun_pt);
+	addpts("ps3", read_ps3_pt);
 }
 
-static char short_opts[] = "ladgvp:t:s";
+static char short_opts[] = "rladfgvp:t:su";
 
 /* Used in gpt.c */
 int force_gpt=0;
 
+int force_devmap=0;
+
 static int
 usage(void) {
-	printf("usage : kpartx [-a|-d|-l] [-v] wholedisk\n");
+	printf("usage : kpartx [-a|-d|-l] [-f] [-v] wholedisk\n");
 	printf("\t-a add partition devmappings\n");
+	printf("\t-r devmappings will be readonly\n");
 	printf("\t-d del partition devmappings\n");
+	printf("\t-u update partition devmappings\n");
 	printf("\t-l list partitions devmappings that would be added by -a\n");
 	printf("\t-p set device name-partition number delimiter\n");
 	printf("\t-g force GUID partition table (GPT)\n");
+	printf("\t-f force devmap create\n");
 	printf("\t-v verbose\n");
 	printf("\t-s sync mode. Don't return until the partitions are created\n");
 	return 1;
@@ -185,7 +192,8 @@ get_hotplug_device(void)
 
 int
 main(int argc, char **argv){
-	int fd, i, j, m, n, op, off, arg, c, d;
+	int i, j, m, n, op, off, arg, c, d, ro=0;
+	int fd = -1;
 	struct slice all;
 	struct pt *ptp;
 	enum action what = LIST;
@@ -199,7 +207,6 @@ main(int argc, char **argv){
 	int loopro = 0;
 	int hotplug = 0;
 	int loopcreated = 0;
-	int sync = 0;
 	struct stat buf;
 	uint32_t cookie = 0;
 
@@ -233,6 +240,12 @@ main(int argc, char **argv){
 	}
 
 	while ((arg = getopt(argc, argv, short_opts)) != EOF) switch(arg) {
+		case 'r':
+			ro=1;
+			break;
+		case 'f':
+			force_devmap=1;
+			break;
 		case 'g':
 			force_gpt=1;
 			break;
@@ -255,17 +268,22 @@ main(int argc, char **argv){
 			what = DELETE;
 			break;
 		case 's':
-			sync = 1;
+			udev_sync = 1;
+			break;
+		case 'u':
+			what = UPDATE;
 			break;
 		default:
 			usage();
 			exit(1);
 	}
 
-	if (!sync)
+#ifdef LIBDM_API_COOKIE
+	if (!udev_sync)
 		dm_udev_set_sync_support(0);
+#endif
 
-	if (dm_prereq(DM_TARGET, 0, 0, 0) && (what == ADD || what == DELETE)) {
+	if (dm_prereq(DM_TARGET, 0, 0, 0) && (what == ADD || what == DELETE || what == UPDATE)) {
 		fprintf(stderr, "device mapper prerequisites not met\n");
 		exit(1);
 	}
@@ -306,12 +324,6 @@ main(int argc, char **argv){
 		device = loopdev;
 	}
 
-	if (delim == NULL) {
-		delim = malloc(DELIM_SIZE);
-		memset(delim, 0, DELIM_SIZE);
-		set_delimiter(device, delim);
-	}
-
 	off = find_devname_offset(device);
 
 	if (!loopdev) {
@@ -326,6 +338,18 @@ main(int argc, char **argv){
 
 	if (!mapname)
 		mapname = device + off;
+	else if (!force_devmap &&
+		 dm_no_partitions((unsigned int)MAJOR(buf.st_rdev),
+				  (unsigned int)MINOR(buf.st_rdev))) {
+		/* Feature 'no_partitions' is set, return */
+		return 0;
+	}
+
+	if (delim == NULL) {
+		delim = malloc(DELIM_SIZE);
+		memset(delim, 0, DELIM_SIZE);
+		set_delimiter(mapname, delim);
+	}
 
 	fd = open(device, O_RDONLY);
 
@@ -350,8 +374,10 @@ main(int argc, char **argv){
 			printf("%s: %d slices\n", ptp->type, n);
 #endif
 
-		if (n > 0)
+		if (n > 0) {
 			close(fd);
+			fd = -1;
+		}
 		else
 			continue;
 
@@ -399,15 +425,6 @@ main(int argc, char **argv){
 					break;
 			}
 
-			if (loopcreated && S_ISREG (buf.st_mode)) {
-				if (del_loop(device)) {
-					if (verbose)
-						printf("can't del loop : %s\n",
-							device);
-					exit(1);
-				}
-				printf("loop deleted : %s\n", device);
-			}
 			break;
 
 		case DELETE:
@@ -443,6 +460,8 @@ main(int argc, char **argv){
 			break;
 
 		case ADD:
+		case UPDATE:
+			/* ADD and UPDATE share the same code that adds new partitions. */
 			for (j = 0, c = 0; j < n; j++) {
 				if (slices[j].size == 0)
 					continue;
@@ -470,7 +489,7 @@ main(int argc, char **argv){
 					DM_DEVICE_RELOAD : DM_DEVICE_CREATE);
 
 				if (!dm_addmap(op, partname, DM_TARGET, params,
-					       slices[j].size, uuid, j+1,
+					       slices[j].size, ro, uuid, j+1,
 					       buf.st_mode & 0777, buf.st_uid,
 					       buf.st_gid, &cookie)) {
 					fprintf(stderr, "create/reload failed on %s\n",
@@ -497,7 +516,6 @@ main(int argc, char **argv){
 			d = c;
 			while (c) {
 				for (j = 0; j < n; j++) {
-					uint64_t start;
 					int k = slices[j].container - 1;
 
 					if (slices[j].size == 0)
@@ -523,11 +541,9 @@ main(int argc, char **argv){
 					}
 					strip_slash(partname);
 
-					start = slices[j].start - slices[k].start;
-					if (safe_sprintf(params, "%d:%d %" PRIu64,
-							 slices[k].major,
-							 slices[k].minor,
-							 start)) {
+					if (safe_sprintf(params, "%s %" PRIu64,
+							 device,
+							 slices[j].start)) {
 						fprintf(stderr, "params too small\n");
 						exit(1);
 					}
@@ -536,7 +552,7 @@ main(int argc, char **argv){
 					      DM_DEVICE_RELOAD : DM_DEVICE_CREATE);
 
 					dm_addmap(op, partname, DM_TARGET, params,
-						  slices[j].size, uuid, j+1,
+						  slices[j].size, ro, uuid, j+1,
 						  buf.st_mode & 0777,
 						  buf.st_uid, buf.st_gid,
 						  &cookie);
@@ -559,7 +575,31 @@ main(int argc, char **argv){
 				if (d == c)
 					break;
 			}
-			break;
+
+			if (what == ADD) {
+				/* Skip code that removes devmappings for deleted partitions */
+				break;
+			}
+
+			for (j = MAXSLICES-1; j >= 0; j--) {
+				if (safe_sprintf(partname, "%s%s%d",
+					     mapname, delim, j+1)) {
+					fprintf(stderr, "partname too small\n");
+					exit(1);
+				}
+				strip_slash(partname);
+
+				if (slices[j].size || !dm_map_present(partname))
+					continue;
+
+				if (!dm_simplecmd(DM_DEVICE_REMOVE,
+						  partname, 1, &cookie)) {
+					r++;
+					continue;
+				}
+				if (verbose)
+					printf("del devmap : %s\n", partname);
+			}
 
 		default:
 			break;
@@ -568,7 +608,20 @@ main(int argc, char **argv){
 		if (n > 0)
 			break;
 	}
+	if (what == LIST && loopcreated && S_ISREG (buf.st_mode)) {
+		if (fd != -1)
+			close(fd);
+		if (del_loop(device)) {
+			if (verbose)
+				printf("can't del loop : %s\n",
+					device);
+			exit(1);
+		}
+		printf("loop deleted : %s\n", device);
+	}
+#ifdef LIBDM_API_COOKIE
 	dm_udev_wait(cookie);
+#endif
 	dm_lib_release();
 	dm_lib_exit();
 
diff --git a/kpartx/kpartx.h b/kpartx/kpartx.h
index 43ae3f8..61d31b6 100644
--- a/kpartx/kpartx.h
+++ b/kpartx/kpartx.h
@@ -39,6 +39,7 @@ extern ptreader read_gpt_pt;
 extern ptreader read_dasd_pt;
 extern ptreader read_mac_pt;
 extern ptreader read_sun_pt;
+extern ptreader read_ps3_pt;
 
 char *getblock(int fd, unsigned int secnr);
 
diff --git a/kpartx/kpartx.rules b/kpartx/kpartx.rules
index 8978b73..b96ec89 100644
--- a/kpartx/kpartx.rules
+++ b/kpartx/kpartx.rules
@@ -8,6 +8,8 @@ KERNEL!="dm-*", GOTO="kpartx_end"
 ACTION=="remove", GOTO="kpartx_end"
 
 ENV{DM_TABLE_STATE}!="LIVE", GOTO="kpartx_end"
+ENV{DM_ACTION}=="PATH_FAILED|PATH_REINSTATED", GOTO="kpartx_end"
+ENV{DM_DEPS}=="0", GOTO="kpartx_end"
 
 ENV{DM_UUID}=="?*", IMPORT{program}=="kpartx_id %M %m $env{DM_UUID}"
 
@@ -16,20 +18,22 @@ OPTIONS="link_priority=50"
 # Create persistent links for multipath tables
 ENV{DM_UUID}=="mpath-*", \
 	SYMLINK+="disk/by-id/$env{DM_TYPE}-$env{DM_NAME}"
-
-# Create persistent links for dmraid tables
-ENV{DM_UUID}=="dmraid-*", \
-        SYMLINK+="disk/by-id/$env{DM_TYPE}-$env{DM_NAME}"
+ENV{DM_MPATH}=="?*", ENV{DM_PART}!="?*", \
+	SYMLINK+="disk/by-id/$env{DM_TYPE}-$env{DM_MPATH}"
+ENV{DM_WWN}=="?*", ENV{DM_PART}!="?*", \
+	SYMLINK+="disk/by-id/wwn-$env{DM_WWN}"
 
 # Create persistent links for partitions
 ENV{DM_PART}=="?*", \
         SYMLINK+="disk/by-id/$env{DM_TYPE}-$env{DM_NAME}-part$env{DM_PART}"
+ENV{DM_MPATH}=="?*", ENV{DM_PART}=="?*", \
+	SYMLINK+="disk/by-id/$env{DM_TYPE}-$env{DM_MPATH}-part$env{DM_PART}"
+ENV{DM_WWN}=="?*", ENV{DM_PART}=="?*", \
+	SYMLINK+="disk/by-id/wwn-$env{DM_WWN}-part$env{DM_PART}"
 
 # Create dm tables for partitions
-ENV{DM_STATE}=="ACTIVE", ENV{DM_UUID}=="mpath-*", \
-        RUN+="/sbin/kpartx -a -p -part /dev/$name"
-ENV{DM_STATE}=="ACTIVE", ENV{DM_UUID}=="dmraid-*", \
-        RUN+="/sbin/kpartx -a -p -part /dev/$name"
+ENV{DM_STATE}!="SUSPENDED", ENV{DM_UUID}=="mpath-*", \
+        RUN+="/sbin/kpartx -u -p -part /dev/$name"
 
 LABEL="kpartx_end"
 
diff --git a/kpartx/kpartx_id b/kpartx/kpartx_id
index 81f32bf..517b856 100644
--- a/kpartx/kpartx_id
+++ b/kpartx/kpartx_id
@@ -55,6 +55,9 @@ if [ "$dmtbl" = "part" ] ; then
     # The name of the kpartx table is the name of the parent table
     dmname=$($DMSETUP info  -c --noheadings -o name -u $dmuuid)
     echo "DM_NAME=$dmname"
+    if [ "$dmname" != ${dmuuid#mpath-} ] ; then
+	echo "DM_MPATH=${dmuuid#mpath-}"
+    fi
     # We need the dependencies of the parent table to figure out
     # the type if the parent is a multipath table
     case "$dmuuid" in
@@ -63,7 +66,10 @@ if [ "$dmtbl" = "part" ] ; then
 	    ;;
     esac
 elif [ "$dmtbl" = "mpath" ] ; then
-    dmname=$tblname
+    if [ -n "$DM_NAME" -a "$DM_NAME" != "$dmuuid" ] ; then
+	echo "DM_MPATH=$dmuuid"
+    fi
+    dmname="$dmuuid"
     # We need the dependencies of the table to figure out the type
     dmdeps=$($DMSETUP deps -u $UUID)
 elif [ "$dmtbl" = "dmraid" ] ; then
@@ -77,13 +83,17 @@ fi
 if [ -n "$dmdeps" ] ; then
     case "$dmdeps" in
 	*\(94,*)
-            echo "DM_TYPE=dasd"
+            echo "DM_TYPE=ccw"
+	    ;;
+	*\(104,* | *\(105,* | *\(106,* | *\(107,* | *\(108,* | *\(109,* | *\(110,* | *\(112,*)
+	    echo "DM_TYPE=cciss"
 	    ;;
 	*\(9*)
             echo "DM_TYPE=raid"
 	    ;;
 	*)
             echo "DM_TYPE=scsi"
+	    echo "DM_WWN=0x${dmname#?}"
 	    ;;
     esac
 else
diff --git a/kpartx/lopart.c b/kpartx/lopart.c
index 79d8328..79a7593 100644
--- a/kpartx/lopart.c
+++ b/kpartx/lopart.c
@@ -26,18 +26,7 @@
 #include <sys/stat.h>
 #include <sys/mman.h>
 #include <sysmacros.h>
-
-#if defined(__hppa__) || defined(__powerpc64__) || defined (__alpha__) \
- || defined (__x86_64__)
-typedef unsigned long __kernel_old_dev_t;
-#elif defined(__powerpc__) || defined(__ia64__) || (defined(__sparc__) && defined (__arch64__))
-typedef unsigned int __kernel_old_dev_t;
-#else
-typedef unsigned short __kernel_old_dev_t;
-#endif
-
-#define dev_t __kernel_old_dev_t
-
+#include <asm/posix_types.h>
 #include <linux/loop.h>
 
 #include "lopart.h"
@@ -216,13 +205,13 @@ find_unused_loop_device (void)
 		fprintf(stderr,
 		    "mount: Could not find any loop device, and, according to %s,\n"
 		    "       this kernel does not know about the loop device.\n"
-		    "       (If so, then recompile or `insmod loop.o'.)",
+		    "       (If so, then recompile or `modprobe loop'.)",
 		      PROC_DEVICES);
 
 	    else
 		fprintf(stderr,
 		    "mount: Could not find any loop device. Maybe this kernel does not know\n"
-		    "       about the loop device (then recompile or `insmod loop.o'), or\n"
+		    "       about the loop device (then recompile or `modprobe loop'), or\n"
 		    "       maybe /dev/loop# has the wrong major number?");
 
 	} else
@@ -286,6 +275,7 @@ set_loop (const char *device, const char *file, int offset, int *loopro)
 extern int 
 del_loop (const char *device)
 {
+	int retries = 3;
 	int fd;
 
 	if ((fd = open (device, O_RDONLY)) < 0) {
@@ -295,10 +285,17 @@ del_loop (const char *device)
 		return 1;
 	}
 
-	if (ioctl (fd, LOOP_CLR_FD, 0) < 0) {
-		perror ("ioctl: LOOP_CLR_FD");
-		close (fd);
-		return 1;
+	while (ioctl (fd, LOOP_CLR_FD, 0) < 0) {
+		if (errno != EBUSY || retries-- <= 0) {
+			perror ("ioctl: LOOP_CLR_FD");
+			close (fd);
+			return 1;
+		}
+		fprintf(stderr,
+			"loop: device %s still in use, retrying delete\n",
+			device);
+		sleep(1);
+		continue;
 	}
 
 	close (fd);
diff --git a/kpartx/ps3.c b/kpartx/ps3.c
new file mode 100644
index 0000000..d1e5d64
--- /dev/null
+++ b/kpartx/ps3.c
@@ -0,0 +1,77 @@
+#include "kpartx.h"
+#include "byteorder.h"
+#include <sys/types.h>
+#include <string.h>
+
+#define SECTOR_SIZE		512
+#define MAX_ACL_ENTRIES		8
+#define MAX_PARTITIONS		8
+
+#define MAGIC1			0x0FACE0FFULL
+#define MAGIC2			0xDEADFACEULL
+
+struct p_acl_entry {
+	u_int64_t laid;
+	u_int64_t rights;
+};
+
+struct d_partition {
+	u_int64_t p_start;
+	u_int64_t p_size;
+	struct p_acl_entry p_acl[MAX_ACL_ENTRIES];
+};
+
+struct disklabel {
+	u_int8_t d_res1[16];
+	u_int64_t d_magic1;
+	u_int64_t d_magic2;
+	u_int64_t d_res2;
+	u_int64_t d_res3;
+	struct d_partition d_partitions[MAX_PARTITIONS];
+	u_int8_t d_pad[0x600 - MAX_PARTITIONS * sizeof(struct d_partition)- 0x30];
+};
+
+static int
+read_disklabel(int fd, struct disklabel *label) {
+	unsigned char *data;
+	int i;
+
+	for (i = 0; i < sizeof(struct disklabel) / SECTOR_SIZE; i++) {
+		data = (unsigned char *) getblock(fd, i);
+		if (!data)
+			return 0;
+
+		memcpy((unsigned char *) label + i * SECTOR_SIZE, data, SECTOR_SIZE);
+	}
+
+	return 1;
+}
+
+int
+read_ps3_pt(int fd, struct slice all, struct slice *sp, int ns) {
+	struct disklabel label;
+        int n = 0;
+	int i;
+
+	if (!read_disklabel(fd, &label))
+		return -1;
+
+	if ((be64_to_cpu(label.d_magic1) != MAGIC1) ||
+	    (be64_to_cpu(label.d_magic2) != MAGIC2))
+		return -1;
+
+	for (i = 0; i < MAX_PARTITIONS; i++) {
+		if (label.d_partitions[i].p_start && label.d_partitions[i].p_size) {
+			sp[n].start =  be64_to_cpu(label.d_partitions[i].p_start);
+			sp[n].size =  be64_to_cpu(label.d_partitions[i].p_size);
+			n++;
+		}
+	}
+
+	return n;
+}
+
+
+
+
+
diff --git a/libmpathpersist/Makefile b/libmpathpersist/Makefile
new file mode 100644
index 0000000..c4ec1c5
--- /dev/null
+++ b/libmpathpersist/Makefile
@@ -0,0 +1,49 @@
+# Makefile
+#
+BUILD = glibc
+include ../Makefile.inc
+
+INSTALL_PROGRAM = install
+
+SONAME=0
+DEVLIB = libmpathpersist.so
+LIBS = $(DEVLIB).$(SONAME)
+
+
+CFLAGS += -I$(multipathdir) -I$(mpathpersistdir) 
+LIBDEPS +=  -lpthread -ldevmapper -ldl -L$(multipathdir) -lmultipath
+
+OBJS = mpath_persist.o mpath_updatepr.o mpath_pr_ioctl.o 
+
+all: $(LIBS)
+
+
+$(LIBS): 
+	$(CC) -Wall -fPIC -c $(CFLAGS) *.c 
+	$(CC)  -shared $(LIBDEPS) -Wl,-soname=$@ $(CFLAGS) -o $@ $(OBJS)
+	ln -s $(LIBS) $(DEVLIB)
+	$(GZIP) mpath_persistent_reserve_in.3 > mpath_persistent_reserve_in.3.gz	
+	$(GZIP) mpath_persistent_reserve_out.3 > mpath_persistent_reserve_out.3.gz	
+
+install: $(LIBS)
+	$(INSTALL_PROGRAM) -d $(DESTDIR)$(syslibdir)
+	$(INSTALL_PROGRAM) -m 755 $(LIBS) $(DESTDIR)$(syslibdir)/$(LIBS)
+	$(INSTALL_PROGRAM) -m 755 -d $(DESTDIR)$(syslibdir)
+	$(INSTALL_PROGRAM) -m 755 -d $(DESTDIR)$(man3dir)
+	$(INSTALL_PROGRAM) -m 755 -d $(DESTDIR)/usr/include/
+	$(INSTALL_PROGRAM) -m 755 -d $(DESTDIR)/usr/share/doc/mpathpersist/
+	ln -sf $(DESTDIR)$(syslibdir)/$(LIBS) $(DESTDIR)$(syslibdir)/$(DEVLIB)
+	install -m 644 mpath_persistent_reserve_in.3.gz $(DESTDIR)$(man3dir)	
+	install -m 644 mpath_persistent_reserve_out.3.gz $(DESTDIR)$(man3dir)	
+	install -m 644 mpath_persist.h $(DESTDIR)/usr/include/
+
+uninstall:
+	rm -f $(DESTDIR)$(syslibdir)/$(LIBS)
+	rm $(DESTDIR)$(mandir)/mpath_persistent_reserve_in.3.gz	
+	rm $(DESTDIR)$(mandir)/mpath_persistent_reserve_out.3.gz	
+
+clean:
+	rm -f core *.a *.o 
+	rm -f libmpathpersist.so.0
+	rm -f libmpathpersist.so
+	rm -f mpath_persistent_reserve_in.3.gz mpath_persistent_reserve_out.3.gz
diff --git a/libmpathpersist/mpath_persist.c b/libmpathpersist/mpath_persist.c
new file mode 100644
index 0000000..3041089
--- /dev/null
+++ b/libmpathpersist/mpath_persist.c
@@ -0,0 +1,884 @@
+#include "mpath_persist.h"
+#include <libdevmapper.h>
+#include <defaults.h>
+#include <sys/stat.h>
+#include <linux/kdev_t.h>
+#include <fcntl.h>
+#include <vector.h>
+#include <checkers.h>
+#include <structs.h>
+#include <structs_vec.h>
+
+#include <prio.h>
+#include <unistd.h>
+#include <devmapper.h>
+#include <debug.h>
+#include <config.h>
+#include <switchgroup.h>
+#include <discovery.h>
+#include <dmparser.h>
+#include <ctype.h>
+#include <propsel.h>
+
+#include "mpathpr.h"
+#include "mpath_pr_ioctl.h"
+
+#include <pthread.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define __STDC_FORMAT_MACROS 1
+
+
+int
+mpath_lib_init (void)
+{
+	if (load_config(DEFAULT_CONFIGFILE)){
+		condlog(0, "Failed to initialize multipath config.");
+		return 1;
+	}
+
+	return 0;
+}
+
+int
+mpath_lib_exit (void)
+{
+	dm_lib_release();
+	dm_lib_exit();
+	cleanup_prio();
+	cleanup_checkers();
+	free_config(conf);
+	conf = NULL;
+	return 0;
+}
+
+static int
+updatepaths (struct multipath * mpp)
+{
+	int i, j;
+	struct pathgroup * pgp;
+	struct path * pp;
+
+	if (!mpp->pg)
+		return 0;
+
+	vector_foreach_slot (mpp->pg, pgp, i){
+		if (!pgp->paths)
+			continue;
+
+		vector_foreach_slot (pgp->paths, pp, j){
+			if (!strlen(pp->dev)){
+				if (devt2devname(pp->dev, pp->dev_t)){
+					/*
+					 * path is not in sysfs anymore
+					 */
+					pp->state = PATH_DOWN;
+					continue;
+				}
+				pp->mpp = mpp;
+				pathinfo(pp, conf->hwtable, DI_ALL);
+				continue;
+			}
+			pp->mpp = mpp;
+			if (pp->state == PATH_UNCHECKED ||
+					pp->state == PATH_WILD)
+				pathinfo(pp, conf->hwtable, DI_CHECKER);
+
+			if (pp->priority == PRIO_UNDEF)
+				pathinfo(pp, conf->hwtable, DI_PRIO);
+		}
+	}
+	return 0;
+}
+
+int 
+mpath_prin_activepath (struct multipath *mpp, int rq_servact,
+	struct prin_resp * resp, int noisy)
+{
+	int i,j, ret = MPATH_PR_DMMP_ERROR;
+	struct pathgroup *pgp = NULL;
+	struct path *pp = NULL;
+
+	vector_foreach_slot (mpp->pg, pgp, j){
+		vector_foreach_slot (pgp->paths, pp, i){
+			if (!((pp->state == PATH_UP) || (pp->state == PATH_GHOST))){
+				condlog(2, "%s: %s not available. Skip.", mpp->wwid, pp->dev);
+				condlog(3, "%s: status = %d.", mpp->wwid, pp->state);
+				continue;
+			}
+
+			condlog(3, "%s: sending pr in command to %s ", mpp->wwid, pp->dev);
+			ret = mpath_send_prin_activepath(pp->dev, rq_servact, resp, noisy);
+			switch(ret)
+			{
+				case MPATH_PR_SUCCESS:
+				case MPATH_PR_SENSE_INVALID_OP:
+					return ret;
+				default:
+					continue;
+			}
+		}
+	}
+	return ret;	
+}
+
+int mpath_persistent_reserve_in (int fd, int rq_servact, struct prin_resp *resp, int noisy, int verbose)
+{
+	struct stat info;
+	vector curmp = NULL;
+	vector pathvec = NULL;
+	char * alias;
+	struct multipath * mpp;
+	int map_present;
+	int major, minor;
+	int ret;
+
+	conf->verbosity = verbose;
+
+	if (fstat( fd, &info) != 0){
+		condlog(0, "stat error %d", fd);
+		return MPATH_PR_FILE_ERROR;
+	} 
+	if(!S_ISBLK(info.st_mode)){
+		condlog(0, "Failed to get major:minor. fd = %d", fd);
+		return MPATH_PR_FILE_ERROR;
+	}
+
+	major = (int)MAJOR(info.st_rdev);
+	minor = (int)MINOR(info.st_rdev);	
+	condlog(4, "Device %d:%d:  ", major, minor);
+
+	/* get alias from major:minor*/
+	alias = dm_mapname(major, minor);
+	if (!alias){
+		condlog(0, "%d:%d failed to get device alias.", major, minor);
+		return MPATH_PR_DMMP_ERROR;
+	}
+
+	condlog(3, "alias = %s", alias);
+	map_present = dm_map_present(alias);
+	if (map_present && dm_type(alias, TGT_MPATH) <= 0){
+		condlog( 0, "%s: not a multipath device.", alias);
+		ret = MPATH_PR_DMMP_ERROR;
+		goto out;
+	}
+
+	/*
+	 * allocate core vectors to store paths and multipaths
+	 */
+	curmp = vector_alloc ();
+	pathvec = vector_alloc ();
+
+	if (!curmp || !pathvec){
+		condlog (0, "%s: vector allocation failed.", alias);
+		ret = MPATH_PR_DMMP_ERROR;
+		goto out;
+	}
+
+	if (path_discovery(pathvec, conf, DI_SYSFS | DI_CHECKER)) {
+		ret = MPATH_PR_DMMP_ERROR;
+		goto out1;
+	}
+
+	/* get info of all paths from the dm device	*/
+	if (get_mpvec (curmp, pathvec, alias)){
+		condlog(0, "%s: failed to get device info.", alias);
+		ret = MPATH_PR_DMMP_ERROR;
+		goto out1;
+	}
+
+	mpp = find_mp_by_alias(curmp, alias);
+	if (!mpp){
+		condlog(0, "%s: devmap not registered.", alias);
+		ret = MPATH_PR_DMMP_ERROR;
+		goto out1;
+	}
+
+	ret = mpath_prin_activepath(mpp, rq_servact, resp, noisy);
+
+out1:
+	free_multipathvec(curmp, KEEP_PATHS);
+	free_pathvec(pathvec, FREE_PATHS);	
+out:
+	FREE(alias);
+	return ret; 						
+}
+
+int mpath_persistent_reserve_out ( int fd, int rq_servact, int rq_scope,
+		unsigned int rq_type, struct prout_param_descriptor *paramp, int noisy, int verbose)
+{
+
+	struct stat info;
+
+	vector curmp = NULL;
+	vector pathvec = NULL;
+
+	char * alias;
+	struct multipath * mpp;
+	int map_present;
+	int major, minor;
+	int ret;
+	int j;
+	unsigned char *keyp;
+	uint64_t prkey;		
+
+	conf->verbosity = verbose;
+
+	if (fstat( fd, &info) != 0){
+		condlog(0, "stat error fd=%d", fd);
+		return MPATH_PR_FILE_ERROR;
+	}
+
+	if(!S_ISBLK(info.st_mode)){
+		condlog(3, "Failed to get major:minor. fd=%d", fd);
+		return MPATH_PR_FILE_ERROR;	
+	}	
+
+	major = (int)MAJOR(info.st_rdev);
+	minor = (int)MINOR(info.st_rdev);
+	condlog(4, "Device  %d:%d", major, minor);
+
+	/* get WWN of the device from major:minor*/
+	alias = dm_mapname(major, minor);
+	if (!alias){
+		return MPATH_PR_DMMP_ERROR;
+	}
+
+	condlog(3, "alias = %s", alias);
+	map_present = dm_map_present(alias);
+
+	if (map_present && dm_type(alias, TGT_MPATH) <= 0){
+		condlog(3, "%s: not a multipath device.", alias);
+		ret = MPATH_PR_DMMP_ERROR;
+		goto out;
+	}
+
+	/*
+	 * allocate core vectors to store paths and multipaths
+	 */
+	curmp = vector_alloc ();
+	pathvec = vector_alloc ();
+
+	 if (!curmp || !pathvec){
+                condlog (0, "%s: vector allocation failed.", alias);
+                ret = MPATH_PR_DMMP_ERROR;
+                goto out;
+        }
+
+	if (path_discovery(pathvec, conf, DI_SYSFS | DI_CHECKER)) {
+		ret = MPATH_PR_DMMP_ERROR;
+		goto out1;
+	}
+
+	/* get info of all paths from the dm device     */
+	if (get_mpvec(curmp, pathvec, alias)){
+		condlog(0, "%s: failed to get device info.", alias);
+		ret = MPATH_PR_DMMP_ERROR;
+		goto out1;
+	}
+
+	mpp = find_mp_by_alias(curmp, alias);
+
+	if (!mpp) {
+		condlog(0, "%s: devmap not registered.", alias);
+		ret = MPATH_PR_DMMP_ERROR;
+		goto out1;
+	}
+
+	select_reservation_key(mpp);
+
+	switch(rq_servact)
+	{
+		case MPATH_PROUT_REG_SA: 
+		case MPATH_PROUT_REG_IGN_SA:  
+			ret= mpath_prout_reg(mpp, rq_servact, rq_scope, rq_type, paramp, noisy);
+			break;
+		case MPATH_PROUT_RES_SA :  
+		case MPATH_PROUT_PREE_SA :  
+		case MPATH_PROUT_PREE_AB_SA :  
+		case MPATH_PROUT_CLEAR_SA:  
+			ret = mpath_prout_common(mpp, rq_servact, rq_scope, rq_type, paramp, noisy);
+			break;
+		case MPATH_PROUT_REL_SA:
+			ret = mpath_prout_rel(mpp, rq_servact, rq_scope, rq_type, paramp, noisy);
+			break;
+		default:
+			ret = MPATH_PR_OTHER;
+			goto out1;
+	}
+
+	if ((ret == MPATH_PR_SUCCESS) && ((rq_servact == MPATH_PROUT_REG_SA) ||
+				(rq_servact ==  MPATH_PROUT_REG_IGN_SA)))
+	{
+		keyp=paramp->sa_key;
+		prkey = 0;
+		for (j = 0; j < 8; ++j) {
+			if (j > 0)
+				prkey <<= 8;
+			prkey |= *keyp;
+			++keyp;
+		}
+		if (prkey == 0)
+			update_prflag(alias, "unset", noisy);
+		else
+			update_prflag(alias, "set", noisy);
+	} else {
+		if ((ret == MPATH_PR_SUCCESS) && ((rq_servact == MPATH_PROUT_CLEAR_SA) || 
+					(rq_servact == MPATH_PROUT_PREE_AB_SA ))){
+			update_prflag(alias, "unset", noisy);
+		}
+	}
+out1:
+	free_multipathvec(curmp, KEEP_PATHS);
+	free_pathvec(pathvec, FREE_PATHS);
+
+out:
+	FREE(alias);
+	return ret; 
+}
+
+int
+get_mpvec (vector curmp, vector pathvec, char * refwwid)
+{
+	int i;
+	struct multipath *mpp;
+	char params[PARAMS_SIZE], status[PARAMS_SIZE];
+
+	if (dm_get_maps (curmp)){
+		return 1;
+	}
+
+	vector_foreach_slot (curmp, mpp, i){
+		/*
+		 * discard out of scope maps
+		 */
+		if (mpp->alias && refwwid && strncmp (mpp->alias, refwwid, WWID_SIZE)){
+			free_multipath (mpp, KEEP_PATHS);
+			vector_del_slot (curmp, i);
+			i--;
+			continue;
+		}
+
+		dm_get_map(mpp->alias, &mpp->size, params);
+		condlog(3, "params = %s", params);
+		dm_get_status(mpp->alias, status);
+                condlog(3, "status = %s", status);
+		disassemble_map (pathvec, params, mpp);
+		
+		/*
+		 * disassemble_map() can add new paths to pathvec.
+		 * If not in "fast list mode", we need to fetch information
+		 * about them
+		 */
+		updatepaths(mpp);
+		mpp->bestpg = select_path_group (mpp);
+		disassemble_status (status, mpp);
+
+	}
+	return MPATH_PR_SUCCESS ;
+}
+
+void * mpath_prin_pthread_fn (void *p)
+{
+	int ret;
+	struct prin_param * pparam = (struct prin_param *)p;
+
+	ret = prin_do_scsi_ioctl(pparam->dev, pparam->rq_servact, pparam->resp,  pparam->noisy);
+	pparam->status = ret;	
+	pthread_exit(NULL);	
+}
+
+int mpath_send_prin_activepath (char * dev, int rq_servact, struct prin_resp * resp, int noisy)
+{
+
+	int rc;
+
+	rc = prin_do_scsi_ioctl(dev, rq_servact, resp,  noisy);
+	
+	return (rc);
+}
+
+int mpath_prout_reg(struct multipath *mpp,int rq_servact, int rq_scope,
+	unsigned int rq_type, struct prout_param_descriptor * paramp, int noisy)
+{
+
+	int i, j;
+	struct pathgroup *pgp = NULL;
+	struct path *pp = NULL;
+	int rollback = 0;
+	int active_pathcount=0;	
+	int rc;
+	int count=0;
+	int status = MPATH_PR_SUCCESS;
+	uint64_t sa_key = 0;
+
+	if (!mpp)
+		return MPATH_PR_DMMP_ERROR; 
+
+	active_pathcount = pathcount(mpp, PATH_UP) + pathcount(mpp, PATH_GHOST);
+
+	if (active_pathcount == 0) {
+		condlog (0, "%s: no path available", mpp->wwid);
+		return MPATH_PR_DMMP_ERROR;
+	}
+
+	if ( paramp->sa_flags & MPATH_F_ALL_TG_PT_MASK ) {
+		condlog (1, "Warning: ALL_TG_PT is set. Configuration not supported");
+	}
+
+	struct threadinfo thread[active_pathcount];
+
+	memset(thread, 0, sizeof(thread));
+
+	/* init thread parameter */
+	for (i =0; i< active_pathcount; i++){
+		thread[i].param.rq_servact = rq_servact;
+		thread[i].param.rq_scope = rq_scope;
+		thread[i].param.rq_type = rq_type;
+		thread[i].param.paramp = paramp;
+		thread[i].param.noisy = noisy;
+		thread[i].param.status = -1;
+
+		condlog (3, "THRED ID [%d] INFO]", i);
+		condlog (3, "rq_servact=%d ", thread[i].param.rq_servact);
+		condlog (3, "rq_scope=%d ", thread[i].param.rq_scope); 
+		condlog (3, "rq_type=%d ", thread[i].param.rq_type);  
+		condlog (3, "rkey="); 
+		condlog (3, "paramp->sa_flags =%02x ", thread[i].param.paramp->sa_flags); 
+		condlog (3, "noisy=%d ", thread[i].param.noisy); 
+		condlog (3, "status=%d ", thread[i].param.status); 
+	}
+
+	pthread_attr_t attr;
+	pthread_attr_init(&attr);
+	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
+
+	vector_foreach_slot (mpp->pg, pgp, j){
+		vector_foreach_slot (pgp->paths, pp, i){
+			if (!((pp->state == PATH_UP) || (pp->state == PATH_GHOST))){
+				condlog (1, "%s: %s path not up. Skip.", mpp->wwid, pp->dev);
+				continue;
+			}
+			strncpy(thread[count].param.dev, pp->dev, FILE_NAME_SIZE);
+
+			if (count && (thread[count].param.paramp->sa_flags & MPATH_F_SPEC_I_PT_MASK)){
+				/*
+				 * Clearing SPEC_I_PT as transportids are already registered by now.
+				 */
+				thread[count].param.paramp->sa_flags &= (~MPATH_F_SPEC_I_PT_MASK);
+			}
+
+			condlog (3, "%s: sending pr out command to %s", mpp->wwid, pp->dev);
+
+			rc = pthread_create(&thread[count].id, &attr, mpath_prout_pthread_fn, (void *)(&thread[count].param));
+			if (rc){
+				condlog (0, "%s: failed to create thread %d", mpp->wwid, rc);
+			}
+			count = count +1;
+		}
+	}
+	for( i=0; i < active_pathcount ; i++){
+		rc = pthread_join(thread[i].id, NULL);
+		if (rc){
+			condlog (0, "%s: Thread[%d] failed to join thread %d", mpp->wwid, i, rc);
+		}
+		if (!rollback && (thread[i].param.status == MPATH_PR_RESERV_CONFLICT)){
+			rollback = 1;
+			sa_key = 0;
+			for (i = 0; i < 8; ++i){
+				if (i > 0)
+					sa_key <<= 8;
+				sa_key |= paramp->sa_key[i];
+			}
+			status = MPATH_PR_RESERV_CONFLICT ;
+		}
+		if (!rollback && (status == MPATH_PR_SUCCESS)){
+			status = thread[i].param.status;
+		}
+	}
+	if (rollback && ((rq_servact == MPATH_PROUT_REG_SA) && sa_key != 0 )){
+		condlog (3, "%s: ERROR: initiating pr out rollback", mpp->wwid);
+		for( i=0 ; i < active_pathcount ; i++){
+			if((thread[i].param.status == MPATH_PR_SUCCESS) &&
+					((pp->state == PATH_UP) || (pp->state == PATH_GHOST))){
+				memcpy(&thread[i].param.paramp->key, &thread[i].param.paramp->sa_key, 8);
+				memset(&thread[i].param.paramp->sa_key, 0, 8);
+				thread[i].param.status = MPATH_PR_SUCCESS;
+				rc = pthread_create(&thread[i].id, &attr, mpath_prout_pthread_fn, 
+						(void *)(&thread[count].param));
+				if (rc){
+					condlog (0, "%s: failed to create thread for rollback. %d",  mpp->wwid, rc);
+				}
+			}
+		}
+		for(i=0; i < active_pathcount ; i++){
+			rc = pthread_join(thread[i].id, NULL);
+			if (rc){
+				condlog (3, "%s: failed to join thread while rolling back %d",
+						mpp->wwid, i);
+			}
+		}
+	}
+
+	pthread_attr_destroy(&attr);
+	return (status);
+}
+
+void * mpath_prout_pthread_fn(void *p)
+{
+	int ret;
+	struct prout_param * param = (struct prout_param *)p;
+
+	ret = prout_do_scsi_ioctl( param->dev,param->rq_servact, param->rq_scope,
+			param->rq_type, param->paramp, param->noisy);
+	param->status = ret;
+	pthread_exit(NULL);
+}
+
+int mpath_prout_common(struct multipath *mpp,int rq_servact, int rq_scope,
+        unsigned int rq_type, struct prout_param_descriptor* paramp, int noisy)
+{
+	int i,j, ret;
+	struct pathgroup *pgp = NULL;
+	struct path *pp = NULL;
+
+	vector_foreach_slot (mpp->pg, pgp, j){
+		vector_foreach_slot (pgp->paths, pp, i){
+			if (!((pp->state == PATH_UP) || (pp->state == PATH_GHOST))){
+				condlog (1, "%s: %s path not up. Skip", mpp->wwid, pp->dev); 
+				continue;
+			}
+
+			condlog (3, "%s: sending pr out command to %s", mpp->wwid, pp->dev);
+			ret = send_prout_activepath(pp->dev, rq_servact, rq_scope, rq_type, 
+					paramp, noisy); 
+			return ret ;
+		}
+	}
+	return MPATH_PR_SUCCESS;
+}
+
+int send_prout_activepath(char * dev, int rq_servact, int rq_scope,
+	unsigned int rq_type, struct prout_param_descriptor * paramp, int noisy)
+{
+	struct prout_param param;
+	param.rq_servact = rq_servact;
+	param.rq_scope  = rq_scope;
+	param.rq_type   = rq_type;
+	param.paramp    = paramp;
+	param.noisy = noisy;
+	param.status = -1;
+
+	pthread_t thread;
+	pthread_attr_t attr;
+	int rc;
+
+	memset(&thread, 0, sizeof(thread));
+	strncpy(param.dev, dev, FILE_NAME_SIZE);
+	/* Initialize and set thread joinable attribute */
+	pthread_attr_init(&attr);
+	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
+
+	rc = pthread_create(&thread, &attr, mpath_prout_pthread_fn, (void *)(&param));
+	if (rc){
+		condlog (3, "%s: failed to create thread %d", dev, rc);
+		exit(-1);
+	}
+	/* Free attribute and wait for the other threads */
+	pthread_attr_destroy(&attr);
+	rc = pthread_join(thread, NULL);
+
+	return (param.status);
+}
+
+int mpath_prout_rel(struct multipath *mpp,int rq_servact, int rq_scope,
+        unsigned int rq_type, struct prout_param_descriptor * paramp, int noisy)
+{
+	int i, j;
+	int num = 0;
+	struct pathgroup *pgp = NULL;
+	struct path *pp = NULL;
+	int active_pathcount = 0;
+	pthread_attr_t attr;
+	int rc, found = 0;;
+	int count = 0;
+	int status = MPATH_PR_SUCCESS;
+	struct prin_resp resp;
+	struct prout_param_descriptor *pamp;
+	struct prin_resp *pr_buff;
+	int length;
+	struct transportid *pptr;	
+
+	if (!mpp)
+		return MPATH_PR_DMMP_ERROR;
+
+	active_pathcount = pathcount (mpp, PATH_UP) + pathcount (mpp, PATH_GHOST);
+
+	struct threadinfo thread[active_pathcount];
+	memset(thread, 0, sizeof(thread));
+	for (i = 0; i < active_pathcount; i++){
+		thread[i].param.rq_servact = rq_servact;
+		thread[i].param.rq_scope = rq_scope;
+		thread[i].param.rq_type = rq_type;
+		thread[i].param.paramp = paramp;
+		thread[i].param.noisy = noisy;
+		thread[i].param.status = -1;
+
+		condlog (3, " path count = %d", i);
+		condlog (3, "rq_servact=%d ", thread[i].param.rq_servact);
+		condlog (3, "rq_scope=%d ", thread[i].param.rq_scope);
+		condlog (3, "rq_type=%d ", thread[i].param.rq_type);
+		condlog (3, "noisy=%d ", thread[i].param.noisy);
+		condlog (3, "status=%d ", thread[i].param.status);
+	}
+
+	pthread_attr_init (&attr);
+	pthread_attr_setdetachstate (&attr, PTHREAD_CREATE_JOINABLE);
+
+	vector_foreach_slot (mpp->pg, pgp, j){
+		vector_foreach_slot (pgp->paths, pp, i){
+			if (!((pp->state == PATH_UP) || (pp->state == PATH_GHOST))){
+				condlog (1, "%s: %s path not up.", mpp->wwid, pp->dev);
+				continue;
+			}
+			
+			strncpy(thread[count].param.dev, pp->dev, FILE_NAME_SIZE);
+			condlog (3, "%s: sending pr out command to %s", mpp->wwid, pp->dev);
+			rc = pthread_create (&thread[count].id, &attr, mpath_prout_pthread_fn,
+					(void *) (&thread[count].param));
+			if (rc)
+				condlog (0, "%s: failed to create thread. %d",  mpp->wwid, rc);
+			count = count + 1;
+		}
+	}
+	pthread_attr_destroy (&attr);
+	for (i = 0; i < active_pathcount; i++){
+		rc = pthread_join (thread[i].id, NULL);
+		if (rc){
+			condlog (1, "%s: failed to join thread.  %d",  mpp->wwid,  rc);
+		}
+	}
+
+	for (i = 0; i < active_pathcount; i++){
+		/*  check thread status here and return the status */
+
+		if (thread[i].param.status == MPATH_PR_RESERV_CONFLICT)
+			status = MPATH_PR_RESERV_CONFLICT;
+		else if (status == MPATH_PR_SUCCESS
+				&& thread[i].param.status != MPATH_PR_RESERV_CONFLICT)
+			status = thread[i].param.status;
+	}
+
+	status = mpath_prin_activepath (mpp, MPATH_PRIN_RRES_SA, &resp, noisy);
+	if (status != MPATH_PR_SUCCESS){
+		condlog (0, "%s: pr in read reservation command failed.", mpp->wwid);
+		return MPATH_PR_OTHER;
+	}
+
+	num = resp.prin_descriptor.prin_readresv.additional_length / 8;
+	if (num == 0){
+		condlog (2, "%s: Path holding reservation is released.", mpp->wwid);
+		return MPATH_PR_SUCCESS;	
+	}
+	condlog (2, "%s: Path holding reservation is not avialable.", mpp->wwid);
+
+	pr_buff =  mpath_alloc_prin_response(MPATH_PRIN_RFSTAT_SA);
+	if (!pr_buff){
+		condlog (0, "%s: failed to  alloc pr in response buffer.", mpp->wwid);	
+		return MPATH_PR_OTHER;
+	}
+
+	status = mpath_prin_activepath (mpp, MPATH_PRIN_RFSTAT_SA, pr_buff, noisy);
+
+	if (status != MPATH_PR_SUCCESS){
+		condlog (0,  "%s: pr in read full status command failed.",  mpp->wwid);
+		goto out;
+	}
+
+	num = pr_buff->prin_descriptor.prin_readfd.number_of_descriptor;
+	if (0 == num){
+		goto out;
+	}
+	length = sizeof (struct prout_param_descriptor) + (sizeof (struct transportid *));
+
+	pamp = (struct prout_param_descriptor *)malloc (length);
+	if (!pamp){
+		condlog (0, "%s: failed to alloc pr out parameter.", mpp->wwid);
+		goto out1;
+	}
+
+	memset(pamp, 0, length);
+
+	pamp->trnptid_list[0] = (struct transportid *) malloc (sizeof (struct transportid));
+	if (!pamp->trnptid_list[0]){
+		condlog (0, "%s: failed to alloc pr out transportid.", mpp->wwid);
+		goto out1;
+	}
+
+	if (mpp->reservation_key ){
+		memcpy (pamp->key, mpp->reservation_key, 8);
+		condlog (3, "%s: reservation key set.", mpp->wwid);
+	}
+
+	mpath_prout_common (mpp, MPATH_PROUT_CLEAR_SA, rq_scope, rq_type, pamp,
+			noisy);
+
+	pamp->num_transportid = 1;
+	pptr=pamp->trnptid_list[0];
+
+	for (i = 0; i < num; i++){
+		if (mpp->reservation_key && 
+			memcmp(pr_buff->prin_descriptor.prin_readfd.descriptors[i]->key,
+			mpp->reservation_key, 8)){	
+			/*register with tarnsport id*/
+			memset(pamp, 0, length);
+			pamp->trnptid_list[0] = pptr;
+			memset (pamp->trnptid_list[0], 0, sizeof (struct transportid));
+			memcpy (pamp->sa_key,
+					pr_buff->prin_descriptor.prin_readfd.descriptors[i]->key, 8);
+			pamp->sa_flags = MPATH_F_SPEC_I_PT_MASK;
+			pamp->num_transportid = 1;
+
+			memcpy (pamp->trnptid_list[0],
+					&pr_buff->prin_descriptor.prin_readfd.descriptors[i]->trnptid,
+					sizeof (struct transportid));
+			status = mpath_prout_common (mpp, MPATH_PROUT_REG_SA, 0, rq_type,
+					pamp, noisy);
+
+			pamp->sa_flags = 0;
+			memcpy (pamp->key, pr_buff->prin_descriptor.prin_readfd.descriptors[i]->key, 8);
+			memset (pamp->sa_key, 0, 8);
+			pamp->num_transportid = 0;
+			status = mpath_prout_common (mpp, MPATH_PROUT_REG_SA, 0, rq_type,
+					pamp, noisy);
+		}
+		else
+		{
+			if (mpp->reservation_key)
+				found = 1;
+		}
+
+
+	}
+
+	if (found){
+		memset (pamp, 0, length);
+		memcpy (pamp->sa_key, mpp->reservation_key, 8);
+		memset (pamp->key, 0, 8);
+		status = mpath_prout_reg(mpp, MPATH_PROUT_REG_SA, rq_scope, rq_type, pamp, noisy);	
+	}
+
+
+	free(pptr);
+out1:
+	free (pamp);
+out:
+	free (pr_buff);
+	return (status);
+}
+
+void * mpath_alloc_prin_response(int prin_sa)
+{
+	void * ptr = NULL;
+	int size=0;
+	switch (prin_sa)
+	{
+		case MPATH_PRIN_RKEY_SA:
+			size = sizeof(struct prin_readdescr);
+			ptr = malloc(size);
+			memset(ptr, 0, size);
+			break;
+		case MPATH_PRIN_RRES_SA:
+			size = sizeof(struct prin_resvdescr);
+			ptr = malloc(size);
+			memset(ptr, 0, size);
+			break;
+		case MPATH_PRIN_RCAP_SA:
+			size=sizeof(struct prin_capdescr);
+			ptr = malloc(size);
+			memset(ptr, 0, size);
+			break;
+		case MPATH_PRIN_RFSTAT_SA:
+			size = sizeof(struct print_fulldescr_list) + 
+				sizeof(struct prin_fulldescr *)*MPATH_MX_TIDS;
+			ptr = malloc(size);
+			memset(ptr, 0, size);
+			break;
+	}
+	return ptr;
+}
+
+int update_map_pr(struct multipath *mpp)
+{
+	int noisy=0;
+	struct prin_resp *resp;
+	int i,j, ret, isFound;
+	unsigned char *keyp;
+	uint64_t prkey;
+
+	if (!mpp->reservation_key)
+	{
+		/* Nothing to do. Assuming pr mgmt feature is disabled*/
+		condlog(3, "%s: reservation_key not set in multiapth.conf", mpp->alias);
+		return MPATH_PR_SUCCESS;
+	}
+
+	resp = mpath_alloc_prin_response(MPATH_PRIN_RKEY_SA);
+	if (!resp)
+	{
+		condlog(0,"%s : failed to alloc resp in update_map_pr", mpp->alias);
+		return MPATH_PR_OTHER;
+	}
+	ret = mpath_prin_activepath(mpp, MPATH_PRIN_RKEY_SA, resp, noisy);
+
+	if (ret != MPATH_PR_SUCCESS )
+	{
+		condlog(0,"%s : pr in read keys service action failed Error=%d", mpp->alias, ret);
+		free(resp);
+		return  ret;
+	}
+
+	if (resp->prin_descriptor.prin_readkeys.additional_length == 0 )
+	{
+		condlog(0,"%s: No key found. Device may not be registered. ", mpp->alias);
+		free(resp);
+		return MPATH_PR_SUCCESS;
+	}
+
+	prkey = 0;
+	keyp = mpp->reservation_key;
+	for (j = 0; j < 8; ++j) {
+		if (j > 0)
+			prkey <<= 8;
+		prkey |= *keyp;
+		++keyp;
+	}
+	condlog(2, "%s: Multipath  reservation_key: 0x%" PRIx64 " ", mpp->alias, prkey);
+
+	isFound =0;
+	for (i = 0; i < resp->prin_descriptor.prin_readkeys.additional_length/8; i++ )
+	{
+		condlog(2, "%s: PR IN READKEYS[%d]  reservation key:", mpp->alias, i);
+		dumpHex((char *)&resp->prin_descriptor.prin_readkeys.key_list[i*8], 8 , 1);
+
+		if (!memcmp(mpp->reservation_key, &resp->prin_descriptor.prin_readkeys.key_list[i*8], 8))
+		{
+			condlog(2, "%s: reservation key found in pr in readkeys response", mpp->alias);
+			isFound =1;
+		}
+	}
+
+	if (isFound)
+	{
+		mpp->prflag = 1;
+		condlog(2, "%s: prflag flag set.", mpp->alias );
+	}
+
+	free(resp);
+	return MPATH_PR_SUCCESS;
+}
+
+
+
diff --git a/libmpathpersist/mpath_persist.h b/libmpathpersist/mpath_persist.h
new file mode 100644
index 0000000..d8ff6f2
--- /dev/null
+++ b/libmpathpersist/mpath_persist.h
@@ -0,0 +1,241 @@
+/* version - 1.0 */
+
+#ifndef MPATH_PERSIST_LIB_H
+#define MPATH_PERSIST_LIB_H
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <inttypes.h>
+
+#define MPATH_MAX_PARAM_LEN	8192
+
+#define MPATH_MX_TIDS 		32	  /* Max number of transport ids"*/
+#define MPATH_MX_TID_LEN	256	  /* Max lenght of transport id */
+
+/* PRIN Service Actions */
+#define MPATH_PRIN_RKEY_SA	0x00	   /* READ KEYS SA*/
+#define MPATH_PRIN_RRES_SA	0x01	   /* READ RESERVATION  SA*/
+#define MPATH_PRIN_RCAP_SA	0x02	   /* REPORT CAPABILITIES SA*/
+#define MPATH_PRIN_RFSTAT_SA	0x03	   /* READ FULL STATUS SA*/
+
+/* PROUT Service Actions */
+#define MPATH_PROUT_REG_SA	0x00	    /* REGISTER SA */
+#define MPATH_PROUT_RES_SA	0x01	    /* RESERVE SA*/
+#define MPATH_PROUT_REL_SA	0x02	    /* RELEASE SA*/
+#define MPATH_PROUT_CLEAR_SA	0x03	    /* CLEAR SA*/
+#define MPATH_PROUT_PREE_SA	0x04	    /* PREEMPT SA*/
+#define MPATH_PROUT_PREE_AB_SA	0x05	    /* PREEMPT AND ABORT SA*/
+#define MPATH_PROUT_REG_IGN_SA	0x06	    /* REGISTER AND IGNORE EXISTING KEY SA*/
+#define MPATH_PROUT_REG_MOV_SA	0x07	    /* REGISTER AND MOVE SA*/
+
+#define MPATH_LU_SCOPE		0x00	    /* LU_SCOPE */
+
+/* Persistent reservations type */
+#define MPATH_PRTPE_WE	 	0x01	    /* Write Exclusive */
+#define MPATH_PRTPE_EA 		0x03	    /* Exclusive Access*/
+#define MPATH_PRTPE_WE_RO 	0x05	    /* WriteExclusive Registrants Only */
+#define MPATH_PRTPE_EA_RO 	0x06	    /* Exclusive Access. Registrants Only*/
+#define MPATH_PRTPE_WE_AR	0x07	    /* Write Exclusive. All Registrants*/
+#define MPATH_PRTPE_EA_AR 	0x08	    /* Exclusive Access. All Registrants */
+
+
+/* PR RETURN_STATUS */
+#define MPATH_PR_SUCCESS 		0
+#define MPATH_PR_SYNTAX_ERROR		1   /*  syntax error or invalid parameter */
+					    /* status for check condition */
+#define MPATH_PR_SENSE_NOT_READY 	2   /*	[sk,asc,ascq: 0x2,*,*] */
+#define MPATH_PR_SENSE_MEDIUM_ERROR	3   /*	[sk,asc,ascq: 0x3,*,*] */
+#define MPATH_PR_SENSE_HARDWARE_ERROR	4   /*	[sk,asc,ascq: 0x4,*,*] */
+#define MPATH_PR_ILLEGAL_REQ 		5   /*	[sk,asc,ascq: 0x5,*,*]*/
+#define MPATH_PR_SENSE_UNIT_ATTENTION	6   /*	[sk,asc,ascq: 0x6,*,*] */
+#define MPATH_PR_SENSE_INVALID_OP	7   /* 	[sk,asc,ascq: 0x5,0x20,0x0]*/
+#define MPATH_PR_SENSE_ABORTED_COMMAND  8   /*  [sk,asc,ascq: 0xb,*,*] */
+#define MPATH_PR_NO_SENSE		9   /*	[sk,asc,ascq: 0x0,*,*] */
+
+#define MPATH_PR_SENSE_MALFORMED	10  /* Response to SCSI command malformed */
+#define MPATH_PR_RESERV_CONFLICT	11  /* Reservation conflict on the device */
+#define MPATH_PR_FILE_ERROR		12  /* file (device node) problems(e.g. not found)*/
+#define MPATH_PR_DMMP_ERROR		13  /* DMMP related error.(e.g Error in getting dm info */
+#define MPATH_PR_OTHER			14  /*other error/warning has occurred(transport
+					      or driver error) */
+
+/* PR MASK */
+#define MPATH_F_APTPL_MASK		0x01	/* APTPL MASK*/
+#define MPATH_F_ALL_TG_PT_MASK		0x04	/* ALL_TG_PT MASK*/
+#define MPATH_F_SPEC_I_PT_MASK		0x08	/* SPEC_I_PT MASK*/
+#define MPATH_PR_TYPE_MASK 		0x0f	/* TYPE MASK*/
+#define MPATH_PR_SCOPE_MASK		0xf0	/* SCOPE MASK*/
+
+/*Transport ID PROTOCOL IDENTIFIER values */
+#define MPATH_PROTOCOL_ID_FC		0x00
+#define MPATH_PROTOCOL_ID_ISCSI		0x05
+#define MPATH_PROTOCOL_ID_SAS		0x06
+
+
+/*Transport ID FORMATE CODE */
+#define MPATH_WWUI_DEVICE_NAME		0x00	/* World wide unique initiator device name */
+#define MPATH_WWUI_PORT_IDENTIFIER	0x40	/* World wide unique initiator port identifier	*/
+
+
+
+
+struct prin_readdescr
+{
+	uint32_t prgeneration;
+	uint32_t additional_length;	/* The value should be either 0 or divisible by 8.
+					   0 indicates no registered reservation key. */
+	uint8_t	 key_list[MPATH_MAX_PARAM_LEN];
+};
+
+struct prin_resvdescr
+{
+	uint32_t prgeneration;
+	uint32_t additional_length;	/* The value should be either 0 or 10h. 0 indicates
+					   there is no reservation held. 10h indicates the
+					   key[8] and scope_type have valid values */
+	uint8_t  key[8];
+	uint32_t _obsolete;
+	uint8_t  _reserved;
+	uint8_t  scope_type;            /* Use PR SCOPE AND TYPE MASK specified above */
+	uint16_t _obsolete1;
+};
+
+struct prin_capdescr
+{
+	uint16_t length;
+	uint8_t  flags[2];
+	uint16_t pr_type_mask;
+	uint16_t _reserved;
+};
+
+struct transportid
+{
+	uint8_t format_code;
+	uint8_t protocol_id;
+	union {
+		uint8_t n_port_name[8];	/* FC transport*/
+		uint8_t sas_address[8];	/* SAS transport */
+		uint8_t iscsi_name[256]; /* ISCSI  transport */
+	};
+};
+
+struct prin_fulldescr
+{
+	uint8_t key[8];
+	uint8_t flag; 			/* All_tg_pt and reservation holder */
+	uint8_t scope_type;		/* Use PR SCOPE AND TYPE MASK specified above.
+					   Meaningful only for reservation holder */
+	uint16_t rtpi;
+	struct transportid trnptid;
+};
+
+struct print_fulldescr_list
+{
+	uint32_t prgeneration;
+	uint32_t number_of_descriptor;
+	uint8_t private_buffer[MPATH_MAX_PARAM_LEN]; /*Private buffer for list storage*/
+	struct prin_fulldescr *descriptors[];
+};
+
+struct prin_resp
+{
+	union
+	{
+		struct prin_readdescr prin_readkeys; /* for PRIN read keys SA*/
+		struct prin_resvdescr prin_readresv; /* for PRIN read reservation SA*/
+		struct prin_capdescr  prin_readcap;  /* for PRIN Report Capabilities SA*/
+		struct print_fulldescr_list prin_readfd;   /* for PRIN read full status SA*/
+	}prin_descriptor;
+};
+
+struct prout_param_descriptor { 	/* PROUT parameter descriptor */
+	uint8_t	 key[8];
+	uint8_t	 sa_key[8];
+	uint32_t _obsolete;
+	uint8_t	 sa_flags;
+	uint8_t _reserved;
+	uint16_t _obsolete1;
+	uint8_t  private_buffer[MPATH_MAX_PARAM_LEN]; /*private buffer for list storage*/
+	uint32_t num_transportid;	/* Number of Transport ID listed in trnptid_list[]*/
+	struct transportid *trnptid_list[];
+};
+
+
+/* Function declarations */
+
+/*
+ * DESCRIPTION :
+ *	Initialize device mapper multipath configuration. This function must be invoked first
+ *	before performing reservation management functions.
+ * RESTRICTIONS:
+ *
+ * RETURNS: 0->Success, 1->Failed.
+ */
+extern int mpath_lib_init (void );
+
+
+/*
+ * DESCRIPTION :
+ *	Release device mapper multipath configuration. This function must be invoked after
+ *	performing reservation management functions.
+ * RESTRICTIONS:
+ *
+ * RETURNS: 0->Success, 1->Failed.
+ */
+extern int mpath_lib_exit (void );
+
+
+/*
+ * DESCRIPTION :
+ * This function sends PRIN command to the DM device and get the response.
+ *
+ * @fd:	The file descriptor of a multipath device. Input argument.
+ * @rq_servact: PRIN command service action. Input argument
+ * @resp: The response from PRIN service action. The resp is a struct specified above. The caller should
+ * 	manage the memory allocation of this struct
+ * @noisy: Turn on debugging trace: Input argument. 0->Disable, 1->Enable
+ * @verbose: Set verbosity level. Input argument. value:[0-3]. 0->disabled, 3->Max verbose
+ *
+ * RESTRICTIONS:
+ *
+ * RETURNS: MPATH_PR_SUCCESS if PR command successful else returns any of the status specified
+ *       above in RETURN_STATUS.
+ *
+ */
+extern int mpath_persistent_reserve_in (int fd, int rq_servact, struct prin_resp *resp,
+		int noisy, int verbose);
+
+/*
+ * DESCRIPTION :
+ * This function sends PROUT command to the DM device and get the response.
+ *
+ * @fd: The file descriptor of a multipath device. Input argument.
+ * @rq_servact: PROUT command service action. Input argument
+ * @rq_scope: Persistent reservation scope. The value should be always LU_SCOPE (0h).
+ * @rq_type: Persistent reservation type. The valid values of persistent reservation types are
+ *	5h (Write exclusive - registrants only)
+ *	6h (Exclusive access - registrants only)
+ *	7h (Write exclusive - All registrants)
+ *	8h (Exclusive access - All registrants).
+ * @paramp: PROUT command parameter data. The paramp is a struct which describes PROUT
+ * 	    parameter list. The caller should manage the memory allocation of this struct.
+ * @noisy: Turn on debugging trace: Input argument.0->Disable, 1->Enable.
+ * @verbose: Set verbosity level. Input argument. value:0 to 3. 0->disabled, 3->Max verbose
+ *
+ * RESTRICTIONS:
+ *
+ * RETURNS: MPATH_PR_SUCCESS if PR command successful else returns any of the status specified
+ *       above in RETURN_STATUS.
+ */
+extern int mpath_persistent_reserve_out ( int fd, int rq_servact, int rq_scope,
+		unsigned int rq_type, struct prout_param_descriptor *paramp, int noisy,
+		int verbose);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /*MPATH_PERSIST_LIB_H*/
diff --git a/libmpathpersist/mpath_persistent_reserve_in.3 b/libmpathpersist/mpath_persistent_reserve_in.3
new file mode 100644
index 0000000..c404e13
--- /dev/null
+++ b/libmpathpersist/mpath_persistent_reserve_in.3
@@ -0,0 +1,80 @@
+.\"
+.TH MPATH_PERSISTENT_RESERVE_IN 3  2011-04-08 "Linux Manpage" 
+.SH NAME
+mpath_persistent_reserve_in
+.SH SYNOPSIS
+.B #include <mpath_persist.h>
+.sp
+.BI "int mpath_persistent_reserve_in (int fd, int rq_servact, struct prin_resp *resp, int noisy, int verbose)"
+.sp
+.SH DESCRIPTION
+The function in the
+.BR mpath_persistent_reserve_in ()
+sends PRIN command to the DM device and gets the response.
+.br
+.BI Parameters:
+.br
+.I fd
+.B The file descriptor of a multipath device. Input argument.
+.br
+.I rq_servact
+.B PRIN command service action. Input argument
+.br
+.I resp
+.B The response from PRIN service action. The caller should manage the memory allocation of this structure
+.br
+.I noisy
+.B Turn on debugging trace: Input argument. 0->Disable, 1->Enable
+.br
+.I verbose
+.B Set verbosity level. Input argument. value:[0-3]. 0->Crits and Errors, 1->Warnings, 2->Info, 3->Debug
+.br
+
+.SH "RETURNS"
+.I MPATH_PR_SUCCESS
+.B if PR command successful
+.br
+.I MPATH_PR_SYNTAX_ERROR        
+.B if  syntax error or invalid parameter
+.br
+.I MPATH_PR_SENSE_NOT_READY     
+.B  if command fails with [sk,asc,ascq: 0x2,*,*]
+.br
+.I MPATH_PR_SENSE_MEDIUM_ERROR
+.B  if command fails with [sk,asc,ascq: 0x3,*,*]
+.br
+.I MPATH_PR_SENSE_HARDWARE_ERROR
+.B  if command fails with [sk,asc,ascq: 0x4,*,*]
+.br
+.I MPATH_PR_SENSE_INVALID_OP
+.B  if command fails with [sk,asc,ascq: 0x5,0x20,0x0]
+.br
+.I MPATH_PR_ILLEGAL_REQ
+.B  if command fails with [sk,asc,ascq: 0x5,*,*]
+.br
+.I MPATH_PR_SENSE_UNIT_ATTENTION
+.B  if command fails with [sk,asc,ascq: 0x6,*,*]
+.br
+.I MPATH_PR_SENSE_ABORTED_COMMAND
+.B  if command fails with [sk,asc,ascq: 0xb,*,*]
+.br
+.I MPATH_PR_NO_SENSE
+.B  if command fails with [sk,asc,ascq: 0x0,*,*]
+.br
+.I MPATH_PR_SENSE_MALFORMED  
+.B if command fails with SCSI command malformed
+.br
+.I MPATH_PR_FILE_ERROR
+.B if command fails while accessing file (device node) problems(e.g. not found)
+.br
+.I MPATH_PR_DMMP_ERROR
+.B if Device Mapper related error.(e.g Error in getting dm info) 
+.br
+.I MPATH_PR_OTHER
+.B if other error/warning has occurred(e.g transport or driver error)
+.br
+
+
+.SH "SEE ALSO"
+.I  mpath_persistent_reserve_out      mpathpersist     /usr/share/doc/mpathpersist/README
+.br
diff --git a/libmpathpersist/mpath_persistent_reserve_out.3 b/libmpathpersist/mpath_persistent_reserve_out.3
new file mode 100644
index 0000000..f7f84ff
--- /dev/null
+++ b/libmpathpersist/mpath_persistent_reserve_out.3
@@ -0,0 +1,92 @@
+.\"
+.TH MPATH_PERSISTENT_RESERVE_OUT 3  2011-04-08 "Linux Manpage" 
+.SH NAME
+mpath_persistent_reserve_out
+.SH SYNOPSIS
+.B #include <mpath_persist.h>
+.sp
+.BI "int mpath_persistent_reserve_out (int fd, int rq_servact, struct prin_resp *resp, int noisy, int verbose)"
+.sp
+.SH DESCRIPTION
+The function in the
+.BR mpath_persistent_reserve_out ()
+sends PR OUT command to the DM device and gets the response.
+.br
+.BI Parameters:
+.br
+.I fd 
+.B The file descriptor of a multipath device. Input argument.
+.br
+.I rq_servact
+.B PROUT command service action. Input argument
+.br
+.I rq_scope
+.B Persistent reservation scope. The value should be always LU_SCOPE (0h).
+.br
+.I rq_type
+.B Persistent reservation type. The valid values of persistent reservation types are
+      5h (Write exclusive - registrants only)
+      6h (Exclusive access - registrants only)
+      7h (Write exclusive - All registrants)
+      8h (Exclusive access - All registrants).
+.br
+.I paramp
+.B PROUT command parameter data. The paramp is a struct which describes PROUT parameter list. Caller should manage the memory allocation of this structure.
+.br
+.I noisy
+.B Turn on debugging trace: Input argument. 0->Disable, 1->Enable.
+.br
+.I verbose
+.B Set verbosity level. Input argument. value: 0 to 3. 0->Crits and Errors, 1->Warnings, 2->Info, 3->Debug
+
+.SH "RETURNS"
+.I MPATH_PR_SUCCESS
+.B if PR command successful else returns any one of the status mentioned below
+.br
+.I MPATH_PR_SYNTAX_ERROR        
+.B if  syntax error or invalid parameter
+.br
+.I MPATH_PR_SENSE_NOT_READY     
+.B  if command fails with [sk,asc,ascq: 0x2,*,*]
+.br
+.I MPATH_PR_SENSE_MEDIUM_ERROR
+.B  if command fails with [sk,asc,ascq: 0x3,*,*]
+.br
+.I MPATH_PR_SENSE_HARDWARE_ERROR
+.B  if command fails with [sk,asc,ascq: 0x4,*,*]
+.br
+.I MPATH_PR_SENSE_INVALID_OP
+.B  if command fails with [sk,asc,ascq: 0x5,0x20,0x0]
+.br
+.I MPATH_PR_ILLEGAL_REQ
+.B  if command fails with [sk,asc,ascq: 0x5,*,*]
+.br
+.I MPATH_PR_SENSE_UNIT_ATTENTION
+.B  if command fails with [sk,asc,ascq: 0x6,*,*]
+.br
+.I MPATH_PR_SENSE_ABORTED_COMMAND
+.B  if command fails with [sk,asc,ascq: 0xb,*,*]
+.br
+.I MPATH_PR_NO_SENSE
+.B  if command fails with [sk,asc,ascq: 0x0,*,*]
+.br
+.I MPATH_PR_SENSE_MALFORMED  
+.B if command fails with SCSI command malformed
+.br
+.I MPATH_PR_RESERV_CONFLICT
+.B if command fails with reservation conflict
+.br
+.I MPATH_PR_FILE_ERROR
+.B if command fails while accessing file (device node) problems(e.g. not found)
+.br
+.I MPATH_PR_DMMP_ERROR
+.B if Device Mapper related error.(e.g Error in getting dm info) 
+.br
+.I MPATH_PR_OTHER
+.B if other error/warning has occurred(e.g transport or driver error)
+.br
+
+
+.SH "SEE ALSO"
+.I  mpath_persistent_reserve_in		mpathpersist     /usr/share/doc/mpathpersist/README
+.br
diff --git a/libmpathpersist/mpath_pr_ioctl.c b/libmpathpersist/mpath_pr_ioctl.c
new file mode 100644
index 0000000..de3292e
--- /dev/null
+++ b/libmpathpersist/mpath_pr_ioctl.c
@@ -0,0 +1,583 @@
+#include <stdio.h>
+#include <stdlib.h>
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <scsi/sg.h>
+#include <scsi/scsi.h>
+#include <unistd.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <unistd.h>
+#include "mpath_pr_ioctl.h" 
+#include <mpath_persist.h> 
+
+#include <debug.h>
+
+#define FILE_NAME_SIZE          256
+
+#define TIMEOUT 2000
+#define MAXRETRY 5
+
+int prin_do_scsi_ioctl(char * dev, int rq_servact, struct prin_resp *resp, int noisy);
+void mpath_format_readkeys(struct prin_resp *pr_buff, int len , int noisy);
+void mpath_format_readfullstatus(struct prin_resp *pr_buff, int len, int noisy);
+int mpath_translate_response (char * dev, struct sg_io_hdr io_hdr, SenseData_t Sensedata, int noisy);
+void dumpHex(const char* str, int len, int no_ascii);
+int prout_do_scsi_ioctl( char * dev, int rq_servact, int rq_scope,
+                unsigned int rq_type, struct prout_param_descriptor *paramp, int noisy);
+uint32_t  format_transportids(struct prout_param_descriptor *paramp);
+void mpath_reverse_uint32_byteorder(uint32_t *num);
+void mpath_reverse_uint16_byteorder(uint16_t *num);
+void decode_transport_id(struct prin_fulldescr *fdesc, unsigned char * p, int length);
+int get_prin_length(int rq_servact);
+int mpath_isLittleEndian(void);
+
+extern unsigned int mpath_mx_alloc_len;
+
+int prout_do_scsi_ioctl(char * dev, int rq_servact, int rq_scope,
+                unsigned int rq_type, struct prout_param_descriptor *paramp, int noisy)
+{
+
+	int status, paramlen = 24, ret = 0;
+	uint32_t translen=0;
+	int retry = MAXRETRY;
+	SenseData_t Sensedata;
+	struct sg_io_hdr io_hdr;
+	char devname[FILE_NAME_SIZE];
+	int fd = -1;
+
+	snprintf(devname, FILE_NAME_SIZE, "/dev/%s",dev);
+	fd = open(devname, O_WRONLY);
+	if(fd < 0){
+		condlog (1, "%s: unable to open device.", dev);
+		return MPATH_PR_FILE_ERROR;
+	}
+
+	unsigned char cdb[MPATH_PROUT_CMDLEN] =
+	{MPATH_PROUT_CMD, 0, 0, 0, 0, 0, 0, 0, 0, 0};
+
+
+	if (paramp->sa_flags & MPATH_F_SPEC_I_PT_MASK)
+	{
+		translen = format_transportids(paramp);
+		paramlen = 24 + translen;
+	}	
+	else
+		paramlen = 24;
+
+	if ( rq_servact > 0)
+		cdb[1] = (unsigned char)(rq_servact & 0x1f);
+	cdb[2] = (((rq_scope & 0xf) << 4) | (rq_type & 0xf));
+	cdb[7] = (unsigned char)((paramlen >> 8) & 0xff);
+	cdb[8] = (unsigned char)(paramlen & 0xff);
+
+retry :
+	condlog(3, "%s: rq_servact = %d", dev, rq_servact); 
+	condlog(3, "%s: rq_scope = %d ", dev, rq_scope);
+	condlog(3, "%s: rq_type = %d ", dev, rq_type);
+	condlog(3, "%s: paramlen = %d", dev, paramlen);
+
+	if (noisy)
+	{
+		condlog(3, "%s: Persistent Reservation OUT parameter:", dev);
+		dumpHex((const char *)paramp, paramlen,1);
+	}
+
+	memset(&Sensedata, 0, sizeof(SenseData_t));
+	memset(&io_hdr,0 , sizeof( struct sg_io_hdr));
+	io_hdr.interface_id = 'S';
+	io_hdr.cmd_len = MPATH_PROUT_CMDLEN;
+	io_hdr.cmdp = cdb;
+	io_hdr.sbp = (void *)&Sensedata;
+	io_hdr.mx_sb_len = sizeof (SenseData_t);
+	io_hdr.timeout = TIMEOUT;
+
+	if (paramlen > 0) {
+		io_hdr.dxferp = (void *)paramp;
+		io_hdr.dxfer_len = paramlen;
+		io_hdr.dxfer_direction = SG_DXFER_TO_DEV ;
+	}
+	else {
+		io_hdr.dxfer_direction = SG_DXFER_NONE;
+	}
+	ret = ioctl(fd, SG_IO, &io_hdr);
+	if (ret < 0)
+	{
+		condlog(0, "%s: ioctl failed %d", dev, ret);
+		close(fd);
+		return ret;
+	}
+
+	condlog(2, "%s: Duration=%u (ms)", dev, io_hdr.duration);
+
+	status = mpath_translate_response(dev, io_hdr, Sensedata, noisy);
+	condlog(3, "%s: status = %d", dev, status);
+
+	if (status == MPATH_PR_SENSE_UNIT_ATTENTION && (retry > 0))
+	{
+		--retry;
+		condlog(2, "%s: retrying for Unit Attention. Remaining retries = %d", 
+			dev, retry);
+		goto retry;
+	}
+
+	if (((status == MPATH_PR_SENSE_NOT_READY )&& (Sensedata.ASC == 0x04)&&
+				(Sensedata.ASCQ == 0x07))&& (retry > 0))
+	{
+		usleep(1000);
+		--retry;
+		condlog(2, "%s: retrying for sense 02/04/07."
+			" Remaining retries = %d", dev, retry);
+		goto retry;
+	}
+
+	close(fd);	
+	return status;
+}
+
+uint32_t  format_transportids(struct prout_param_descriptor *paramp)
+{
+	int i = 0, len;	
+	uint32_t buff_offset = 4;
+	memset(paramp->private_buffer, 0, MPATH_MAX_PARAM_LEN);
+	for (i=0; i < paramp->num_transportid; i++ )
+	{
+		paramp->private_buffer[buff_offset] = (uint8_t)((paramp->trnptid_list[i]->format_code & 0xff)|
+							(paramp->trnptid_list[i]->protocol_id & 0xff));
+		buff_offset += 1;
+		switch(paramp->trnptid_list[i]->protocol_id)
+		{
+			case MPATH_PROTOCOL_ID_FC:
+				buff_offset += 7;
+				memcpy(&paramp->private_buffer[buff_offset], &paramp->trnptid_list[i]->n_port_name, 8);
+				buff_offset +=8 ;
+				buff_offset +=8 ;
+				break;
+			case MPATH_PROTOCOL_ID_SAS:
+				buff_offset += 3;
+				memcpy(&paramp->private_buffer[buff_offset], &paramp->trnptid_list[i]->sas_address, 8);
+				buff_offset += 12;
+				break;
+			case MPATH_PROTOCOL_ID_ISCSI:
+				buff_offset += 1;
+				len = (paramp->trnptid_list[i]->iscsi_name[1] & 0xff)+2;	
+				memcpy(&paramp->private_buffer[buff_offset], &paramp->trnptid_list[i]->iscsi_name,len);
+				buff_offset += len ; 
+				break;
+		}
+
+	}
+	buff_offset -= 4; 
+	paramp->private_buffer[0] = (unsigned char)((buff_offset >> 24) & 0xff);
+	paramp->private_buffer[1] = (unsigned char)((buff_offset >> 16) & 0xff);
+	paramp->private_buffer[2] = (unsigned char)((buff_offset >> 8) & 0xff);
+	paramp->private_buffer[3] = (unsigned char)(buff_offset & 0xff);
+	buff_offset += 4; 
+	return buff_offset;	
+}
+
+void mpath_format_readkeys( struct prin_resp *pr_buff, int len, int noisy)
+{
+        mpath_reverse_uint32_byteorder(&pr_buff->prin_descriptor.prin_readkeys.prgeneration);
+        mpath_reverse_uint32_byteorder(&pr_buff->prin_descriptor.prin_readkeys.additional_length);
+}
+
+void mpath_format_readresv(struct prin_resp *pr_buff, int len, int noisy)
+{
+
+        mpath_reverse_uint32_byteorder(&pr_buff->prin_descriptor.prin_readkeys.prgeneration);
+        mpath_reverse_uint32_byteorder(&pr_buff->prin_descriptor.prin_readkeys.additional_length);
+
+        return;
+}
+
+void mpath_format_reportcapabilities(struct prin_resp *pr_buff, int len, int noisy)
+{
+        mpath_reverse_uint16_byteorder(&pr_buff->prin_descriptor.prin_readcap.length);
+        mpath_reverse_uint16_byteorder(&pr_buff->prin_descriptor.prin_readcap.pr_type_mask);
+
+        return;
+}
+
+void mpath_format_readfullstatus(struct prin_resp *pr_buff, int len, int noisy)
+{
+	int num, k, tid_len_len=0;
+	uint32_t fdesc_count=0;
+	unsigned char *p;
+	char  *ppbuff;
+	uint32_t additional_length;
+
+
+	mpath_reverse_uint32_byteorder(&pr_buff->prin_descriptor.prin_readfd.prgeneration);
+	mpath_reverse_uint32_byteorder(&pr_buff->prin_descriptor.prin_readfd.number_of_descriptor);
+
+	if (0 == pr_buff->prin_descriptor.prin_readfd.number_of_descriptor)
+	{
+		return ;
+	}
+
+
+	if (pr_buff->prin_descriptor.prin_readfd.number_of_descriptor == 0)
+	{
+		condlog(2, "No registration or resrvation found.");
+		return;
+	}
+
+	additional_length = pr_buff->prin_descriptor.prin_readfd.number_of_descriptor;
+
+	char tempbuff[MPATH_MAX_PARAM_LEN];
+	struct prin_fulldescr fdesc;
+	memset(&fdesc, 0, sizeof(struct prin_fulldescr));
+
+	memcpy( tempbuff, pr_buff->prin_descriptor.prin_readfd.private_buffer,MPATH_MAX_PARAM_LEN );
+	memset(&pr_buff->prin_descriptor.prin_readfd.private_buffer, 0, MPATH_MAX_PARAM_LEN);
+
+	p =(unsigned char *)tempbuff;
+	ppbuff = (char *)pr_buff->prin_descriptor.prin_readfd.private_buffer;
+
+	for (k = 0; k < additional_length; k += num, p += num) {
+		memcpy(&fdesc.key, p, 8 );
+		fdesc.flag = p[12];
+		fdesc.scope_type =  p[13];
+		fdesc.rtpi = ((p[18] << 8) | p[19]);
+
+		tid_len_len = ((p[20] << 24) | (p[21] << 16) |
+				(p[22] << 8) | p[23]);
+
+		if (tid_len_len > 0)
+			decode_transport_id( &fdesc, &p[24], tid_len_len);
+
+		num = 24 + tid_len_len;
+		memcpy(ppbuff, &fdesc, sizeof(struct prin_fulldescr));
+		pr_buff->prin_descriptor.prin_readfd.descriptors[fdesc_count]= (struct prin_fulldescr *)ppbuff;
+		ppbuff += sizeof(struct prin_fulldescr);
+		++fdesc_count;
+	}
+
+	pr_buff->prin_descriptor.prin_readfd.number_of_descriptor = fdesc_count;
+
+	return;
+}
+
+void
+decode_transport_id(struct prin_fulldescr *fdesc, unsigned char * p, int length)
+{
+	int num, k;
+	int jump;
+	for (k = 0, jump = 24; k < length; k += jump, p += jump) {
+		fdesc->trnptid.format_code = ((p[0] >> 6) & 0x3);
+		fdesc->trnptid.protocol_id = (p[0] & 0xf);
+		switch (fdesc->trnptid.protocol_id) {
+			case MPATH_PROTOCOL_ID_FC:
+				memcpy(&fdesc->trnptid.n_port_name, &p[8], 8);
+				jump = 24;
+				break;
+			case MPATH_PROTOCOL_ID_ISCSI:
+				num = ((p[2] << 8) | p[3]);
+				memcpy(&fdesc->trnptid.iscsi_name, &p[4], num);
+				jump = (((num + 4) < 24) ? 24 : num + 4);
+				break;
+			case MPATH_PROTOCOL_ID_SAS:
+				memcpy(&fdesc->trnptid.sas_address, &p[4], 8);
+				jump = 24;
+				break;
+			default:
+				jump = 24;
+				break;
+		}
+	}
+}
+
+int prin_do_scsi_ioctl(char * dev, int rq_servact, struct prin_resp * resp, int noisy)
+{
+
+	int ret, status, got, fd;
+	int mx_resp_len;
+	SenseData_t Sensedata;
+	int retry = MAXRETRY;
+	struct sg_io_hdr io_hdr;
+	char devname[FILE_NAME_SIZE];
+	unsigned char cdb[MPATH_PRIN_CMDLEN] =
+	{MPATH_PRIN_CMD, 0, 0, 0, 0, 0, 0, 0, 0, 0};
+
+	snprintf(devname, FILE_NAME_SIZE, "/dev/%s",dev);
+        fd = open(devname, O_WRONLY);
+        if(fd < 0){
+        	condlog(0, "%s: Unable to open device ", dev);
+		return MPATH_PR_FILE_ERROR;
+         }
+
+	if (mpath_mx_alloc_len)
+		mx_resp_len = mpath_mx_alloc_len;
+	else
+		mx_resp_len = get_prin_length(rq_servact);
+
+	if (mx_resp_len == 0) {
+		status = MPATH_PR_SYNTAX_ERROR;
+		goto out;
+	}
+
+	cdb[1] = (unsigned char)(rq_servact & 0x1f);
+	cdb[7] = (unsigned char)((mx_resp_len >> 8) & 0xff);
+	cdb[8] = (unsigned char)(mx_resp_len & 0xff);
+
+retry :
+	memset(&Sensedata, 0, sizeof(SenseData_t));
+	memset(&io_hdr,0 , sizeof( struct sg_io_hdr));
+
+	io_hdr.interface_id = 'S';
+	io_hdr.cmd_len = MPATH_PRIN_CMDLEN;
+	io_hdr.mx_sb_len = sizeof (SenseData_t);
+	io_hdr.dxfer_direction = SG_DXFER_FROM_DEV;
+	io_hdr.cmdp = cdb;
+	io_hdr.sbp = (void *)&Sensedata;
+	io_hdr.timeout = TIMEOUT;
+
+
+
+	io_hdr.dxfer_len = mx_resp_len;
+	io_hdr.dxferp = (void *)resp;
+
+	ret =ioctl(fd, SG_IO, &io_hdr);
+	if (ret < 0){
+		condlog(0, "%s: IOCTL failed %d", dev, ret);
+		status = MPATH_PR_OTHER;
+		goto out;
+	}
+
+	got = mx_resp_len - io_hdr.resid;
+
+	condlog(2, "%s: duration = %u (ms)", dev, io_hdr.duration);
+	condlog(2, "%s: persistent reservation in: requested %d bytes but got %d bytes)", dev, mx_resp_len, got);
+
+	status = mpath_translate_response(dev, io_hdr, Sensedata, noisy);
+
+	if (status == MPATH_PR_SENSE_UNIT_ATTENTION && (retry > 0))
+	{
+		--retry;
+		condlog(2, "%s: retrying for Unit Attention. Remaining retries = %d", dev, retry);
+		goto retry;
+	}
+
+	if (((status == MPATH_PR_SENSE_NOT_READY )&& (Sensedata.ASC == 0x04)&&
+				(Sensedata.ASCQ == 0x07))&& (retry > 0))
+	{
+		usleep(1000);
+		--retry;
+		condlog(2, "%s: retrying for 02/04/07. Remaining retries = %d", dev, retry);
+		goto retry;
+	}
+
+	if (status != MPATH_PR_SUCCESS)
+		goto out;
+
+	if (noisy)
+		dumpHex((const char *)resp, got , 1);
+
+
+	switch (rq_servact)
+	{
+		case MPATH_PRIN_RKEY_SA :
+			mpath_format_readkeys(resp, got, noisy);
+			break;
+		case MPATH_PRIN_RRES_SA :
+			mpath_format_readresv(resp, got, noisy);
+			break;
+		case MPATH_PRIN_RCAP_SA :
+			mpath_format_reportcapabilities(resp, got, noisy);
+			break;
+		case MPATH_PRIN_RFSTAT_SA :
+			mpath_format_readfullstatus(resp, got, noisy);
+	}
+
+out:
+	close(fd);
+	return status;
+}
+
+int mpath_translate_response (char * dev, struct sg_io_hdr io_hdr, SenseData_t Sensedata, int noisy)
+{
+	condlog(3, "%s: status driver:%02x host:%02x scsi:%02x", dev, 
+			io_hdr.driver_status, io_hdr.host_status ,io_hdr.status);
+	io_hdr.status &= 0x7e;
+	if ((0 == io_hdr.status) && (0 == io_hdr.host_status) &&
+			(0 == io_hdr.driver_status))
+	{
+		return MPATH_PR_SUCCESS;
+	}
+
+	switch(io_hdr.status)
+	{
+		case SAM_STAT_GOOD:
+			break;
+		case SAM_STAT_CHECK_CONDITION:
+			condlog(2, "%s: Sense_Key=%02x, ASC=%02x ASCQ=%02x", dev,
+					Sensedata.Sense_Key, Sensedata.ASC, Sensedata.ASCQ);
+			switch(Sensedata.Sense_Key)
+			{
+				case NO_SENSE:
+					return MPATH_PR_NO_SENSE;
+				case RECOVERED_ERROR:
+					return MPATH_PR_SUCCESS;
+				case NOT_READY:
+					return MPATH_PR_SENSE_NOT_READY;
+				case MEDIUM_ERROR:
+					return MPATH_PR_SENSE_MEDIUM_ERROR;
+				case BLANK_CHECK:
+					return MPATH_PR_OTHER;
+				case HARDWARE_ERROR:
+					return MPATH_PR_SENSE_HARDWARE_ERROR;
+				case ILLEGAL_REQUEST:
+					return MPATH_PR_ILLEGAL_REQ;
+				case UNIT_ATTENTION:
+					return MPATH_PR_SENSE_UNIT_ATTENTION;
+				case DATA_PROTECT:
+				case COPY_ABORTED:
+					return MPATH_PR_OTHER;
+				case ABORTED_COMMAND:
+					return MPATH_PR_SENSE_ABORTED_COMMAND;
+
+				default :
+					return MPATH_PR_OTHER;
+			}
+		case SAM_STAT_RESERVATION_CONFLICT:
+			return MPATH_PR_RESERV_CONFLICT;
+
+		default :
+			return  MPATH_PR_OTHER;
+	}
+
+	switch(io_hdr.host_status)
+	{
+		case DID_OK :
+			break;
+		default :
+			return MPATH_PR_OTHER;
+	}
+	switch(io_hdr.driver_status)
+	{
+		case DRIVER_OK:
+			break;
+		default :
+			return MPATH_PR_OTHER;
+	}
+	return MPATH_PR_SUCCESS;
+}
+
+int mpath_isLittleEndian()
+{
+	int num = 1;
+	if(*(char *)&num == 1)
+	{
+		condlog(2, "Little-Endian");
+	}
+	else
+	{
+		condlog(2, "Big-Endian");
+	}
+	return 0;
+}
+
+void mpath_reverse_uint16_byteorder(uint16_t *num)
+{
+	uint16_t byte0, byte1;
+
+	byte0 = (*num & 0x000000FF) >>  0 ;
+	byte1 = (*num & 0x0000FF00) >>  8 ;
+
+	*num = ((byte0 << 8) | (byte1 << 0));
+}
+
+void mpath_reverse_uint32_byteorder(uint32_t *num)
+{
+	uint32_t byte0, byte1, byte2, byte3;
+
+	byte0 = (*num & 0x000000FF) >>  0 ;
+	byte1 = (*num & 0x0000FF00) >>  8 ;
+	byte2 = (*num & 0x00FF0000) >> 16 ;
+	byte3 = (*num & 0xFF000000) >> 24 ;
+
+	*num = ((byte0 << 24) | (byte1 << 16) | (byte2 << 8) | (byte3 << 0));
+}
+
+void mpath_reverse_8bytes_order(char * var)
+{
+	char byte[8];
+
+	int i;
+	for(i=0 ; i < 8 ; i++ )
+	{
+		byte[i] = var[i];
+	}
+	for(i=0 ; i < 8 ; i++ )
+	{
+		var[7 - i] = byte[i];
+	}
+}
+
+void
+dumpHex(const char* str, int len, int log)
+{
+	const char * p = str;
+	unsigned char c;
+	char buff[82];
+	const int bpstart = 5;
+	int bpos = bpstart;
+	int  k;
+
+	if (len <= 0)
+		return;
+	memset(buff, ' ', 80);
+	buff[80] = '\0';
+	for (k = 0; k < len; k++) {
+		c = *p++;
+		bpos += 3;
+		if (bpos == (bpstart + (9 * 3)))
+			bpos++;
+		sprintf(&buff[bpos], "%.2x", (int)(unsigned char)c);
+		buff[bpos + 2] = ' ';
+		if ((k > 0) && (0 == ((k + 1) % 16))) {
+			if (log)
+				condlog(0, "%.76s" , buff);
+			else
+				printf("%.76s" , buff);
+			bpos = bpstart;
+			memset(buff, ' ', 80);
+		}
+	}
+	if (bpos > bpstart) {
+		buff[bpos + 2] = '\0';
+		if (log)
+			condlog(0, "%s", buff);
+		else
+			printf("%s\n" , buff);
+	}
+	return;
+}
+
+int get_prin_length(int rq_servact)
+{
+        int mx_resp_len;
+        switch (rq_servact)
+        {
+                case MPATH_PRIN_RKEY_SA:
+                        mx_resp_len =  sizeof(struct prin_readdescr);
+                        break;
+                case MPATH_PRIN_RRES_SA :
+                        mx_resp_len =  sizeof(struct prin_resvdescr);
+                        break;
+                case MPATH_PRIN_RCAP_SA :
+                        mx_resp_len = sizeof(struct prin_capdescr);
+                        break;
+                case MPATH_PRIN_RFSTAT_SA:
+                        mx_resp_len = sizeof(struct print_fulldescr_list) + sizeof(struct prin_fulldescr *)*32;
+                        break;
+		default:
+			condlog(0, "invalid service action, %d", rq_servact);
+			mx_resp_len = 0;
+			break;
+        }
+        return mx_resp_len;
+}
diff --git a/libmpathpersist/mpath_pr_ioctl.h b/libmpathpersist/mpath_pr_ioctl.h
new file mode 100644
index 0000000..573ff15
--- /dev/null
+++ b/libmpathpersist/mpath_pr_ioctl.h
@@ -0,0 +1,111 @@
+#define MPATH_XFER_HOST_DEV              0   /*data transfer from initiator to target */
+#define MPATH_XFER_DEV_HOST              1   /*data transfer from target to initiator */
+#define MPATH_XFER_NONE                  2   /*no data transfer */
+#define MPATH_XFER_UNKNOWN               3   /*data transfer direction is unknown */
+
+#if 0
+static const char * pr_type_strs[] = {
+    "obsolete [0]",
+    "Write Exclusive",
+    "obsolete [2]",
+    "Exclusive Access",
+    "obsolete [4]",
+    "Write Exclusive, registrants only",
+    "Exclusive Access, registrants only",
+    "Write Exclusive, all registrants",
+    "Exclusive Access, all registrants",
+    "obsolete [9]", "obsolete [0xa]", "obsolete [0xb]", "obsolete [0xc]",
+    "obsolete [0xd]", "obsolete [0xe]", "obsolete [0xf]",
+};
+#endif
+
+typedef unsigned int     LWORD;     /* unsigned numeric, bit patterns */
+typedef unsigned char    BYTE;      /* unsigned numeric, bit patterns */
+
+typedef struct SenseData
+{
+    BYTE        Error_Code;
+    BYTE        Segment_Number; /* not applicable to DAC */
+    BYTE        Sense_Key;
+    BYTE        Information[ 4 ];
+    BYTE        Additional_Len;
+    LWORD       Command_Specific_Info;
+    BYTE        ASC;
+    BYTE        ASCQ;
+    BYTE        Field_Replaceable_Unit;
+    BYTE        Sense_Key_Specific_Info[ 3 ];
+    BYTE        Recovery_Action[ 2 ];
+    BYTE        Total_Errors;
+    BYTE        Total_Retries;
+    BYTE        ASC_Stack_1;
+    BYTE        ASCQ_Stack_1;
+    BYTE        ASC_Stack_2;
+    BYTE        ASCQ_Stack_2;
+    BYTE        Additional_FRU_Info[ 8 ];
+    BYTE        Error_Specific_Info[ 3 ];
+    BYTE        Error_Detection_Point[ 4 ];
+    BYTE        Original_CDB[10];
+    BYTE        Host_ID;
+    BYTE        Host_Descriptor[ 2 ];
+    BYTE        Serial_Number[ 16 ];
+    BYTE        Array_SW_Revision[ 4 ];
+    BYTE        Data_Xfer_Operation;
+    BYTE        LUN_Number;
+    BYTE        LUN_Status;
+    BYTE        Drive_ID;
+    BYTE        Xfer_Start_Drive_ID;
+    BYTE        Drive_SW_Revision[ 4 ];
+    BYTE        Drive_Product_ID[ 16 ];
+    BYTE        PowerUp_Status[ 2 ];
+    BYTE        RAID_Level;
+    BYTE        Drive_Sense_ID[ 2 ];
+    BYTE        Drive_Sense_Data[ 32 ];
+    BYTE        Reserved2[24];
+} SenseData_t;
+
+#define MPATH_PRIN_CMD 0x5e
+#define MPATH_PRIN_CMDLEN 10
+#define MPATH_PROUT_CMD 0x5f
+#define MPATH_PROUT_CMDLEN 10
+
+#define  DID_OK	0x00
+/*
+ *  Status codes
+ */
+#define SAM_STAT_GOOD            0x00
+#define SAM_STAT_CHECK_CONDITION 0x02
+#define SAM_STAT_CONDITION_MET   0x04
+#define SAM_STAT_BUSY            0x08
+#define SAM_STAT_INTERMEDIATE    0x10
+#define SAM_STAT_INTERMEDIATE_CONDITION_MET 0x14
+#define SAM_STAT_RESERVATION_CONFLICT 0x18
+#define SAM_STAT_COMMAND_TERMINATED 0x22        /* obsolete in SAM-3 */
+#define SAM_STAT_TASK_SET_FULL   0x28
+#define SAM_STAT_ACA_ACTIVE      0x30
+#define SAM_STAT_TASK_ABORTED    0x40
+
+#define STATUS_MASK          0x3e
+
+/*
+ *  SENSE KEYS
+ */
+
+#define NO_SENSE            0x00
+#define RECOVERED_ERROR     0x01
+#define NOT_READY           0x02
+#define MEDIUM_ERROR        0x03
+#define HARDWARE_ERROR      0x04
+#define ILLEGAL_REQUEST     0x05
+#define UNIT_ATTENTION      0x06
+#define DATA_PROTECT        0x07
+#define BLANK_CHECK         0x08
+#define COPY_ABORTED        0x0a
+#define ABORTED_COMMAND     0x0b
+#define VOLUME_OVERFLOW     0x0d
+#define MISCOMPARE          0x0e
+
+
+/* Driver status */
+#define DRIVER_OK 0x00
+
+
diff --git a/libmpathpersist/mpath_updatepr.c b/libmpathpersist/mpath_updatepr.c
new file mode 100644
index 0000000..8597d40
--- /dev/null
+++ b/libmpathpersist/mpath_updatepr.c
@@ -0,0 +1,51 @@
+#include<stdio.h>
+#include<unistd.h>
+#include <errno.h>
+
+#include <stdlib.h>
+#include <stdarg.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <sys/poll.h>
+#include <errno.h>
+#include <debug.h>
+#include "memory.h"
+#include "../libmultipath/uxsock.h"
+#include "../libmultipath/defaults.h"
+
+unsigned long mem_allocated;    /* Total memory used in Bytes */
+
+int update_prflag(char * arg1, char * arg2, int noisy)
+{
+	int fd;
+	char str[64];
+	char *reply;
+	size_t len;
+	int ret = 0;
+
+	fd = ux_socket_connect(DEFAULT_SOCKET);
+	if (fd == -1) {
+		condlog (0, "ux socket connect error");
+		return 1 ;
+	}
+
+	snprintf(str,sizeof(str),"map %s %s", arg1, arg2);
+	condlog (2, "%s: pr flag message=%s", arg1, str);
+	send_packet(fd, str, strlen(str) + 1);
+	recv_packet(fd, &reply, &len);
+
+	condlog (2, "%s: message=%s reply=%s", arg1, str, reply);
+	if (!reply || strncmp(reply,"ok", 2) == 0)
+		ret = -1;
+	else if (strncmp(reply, "fail", 4) == 0)
+		ret = -2;
+	else{
+		ret = atoi(reply);
+	}
+
+	free(reply);
+	return ret;
+}
diff --git a/libmpathpersist/mpathpr.h b/libmpathpersist/mpathpr.h
new file mode 100644
index 0000000..54dfb3e
--- /dev/null
+++ b/libmpathpersist/mpathpr.h
@@ -0,0 +1,55 @@
+#ifndef MPATHPR_H
+#define MPATHPR_H
+
+struct prin_param {
+	char dev[FILE_NAME_SIZE];
+        int rq_servact;
+        struct prin_resp *resp;
+        int noisy;
+        int status;
+};
+
+struct prout_param {
+	char dev[FILE_NAME_SIZE];
+        int rq_servact;
+        int rq_scope;
+        unsigned int rq_type;
+        struct prout_param_descriptor  *paramp;
+        int noisy;
+        int status;
+};
+
+struct threadinfo {
+        int status;
+        pthread_t id;
+        struct prout_param param;
+};
+
+
+struct config * conf;
+
+
+int prin_do_scsi_ioctl(char * dev, int rq_servact, struct prin_resp * resp, int noisy);
+int prout_do_scsi_ioctl( char * dev, int rq_servact, int rq_scope,
+                unsigned int rq_type, struct prout_param_descriptor *paramp, int noisy);
+void * _mpath_pr_update (void *arg);
+int mpath_send_prin_activepath (char * dev, int rq_servact, struct prin_resp * resp, int noisy);
+int get_mpvec (vector curmp, vector pathvec, char * refwwid);
+void * mpath_prout_pthread_fn(void *p);
+void dumpHex(const char* , int len, int no_ascii);
+
+int mpath_prout_reg(struct multipath *mpp,int rq_servact, int rq_scope,
+        unsigned int rq_type,  struct prout_param_descriptor * paramp, int noisy);
+int mpath_prout_common(struct multipath *mpp,int rq_servact, int rq_scope,
+        unsigned int rq_type,  struct prout_param_descriptor * paramp, int noisy);
+int mpath_prout_rel(struct multipath *mpp,int rq_servact, int rq_scope,
+        unsigned int rq_type,  struct prout_param_descriptor * paramp, int noisy);
+int send_prout_activepath(char * dev, int rq_servact, int rq_scope,
+        unsigned int rq_type,   struct prout_param_descriptor * paramp, int noisy);
+
+int update_prflag(char * arg1, char * arg2, int noisy);
+void * mpath_alloc_prin_response(int prin_sa);
+int update_map_pr(struct multipath *mpp);
+int devt2devname (char *devname, char *devt);
+
+#endif  
diff --git a/libmultipath/Makefile b/libmultipath/Makefile
index 203833d..22d3844 100644
--- a/libmultipath/Makefile
+++ b/libmultipath/Makefile
@@ -7,15 +7,15 @@ include ../Makefile.inc
 SONAME=0
 DEVLIB = libmultipath.so
 LIBS = $(DEVLIB).$(SONAME)
-LIBDEPS = -lpthread -ldl -ldevmapper
+LIBDEPS = -lpthread -ldl -ldevmapper -ludev
 
-OBJS = memory.o parser.o vector.o devmapper.o callout.o \
+OBJS = memory.o parser.o vector.o devmapper.o \
        hwtable.o blacklist.o util.o dmparser.o config.o \
        structs.o discovery.o propsel.o dict.o \
        pgpolicies.o debug.o regex.o defaults.o uevent.o \
        switchgroup.o uxsock.o print.o alias.o log_pthread.o \
        log.o configure.o structs_vec.o sysfs.o prio.o checkers.o \
-       lock.o waiter.o
+       lock.o waiter.o file.o wwids.o prioritizers/alua_rtpg.o
 
 LIBDM_API_FLUSH = $(shell grep -Ecs '^[a-z]*[[:space:]]+dm_task_no_flush' /usr/include/libdevmapper.h)
 
@@ -23,10 +23,23 @@ ifneq ($(strip $(LIBDM_API_FLUSH)),0)
 	CFLAGS += -DLIBDM_API_FLUSH -D_GNU_SOURCE
 endif
 
+LIBDM_API_COOKIE = $(shell grep -Ecs '^[a-z]*[[:space:]]+dm_task_set_cookie' /usr/include/libdevmapper.h)
+
+ifneq ($(strip $(LIBDM_API_COOKIE)),0)
+	CFLAGS += -DLIBDM_API_COOKIE
+endif
+
+LIBUDEV_API_RECVBUF = $(shell grep -Ecs '^[a-z]*[[:space:]]+udev_monitor_set_resolve_buffer_size' /usr/include/libudev.h)
+
+ifneq ($(strip $(LIBUDEV_API_RECVBUF)),0)
+	CFLAGS += -DLIBUDEV_API_RECVBUF
+endif
+
+
 all: $(LIBS)
 
 $(LIBS): $(OBJS)
-	$(CC) $(SHARED_FLAGS) $(LIBDEPS) -Wl,-soname=$@ $(CFLAGS) -o $@ $(OBJS)
+	$(CC) $(LDFLAGS) $(SHARED_FLAGS) -Wl,-soname=$@ $(CFLAGS) -o $@ $(OBJS) $(LIBDEPS)
 	ln -sf $@ $(DEVLIB)
 
 install:
diff --git a/libmultipath/alias.c b/libmultipath/alias.c
index 95506b4..d913294 100644
--- a/libmultipath/alias.c
+++ b/libmultipath/alias.c
@@ -3,19 +3,19 @@
  * Copyright (c) 2005 Benjamin Marzinski, Redhat
  */
 #include <stdlib.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <fcntl.h>
 #include <errno.h>
 #include <unistd.h>
 #include <string.h>
 #include <limits.h>
 #include <stdio.h>
-#include <signal.h>
 
 #include "debug.h"
 #include "uxsock.h"
 #include "alias.h"
+#include "file.h"
+#include "vector.h"
+#include "checkers.h"
+#include "structs.h"
 
 
 /*
@@ -36,178 +36,37 @@
  * See the file COPYING included with this distribution for more details.
  */
 
-static int
-ensure_directories_exist(char *str, mode_t dir_mode)
-{
-	char *pathname;
-	char *end;
-	int err;
-
-	pathname = strdup(str);
-	if (!pathname){
-		condlog(0, "Cannot copy bindings file pathname : %s",
-			strerror(errno));
-		return -1;
-	}
-	end = pathname;
-	/* skip leading slashes */
-	while (end && *end && (*end == '/'))
-		end++;
-
-	while ((end = strchr(end, '/'))) {
-		/* if there is another slash, make the dir. */
-		*end = '\0';
-		err = mkdir(pathname, dir_mode);
-		if (err && errno != EEXIST) {
-			condlog(0, "Cannot make directory [%s] : %s",
-				pathname, strerror(errno));
-			free(pathname);
-			return -1;
-		}
-		if (!err)
-			condlog(3, "Created dir [%s]", pathname);
-		*end = '/';
-		end++;
-	}
-	free(pathname);
-	return 0;
-}
-
-static void
-sigalrm(int sig)
-{
-	/* do nothing */
-}
 
 static int
-lock_bindings_file(int fd)
-{
-	struct sigaction act, oldact;
-	sigset_t set, oldset;
-	struct flock lock;
-	int err;
-
-	memset(&lock, 0, sizeof(lock));
-	lock.l_type = F_WRLCK;
-	lock.l_whence = SEEK_SET;
-
-	act.sa_handler = sigalrm;
-	sigemptyset(&act.sa_mask);
-	act.sa_flags = 0;
-	sigemptyset(&set);
-	sigaddset(&set, SIGALRM);
-
-	sigaction(SIGALRM, &act, &oldact);
-	sigprocmask(SIG_UNBLOCK, &set, &oldset);
-
-	alarm(BINDINGS_FILE_TIMEOUT);
-	err = fcntl(fd, F_SETLKW, &lock);
-	alarm(0);
-
-	if (err) {
-		if (errno != EINTR)
-			condlog(0, "Cannot lock bindings file : %s",
-					strerror(errno));
-		else
-			condlog(0, "Bindings file is locked. Giving up.");
-	}
-
-	sigprocmask(SIG_SETMASK, &oldset, NULL);
-	sigaction(SIGALRM, &oldact, NULL);
-	return err;
-
-}
-
-
-static int
-open_bindings_file(char *file, int *can_write)
-{
-	int fd;
-	struct stat s;
-
-	if (ensure_directories_exist(file, 0700))
-		return -1;
-	*can_write = 1;
-	fd = open(file, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);
-	if (fd < 0) {
-		if (errno == EROFS) {
-			*can_write = 0;
-			condlog(3, "Cannot open bindings file [%s] read/write. "
-				" trying readonly", file);
-			fd = open(file, O_RDONLY);
-			if (fd < 0) {
-				condlog(0, "Cannot open bindings file [%s] "
-					"readonly : %s", file, strerror(errno));
-				return -1;
-			}
-		}
-		else {
-			condlog(0, "Cannot open bindings file [%s] : %s", file,
-				strerror(errno));
-			return -1;
-		}
-	}
-	if (*can_write && lock_bindings_file(fd) < 0)
-		goto fail;
-
-	memset(&s, 0, sizeof(s));
-	if (fstat(fd, &s) < 0){
-		condlog(0, "Cannot stat bindings file : %s", strerror(errno));
-		goto fail;
-	}
-	if (s.st_size == 0) {
-		if (*can_write == 0)
-			goto fail;
-		/* If bindings file is empty, write the header */
-		size_t len = strlen(BINDINGS_FILE_HEADER);
-		if (write_all(fd, BINDINGS_FILE_HEADER, len) != len) {
-			condlog(0,
-				"Cannot write header to bindings file : %s",
-				strerror(errno));
-			/* cleanup partially written header */
-			ftruncate(fd, 0);
-			goto fail;
-		}
-		fsync(fd);
-		condlog(3, "Initialized new bindings file [%s]", file);
-	}
-
-	return fd;
-
-fail:
-	close(fd);
-	return -1;
-}
-
-static int
-format_devname(char *name, int id, int len)
+format_devname(char *name, int id, int len, char *prefix)
 {
 	int pos;
+	int prefix_len = strlen(prefix);
 
 	memset(name,0, len);
-	strcpy(name,"mpath");
-	for (pos = len - 1; pos >= 5; pos--) {
+	strcpy(name, prefix);
+	for (pos = len - 1; pos >= prefix_len; pos--) {
 		name[pos] = 'a' + id % 26;
 		if (id < 26)
 			break;
 		id /= 26;
 		id--;
 	}
-	memmove(name + 5, name + pos, len - pos);
-	name[5 + len - pos] = '\0';
-	return (5 + len - pos);
+	memmove(name + prefix_len, name + pos, len - pos);
+	name[prefix_len + len - pos] = '\0';
+	return (prefix_len + len - pos);
 }
 
 static int
-scan_devname(char *alias)
+scan_devname(char *alias, char *prefix)
 {
 	char *c;
 	int i, n = 0;
 
-	if (strncmp(alias, "mpath", 5))
+	if (!prefix || strncmp(alias, prefix, strlen(prefix)))
 		return -1;
 
-	c = alias + 5;
+	c = alias + strlen(prefix);
 	while (*c != '\0' && *c != ' ' && *c != '\t') {
 		i = *c - 'a';
 		n = ( n * 26 ) + i;
@@ -221,7 +80,7 @@ scan_devname(char *alias)
 }
 
 static int
-lookup_binding(FILE *f, char *map_wwid, char **map_alias)
+lookup_binding(FILE *f, char *map_wwid, char **map_alias, char *prefix)
 {
 	char buf[LINE_MAX];
 	unsigned int line_nr = 0;
@@ -240,10 +99,10 @@ lookup_binding(FILE *f, char *map_wwid, char **map_alias)
 		alias = strtok(buf, " \t");
 		if (!alias) /* blank line */
 			continue;
-		curr_id = scan_devname(alias);
+		curr_id = scan_devname(alias, prefix);
 		if (curr_id >= id)
 			id = curr_id + 1;
-		wwid = strtok(NULL, "");
+		wwid = strtok(NULL, " \t");
 		if (!wwid){
 			condlog(3,
 				"Ignoring malformed line %u in bindings file",
@@ -265,26 +124,26 @@ lookup_binding(FILE *f, char *map_wwid, char **map_alias)
 }
 
 static int
-rlookup_binding(FILE *f, char **map_wwid, char *map_alias)
+rlookup_binding(FILE *f, char *buff, char *map_alias)
 {
-	char buf[LINE_MAX];
+	char line[LINE_MAX];
 	unsigned int line_nr = 0;
 	int id = 0;
 
-	*map_wwid = NULL;
+	buff[0] = '\0';
 
-	while (fgets(buf, LINE_MAX, f)) {
+	while (fgets(line, LINE_MAX, f)) {
 		char *c, *alias, *wwid;
 		int curr_id;
 
 		line_nr++;
-		c = strpbrk(buf, "#\n\r");
+		c = strpbrk(line, "#\n\r");
 		if (c)
 			*c = '\0';
-		alias = strtok(buf, " \t");
+		alias = strtok(line, " \t");
 		if (!alias) /* blank line */
 			continue;
-		curr_id = scan_devname(alias);
+		curr_id = scan_devname(alias, NULL); /* TBD: Why this call? */
 		if (curr_id >= id)
 			id = curr_id + 1;
 		wwid = strtok(NULL, " \t");
@@ -294,13 +153,16 @@ rlookup_binding(FILE *f, char **map_wwid, char *map_alias)
 				line_nr);
 			continue;
 		}
+		if (strlen(wwid) > WWID_SIZE - 1) {
+			condlog(3,
+				"Ignoring too large wwid at %u in bindings file", line_nr);
+			continue;
+		}
 		if (strcmp(alias, map_alias) == 0){
 			condlog(3, "Found matching alias [%s] in bindings file."
 				"\nSetting wwid to %s", alias, wwid);
-			*map_wwid = strdup(wwid);
-			if (*map_wwid == NULL)
-				condlog(0, "Cannot copy alias from bindings "
-					"file : %s", strerror(errno));
+			strncpy(buff, wwid, WWID_SIZE);
+			buff[WWID_SIZE - 1] = '\0';
 			return id;
 		}
 	}
@@ -309,7 +171,7 @@ rlookup_binding(FILE *f, char **map_wwid, char *map_alias)
 }
 
 static char *
-allocate_binding(int fd, char *wwid, int id)
+allocate_binding(int fd, char *wwid, int id, char *prefix)
 {
 	char buf[LINE_MAX];
 	off_t offset;
@@ -321,7 +183,7 @@ allocate_binding(int fd, char *wwid, int id)
 		return NULL;
 	}
 
-	i = format_devname(buf, id, LINE_MAX);
+	i = format_devname(buf, id, LINE_MAX, prefix);
 	c = buf + i;
 	snprintf(c,LINE_MAX - i, " %s\n", wwid);
 	buf[LINE_MAX - 1] = '\0';
@@ -336,7 +198,9 @@ allocate_binding(int fd, char *wwid, int id)
 		condlog(0, "Cannot write binding to bindings file : %s",
 			strerror(errno));
 		/* clear partial write */
-		ftruncate(fd, offset);
+		if (ftruncate(fd, offset))
+			condlog(0, "Cannot truncate the header : %s",
+				strerror(errno));
 		return NULL;
 	}
 	c = strchr(buf, ' ');
@@ -352,10 +216,11 @@ allocate_binding(int fd, char *wwid, int id)
 }
 
 char *
-get_user_friendly_alias(char *wwid, char *file)
+get_user_friendly_alias(char *wwid, char *file, char *prefix,
+			int bindings_read_only)
 {
 	char *alias;
-	int fd, scan_fd, id;
+	int fd, id;
 	FILE *f;
 	int can_write;
 
@@ -364,87 +229,67 @@ get_user_friendly_alias(char *wwid, char *file)
 		return NULL;
 	}
 
-	fd = open_bindings_file(file, &can_write);
+	fd = open_file(file, &can_write, BINDINGS_FILE_HEADER);
 	if (fd < 0)
 		return NULL;
 
-	scan_fd = dup(fd);
-	if (scan_fd < 0) {
-		condlog(0, "Cannot dup bindings file descriptor : %s",
-			strerror(errno));
-		close(fd);
-		return NULL;
-	}
-
-	f = fdopen(scan_fd, "r");
+	f = fdopen(fd, "r");
 	if (!f) {
 		condlog(0, "cannot fdopen on bindings file descriptor : %s",
 			strerror(errno));
-		close(scan_fd);
 		close(fd);
 		return NULL;
 	}
 
-	id = lookup_binding(f, wwid, &alias);
+	id = lookup_binding(f, wwid, &alias, prefix);
 	if (id < 0) {
 		fclose(f);
-		close(scan_fd);
-		close(fd);
 		return NULL;
 	}
 
-	if (!alias && can_write)
-		alias = allocate_binding(fd, wwid, id);
+	if (fflush(f) != 0) {
+		condlog(0, "cannot fflush bindings file stream : %s",
+			strerror(errno));
+		fclose(f);
+		return NULL;
+	}
+
+	if (!alias && can_write && !bindings_read_only)
+		alias = allocate_binding(fd, wwid, id, prefix);
 
 	fclose(f);
-	close(scan_fd);
-	close(fd);
 	return alias;
 }
 
-char *
-get_user_friendly_wwid(char *alias, char *file)
+int
+get_user_friendly_wwid(char *alias, char *buff, char *file)
 {
-	char *wwid;
-	int fd, scan_fd, id, unused;
+	int fd, unused;
 	FILE *f;
 
 	if (!alias || *alias == '\0') {
 		condlog(3, "Cannot find binding for empty alias");
-		return NULL;
+		return -1;
 	}
 
-	fd = open_bindings_file(file, &unused);
+	fd = open_file(file, &unused, BINDINGS_FILE_HEADER);
 	if (fd < 0)
-		return NULL;
-
-	scan_fd = dup(fd);
-	if (scan_fd < 0) {
-		condlog(0, "Cannot dup bindings file descriptor : %s",
-			strerror(errno));
-		close(fd);
-		return NULL;
-	}
+		return -1;
 
-	f = fdopen(scan_fd, "r");
+	f = fdopen(fd, "r");
 	if (!f) {
 		condlog(0, "cannot fdopen on bindings file descriptor : %s",
 			strerror(errno));
-		close(scan_fd);
 		close(fd);
-		return NULL;
+		return -1;
 	}
 
-	id = rlookup_binding(f, &wwid, alias);
-	if (id < 0) {
+	rlookup_binding(f, buff, alias);
+	if (!strlen(buff)) {
 		fclose(f);
-		close(scan_fd);
-		close(fd);
-		return NULL;
+		return -1;
 	}
 
 	fclose(f);
-	close(scan_fd);
-	close(fd);
-	return wwid;
+	return 0;
 }
diff --git a/libmultipath/alias.h b/libmultipath/alias.h
index fe1191b..8ddd0b5 100644
--- a/libmultipath/alias.h
+++ b/libmultipath/alias.h
@@ -1,4 +1,3 @@
-#define BINDINGS_FILE_TIMEOUT 30
 #define BINDINGS_FILE_HEADER \
 "# Multipath bindings, Version : 1.0\n" \
 "# NOTE: this file is automatically maintained by the multipath program.\n" \
@@ -8,5 +7,6 @@
 "# alias wwid\n" \
 "#\n"
 
-char *get_user_friendly_alias(char *wwid, char *file);
-char *get_user_friendly_wwid(char *alias, char *file);
+char *get_user_friendly_alias(char *wwid, char *file, char *prefix,
+			      int bindings_readonly);
+int get_user_friendly_wwid(char *alias, char *buff, char *file);
diff --git a/libmultipath/blacklist.c b/libmultipath/blacklist.c
index f369517..49a40f9 100644
--- a/libmultipath/blacklist.c
+++ b/libmultipath/blacklist.c
@@ -96,50 +96,6 @@ set_ble_device (vector blist, char * vendor, char * product, int origin)
 }
 
 int
-setup_default_blist (struct config * conf)
-{
-	struct blentry * ble;
-	struct hwentry *hwe;
-	char * str;
-	int i;
-
-	str = STRDUP("^(ram|raw|loop|fd|md|dm-|sr|scd|st)[0-9]*");
-	if (!str)
-		return 1;
-	if (store_ble(conf->blist_devnode, str, ORIGIN_DEFAULT))
-		return 1;
-
-	str = STRDUP("^hd[a-z]");
-	if (!str)
-		return 1;
-	if (store_ble(conf->blist_devnode, str, ORIGIN_DEFAULT))
-		return 1;
-
-	str = STRDUP("^dcssblk[0-9]*");
-	if (!str)
-		return 1;
-	if (store_ble(conf->blist_devnode, str, ORIGIN_DEFAULT))
-		return 1;
-
-	vector_foreach_slot (conf->hwtable, hwe, i) {
-		if (hwe->bl_product) {
-			if (alloc_ble_device(conf->blist_device))
-				return 1;
-			ble = VECTOR_SLOT(conf->blist_device,
-					  VECTOR_SIZE(conf->blist_device) -1);
-			if (set_ble_device(conf->blist_device,
-					   STRDUP(hwe->vendor),
-					   STRDUP(hwe->bl_product),
-					   ORIGIN_DEFAULT)) {
-				FREE(ble);
-				return 1;
-			}
-		}
-	}
-	return 0;
-}
-
-int
 _blacklist_exceptions (vector elist, char * str)
 {
 	int i;
@@ -193,6 +149,53 @@ _blacklist_device (vector blist, char * vendor, char * product)
 	return 0;
 }
 
+int
+setup_default_blist (struct config * conf)
+{
+	struct blentry * ble;
+	struct hwentry *hwe;
+	char * str;
+	int i;
+
+	str = STRDUP("^(ram|raw|loop|fd|md|dm-|sr|scd|st)[0-9]*");
+	if (!str)
+		return 1;
+	if (store_ble(conf->blist_devnode, str, ORIGIN_DEFAULT))
+		return 1;
+
+	str = STRDUP("^hd[a-z]");
+	if (!str)
+		return 1;
+	if (store_ble(conf->blist_devnode, str, ORIGIN_DEFAULT))
+		return 1;
+
+	str = STRDUP("^dcssblk[0-9]*");
+	if (!str)
+		return 1;
+	if (store_ble(conf->blist_devnode, str, ORIGIN_DEFAULT))
+		return 1;
+
+	vector_foreach_slot (conf->hwtable, hwe, i) {
+		if (hwe->bl_product) {
+			if (_blacklist_device(conf->blist_device, hwe->vendor,
+					      hwe->bl_product))
+				continue;
+			if (alloc_ble_device(conf->blist_device))
+				return 1;
+			ble = VECTOR_SLOT(conf->blist_device,
+					  VECTOR_SIZE(conf->blist_device) -1);
+			if (set_ble_device(conf->blist_device,
+					   STRDUP(hwe->vendor),
+					   STRDUP(hwe->bl_product),
+					   ORIGIN_DEFAULT)) {
+				FREE(ble);
+				return 1;
+			}
+		}
+	}
+	return 0;
+}
+
 #define LOG_BLIST(M) \
 	if (vendor && product)						 \
 		condlog(3, "%s: (%s:%s) %s", dev, vendor, product, (M)); \
diff --git a/libmultipath/callout.c b/libmultipath/callout.c
deleted file mode 100644
index 520343e..0000000
--- a/libmultipath/callout.c
+++ /dev/null
@@ -1,224 +0,0 @@
-/*
- * Source: copy of the udev package source file
- *
- * Copyrights of the source file apply
- * Copyright (c) 2004 Christophe Varoqui
- */
-#include <stdio.h>
-#include <sys/stat.h>
-#include <string.h>
-#include <unistd.h>
-#include <sys/types.h>
-#include <stdlib.h>
-#include <fcntl.h>
-#include <sys/wait.h>
-#include <errno.h>
-
-#include "checkers.h"
-#include "vector.h"
-#include "structs.h"
-#include "debug.h"
-
-#define PROGRAM_SIZE	100
-#define FIELD_PROGRAM
-
-#define strfieldcpy(to, from) \
-do { \
-	to[sizeof(to)-1] = '\0'; \
-	strncpy(to, from, sizeof(to)-1); \
-} while (0)
-
-int execute_program(char *path, char *value, int len)
-{
-	int retval;
-	int count;
-	int status;
-	int fds[2], null_fd;
-	pid_t pid;
-	char *pos;
-	char arg[PROGRAM_SIZE];
-	char *argv[sizeof(arg) / 2];
-	int i;
-
-	i = 0;
-
-	if (strchr(path, ' ')) {
-		strfieldcpy(arg, path);
-		pos = arg;
-		while (pos != NULL) {
-			if (pos[0] == '\'') {
-				/* don't separate if in apostrophes */
-				pos++;
-				argv[i] = strsep(&pos, "\'");
-				while (pos[0] == ' ')
-					pos++;
-			} else {
-				argv[i] = strsep(&pos, " ");
-			}
-			i++;
-		}
-	} else {
-		argv[i++] = path;
-	}
-	argv[i] =  NULL;
-
-	retval = pipe(fds);
-
-	if (retval != 0) {
-		condlog(0, "error creating pipe for callout: %s", strerror(errno));
-		return -1;
-	}
-
-	pid = fork();
-
-	switch(pid) {
-	case 0:
-		/* child */
-		close(STDOUT_FILENO);
-
-		/* dup write side of pipe to STDOUT */
-		if (dup(fds[1]) < 0)
-			return -1;
-
-		/* Ignore writes to stderr */
-		null_fd = open("/dev/null", O_WRONLY);
-		if (null_fd > 0) {
-			close(STDERR_FILENO);
-			dup(null_fd);
-			close(null_fd);
-		}
-
-		retval = execv(argv[0], argv);
-		condlog(0, "error execing %s : %s", argv[0], strerror(errno));
-		exit(-1);
-	case -1:
-		condlog(0, "fork failed: %s", strerror(errno));
-		close(fds[0]);
-		close(fds[1]);
-		return -1;
-	default:
-		/* parent reads from fds[0] */
-		close(fds[1]);
-		retval = 0;
-		i = 0;
-		while (1) {
-			count = read(fds[0], value + i, len - i-1);
-			if (count <= 0)
-				break;
-
-			i += count;
-			if (i >= len-1) {
-				condlog(0, "not enough space for response from %s", argv[0]);
-				retval = -1;
-				break;
-			}
-		}
-
-		if (count < 0) {
-			condlog(0, "no response from %s", argv[0]);
-			retval = -1;
-		}
-
-		if (i > 0 && value[i-1] == '\n')
-			i--;
-		value[i] = '\0';
-
-		wait(&status);
-		close(fds[0]);
-
-		retval = -1;
-		if (WIFEXITED(status)) {
-			status = WEXITSTATUS(status);
-			if (status == 0)
-				retval = 0;
-			else
-				condlog(0, "%s exitted with %d", argv[0], status);
-		}
-		else if (WIFSIGNALED(status))
-			condlog(0, "%s was terminated by signal %d", argv[0], WTERMSIG(status));
-		else
-			condlog(0, "%s terminated abnormally", argv[0]);
-	}
-	return retval;
-}
-
-extern int
-apply_format (char * string, char * cmd, struct path * pp)
-{
-	char * pos;
-	char * dst;
-	char * p;
-	char * q;
-	int len;
-	int myfree;
-
-	if (!string)
-		return 1;
-
-	if (!cmd)
-		return 1;
-
-	dst = cmd;
-	p = dst;
-	pos = strchr(string, '%');
-	myfree = CALLOUT_MAX_SIZE;
-
-	if (!pos) {
-		strcpy(dst, string);
-		return 0;
-	}
-
-	len = (int) (pos - string) + 1;
-	myfree -= len;
-
-	if (myfree < 2)
-		return 1;
-
-	snprintf(p, len, "%s", string);
-	p += len - 1;
-	pos++;
-
-	switch (*pos) {
-	case 'n':
-		len = strlen(pp->dev) + 1;
-		myfree -= len;
-
-		if (myfree < 2)
-			return 1;
-
-		snprintf(p, len, "%s", pp->dev);
-		for (q = p; q < p + len; q++) {
-			if (q && *q == '!')
-				*q = '/';
-		}
-		p += len - 1;
-		break;
-	case 'd':
-		len = strlen(pp->dev_t) + 1;
-		myfree -= len;
-
-		if (myfree < 2)
-			return 1;
-
-		snprintf(p, len, "%s", pp->dev_t);
-		p += len - 1;
-		break;
-	default:
-		break;
-	}
-	pos++;
-
-	if (!*pos)
-		return 0;
-
-	len = strlen(pos) + 1;
-	myfree -= len;
-
-	if (myfree < 2)
-		return 1;
-
-	snprintf(p, len, "%s", pos);
-	condlog(3, "reformated callout = %s", dst);
-	return 0;
-}
-
diff --git a/libmultipath/callout.h b/libmultipath/callout.h
deleted file mode 100644
index ab648e8..0000000
--- a/libmultipath/callout.h
+++ /dev/null
@@ -1,7 +0,0 @@
-#ifndef _CALLOUT_H
-#define _CALLOUT_H
-
-int execute_program(char *, char *, int);
-int apply_format (char *, char *, struct path *);
-
-#endif /* _CALLOUT_H */
diff --git a/libmultipath/checkers.c b/libmultipath/checkers.c
index 19d0781..01dafdd 100644
--- a/libmultipath/checkers.c
+++ b/libmultipath/checkers.c
@@ -2,6 +2,7 @@
 #include <string.h>
 #include <stddef.h>
 #include <dlfcn.h>
+#include <sys/stat.h>
 
 #include "debug.h"
 #include "checkers.h"
@@ -34,11 +35,34 @@ int init_checkers (void)
 
 struct checker * alloc_checker (void)
 {
-	return MALLOC(sizeof(struct checker));
+	struct checker *c;
+
+	c = MALLOC(sizeof(struct checker));
+	if (c) {
+		INIT_LIST_HEAD(&c->node);
+		c->refcount = 1;
+	}
+	return c;
 }
 
 void free_checker (struct checker * c)
 {
+	if (!c)
+		return;
+	c->refcount--;
+	if (c->refcount) {
+		condlog(3, "%s checker refcount %d",
+			c->name, c->refcount);
+		return;
+	}
+	condlog(3, "unloading %s checker", c->name);
+	list_del(&c->node);
+	if (c->handle) {
+		if (dlclose(c->handle) != 0) {
+			condlog(0, "Cannot unload checker %s: %s",
+				c->name, dlerror());
+		}
+	}
 	FREE(c);
 }
 
@@ -48,7 +72,6 @@ void cleanup_checkers (void)
 	struct checker * checker_temp;
 
 	list_for_each_entry_safe(checker_loop, checker_temp, &checkers, node) {
-		list_del(&checker_loop->node);
 		free_checker(checker_loop);
 	}
 }
@@ -57,6 +80,8 @@ struct checker * checker_lookup (char * name)
 {
 	struct checker * c;
 
+	if (!name || !strlen(name))
+		return NULL;
 	list_for_each_entry(c, &checkers, node) {
 		if (!strncmp(name, c->name, CHECKER_NAME_LEN))
 			return c;
@@ -67,45 +92,50 @@ struct checker * checker_lookup (char * name)
 struct checker * add_checker (char * name)
 {
 	char libname[LIB_CHECKER_NAMELEN];
-	void * handle;
+	struct stat stbuf;
 	struct checker * c;
 	char *errstr;
 
 	c = alloc_checker();
 	if (!c)
 		return NULL;
+	snprintf(c->name, CHECKER_NAME_LEN, "%s", name);
 	snprintf(libname, LIB_CHECKER_NAMELEN, "%s/libcheck%s.so",
 		 conf->multipath_dir, name);
+	if (stat(libname,&stbuf) < 0) {
+		condlog(0,"Checker '%s' not found in %s",
+			name, conf->multipath_dir);
+		goto out;
+	}
 	condlog(3, "loading %s checker", libname);
-	handle = dlopen(libname, RTLD_NOW);
-	errstr = dlerror();
-	if (errstr != NULL)
-	condlog(0, "A dynamic linking error occurred: (%s)", errstr);
-	if (!handle)
+	c->handle = dlopen(libname, RTLD_NOW);
+	if (!c->handle) {
+		if ((errstr = dlerror()) != NULL)
+			condlog(0, "A dynamic linking error occurred: (%s)",
+				errstr);
 		goto out;
-
-	c->check = (int (*)(struct checker *)) dlsym(handle, "libcheck_check");
+	}
+	c->check = (int (*)(struct checker *)) dlsym(c->handle, "libcheck_check");
 	errstr = dlerror();
 	if (errstr != NULL)
-	condlog(0, "A dynamic linking error occurred: (%s)", errstr);
+		condlog(0, "A dynamic linking error occurred: (%s)", errstr);
 	if (!c->check)
 		goto out;
 
-	c->init = (int (*)(struct checker *)) dlsym(handle, "libcheck_init");
+	c->init = (int (*)(struct checker *)) dlsym(c->handle, "libcheck_init");
 	errstr = dlerror();
 	if (errstr != NULL)
-	condlog(0, "A dynamic linking error occurred: (%s)", errstr);
+		condlog(0, "A dynamic linking error occurred: (%s)", errstr);
 	if (!c->init)
 		goto out;
 
-	c->free = (void (*)(struct checker *)) dlsym(handle, "libcheck_free");
+	c->free = (void (*)(struct checker *)) dlsym(c->handle, "libcheck_free");
 	errstr = dlerror();
 	if (errstr != NULL)
-	condlog(0, "A dynamic linking error occurred: (%s)", errstr);
+		condlog(0, "A dynamic linking error occurred: (%s)", errstr);
 	if (!c->free)
 		goto out;
 
-	snprintf(c->name, CHECKER_NAME_LEN, "%s", name);
 	c->fd = 0;
 	c->sync = 1;
 	list_add(&c->node, &checkers);
@@ -117,48 +147,72 @@ out:
 
 void checker_set_fd (struct checker * c, int fd)
 {
+	if (!c)
+		return;
 	c->fd = fd;
 }
 
 void checker_set_sync (struct checker * c)
 {
+	if (!c)
+		return;
 	c->sync = 1;
 }
 
 void checker_set_async (struct checker * c)
 {
+	if (!c)
+		return;
 	c->sync = 0;
 }
 
 void checker_enable (struct checker * c)
 {
+	if (!c)
+		return;
 	c->disable = 0;
 }
 
 void checker_disable (struct checker * c)
 {
+	if (!c)
+		return;
 	c->disable = 1;
 }
 
 int checker_init (struct checker * c, void ** mpctxt_addr)
 {
+	if (!c)
+		return 1;
 	c->mpcontext = mpctxt_addr;
 	return c->init(c);
 }
 
-void checker_put (struct checker * c)
+void checker_put (struct checker * dst)
 {
-	if (c->free)
-		c->free(c);
-	memset(c, 0x0, sizeof(struct checker));
+	struct checker * src;
+
+	if (!dst)
+		return;
+	src = checker_lookup(dst->name);
+	if (dst->free)
+		dst->free(dst);
+	memset(dst, 0x0, sizeof(struct checker));
+	free_checker(src);
 }
 
 int checker_check (struct checker * c)
 {
 	int r;
 
-	if (c->disable)
+	if (!c)
+		return PATH_WILD;
+
+	c->message[0] = '\0';
+	if (c->disable) {
+		MSG(c, "checker disabled");
 		return PATH_UNCHECKED;
+	}
 	if (c->fd <= 0) {
 		MSG(c, "no usable fd");
 		return PATH_WILD;
@@ -170,23 +224,39 @@ int checker_check (struct checker * c)
 
 int checker_selected (struct checker * c)
 {
+	if (!c)
+		return 0;
 	return (c->check) ? 1 : 0;
 }
 
 char * checker_name (struct checker * c)
 {
+	if (!c)
+		return NULL;
 	return c->name;
 }
 
 char * checker_message (struct checker * c)
 {
+	if (!c)
+		return NULL;
 	return c->message;
 }
 
+void checker_clear_message (struct checker *c)
+{
+	if (!c)
+		return;
+	c->message[0] = '\0';
+}
+
 void checker_get (struct checker * dst, char * name)
 {
 	struct checker * src = checker_lookup(name);
 
+	if (!dst)
+		return;
+
 	if (!src) {
 		dst->check = NULL;
 		return;
@@ -198,4 +268,6 @@ void checker_get (struct checker * dst, char * name)
 	dst->check = src->check;
 	dst->init = src->init;
 	dst->free = src->free;
+	dst->handle = NULL;
+	src->refcount++;
 }
diff --git a/libmultipath/checkers.h b/libmultipath/checkers.h
index 6ba0339..5a96165 100644
--- a/libmultipath/checkers.h
+++ b/libmultipath/checkers.h
@@ -68,20 +68,6 @@ enum path_check_state {
 
 #define DEFAULT_CHECKER DIRECTIO
 
-/*
- * Overloaded storage response time can be very long.
- * SG_IO timouts after DEF_TIMEOUT milliseconds, and checkers interprets this
- * as a path failure. multipathd then proactively evicts the path from the DM
- * multipath table in this case.
- *
- * This generaly snow balls and ends up in full eviction and IO errors for end
- * users. Bad. This may also cause SCSI bus resets, causing disruption for all
- * local and external storage hardware users.
- * 
- * Provision a long timeout. Longer than any real-world application would cope
- * with.
- */
-#define DEF_TIMEOUT		300000
 #define ASYNC_TIMEOUT_SEC	30
 
 /*
@@ -94,8 +80,11 @@ enum path_check_state {
 
 struct checker {
 	struct list_head node;
+	void *handle;
+	int refcount;
 	int fd;
 	int sync;
+	unsigned int timeout;
 	int disable;
 	char name[CHECKER_NAME_LEN];
 	char message[CHECKER_MSG_LEN];       /* comm with callers */
@@ -127,6 +116,7 @@ int checker_check (struct checker *);
 int checker_selected (struct checker *);
 char * checker_name (struct checker *);
 char * checker_message (struct checker *);
+void checker_clear_message (struct checker *c);
 void checker_get (struct checker *, char *);
 
 #endif /* _CHECKERS_H */
diff --git a/libmultipath/checkers/Makefile b/libmultipath/checkers/Makefile
index 92a9382..4b1a108 100644
--- a/libmultipath/checkers/Makefile
+++ b/libmultipath/checkers/Makefile
@@ -18,10 +18,10 @@ CFLAGS += -I..
 all: $(LIBS)
 
 libcheckdirectio.so: libsg.o directio.o
-	$(CC) $(SHARED_FLAGS) -o $@ $^ -laio
+	$(CC) $(LDFLAGS) $(SHARED_FLAGS) -o $@ $^ -laio
 
 libcheck%.so: libsg.o %.o
-	$(CC) $(SHARED_FLAGS) -o $@ $^
+	$(CC) $(LDFLAGS) $(SHARED_FLAGS) -o $@ $^
 
 install:
 	$(INSTALL_PROGRAM) -m 755 $(LIBS) $(DESTDIR)$(libdir)
diff --git a/libmultipath/checkers/directio.c b/libmultipath/checkers/directio.c
index 6696b41..46fe6a7 100644
--- a/libmultipath/checkers/directio.c
+++ b/libmultipath/checkers/directio.c
@@ -12,7 +12,7 @@
 #include <sys/ioctl.h>
 #include <linux/fs.h>
 #include <errno.h>
-#include <asm/unistd.h>
+#include <unistd.h>
 #include <libaio.h>
 
 #include "checkers.h"
@@ -117,7 +117,7 @@ void libcheck_free (struct checker * c)
 }
 
 static int
-check_state(int fd, struct directio_context *ct, int sync)
+check_state(int fd, struct directio_context *ct, int sync, int timeout_secs)
 {
 	struct timespec	timeout = { .tv_nsec = 5 };
 	struct io_event event;
@@ -128,9 +128,9 @@ check_state(int fd, struct directio_context *ct, int sync)
 	if (fstat(fd, &sb) == 0) {
 		LOG(4, "called for %x", (unsigned) sb.st_rdev);
 	}
-	if (sync) {
+	if (sync > 0) {
 		LOG(4, "called in synchronous mode");
-		timeout.tv_sec  = ASYNC_TIMEOUT_SEC;
+		timeout.tv_sec  = timeout_secs;
 		timeout.tv_nsec = 0;
 	}
 
@@ -153,10 +153,22 @@ check_state(int fd, struct directio_context *ct, int sync)
 	if (r < 0 ) {
 		LOG(3, "async io getevents returned %li (errno=%s)", r,
 		    strerror(errno));
+		ct->running = 0;
 		rc = PATH_UNCHECKED;
 	} else if (r < 1L) {
-		if (ct->running > ASYNC_TIMEOUT_SEC || sync) {
+		if (ct->running > timeout_secs || sync) {
+			struct iocb *ios[1] = { &ct->io };
+
 			LOG(3, "abort check on timeout");
+			r = io_cancel(ct->ioctx, ios[0], &event);
+			/*
+			 * Only reset ct->running if we really
+			 * could abort the pending I/O
+			 */
+			if (r)
+				LOG(3, "io_cancel error %i", errno);
+			else
+				ct->running = 0;
 			rc = PATH_DOWN;
 		} else {
 			LOG(3, "async io pending");
@@ -179,7 +191,7 @@ int libcheck_check (struct checker * c)
 	if (!ct)
 		return PATH_UNCHECKED;
 
-	ret = check_state(c->fd, ct, c->sync);
+	ret = check_state(c->fd, ct, c->sync, c->timeout);
 
 	switch (ret)
 	{
diff --git a/libmultipath/checkers/emc_clariion.c b/libmultipath/checkers/emc_clariion.c
index 3a88b0b..5d87bfd 100644
--- a/libmultipath/checkers/emc_clariion.c
+++ b/libmultipath/checkers/emc_clariion.c
@@ -15,6 +15,7 @@
 #include "../libmultipath/sg_include.h"
 #include "libsg.h"
 #include "checkers.h"
+#include "debug.h"
 
 #define INQUIRY_CMD     0x12
 #define INQUIRY_CMDLEN  6
@@ -113,7 +114,7 @@ int libcheck_check (struct checker * c)
 	io_hdr.dxferp = sense_buffer;
 	io_hdr.cmdp = inqCmdBlk;
 	io_hdr.sbp = sb;
-	io_hdr.timeout = DEF_TIMEOUT;
+	io_hdr.timeout = c->timeout;
 	io_hdr.pack_id = 0;
 	if (ioctl(c->fd, SG_IO, &io_hdr) < 0) {
 		MSG(c, "emc_clariion_checker: sending query command failed");
@@ -182,7 +183,8 @@ int libcheck_check (struct checker * c)
 		unsigned char buf[4096];
 
 		memset(buf, 0, 4096);
-		ret = sg_read(c->fd, &buf[0], sbb = &sb[0]);
+		ret = sg_read(c->fd, &buf[0], 4096,
+			      sbb = &sb[0], SENSE_BUFF_LEN, c->timeout);
 		if (ret == PATH_DOWN) {
 			hexadecimal_to_ascii(ct->wwn, wwnstr);
 
@@ -198,7 +200,7 @@ int libcheck_check (struct checker * c)
 				 * 02/04/03 not 05/25/01 on read.
 				 */
 				SET_INACTIVE_SNAP(c);
-				MSG(c, "emc_clariion_checker: Active "
+				condlog(3, "emc_clariion_checker: Active "
 					"path to inactive snapshot WWN %s.",
 					wwnstr);
 			} else
@@ -219,7 +221,7 @@ int libcheck_check (struct checker * c)
 	} else {
 		if (IS_INACTIVE_SNAP(c)) {
 			hexadecimal_to_ascii(ct->wwn, wwnstr);
-			MSG(c, "emc_clariion_checker: Passive "
+			condlog(3, "emc_clariion_checker: Passive "
 				"path to inactive snapshot WWN %s.",
 				wwnstr);
 			ret = PATH_DOWN;
diff --git a/libmultipath/checkers/hp_sw.c b/libmultipath/checkers/hp_sw.c
index 3f28d85..b50ac0c 100644
--- a/libmultipath/checkers/hp_sw.c
+++ b/libmultipath/checkers/hp_sw.c
@@ -46,7 +46,7 @@ void libcheck_free (struct checker * c)
 
 static int
 do_inq(int sg_fd, int cmddt, int evpd, unsigned int pg_op,
-       void *resp, int mx_resp_len, int noisy)
+       void *resp, int mx_resp_len, int noisy, unsigned int timeout)
 {
 	unsigned char inqCmdBlk[INQUIRY_CMDLEN] =
 		{ INQUIRY_CMD, 0, 0, 0, 0, 0 };
@@ -70,7 +70,7 @@ do_inq(int sg_fd, int cmddt, int evpd, unsigned int pg_op,
 	io_hdr.dxferp = resp;
 	io_hdr.cmdp = inqCmdBlk;
 	io_hdr.sbp = sense_b;
-	io_hdr.timeout = DEF_TIMEOUT;
+	io_hdr.timeout = timeout;
 
 	if (ioctl(sg_fd, SG_IO, &io_hdr) < 0)
 		return 1;
@@ -98,7 +98,7 @@ do_inq(int sg_fd, int cmddt, int evpd, unsigned int pg_op,
 }
 
 static int
-do_tur (int fd)
+do_tur (int fd, unsigned int timeout)
 {
 	unsigned char turCmdBlk[TUR_CMD_LEN] = { 0x00, 0, 0, 0, 0, 0 };
 	struct sg_io_hdr io_hdr;
@@ -111,7 +111,7 @@ do_tur (int fd)
 	io_hdr.dxfer_direction = SG_DXFER_NONE;
 	io_hdr.cmdp = turCmdBlk;
 	io_hdr.sbp = sense_buffer;
-	io_hdr.timeout = DEF_TIMEOUT;
+	io_hdr.timeout = timeout;
 	io_hdr.pack_id = 0;
 
 	if (ioctl(fd, SG_IO, &io_hdr) < 0)
@@ -128,12 +128,12 @@ libcheck_check (struct checker * c)
 {
 	char buff[MX_ALLOC_LEN];
 
-	if (0 != do_inq(c->fd, 0, 1, 0x80, buff, MX_ALLOC_LEN, 0)) {
+	if (0 != do_inq(c->fd, 0, 1, 0x80, buff, MX_ALLOC_LEN, 0, c->timeout)) {
 		MSG(c, MSG_HP_SW_DOWN);
 		return PATH_DOWN;
 	}
 
-	if (do_tur(c->fd)) {
+	if (do_tur(c->fd, c->timeout)) {
 		MSG(c, MSG_HP_SW_GHOST);
 		return PATH_GHOST;
 	}
diff --git a/libmultipath/checkers/libsg.c b/libmultipath/checkers/libsg.c
index 4cb7ecc..5a989d3 100644
--- a/libmultipath/checkers/libsg.c
+++ b/libmultipath/checkers/libsg.c
@@ -11,17 +11,18 @@
 #include "../libmultipath/sg_include.h"
 
 int
-sg_read (int sg_fd, unsigned char * buff, unsigned char * senseBuff)
+sg_read (int sg_fd, unsigned char * buff, int buff_len,
+	 unsigned char * sense, int sense_len, unsigned int timeout)
 {
 	/* defaults */
-	int blocks = 1;
+	int blocks;
 	long long start_block = 0;
 	int bs = 512;
 	int cdbsz = 10;
 	int * diop = NULL;
 
 	unsigned char rdCmd[cdbsz];
-	unsigned char *sbb = senseBuff;
+	unsigned char *sbb = sense;
 	struct sg_io_hdr io_hdr;
 	int res;
 	int rd_opcode[] = {0x8, 0x28, 0xa8, 0x88};
@@ -32,6 +33,7 @@ sg_read (int sg_fd, unsigned char * buff, unsigned char * senseBuff)
 	if (fstat(sg_fd, &filestatus) != 0)
 		return PATH_DOWN;
 	bs = (filestatus.st_blksize > 4096)? 4096: filestatus.st_blksize;
+	blocks = buff_len / bs;
 	memset(rdCmd, 0, cdbsz);
 	sz_ind = 1;
 	rdCmd[0] = rd_opcode[sz_ind];
@@ -49,15 +51,15 @@ sg_read (int sg_fd, unsigned char * buff, unsigned char * senseBuff)
 	io_hdr.dxfer_direction = SG_DXFER_FROM_DEV;
 	io_hdr.dxfer_len = bs * blocks;
 	io_hdr.dxferp = buff;
-	io_hdr.mx_sb_len = SENSE_BUFF_LEN;
-	io_hdr.sbp = senseBuff;
-	io_hdr.timeout = DEF_TIMEOUT;
+	io_hdr.mx_sb_len = sense_len;
+	io_hdr.sbp = sense;
+	io_hdr.timeout = timeout;
 	io_hdr.pack_id = (int)start_block;
 	if (diop && *diop)
 	io_hdr.flags |= SG_FLAG_DIRECT_IO;
 
-retry: 
-	memset(senseBuff, 0, SENSE_BUFF_LEN);
+retry:
+	memset(sense, 0, sense_len);
 	while (((res = ioctl(sg_fd, SG_IO, &io_hdr)) < 0) && (EINTR == errno));
 
 	if (res < 0) {
diff --git a/libmultipath/checkers/libsg.h b/libmultipath/checkers/libsg.h
index 97c4491..3994f45 100644
--- a/libmultipath/checkers/libsg.h
+++ b/libmultipath/checkers/libsg.h
@@ -3,6 +3,7 @@
 
 #define SENSE_BUFF_LEN 32
 
-int sg_read (int sg_fd, unsigned char * buff, unsigned char * senseBuff);
+int sg_read (int sg_fd, unsigned char * buff, int buff_len,
+	     unsigned char * sense, int sense_len, unsigned int timeout);
 
 #endif /* _LIBSG_H */
diff --git a/libmultipath/checkers/rdac.c b/libmultipath/checkers/rdac.c
index d12eed1..5f24f55 100644
--- a/libmultipath/checkers/rdac.c
+++ b/libmultipath/checkers/rdac.c
@@ -12,28 +12,113 @@
 #include <errno.h>
 
 #include "checkers.h"
+#include "debug.h"
 
 #include "../libmultipath/sg_include.h"
 
 #define INQUIRY_CMDLEN		6
 #define INQUIRY_CMD		0x12
+#define MODE_SENSE_CMD		0x5a
+#define MODE_SELECT_CMD		0x55
+#define MODE_SEN_SEL_CMDLEN	10
 #define SENSE_BUFF_LEN		32
-#define RDAC_DEF_TIMEOUT	60000
 #define SCSI_CHECK_CONDITION	0x2
 #define SCSI_COMMAND_TERMINATED	0x22
 #define SG_ERR_DRIVER_SENSE	0x08
 #define RECOVERED_ERROR		0x01
 
+
+#define CURRENT_PAGE_CODE_VALUES	0
+#define CHANGEABLE_PAGE_CODE_VALUES	1
+
 #define MSG_RDAC_UP    "rdac checker reports path is up"
 #define MSG_RDAC_DOWN  "rdac checker reports path is down"
 #define MSG_RDAC_GHOST "rdac checker reports path is ghost"
 
+struct control_mode_page {
+	unsigned char header[8];
+	unsigned char page_code;
+	unsigned char page_len;
+	unsigned char dontcare0[3];
+	unsigned char tas_bit;
+	unsigned char dontcare1[6];
+};
+
 struct rdac_checker_context {
 	void * dummy;
 };
 
 int libcheck_init (struct checker * c)
 {
+	unsigned char cmd[MODE_SEN_SEL_CMDLEN];
+	unsigned char sense_b[SENSE_BUFF_LEN];
+	struct sg_io_hdr io_hdr;
+	struct control_mode_page current, changeable;
+	int set = 0;
+
+	memset(cmd, 0, MODE_SEN_SEL_CMDLEN);
+	cmd[0] = MODE_SENSE_CMD;
+	cmd[1] = 0x08; /* DBD bit on */
+	cmd[2] = 0xA + (CURRENT_PAGE_CODE_VALUES << 6);
+	cmd[8] = (sizeof(struct control_mode_page) &  0xff);
+
+	memset(&io_hdr, 0, sizeof(struct sg_io_hdr));
+	memset(sense_b, 0, SENSE_BUFF_LEN);
+	memset(&current, 0, sizeof(struct control_mode_page));
+
+	io_hdr.interface_id = 'S';
+	io_hdr.cmd_len = MODE_SEN_SEL_CMDLEN;
+	io_hdr.mx_sb_len = sizeof(sense_b);
+	io_hdr.dxfer_direction = SG_DXFER_FROM_DEV;
+	io_hdr.dxfer_len = (sizeof(struct control_mode_page) &  0xff);
+	io_hdr.dxferp = &current;
+	io_hdr.cmdp = cmd;
+	io_hdr.sbp = sense_b;
+	io_hdr.timeout = c->timeout;
+
+	if (ioctl(c->fd, SG_IO, &io_hdr) < 0)
+		goto out;
+
+	/* check the TAS bit to see if it is already set */
+	if ((current.tas_bit >> 6) & 0x1) {
+		set = 1;
+		goto out;
+	}
+
+	/* get the changeble values */
+	cmd[2] = 0xA + (CHANGEABLE_PAGE_CODE_VALUES << 6);
+	io_hdr.dxferp = &changeable;
+	memset(&changeable, 0, sizeof(struct control_mode_page));
+
+	if (ioctl(c->fd, SG_IO, &io_hdr) < 0)
+		goto out;
+
+	/* if TAS bit is not settable exit */
+	if (((changeable.tas_bit >> 6) & 0x1) == 0)
+		goto out;
+
+	/* Now go ahead and set it */
+	memset(cmd, 0, MODE_SEN_SEL_CMDLEN);
+	cmd[0] = MODE_SELECT_CMD;
+	cmd[1] = 0x1; /* set SP bit on */
+	cmd[8] = (sizeof(struct control_mode_page) &  0xff);
+
+	/* use the same buffer as current, only set the tas bit */
+	current.page_code = 0xA;
+	current.page_len = 0xA;
+	current.tas_bit |= (1 << 6);
+
+	io_hdr.dxfer_direction = SG_DXFER_TO_DEV;
+	io_hdr.dxferp = &current;
+
+	if (ioctl(c->fd, SG_IO, &io_hdr) < 0)
+		goto out;
+
+	/* Success */
+	set = 1;
+out:
+	if (set == 0)
+		condlog(3, "rdac checker failed to set TAS bit");
 	return 0;
 }
 
@@ -43,12 +128,15 @@ void libcheck_free (struct checker * c)
 }
 
 static int
-do_inq(int sg_fd, unsigned int pg_op, void *resp, int mx_resp_len)
+do_inq(int sg_fd, unsigned int pg_op, void *resp, int mx_resp_len,
+       unsigned int timeout)
 {
 	unsigned char inqCmdBlk[INQUIRY_CMDLEN] = { INQUIRY_CMD, 1, 0, 0, 0, 0 };
 	unsigned char sense_b[SENSE_BUFF_LEN];
 	struct sg_io_hdr io_hdr;
+	int retry_rdac = 5;
 
+retry:
 	inqCmdBlk[2] = (unsigned char) pg_op;
 	inqCmdBlk[4] = (unsigned char) (mx_resp_len & 0xff);
 	memset(&io_hdr, 0, sizeof (struct sg_io_hdr));
@@ -62,7 +150,7 @@ do_inq(int sg_fd, unsigned int pg_op, void *resp, int mx_resp_len)
 	io_hdr.dxferp = resp;
 	io_hdr.cmdp = inqCmdBlk;
 	io_hdr.sbp = sense_b;
-	io_hdr.timeout = RDAC_DEF_TIMEOUT;
+	io_hdr.timeout = timeout;
 
 	if (ioctl(sg_fd, SG_IO, &io_hdr) < 0)
 		return 1;
@@ -72,6 +160,23 @@ do_inq(int sg_fd, unsigned int pg_op, void *resp, int mx_resp_len)
 	if ((0 == io_hdr.status) && (0 == io_hdr.host_status) &&
 	    (0 == io_hdr.driver_status))
 		return 0;
+
+	/* check if we need to retry this error */
+	if (io_hdr.info & SG_INFO_OK_MASK) {
+		switch (io_hdr.host_status) {
+		case DID_BUS_BUSY:
+		case DID_ERROR:
+		case DID_SOFT_ERROR:
+		case DID_TRANSPORT_DISRUPTED:
+			/* Transport error, retry */
+			if (--retry_rdac)
+				goto retry;
+			break;
+		default:
+			break;
+		}
+	}
+
 	if ((SCSI_CHECK_CONDITION == io_hdr.status) ||
 	    (SCSI_COMMAND_TERMINATED == io_hdr.status) ||
 	    (SG_ERR_DRIVER_SENSE == (0xf & io_hdr.driver_status))) {
@@ -94,7 +199,10 @@ struct volume_access_inq
 	char PQ_PDT;
 	char dontcare0[7];
 	char avtcvp;
-	char dontcare1[39];
+	char dontcare1;
+	char asym_access_state_cur;
+	char vendor_specific_cur;
+	char dontcare2[36];
 };
 
 extern int
@@ -104,16 +212,29 @@ libcheck_check (struct checker * c)
 	int ret;
 
 	memset(&inq, 0, sizeof(struct volume_access_inq));
-	if (0 != do_inq(c->fd, 0xC9, &inq, sizeof(struct volume_access_inq))) {
+	if (0 != do_inq(c->fd, 0xC9, &inq, sizeof(struct volume_access_inq),
+			c->timeout)) {
 		ret = PATH_DOWN;
 		goto done;
-	} else if ((inq.PQ_PDT & 0x20) || (inq.PQ_PDT & 0x7f)) {
+	} else if (((inq.PQ_PDT & 0xE0) == 0x20) || (inq.PQ_PDT & 0x7f)) {
 		/* LUN not connected*/
 		ret = PATH_DOWN;
 		goto done;
 	}
 
-	ret = ((inq.avtcvp & 0x1) ? PATH_UP : PATH_GHOST);
+	/* check if controller is in service mode */
+	if ((inq.avtcvp & 0x10) &&
+	    ((inq.asym_access_state_cur & 0x0F) == 0x3) &&
+	    (inq.vendor_specific_cur == 0x7)) {
+		ret = PATH_DOWN;
+		goto done;
+	}
+
+	/* If owner set or ioship mode is enabled return PATH_UP always */
+	if ((inq.avtcvp & 0x1) || ((inq.avtcvp >> 5) & 0x1))
+		ret = PATH_UP;
+	else
+		ret = PATH_GHOST;
 
 done:
 	switch (ret) {
diff --git a/libmultipath/checkers/readsector0.c b/libmultipath/checkers/readsector0.c
index 24182e6..0550fb6 100644
--- a/libmultipath/checkers/readsector0.c
+++ b/libmultipath/checkers/readsector0.c
@@ -29,7 +29,8 @@ int libcheck_check (struct checker * c)
 	unsigned char sbuf[SENSE_BUFF_LEN];
 	int ret;
 
-	ret = sg_read(c->fd, &buf[0], &sbuf[0]);
+	ret = sg_read(c->fd, &buf[0], 4069, &sbuf[0],
+		      SENSE_BUFF_LEN, c->timeout);
 
 	switch (ret)
 	{
diff --git a/libmultipath/checkers/tur.c b/libmultipath/checkers/tur.c
index 47107a2..9c141aa 100644
--- a/libmultipath/checkers/tur.c
+++ b/libmultipath/checkers/tur.c
@@ -12,10 +12,14 @@
 #include <fcntl.h>
 #include <sys/ioctl.h>
 #include <errno.h>
+#include <sys/time.h>
+#include <pthread.h>
 
 #include "checkers.h"
 
+#include "../libmultipath/debug.h"
 #include "../libmultipath/sg_include.h"
+#include "../libmultipath/uevent.h"
 
 #define TUR_CMD_LEN 6
 #define HEAVY_CHECK_COUNT       10
@@ -23,23 +27,80 @@
 #define MSG_TUR_UP	"tur checker reports path is up"
 #define MSG_TUR_DOWN	"tur checker reports path is down"
 #define MSG_TUR_GHOST	"tur checker reports path is in standby state"
+#define MSG_TUR_RUNNING	"tur checker still running"
+#define MSG_TUR_TIMEOUT	"tur checker timed out"
+#define MSG_TUR_FAILED	"tur checker failed to initialize"
 
 struct tur_checker_context {
-	void * dummy;
+	dev_t devt;
+	int state;
+	int running;
+	int fd;
+	unsigned int timeout;
+	time_t time;
+	pthread_t thread;
+	pthread_mutex_t lock;
+	pthread_cond_t active;
+	pthread_spinlock_t hldr_lock;
+	int holders;
+	char message[CHECKER_MSG_LEN];
 };
 
+#define TUR_DEVT(c) major((c)->devt), minor((c)->devt)
+
 int libcheck_init (struct checker * c)
 {
+	struct tur_checker_context *ct;
+
+	ct = malloc(sizeof(struct tur_checker_context));
+	if (!ct)
+		return 1;
+	memset(ct, 0, sizeof(struct tur_checker_context));
+
+	ct->state = PATH_UNCHECKED;
+	ct->fd = -1;
+	ct->holders = 1;
+	pthread_cond_init(&ct->active, NULL);
+	pthread_mutex_init(&ct->lock, NULL);
+	pthread_spin_init(&ct->hldr_lock, PTHREAD_PROCESS_PRIVATE);
+	c->context = ct;
+
 	return 0;
 }
 
+void cleanup_context(struct tur_checker_context *ct)
+{
+	pthread_mutex_destroy(&ct->lock);
+	pthread_cond_destroy(&ct->active);
+	pthread_spin_destroy(&ct->hldr_lock);
+	free(ct);
+}
+
 void libcheck_free (struct checker * c)
 {
+	if (c->context) {
+		struct tur_checker_context *ct = c->context;
+		int holders;
+		pthread_t thread;
+
+		pthread_spin_lock(&ct->hldr_lock);
+		ct->holders--;
+		holders = ct->holders;
+		thread = ct->thread;
+		pthread_spin_unlock(&ct->hldr_lock);
+		if (holders)
+			pthread_cancel(thread);
+		else
+			cleanup_context(ct);
+		c->context = NULL;
+	}
 	return;
 }
 
-extern int
-libcheck_check (struct checker * c)
+#define TUR_MSG(msg, fmt, args...) snprintf(msg, CHECKER_MSG_LEN, fmt, ##args);
+
+int
+tur_check(int fd, unsigned int timeout, char *msg)
 {
 	struct sg_io_hdr io_hdr;
 	unsigned char turCmdBlk[TUR_CMD_LEN] = { 0x00, 0, 0, 0, 0, 0 };
@@ -55,12 +116,20 @@ libcheck_check (struct checker * c)
 	io_hdr.dxfer_direction = SG_DXFER_NONE;
 	io_hdr.cmdp = turCmdBlk;
 	io_hdr.sbp = sense_buffer;
-	io_hdr.timeout = DEF_TIMEOUT;
+	io_hdr.timeout = timeout;
 	io_hdr.pack_id = 0;
-	if (ioctl(c->fd, SG_IO, &io_hdr) < 0) {
-		MSG(c, MSG_TUR_DOWN);
+	if (ioctl(fd, SG_IO, &io_hdr) < 0) {
+		TUR_MSG(msg, MSG_TUR_DOWN);
 		return PATH_DOWN;
 	}
+	if ((io_hdr.status & 0x7e) == 0x18) {
+		/*
+		 * SCSI-3 arrays might return
+		 * reservation conflict on TUR
+		 */
+		TUR_MSG(msg, MSG_TUR_UP);
+		return PATH_UP;
+	}
 	if (io_hdr.info & SG_INFO_OK_MASK) {
 		int key = 0, asc, ascq;
 
@@ -103,13 +172,188 @@ libcheck_check (struct checker * c)
 				 * LOGICAL UNIT NOT ACCESSIBLE,
 				 * TARGET PORT IN STANDBY STATE
 				 */
-				MSG(c, MSG_TUR_GHOST);
+				TUR_MSG(msg, MSG_TUR_GHOST);
 				return PATH_GHOST;
 			}
 		}
-		MSG(c, MSG_TUR_DOWN);
+		TUR_MSG(msg, MSG_TUR_DOWN);
 		return PATH_DOWN;
 	}
-	MSG(c, MSG_TUR_UP);
+	TUR_MSG(msg, MSG_TUR_UP);
 	return PATH_UP;
 }
+
+#define tur_thread_cleanup_push(ct) pthread_cleanup_push(cleanup_func, ct)
+#define tur_thread_cleanup_pop(ct) pthread_cleanup_pop(1)
+
+void cleanup_func(void *data)
+{
+	int holders;
+	struct tur_checker_context *ct = data;
+	pthread_spin_lock(&ct->hldr_lock);
+	ct->holders--;
+	holders = ct->holders;
+	ct->thread = 0;
+	pthread_spin_unlock(&ct->hldr_lock);
+	if (!holders)
+		cleanup_context(ct);
+}
+
+void *tur_thread(void *ctx)
+{
+	struct tur_checker_context *ct = ctx;
+	int state;
+
+	condlog(3, "%d:%d: tur checker starting up", TUR_DEVT(ct));
+
+	ct->message[0] = '\0';
+	/* This thread can be canceled, so setup clean up */
+	tur_thread_cleanup_push(ct)
+
+	/* TUR checker start up */
+	pthread_mutex_lock(&ct->lock);
+	ct->state = PATH_PENDING;
+	pthread_mutex_unlock(&ct->lock);
+
+	state = tur_check(ct->fd, ct->timeout, ct->message);
+
+	/* TUR checker done */
+	pthread_mutex_lock(&ct->lock);
+	ct->state = state;
+	pthread_mutex_unlock(&ct->lock);
+	pthread_cond_signal(&ct->active);
+
+	condlog(3, "%d:%d: tur checker finished, state %s",
+		TUR_DEVT(ct), checker_state_name(state));
+	tur_thread_cleanup_pop(ct);
+	return ((void *)0);
+}
+
+
+void tur_timeout(struct timespec *tsp)
+{
+	struct timeval now;
+
+	gettimeofday(&now, NULL);
+	tsp->tv_sec = now.tv_sec;
+	tsp->tv_nsec = now.tv_usec * 1000;
+	tsp->tv_nsec += 1000000; /* 1 millisecond */
+}
+
+void tur_set_async_timeout(struct checker *c)
+{
+	struct tur_checker_context *ct = c->context;
+	struct timeval now;
+
+	gettimeofday(&now, NULL);
+	ct->time = now.tv_sec + c->timeout;
+}
+
+int tur_check_async_timeout(struct checker *c)
+{
+	struct tur_checker_context *ct = c->context;
+	struct timeval now;
+
+	gettimeofday(&now, NULL);
+	return (now.tv_sec > ct->time);
+}
+
+extern int
+libcheck_check (struct checker * c)
+{
+	struct tur_checker_context *ct = c->context;
+	struct timespec tsp;
+	struct stat sb;
+	pthread_attr_t attr;
+	int tur_status, r;
+
+
+	if (!ct)
+		return PATH_UNCHECKED;
+
+	if (fstat(c->fd, &sb) == 0)
+		ct->devt = sb.st_rdev;
+
+	if (c->sync)
+		return tur_check(c->fd, c->timeout, c->message);
+
+	/*
+	 * Async mode
+	 */
+	r = pthread_mutex_lock(&ct->lock);
+	if (r != 0) {
+		condlog(2, "%d:%d: tur mutex lock failed with %d",
+			TUR_DEVT(ct), r);
+		MSG(c, MSG_TUR_FAILED);
+		return PATH_WILD;
+	}
+
+	if (ct->running) {
+		/* Check if TUR checker is still running */
+		if (ct->thread) {
+			if (tur_check_async_timeout(c)) {
+				condlog(3, "%d:%d: tur checker timeout",
+					TUR_DEVT(ct));
+				pthread_cancel(ct->thread);
+				ct->running = 0;
+				MSG(c, MSG_TUR_TIMEOUT);
+				tur_status = PATH_DOWN;
+				ct->state = PATH_UNCHECKED;
+			} else {
+				condlog(3, "%d:%d: tur checker not finished",
+					TUR_DEVT(ct));
+				ct->running++;
+				tur_status = PATH_PENDING;
+			}
+		} else {
+			/* TUR checker done */
+			ct->running = 0;
+			tur_status = ct->state;
+			strncpy(c->message, ct->message, CHECKER_MSG_LEN);
+			c->message[CHECKER_MSG_LEN - 1] = '\0';
+		}
+		pthread_mutex_unlock(&ct->lock);
+	} else {
+		if (ct->thread) {
+			/* pthread cancel failed. continue in sync mode */
+			pthread_mutex_unlock(&ct->lock);
+			condlog(3, "%d:%d: tur thread not responding, "
+				"using sync mode", TUR_DEVT(ct));
+			return tur_check(c->fd, c->timeout, c->message);
+		}
+		/* Start new TUR checker */
+		ct->state = PATH_UNCHECKED;
+		ct->fd = c->fd;
+		ct->timeout = c->timeout;
+		pthread_spin_lock(&ct->hldr_lock);
+		ct->holders++;
+		pthread_spin_unlock(&ct->hldr_lock);
+		tur_set_async_timeout(c);
+		setup_thread_attr(&attr, 32 * 1024, 1);
+		r = pthread_create(&ct->thread, &attr, tur_thread, ct);
+		if (r) {
+			pthread_mutex_unlock(&ct->lock);
+			ct->thread = 0;
+			ct->holders--;
+			condlog(3, "%d:%d: failed to start tur thread, using"
+				" sync mode", TUR_DEVT(ct));
+			return tur_check(c->fd, c->timeout, c->message);
+		}
+		pthread_attr_destroy(&attr);
+		tur_timeout(&tsp);
+		r = pthread_cond_timedwait(&ct->active, &ct->lock, &tsp);
+		tur_status = ct->state;
+		strncpy(c->message, ct->message,CHECKER_MSG_LEN);
+		c->message[CHECKER_MSG_LEN -1] = '\0';
+		pthread_mutex_unlock(&ct->lock);
+		if (ct->thread &&
+		    (tur_status == PATH_PENDING || tur_status == PATH_UNCHECKED)) {
+			condlog(3, "%d:%d: tur checker still running",
+				TUR_DEVT(ct));
+			ct->running = 1;
+			tur_status = PATH_PENDING;
+		}
+	}
+
+	return tur_status;
+}
diff --git a/libmultipath/config.c b/libmultipath/config.c
index a4178be..da676df 100644
--- a/libmultipath/config.c
+++ b/libmultipath/config.c
@@ -5,6 +5,7 @@
  */
 #include <stdio.h>
 #include <string.h>
+#include <libudev.h>
 
 #include "checkers.h"
 #include "memory.h"
@@ -19,17 +20,24 @@
 #include "blacklist.h"
 #include "defaults.h"
 #include "prio.h"
+#include "devmapper.h"
 
 static int
 hwe_strmatch (struct hwentry *hwe1, struct hwentry *hwe2)
 {
-	if (hwe1->vendor && hwe2->vendor && strcmp(hwe1->vendor, hwe2->vendor))
+	if ((hwe2->vendor && !hwe1->vendor) ||
+	    (hwe1->vendor && (!hwe2->vendor ||
+			      strcmp(hwe1->vendor, hwe2->vendor))))
 		return 1;
 
-	if (hwe1->product && hwe2->product && strcmp(hwe1->product, hwe2->product))
+	if ((hwe2->product && !hwe1->product) ||
+	    (hwe1->product && (!hwe2->product ||
+			      strcmp(hwe1->product, hwe2->product))))
 		return 1;
 
-	if (hwe1->revision && hwe2->revision && strcmp(hwe1->revision, hwe2->revision))
+	if ((hwe2->revision && !hwe1->revision) ||
+	    (hwe1->revision && (!hwe2->revision ||
+			      strcmp(hwe1->revision, hwe2->revision))))
 		return 1;
 
 	return 0;
@@ -50,42 +58,64 @@ find_hwe_strmatch (vector hwtable, struct hwentry *hwe)
 	return ret;
 }
 
+static int
+hwe_regmatch (struct hwentry *hwe1, struct hwentry *hwe2)
+{
+	regex_t vre, pre, rre;
+	int retval = 1;
+
+	if (hwe1->vendor &&
+	    regcomp(&vre, hwe1->vendor, REG_EXTENDED|REG_NOSUB))
+		goto out;
+
+	if (hwe1->product &&
+	    regcomp(&pre, hwe1->product, REG_EXTENDED|REG_NOSUB))
+		goto out_vre;
+
+	if (hwe1->revision &&
+	    regcomp(&rre, hwe1->revision, REG_EXTENDED|REG_NOSUB))
+		goto out_pre;
+
+	if ((!hwe1->vendor || !hwe2->vendor ||
+	     !regexec(&vre, hwe2->vendor, 0, NULL, 0)) &&
+	    (!hwe1->product || !hwe2->product ||
+	     !regexec(&pre, hwe2->product, 0, NULL, 0)) &&
+	    (!hwe1->revision || !hwe2->revision ||
+	     !regexec(&rre, hwe2->revision, 0, NULL, 0)))
+		retval = 0;
+
+	if (hwe1->revision)
+		regfree(&rre);
+out_pre:
+	if (hwe1->product)
+		regfree(&pre);
+out_vre:
+	if (hwe1->vendor)
+		regfree(&vre);
+out:
+	return retval;
+}
+
 struct hwentry *
 find_hwe (vector hwtable, char * vendor, char * product, char * revision)
 {
 	int i;
-	struct hwentry *hwe, *ret = NULL;
-	regex_t vre, pre, rre;
+	struct hwentry hwe, *tmp, *ret = NULL;
 
-	vector_foreach_slot (hwtable, hwe, i) {
-		if (hwe->vendor &&
-		    regcomp(&vre, hwe->vendor, REG_EXTENDED|REG_NOSUB))
-			break;
-		if (hwe->product &&
-		    regcomp(&pre, hwe->product, REG_EXTENDED|REG_NOSUB)) {
-			regfree(&vre);
-			break;
-		}
-		if (hwe->revision &&
-		    regcomp(&rre, hwe->revision, REG_EXTENDED|REG_NOSUB)) {
-			regfree(&vre);
-			regfree(&pre);
-			break;
-		}
-		if ((!hwe->vendor || !regexec(&vre, vendor, 0, NULL, 0)) &&
-		    (!hwe->product || !regexec(&pre, product, 0, NULL, 0)) &&
-		    (!hwe->revision || !regexec(&rre, revision, 0, NULL, 0)))
-			ret = hwe;
-
-		if (hwe->revision)
-			regfree(&rre);
-		if (hwe->product)
-			regfree(&pre);
-		if (hwe->vendor)
-			regfree(&vre);
-
-		if (ret)
-			break;
+	hwe.vendor = vendor;
+	hwe.product = product;
+	hwe.revision = revision;
+	/*
+	 * Search backwards here.
+	 * User modified entries are attached at the end of
+	 * the list, so we have to check them first before
+	 * continuing to the generic entries
+	 */
+	vector_foreach_slot_backwards (hwtable, tmp, i) {
+		if (hwe_regmatch(tmp, &hwe))
+			continue;
+		ret = tmp;
+		break;
 	}
 	return ret;
 }
@@ -137,8 +167,8 @@ free_hwe (struct hwentry * hwe)
 	if (hwe->revision)
 		FREE(hwe->revision);
 
-	if (hwe->getuid)
-		FREE(hwe->getuid);
+	if (hwe->uid_attribute)
+		FREE(hwe->uid_attribute);
 
 	if (hwe->features)
 		FREE(hwe->features);
@@ -158,6 +188,9 @@ free_hwe (struct hwentry * hwe)
 	if (hwe->prio_args)
 		FREE(hwe->prio_args);
 
+	if (hwe->alias_prefix)
+		FREE(hwe->alias_prefix);
+
 	if (hwe->bl_product)
 		FREE(hwe->bl_product);
 
@@ -191,12 +224,18 @@ free_mpe (struct mpentry * mpe)
 	if (mpe->selector)
 		FREE(mpe->selector);
 
-	if (mpe->getuid)
-		FREE(mpe->getuid);
+	if (mpe->uid_attribute)
+		FREE(mpe->uid_attribute);
 
 	if (mpe->alias)
 		FREE(mpe->alias);
 
+	if (mpe->prio_name)
+		FREE(mpe->prio_name);
+
+	if (mpe->prio_args)
+		FREE(mpe->prio_args);
+
 	FREE(mpe);
 }
 
@@ -257,37 +296,53 @@ set_param_str(char * str)
 }
 
 #define merge_str(s) \
-	if (hwe2->s) { \
-		if (hwe1->s) \
-			FREE(hwe1->s); \
-		if (!(hwe1->s = set_param_str(hwe2->s))) \
+	if (!dst->s && src->s) { \
+		if (!(dst->s = set_param_str(src->s))) \
 			return 1; \
 	}
 
 #define merge_num(s) \
-	if (hwe2->s) \
-		hwe1->s = hwe2->s
+	if (!dst->s && src->s) \
+		dst->s = src->s
 
 
 static int
-merge_hwe (struct hwentry * hwe1, struct hwentry * hwe2)
+merge_hwe (struct hwentry * dst, struct hwentry * src)
 {
 	merge_str(vendor);
 	merge_str(product);
 	merge_str(revision);
-	merge_str(getuid);
+	merge_str(uid_attribute);
 	merge_str(features);
 	merge_str(hwhandler);
 	merge_str(selector);
 	merge_str(checker_name);
 	merge_str(prio_name);
 	merge_str(prio_args);
+	merge_str(alias_prefix);
 	merge_str(bl_product);
 	merge_num(pgpolicy);
 	merge_num(pgfailback);
 	merge_num(rr_weight);
 	merge_num(no_path_retry);
 	merge_num(minio);
+	merge_num(minio_rq);
+	merge_num(pg_timeout);
+	merge_num(flush_on_last_del);
+	merge_num(fast_io_fail);
+	merge_num(dev_loss);
+	merge_num(user_friendly_names);
+	merge_num(retain_hwhandler);
+	merge_num(detect_prio);
+
+	/*
+	 * Make sure features is consistent with
+	 * no_path_retry
+	 */
+	if (dst->no_path_retry == NO_PATH_RETRY_FAIL)
+		remove_feature(&dst->features, "queue_if_no_path");
+	else if (dst->no_path_retry != NO_PATH_RETRY_UNDEF)
+		add_feature(&dst->features, "queue_if_no_path");
 
 	return 0;
 }
@@ -312,7 +367,7 @@ store_hwe (vector hwtable, struct hwentry * dhwe)
 	if (dhwe->revision && !(hwe->revision = set_param_str(dhwe->revision)))
 		goto out;
 
-	if (dhwe->getuid && !(hwe->getuid = set_param_str(dhwe->getuid)))
+	if (dhwe->uid_attribute && !(hwe->uid_attribute = set_param_str(dhwe->uid_attribute)))
 		goto out;
 
 	if (dhwe->features && !(hwe->features = set_param_str(dhwe->features)))
@@ -333,11 +388,22 @@ store_hwe (vector hwtable, struct hwentry * dhwe)
 	if (dhwe->prio_args && !(hwe->prio_args = set_param_str(dhwe->prio_args)))
 		goto out;
 
+	if (dhwe->alias_prefix && !(hwe->alias_prefix = set_param_str(dhwe->alias_prefix)))
+		goto out;
+
 	hwe->pgpolicy = dhwe->pgpolicy;
 	hwe->pgfailback = dhwe->pgfailback;
 	hwe->rr_weight = dhwe->rr_weight;
 	hwe->no_path_retry = dhwe->no_path_retry;
 	hwe->minio = dhwe->minio;
+	hwe->minio_rq = dhwe->minio_rq;
+	hwe->pg_timeout = dhwe->pg_timeout;
+	hwe->flush_on_last_del = dhwe->flush_on_last_del;
+	hwe->fast_io_fail = dhwe->fast_io_fail;
+	hwe->dev_loss = dhwe->dev_loss;
+	hwe->user_friendly_names = dhwe->user_friendly_names;
+	hwe->retain_hwhandler = dhwe->retain_hwhandler;
+	hwe->detect_prio = dhwe->detect_prio;
 
 	if (dhwe->bl_product && !(hwe->bl_product = set_param_str(dhwe->bl_product)))
 		goto out;
@@ -352,25 +418,37 @@ out:
 	return 1;
 }
 
-static int
-factorize_hwtable (vector hw)
+static void
+factorize_hwtable (vector hw, int n)
 {
 	struct hwentry *hwe1, *hwe2;
 	int i, j;
 
+restart:
 	vector_foreach_slot(hw, hwe1, i) {
-		j = i+1;
+		if (i == n)
+			break;
+		j = n;
 		vector_foreach_slot_after(hw, hwe2, j) {
-			if (hwe_strmatch(hwe1, hwe2))
+			if (hwe_regmatch(hwe1, hwe2))
 				continue;
 			/* dup */
-			merge_hwe(hwe1, hwe2);
-			free_hwe(hwe2);
-			vector_del_slot(hw, j);
-			j--;
+			merge_hwe(hwe2, hwe1);
+			if (hwe_strmatch(hwe2, hwe1) == 0) {
+				vector_del_slot(hw, i);
+				free_hwe(hwe1);
+				n -= 1;
+				/*
+				 * Play safe here; we have modified
+				 * the original vector so the outer
+				 * vector_foreach_slot() might
+				 * become confused.
+				 */
+				goto restart;
+			}
 		}
 	}
-	return 0;
+	return;
 }
 
 struct config *
@@ -388,8 +466,8 @@ free_config (struct config * conf)
 	if (conf->dev)
 		FREE(conf->dev);
 
-	if (conf->udev_dir)
-		FREE(conf->udev_dir);
+	if (conf->udev)
+		udev_unref(conf->udev);
 
 	if (conf->multipath_dir)
 		FREE(conf->multipath_dir);
@@ -397,8 +475,8 @@ free_config (struct config * conf)
 	if (conf->selector)
 		FREE(conf->selector);
 
-	if (conf->getuid)
-		FREE(conf->getuid);
+	if (conf->uid_attribute)
+		FREE(conf->uid_attribute);
 
 	if (conf->features)
 		FREE(conf->features);
@@ -406,14 +484,24 @@ free_config (struct config * conf)
 	if (conf->hwhandler)
 		FREE(conf->hwhandler);
 
+	if (conf->bindings_file)
+		FREE(conf->bindings_file);
+
+	if (conf->wwids_file)
+		FREE(conf->wwids_file);
 	if (conf->prio_name)
 		FREE(conf->prio_name);
 
+	if (conf->alias_prefix)
+		FREE(conf->alias_prefix);
+
 	if (conf->prio_args)
 		FREE(conf->prio_args);
 
 	if (conf->checker_name)
 		FREE(conf->checker_name);
+	if (conf->reservation_key)
+		FREE(conf->reservation_key);
 
 	free_blacklist(conf->blist_devnode);
 	free_blacklist(conf->blist_wwid);
@@ -444,13 +532,25 @@ load_config (char * file)
 	if (!conf->verbosity)
 		conf->verbosity = DEFAULT_VERBOSITY;
 
+	conf->udev = udev_new();
+	dm_drv_version(conf->version, TGT_MPATH);
 	conf->dev_type = DEV_NONE;
-	conf->minio = 1000;
-	conf->max_fds = 0;
-	conf->bindings_file = DEFAULT_BINDINGS_FILE;
+	conf->minio = DEFAULT_MINIO;
+	conf->minio_rq = DEFAULT_MINIO_RQ;
+	get_sys_max_fds(&conf->max_fds);
+	conf->bindings_file = set_default(DEFAULT_BINDINGS_FILE);
+	conf->wwids_file = set_default(DEFAULT_WWIDS_FILE);
+	conf->bindings_read_only = 0;
 	conf->multipath_dir = set_default(DEFAULT_MULTIPATHDIR);
+	conf->features = set_default(DEFAULT_FEATURES);
 	conf->flush_on_last_del = 0;
 	conf->attribute_flags = 0;
+	conf->reassign_maps = DEFAULT_REASSIGN_MAPS;
+	conf->checkint = DEFAULT_CHECKINT;
+	conf->max_checkint = MAX_CHECKINT(conf->checkint);
+	conf->fast_io_fail = DEFAULT_FAST_IO_FAIL;
+	conf->retain_hwhandler = DEFAULT_RETAIN_HWHANDLER;
+	conf->detect_prio = DEFAULT_DETECT_PRIO;
 
 	/*
 	 * preload default hwtable
@@ -467,19 +567,27 @@ load_config (char * file)
 	/*
 	 * read the config file
 	 */
+	set_current_keywords(&conf->keywords);
+	alloc_keywords();
 	if (filepresent(file)) {
-		set_current_keywords(&conf->keywords);
+		int builtin_hwtable_size;
+
+		builtin_hwtable_size = VECTOR_SIZE(conf->hwtable);
 		if (init_data(file, init_keywords)) {
 			condlog(0, "error parsing config file");
 			goto out;
 		}
-	}
+		if (VECTOR_SIZE(conf->hwtable) > builtin_hwtable_size) {
+			/*
+			 * remove duplica in hwtable. config file
+			 * takes precedence over build-in hwtable
+			 */
+			factorize_hwtable(conf->hwtable, builtin_hwtable_size);
+		}
 
-	/*
-	 * remove duplica in hwtable. config file takes precedence
-	 * over build-in hwtable
-	 */
-	factorize_hwtable(conf->hwtable);
+	} else {
+		init_keywords();
+	}
 
 	/*
 	 * fill the voids left in the config file
@@ -530,10 +638,11 @@ load_config (char * file)
 		if (!conf->mptable)
 			goto out;
 	}
-	if (conf->udev_dir == NULL)
-		conf->udev_dir = set_default(DEFAULT_UDEVDIR);
+	if (conf->bindings_file == NULL)
+		conf->bindings_file = set_default(DEFAULT_BINDINGS_FILE);
 
-	if (!conf->udev_dir || !conf->multipath_dir)
+	if (!conf->multipath_dir || !conf->bindings_file ||
+	    !conf->wwids_file)
 		goto out;
 
 	return 0;
diff --git a/libmultipath/config.h b/libmultipath/config.h
index 471eed0..4ade355 100644
--- a/libmultipath/config.h
+++ b/libmultipath/config.h
@@ -7,6 +7,14 @@
 #define ORIGIN_DEFAULT 0
 #define ORIGIN_CONFIG  1
 
+/*
+ * In kernel, fast_io_fail == 0 means immediate failure on rport delete.
+ * OTOH '0' means not-configured in various places in multipath-tools.
+ */
+#define MP_FAST_IO_FAIL_UNSET (0)
+#define MP_FAST_IO_FAIL_OFF (-1)
+#define MP_FAST_IO_FAIL_ZERO (-2)
+
 enum devtypes {
 	DEV_NONE,
 	DEV_DEVT,
@@ -18,40 +26,51 @@ struct hwentry {
 	char * vendor;
 	char * product;
 	char * revision;
-	char * getuid;
+	char * uid_attribute;
 	char * features;
 	char * hwhandler;
 	char * selector;
 	char * checker_name;
 	char * prio_name;
 	char * prio_args;
+	char * alias_prefix;
 
 	int pgpolicy;
 	int pgfailback;
 	int rr_weight;
 	int no_path_retry;
 	int minio;
+	int minio_rq;
 	int pg_timeout;
 	int flush_on_last_del;
 	int fast_io_fail;
 	unsigned int dev_loss;
+	int user_friendly_names;
+	int retain_hwhandler;
+	int detect_prio;
 	char * bl_product;
 };
 
 struct mpentry {
 	char * wwid;
 	char * alias;
-	char * getuid;
+	char * uid_attribute;
 	char * selector;
+	char * features;
 
+	char * prio_name;
+	char * prio_args;
+	unsigned char * reservation_key;
 	int pgpolicy;
 	int pgfailback;
 	int rr_weight;
 	int no_path_retry;
 	int minio;
+	int minio_rq;
 	int pg_timeout;
 	int flush_on_last_del;
 	int attribute_flags;
+	int user_friendly_names;
 	uid_t uid;
 	gid_t gid;
 	mode_t mode;
@@ -62,10 +81,10 @@ struct config {
 	int dry_run;
 	int list;
 	int pgpolicy_flag;
-	int with_sysfs;
 	int pgpolicy;
 	enum devtypes dev_type;
 	int minio;
+	int minio_rq;
 	int checkint;
 	int max_checkint;
 	int pgfailback;
@@ -73,32 +92,42 @@ struct config {
 	int rr_weight;
 	int no_path_retry;
 	int user_friendly_names;
+	int bindings_read_only;
 	int pg_timeout;
 	int max_fds;
 	int force_reload;
 	int queue_without_daemon;
+	int checker_timeout;
 	int daemon;
 	int flush_on_last_del;
 	int attribute_flags;
 	int fast_io_fail;
 	unsigned int dev_loss;
+	int log_checker_err;
+	int allow_queueing;
 	uid_t uid;
 	gid_t gid;
 	mode_t mode;
 	uint32_t cookie;
+	int reassign_maps;
+	int retain_hwhandler;
+	int detect_prio;
+	unsigned int version[3];
 
 	char * dev;
-	char * sysfs_dir;
-	char * udev_dir;
+	struct udev * udev;
 	char * multipath_dir;
 	char * selector;
-	char * getuid;
+	char * uid_attribute;
 	char * features;
 	char * hwhandler;
 	char * bindings_file;
+	char * wwids_file;
 	char * prio_name;
 	char * prio_args;
 	char * checker_name;
+	char * alias_prefix;
+	unsigned char * reservation_key;
 
 	vector keywords;
 	vector mptable;
diff --git a/libmultipath/configure.c b/libmultipath/configure.c
index c6ca4b6..e5048eb 100644
--- a/libmultipath/configure.c
+++ b/libmultipath/configure.c
@@ -13,6 +13,7 @@
 #include <sys/file.h>
 #include <errno.h>
 #include <libdevmapper.h>
+#include <libudev.h>
 
 #include "checkers.h"
 #include "vector.h"
@@ -35,13 +36,15 @@
 #include "alias.h"
 #include "prio.h"
 #include "util.h"
+#include "uxsock.h"
+#include "wwids.h"
 
 extern int
-setup_map (struct multipath * mpp)
+setup_map (struct multipath * mpp, char * params, int params_size)
 {
 	struct pathgroup * pgp;
 	int i;
-	
+
 	/*
 	 * don't bother if devmap size is unknown
 	 */
@@ -72,6 +75,8 @@ setup_map (struct multipath * mpp)
 	select_gid(mpp);
 	select_fast_io_fail(mpp);
 	select_dev_loss(mpp);
+	select_reservation_key(mpp);
+	select_retain_hwhandler(mpp);
 
 	sysfs_set_scsi_tmo(mpp);
 	/*
@@ -88,7 +93,7 @@ setup_map (struct multipath * mpp)
 	if (mpp->pgpolicyfn && mpp->pgpolicyfn(mpp))
 		return 1;
 
-	mpp->nr_active = pathcount(mpp, PATH_UP);
+	mpp->nr_active = pathcount(mpp, PATH_UP) + pathcount(mpp, PATH_GHOST);
 
 	/*
 	 * ponders each path group and determine highest prio pg
@@ -100,7 +105,7 @@ setup_map (struct multipath * mpp)
 	 * transform the mp->pg vector of vectors of paths
 	 * into a mp->params strings to feed the device-mapper
 	 */
-	if (assemble_map(mpp)) {
+	if (assemble_map(mpp, params, params_size)) {
 		condlog(0, "%s: problem assembing map", mpp->alias);
 		return 1;
 	}
@@ -132,7 +137,8 @@ pgcmp (struct multipath * mpp, struct multipath * cmpp)
 		compute_pgid(pgp);
 
 		vector_foreach_slot (cmpp->pg, cpgp, j) {
-			if (pgp->id == cpgp->id) {
+			if (pgp->id == cpgp->id &&
+			    !pathcmp(pgp, cpgp)) {
 				r = 0;
 				break;
 			}
@@ -148,12 +154,12 @@ static void
 select_action (struct multipath * mpp, vector curmp, int force_reload)
 {
 	struct multipath * cmpp;
+	struct multipath * cmpp_by_name;
 
-	cmpp = find_mp_by_alias(curmp, mpp->alias);
-
-	if (!cmpp) {
-		cmpp = find_mp_by_wwid(curmp, mpp->wwid);
+	cmpp = find_mp_by_wwid(curmp, mpp->wwid);
+	cmpp_by_name = find_mp_by_alias(curmp, mpp->alias);
 
+	if (!cmpp_by_name) {
 		if (cmpp) {
 			condlog(2, "%s: rename %s to %s", mpp->wwid,
 				cmpp->alias, mpp->alias);
@@ -167,17 +173,25 @@ select_action (struct multipath * mpp, vector curmp, int force_reload)
 		return;
 	}
 
-	if (!find_mp_by_wwid(curmp, mpp->wwid)) {
-		condlog(2, "%s: remove (wwid changed)", cmpp->alias);
+	if (!cmpp) {
+		condlog(2, "%s: remove (wwid changed)", mpp->alias);
 		dm_flush_map(mpp->alias);
-		strncat(cmpp->wwid, mpp->wwid, WWID_SIZE);
-		drop_multipath(curmp, cmpp->wwid, KEEP_PATHS);
+		strncpy(cmpp_by_name->wwid, mpp->wwid, WWID_SIZE);
+		drop_multipath(curmp, cmpp_by_name->wwid, KEEP_PATHS);
 		mpp->action = ACT_CREATE;
 		condlog(3, "%s: set ACT_CREATE (map wwid change)",
 			mpp->alias);
 		return;
 	}
 
+	if (cmpp != cmpp_by_name) {
+		condlog(2, "%s: unable to rename %s to %s (%s is used by %s)",
+			mpp->wwid, cmpp->alias, mpp->alias,
+			mpp->alias, cmpp_by_name->wwid);
+		mpp->action = ACT_NOTHING;
+		return;
+	}
+
 	if (pathcount(mpp, PATH_UP) == 0) {
 		mpp->action = ACT_NOTHING;
 		condlog(3, "%s: set ACT_NOTHING (no usable path)",
@@ -191,8 +205,8 @@ select_action (struct multipath * mpp, vector curmp, int force_reload)
 		return;
 	}
 	if (cmpp->size != mpp->size) {
-		mpp->action = ACT_RELOAD;
-		condlog(3, "%s: set ACT_RELOAD (size change)",
+		mpp->action = ACT_RESIZE;
+		condlog(3, "%s: set ACT_RESIZE (size change)",
 			mpp->alias);
 		return;
 	}
@@ -204,8 +218,10 @@ select_action (struct multipath * mpp, vector curmp, int force_reload)
 			mpp->alias);
 		return;
 	}
-	if (!cmpp->selector || strncmp(cmpp->hwhandler, mpp->hwhandler,
-		    strlen(mpp->hwhandler))) {
+	if (mpp->retain_hwhandler != RETAIN_HWHANDLER_ON &&
+            (strlen(cmpp->hwhandler) != strlen(mpp->hwhandler) ||
+	     strncmp(cmpp->hwhandler, mpp->hwhandler,
+		    strlen(mpp->hwhandler)))) {
 		mpp->action = ACT_RELOAD;
 		condlog(3, "%s: set ACT_RELOAD (hwhandler change)",
 			mpp->alias);
@@ -284,6 +300,7 @@ lock_multipath (struct multipath * mpp, int lock)
 	struct pathgroup * pgp;
 	struct path * pp;
 	int i, j;
+	int x, y;
 
 	if (!mpp || !mpp->pg)
 		return 0;
@@ -294,12 +311,25 @@ lock_multipath (struct multipath * mpp, int lock)
 		vector_foreach_slot(pgp->paths, pp, j) {
 			if (lock && flock(pp->fd, LOCK_EX | LOCK_NB) &&
 			    errno == EWOULDBLOCK)
-				return 1;
+				goto fail;
 			else if (!lock)
 				flock(pp->fd, LOCK_UN);
 		}
 	}
 	return 0;
+fail:
+	vector_foreach_slot (mpp->pg, pgp, x) {
+		if (x > i)
+			return 1;
+		if (!pgp->paths)
+			continue;
+		vector_foreach_slot(pgp->paths, pp, y) {
+			if (x == i && y >= j)
+				return 1;
+			flock(pp->fd, LOCK_UN);
+		}
+	}
+	return 1;
 }
 
 /*
@@ -312,7 +342,7 @@ lock_multipath (struct multipath * mpp, int lock)
 #define DOMAP_DRY	3
 
 extern int
-domap (struct multipath * mpp)
+domap (struct multipath * mpp, char * params)
 {
 	int r = 0;
 
@@ -352,28 +382,28 @@ domap (struct multipath * mpp)
 			break;
 		}
 
-		r = dm_addmap_create(mpp);
+		r = dm_addmap_create(mpp, params);
 
 		if (!r)
-			 r = dm_addmap_create_ro(mpp);
+			r = dm_addmap_create_ro(mpp, params);
 
 		lock_multipath(mpp, 0);
 		break;
 
 	case ACT_RELOAD:
-		r = dm_addmap_reload(mpp);
+		r = dm_addmap_reload(mpp, params);
 		if (!r)
-			r = dm_addmap_reload_ro(mpp);
+			r = dm_addmap_reload_ro(mpp, params);
 		if (r)
 			r = dm_simplecmd_noflush(DM_DEVICE_RESUME, mpp->alias);
 		break;
 
- 	case ACT_RESIZE:
-  		r = dm_addmap_reload(mpp);
-  		if (!r)
-  			r = dm_addmap_reload_ro(mpp);
-  		if (r)
-  			r = dm_simplecmd_flush(DM_DEVICE_RESUME, mpp->alias, 1);
+	case ACT_RESIZE:
+		r = dm_addmap_reload(mpp, params);
+		if (!r)
+			r = dm_addmap_reload_ro(mpp, params);
+		if (r)
+			r = dm_simplecmd_flush(DM_DEVICE_RESUME, mpp->alias, 1);
 		break;
 
 	case ACT_RENAME:
@@ -389,16 +419,16 @@ domap (struct multipath * mpp)
 		 * DM_DEVICE_CREATE, DM_DEVICE_RENAME, or DM_DEVICE_RELOAD
 		 * succeeded
 		 */
+		if (mpp->action == ACT_CREATE)
+			remember_wwid(mpp->wwid);
 		if (!conf->daemon) {
 			/* multipath client mode */
 			dm_switchgroup(mpp->alias, mpp->bestpg);
-			if (mpp->action != ACT_NOTHING)
-				print_multipath_topology(mpp, conf->verbosity);
 		} else  {
 			/* multipath daemon mode */
 			mpp->stat_map_loads++;
 			condlog(2, "%s: load table [0 %llu %s %s]", mpp->alias,
-				mpp->size, TGT_MPATH, mpp->params);
+				mpp->size, TGT_MPATH, params);
 			/*
 			 * Required action is over, reset for the stateful daemon.
 			 * But don't do it for creation as we use in the caller the
@@ -407,6 +437,7 @@ domap (struct multipath * mpp)
 			if (mpp->action != ACT_CREATE)
 				mpp->action = ACT_NOTHING;
 		}
+		dm_setgeometry(mpp);
 		return DOMAP_OK;
 	}
 	return DOMAP_FAIL;
@@ -434,12 +465,41 @@ deadmap (struct multipath * mpp)
 	return 1; /* dead */
 }
 
+int check_daemon(void)
+{
+	int fd;
+	char *reply;
+	size_t len;
+	int ret = 0;
+
+	fd = ux_socket_connect(DEFAULT_SOCKET);
+	if (fd == -1)
+		return 0;
+
+	if (send_packet(fd, "show daemon", 12) != 0)
+		goto out;
+	if (recv_packet(fd, &reply, &len) != 0)
+		goto out;
+
+	if (strstr(reply, "shutdown"))
+		goto out_free;
+
+	ret = 1;
+
+out_free:
+	FREE(reply);
+out:
+	close(fd);
+	return ret;
+}
+
 extern int
 coalesce_paths (struct vectors * vecs, vector newmp, char * refwwid, int force_reload)
 {
 	int r = 1;
 	int k, i;
 	char empty_buff[WWID_SIZE];
+	char params[PARAMS_SIZE];
 	struct multipath * mpp;
 	struct path * pp1;
 	struct path * pp2;
@@ -458,16 +518,20 @@ coalesce_paths (struct vectors * vecs, vector newmp, char * refwwid, int force_r
 
 		/* 1. if path has no unique id or wwid blacklisted */
 		if (memcmp(empty_buff, pp1->wwid, WWID_SIZE) == 0 ||
-		    filter_path(conf, pp1) > 0)
+		    filter_path(conf, pp1) > 0) {
+			orphan_path(pp1);
 			continue;
+		}
 
 		/* 2. if path already coalesced */
 		if (pp1->mpp)
 			continue;
 
 		/* 3. if path has disappeared */
-		if (!pp1->size)
+		if (!pp1->size) {
+			orphan_path(pp1);
 			continue;
+		}
 
 		/* 4. path is out of scope */
 		if (refwwid && strncmp(pp1->wwid, refwwid, WWID_SIZE))
@@ -511,8 +575,9 @@ coalesce_paths (struct vectors * vecs, vector newmp, char * refwwid, int force_r
 				mpp->action = ACT_REJECT;
 		}
 		verify_paths(mpp, vecs, NULL);
-		
-		if (setup_map(mpp)) {
+
+		params[0] = '\0';
+		if (setup_map(mpp, params, PARAMS_SIZE)) {
 			remove_map(mpp, vecs, 0);
 			continue;
 		}
@@ -520,13 +585,16 @@ coalesce_paths (struct vectors * vecs, vector newmp, char * refwwid, int force_r
 		if (mpp->action == ACT_UNDEF)
 			select_action(mpp, curmp, force_reload);
 
-		r = domap(mpp);
+		r = domap(mpp, params);
 
 		if (r == DOMAP_FAIL || r == DOMAP_RETRY) {
 			condlog(3, "%s: domap (%u) failure "
 				   "for create/reload map",
 				mpp->alias, r);
 			if (r == DOMAP_FAIL) {
+				condlog(2, "%s: %s map",
+					mpp->alias, (mpp->action == ACT_CREATE)?
+					"ignoring" : "removing");
 				remove_map(mpp, vecs, 0);
 				continue;
 			} else /* if (r == DOMAP_RETRY) */
@@ -535,11 +603,29 @@ coalesce_paths (struct vectors * vecs, vector newmp, char * refwwid, int force_r
 		if (r == DOMAP_DRY)
 			continue;
 
-		if (mpp->no_path_retry != NO_PATH_RETRY_UNDEF) {
-			if (mpp->no_path_retry == NO_PATH_RETRY_FAIL)
-				dm_queue_if_no_path(mpp->alias, 0);
-			else
-				dm_queue_if_no_path(mpp->alias, 1);
+		if (!conf->daemon && !conf->allow_queueing && !check_daemon()) {
+			if (mpp->no_path_retry != NO_PATH_RETRY_UNDEF &&
+			    mpp->no_path_retry != NO_PATH_RETRY_FAIL)
+				condlog(3, "%s: multipathd not running, unset "
+					"queue_if_no_path feature", mpp->alias);
+			if (!dm_queue_if_no_path(mpp->alias, 0))
+				remove_feature(&mpp->features,
+					       "queue_if_no_path");
+		}
+		else if (mpp->no_path_retry != NO_PATH_RETRY_UNDEF) {
+			if (mpp->no_path_retry == NO_PATH_RETRY_FAIL) {
+				condlog(3, "%s: unset queue_if_no_path feature",
+					mpp->alias);
+				if (!dm_queue_if_no_path(mpp->alias, 0))
+					remove_feature(&mpp->features,
+						       "queue_if_no_path");
+			} else {
+				condlog(3, "%s: set queue_if_no_path feature",
+					mpp->alias);
+				if (!dm_queue_if_no_path(mpp->alias, 1))
+					add_feature(&mpp->features,
+						    "queue_if_no_path");
+			}
 		}
 		if (mpp->pg_timeout != PGTIMEOUT_UNDEF) {
 			if (mpp->pg_timeout == -PGTIMEOUT_NONE)
@@ -548,6 +634,9 @@ coalesce_paths (struct vectors * vecs, vector newmp, char * refwwid, int force_r
 				dm_set_pg_timeout(mpp->alias, mpp->pg_timeout);
 		}
 
+		if (!conf->daemon && mpp->action != ACT_NOTHING)
+			print_multipath_topology(mpp, conf->verbosity);
+
 		if (newmp) {
 			if (mpp->action != ACT_REJECT) {
 				if (!vector_alloc_slot(newmp))
@@ -577,44 +666,60 @@ coalesce_paths (struct vectors * vecs, vector newmp, char * refwwid, int force_r
 
 			remove_map(mpp, vecs, 0);
 
-			if (dm_flush_map(mpp->alias))
+			if (dm_flush_map(alias))
 				condlog(2, "%s: remove failed (dead)",
-					mpp->alias);
+					alias);
 			else
-				condlog(2, "%s: remove (dead)", mpp->alias);
+				condlog(2, "%s: remove (dead)", alias);
 		}
 	}
 	return 0;
 }
 
-extern char *
-get_refwwid (char * dev, enum devtypes dev_type, vector pathvec)
+/*
+ * returns:
+ * 0 - success
+ * 1 - failure
+ * 2 - blacklist
+ */
+extern int
+get_refwwid (char * dev, enum devtypes dev_type, vector pathvec, char **wwid)
 {
+	int ret = 1;
 	struct path * pp;
 	char buff[FILE_NAME_SIZE];
 	char * refwwid = NULL, tmpwwid[WWID_SIZE];
 
+	if (!wwid)
+		return 1;
+	*wwid = NULL;
+
 	if (dev_type == DEV_NONE)
-		return NULL;
+		return 1;
 
 	if (dev_type == DEV_DEVNODE) {
-		basenamecpy(dev, buff);
+		if (basenamecpy(dev, buff, FILE_NAME_SIZE) == 0) {
+			condlog(1, "basename failed for '%s' (%s)",
+				dev, buff);
+			return 1;
+		}
+
 		pp = find_path_by_dev(pathvec, buff);
-		
 		if (!pp) {
-			pp = alloc_path();
+			struct udev_device *udevice = udev_device_new_from_subsystem_sysname(conf->udev, "block", buff);
 
-			if (!pp)
-				return NULL;
-
-			strncpy(pp->dev, buff, FILE_NAME_SIZE);
-
-			if (pathinfo(pp, conf->hwtable, DI_SYSFS | DI_WWID))
-				return NULL;
-
-			if (store_path(pathvec, pp)) {
-				free_path(pp);
-				return NULL;
+			if (!udevice) {
+				condlog(2, "%s: can't get udev device", buff);
+				return 1;
+			}
+			ret = store_pathinfo(pathvec, conf->hwtable, udevice,
+					     DI_SYSFS | DI_WWID, &pp);
+			udev_device_unref(udevice);
+			if (!pp) {
+				if (ret == 1)
+					condlog(0, "%s can't store path info",
+						buff);
+				return ret;
 			}
 		}
 		refwwid = pp->wwid;
@@ -622,25 +727,23 @@ get_refwwid (char * dev, enum devtypes dev_type, vector pathvec)
 	}
 
 	if (dev_type == DEV_DEVT) {
+		strchop(dev);
 		pp = find_path_by_devt(pathvec, dev);
-		
 		if (!pp) {
-			if (devt2devname(buff, dev))
-				return NULL;
+			struct udev_device *udevice = udev_device_new_from_devnum(conf->udev, 'b', parse_devt(dev));
 
-			pp = alloc_path();
-
-			if (!pp)
-				return NULL;
-
-			strncpy(pp->dev, buff, FILE_NAME_SIZE);
-
-			if (pathinfo(pp, conf->hwtable, DI_SYSFS | DI_WWID))
-				return NULL;
-			
-			if (store_path(pathvec, pp)) {
-				free_path(pp);
-				return NULL;
+			if (!udevice) {
+				condlog(2, "%s: can't get udev device", dev);
+				return 1;
+			}
+			ret = store_pathinfo(pathvec, conf->hwtable, udevice,
+					     DI_SYSFS | DI_WWID, &pp);
+			udev_device_unref(udevice);
+			if (!pp) {
+				if (ret == 1)
+					condlog(0, "%s can't store path info",
+						buff);
+				return ret;
 			}
 		}
 		refwwid = pp->wwid;
@@ -650,17 +753,17 @@ get_refwwid (char * dev, enum devtypes dev_type, vector pathvec)
 
 		if (((dm_get_uuid(dev, tmpwwid)) == 0) && (strlen(tmpwwid))) {
 			refwwid = tmpwwid;
-			goto out;
+			goto check;
 		}
 
 		/*
 		 * may be a binding
 		 */
-		refwwid = get_user_friendly_wwid(dev,
-						 conf->bindings_file);
-
-		if (refwwid)
-			return refwwid;
+		if (get_user_friendly_wwid(dev, tmpwwid,
+					   conf->bindings_file) == 0) {
+			refwwid = tmpwwid;
+			goto check;
+		}
 
 		/*
 		 * or may be an alias
@@ -672,11 +775,58 @@ get_refwwid (char * dev, enum devtypes dev_type, vector pathvec)
 		 */
 		if (!refwwid)
 			refwwid = dev;
+
+check:
+		if (refwwid && strlen(refwwid)) {
+			if (filter_wwid(conf->blist_wwid, conf->elist_wwid,
+					refwwid) > 0)
+			return 2;
+		}
 	}
 out:
-	if (refwwid && strlen(refwwid))
-		return STRDUP(refwwid);
+	if (refwwid && strlen(refwwid)) {
+		*wwid = STRDUP(refwwid);
+		return 0;
+	}
 
-	return NULL;
+	return 1;
 }
 
+extern int reload_map(struct vectors *vecs, struct multipath *mpp, int refresh)
+{
+	char params[PARAMS_SIZE] = {0};
+	struct path *pp;
+	int i, r;
+
+	update_mpp_paths(mpp, vecs->pathvec);
+	if (refresh) {
+		vector_foreach_slot (mpp->paths, pp, i)
+			pathinfo(pp, conf->hwtable, DI_PRIO);
+	}
+	if (setup_map(mpp, params, PARAMS_SIZE)) {
+		condlog(0, "%s: failed to setup map", mpp->alias);
+		return 1;
+	}
+	select_action(mpp, vecs->mpvec, 1);
+
+	r = domap(mpp, params);
+	if (r == DOMAP_FAIL || r == DOMAP_RETRY) {
+		condlog(3, "%s: domap (%u) failure "
+			"for reload map", mpp->alias, r);
+		return 1;
+	}
+	if (mpp->no_path_retry != NO_PATH_RETRY_UNDEF) {
+		if (mpp->no_path_retry == NO_PATH_RETRY_FAIL)
+			dm_queue_if_no_path(mpp->alias, 0);
+		else
+			dm_queue_if_no_path(mpp->alias, 1);
+	}
+	if (mpp->pg_timeout != PGTIMEOUT_UNDEF) {
+		if (mpp->pg_timeout == -PGTIMEOUT_NONE)
+			dm_set_pg_timeout(mpp->alias,  0);
+		else
+			dm_set_pg_timeout(mpp->alias, mpp->pg_timeout);
+	}
+
+	return 0;
+}
diff --git a/libmultipath/configure.h b/libmultipath/configure.h
index 25891ba..650f080 100644
--- a/libmultipath/configure.h
+++ b/libmultipath/configure.h
@@ -23,9 +23,10 @@ enum actions {
 #define FLUSH_ONE 1
 #define FLUSH_ALL 2
 
-int setup_map (struct multipath * mpp);
-int domap (struct multipath * mpp);
+int setup_map (struct multipath * mpp, char * params, int params_size );
+int domap (struct multipath * mpp, char * params);
 int reinstate_paths (struct multipath *mpp);
 int coalesce_paths (struct vectors *vecs, vector curmp, char * refwwid, int force_reload);
-char * get_refwwid (char * dev, enum devtypes dev_type, vector pathvec);
+int get_refwwid (char * dev, enum devtypes dev_type, vector pathvec, char **wwid);
+int reload_map(struct vectors *vecs, struct multipath *mpp, int refresh);
 
diff --git a/libmultipath/defaults.h b/libmultipath/defaults.h
index 5a38d25..b83d9fb 100644
--- a/libmultipath/defaults.h
+++ b/libmultipath/defaults.h
@@ -1,10 +1,12 @@
-#define DEFAULT_GETUID		"/lib/udev/scsi_id --whitelisted --device=/dev/%n"
+#define DEFAULT_UID_ATTRIBUTE	"ID_SERIAL"
 #define DEFAULT_UDEVDIR		"/dev"
 #define DEFAULT_MULTIPATHDIR	"/" LIB_STRING "/multipath"
-#define DEFAULT_SELECTOR	"round-robin 0"
+#define DEFAULT_SELECTOR	"service-time 0"
+#define DEFAULT_ALIAS_PREFIX	"mpath"
 #define DEFAULT_FEATURES	"0"
 #define DEFAULT_HWHANDLER	"0"
 #define DEFAULT_MINIO		1000
+#define DEFAULT_MINIO_RQ	1
 #define DEFAULT_PGPOLICY       FAILOVER
 #define DEFAULT_FAILBACK       -FAILBACK_MANUAL
 #define DEFAULT_RR_WEIGHT      RR_WEIGHT_NONE
@@ -12,13 +14,19 @@
 #define DEFAULT_PGTIMEOUT      -PGTIMEOUT_NONE
 #define DEFAULT_USER_FRIENDLY_NAMES    0
 #define DEFAULT_VERBOSITY	2
+#define DEFAULT_REASSIGN_MAPS	1
+#define DEFAULT_FAST_IO_FAIL	5
+#define DEFAULT_RETAIN_HWHANDLER RETAIN_HWHANDLER_OFF
+#define DEFAULT_DETECT_PRIO DETECT_PRIO_OFF
 
 #define DEFAULT_CHECKINT	5
 #define MAX_CHECKINT(a)		(a << 2)
 
+#define MAX_DEV_LOSS_TMO	0x7FFFFFFF
 #define DEFAULT_PIDFILE		"/var/run/multipathd.pid"
-#define DEFAULT_SOCKET		"/var/run/multipathd.sock"
+#define DEFAULT_SOCKET		"/org/kernel/linux/storage/multipathd"
 #define DEFAULT_CONFIGFILE	"/etc/multipath.conf"
 #define DEFAULT_BINDINGS_FILE	"/etc/multipath/bindings"
+#define DEFAULT_WWIDS_FILE	"/etc/multipath/wwids"
 
 char * set_default (char * str);
diff --git a/libmultipath/devmapper.c b/libmultipath/devmapper.c
index 333659b..67481c4 100644
--- a/libmultipath/devmapper.c
+++ b/libmultipath/devmapper.c
@@ -20,6 +20,7 @@
 #include "memory.h"
 #include "devmapper.h"
 #include "config.h"
+#include "sysfs.h"
 
 #include "log_pthread.h"
 #include <sys/types.h>
@@ -31,6 +32,31 @@
 #define UUID_PREFIX "mpath-"
 #define UUID_PREFIX_LEN 6
 
+#ifndef LIBDM_API_COOKIE
+static inline int dm_task_set_cookie(struct dm_task *dmt, uint32_t *c, int a)
+{
+	return 1;
+}
+
+void udev_wait(unsigned int c)
+{
+}
+
+void udev_set_sync_support(int c)
+{
+}
+#else
+void udev_wait(unsigned int c)
+{
+	dm_udev_wait(c);
+}
+
+void udev_set_sync_support(int c)
+{
+	dm_udev_set_sync_support(c);
+}
+#endif
+
 static void
 dm_write_log (int level, const char *file, int line, const char *f, ...)
 {
@@ -73,37 +99,42 @@ dm_init(void) {
 }
 
 static int
-dm_libprereq (void)
+dm_lib_prereq (void)
 {
 	char version[64];
 	int v[3];
+#ifdef LIBDM_API_COOKIE
 	int minv[3] = {1, 2, 38};
+#else
+	int minv[3] = {1, 2, 8};
+#endif
 
 	dm_get_library_version(version, sizeof(version));
 	condlog(3, "libdevmapper version %s", version);
 	sscanf(version, "%d.%d.%d ", &v[0], &v[1], &v[2]);
 
-	if ((v[0] > minv[0]) ||
-	    ((v[0] ==  minv[0]) && (v[1] > minv[1])) ||
-	    ((v[0] == minv[0]) && (v[1] == minv[1]) && (v[2] >= minv[2])))
+	if VERSION_GE(v, minv)
 		return 0;
 	condlog(0, "libdevmapper version must be >= %d.%.2d.%.2d",
 		minv[0], minv[1], minv[2]);
 	return 1;
 }
 
-static int
-dm_drvprereq (char * str)
+int
+dm_drv_version (unsigned int * version, char * str)
 {
 	int r = 2;
 	struct dm_task *dmt;
 	struct dm_versions *target;
 	struct dm_versions *last_target;
-	int minv[3] = {1, 0, 3};
 	unsigned int *v;
 
+	version[0] = 0;
+	version[1] = 0;
+	version[2] = 0;
+
 	if (!(dmt = dm_task_create(DM_DEVICE_LIST_VERSIONS)))
-		return 3;
+		return 1;
 
 	dm_task_no_open_count(dmt);
 
@@ -123,29 +154,49 @@ dm_drvprereq (char * str)
 	} while (last_target != target);
 
 	if (r == 2) {
-		condlog(0, "DM multipath kernel driver not loaded");
+		condlog(0, "DM %s kernel driver not loaded", str);
 		goto out;
 	}
 	v = target->version;
-	if ((v[0] > minv[0]) ||
-	    ((v[0] == minv[0]) && (v[1] > minv[1])) ||
-	    ((v[0] == minv[0]) && (v[1] == minv[1]) && (v[2] >= minv[2]))) {
-		r = 0;
-		goto out;
-	}
-	condlog(0, "DM multipath kernel driver must be >= %u.%.2u.%.2u",
-		minv[0], minv[1], minv[2]);
+        version[0] = v[0];
+        version[1] = v[1];
+        version[2] = v[2];
+	r = 0;
 out:
 	dm_task_destroy(dmt);
 	return r;
 }
 
+static int
+dm_drv_prereq (void)
+{
+	unsigned int minv[3] = {1, 0, 3};
+	unsigned int version[3] = {0, 0, 0};
+        unsigned int * v = version;
+
+	if (dm_drv_version(v, TGT_MPATH)) {
+		/* in doubt return not capable */
+		return 1;
+	}
+
+	/* test request based multipath capability */
+	condlog(3, "DM multipath kernel driver v%u.%u.%u",
+		v[0], v[1], v[2]);
+
+	if VERSION_GE(v, minv)
+		return 0;
+
+	condlog(0, "DM multipath kernel driver must be >= v%u.%u.%u",
+		minv[0], minv[1], minv[2]);
+	return 1;
+}
+
 extern int
 dm_prereq (void)
 {
-	if (dm_libprereq())
+	if (dm_lib_prereq())
 		return 1;
-	return dm_drvprereq(TGT_MPATH);
+	return dm_drv_prereq();
 }
 
 static int
@@ -168,7 +219,7 @@ dm_simplecmd (int task, const char *name, int no_flush, int need_sync) {
 		dm_task_no_flush(dmt);		/* for DM_DEVICE_SUSPEND/RESUME */
 #endif
 
-	if (udev_wait_flag && !dm_task_set_cookie(dmt, &conf->cookie, 0))
+	if (udev_wait_flag && !dm_task_set_cookie(dmt, &conf->cookie, (conf->daemon)? DM_UDEV_DISABLE_LIBRARY_FALLBACK : 0))
 		goto out;
 	r = dm_task_run (dmt);
 
@@ -188,8 +239,8 @@ dm_simplecmd_noflush (int task, const char *name) {
 }
 
 extern int
-dm_addmap (int task, const char *target, struct multipath *mpp, int use_uuid,
-	   int ro) {
+dm_addmap (int task, const char *target, struct multipath *mpp, char * params,
+	   int use_uuid, int ro) {
 	int r = 0;
 	struct dm_task *dmt;
 	char *prefixed_uuid = NULL;
@@ -200,16 +251,16 @@ dm_addmap (int task, const char *target, struct multipath *mpp, int use_uuid,
 	if (!dm_task_set_name (dmt, mpp->alias))
 		goto addout;
 
-	if (!dm_task_add_target (dmt, 0, mpp->size, target, mpp->params))
+	if (!dm_task_add_target (dmt, 0, mpp->size, target, params))
 		goto addout;
 
 	if (ro)
 		dm_task_set_ro(dmt);
 
-	if (use_uuid && mpp->wwid){
+	if (use_uuid && strlen(mpp->wwid) > 0){
 		prefixed_uuid = MALLOC(UUID_PREFIX_LEN + strlen(mpp->wwid) + 1);
 		if (!prefixed_uuid) {
-			condlog(0, "cannot create prefixed uuid : %s\n",
+			condlog(0, "cannot create prefixed uuid : %s",
 				strerror(errno));
 			goto addout;
 		}
@@ -227,11 +278,13 @@ dm_addmap (int task, const char *target, struct multipath *mpp, int use_uuid,
 	if (mpp->attribute_flags & (1 << ATTR_GID) &&
 	    !dm_task_set_gid(dmt, mpp->gid))
 		goto freeout;
+	condlog(4, "%s: addmap [0 %llu %s %s]", mpp->alias, mpp->size,
+		target, params);
 
 	dm_task_no_open_count(dmt);
 
 	if (task == DM_DEVICE_CREATE &&
-	    !dm_task_set_cookie(dmt, &conf->cookie, 0))
+	    !dm_task_set_cookie(dmt, &conf->cookie, (conf->daemon)? DM_UDEV_DISABLE_LIBRARY_FALLBACK : 0))
 		goto freeout;
 	r = dm_task_run (dmt);
 
@@ -246,9 +299,9 @@ dm_addmap (int task, const char *target, struct multipath *mpp, int use_uuid,
 }
 
 static int
-_dm_addmap_create (struct multipath *mpp, int ro) {
+_dm_addmap_create (struct multipath *mpp, char * params, int ro) {
 	int r;
-	r = dm_addmap(DM_DEVICE_CREATE, TGT_MPATH, mpp, 1, ro);
+	r = dm_addmap(DM_DEVICE_CREATE, TGT_MPATH, mpp, params, 1, ro);
 	/*
 	 * DM_DEVICE_CREATE is actually DM_DEV_CREATE + DM_TABLE_LOAD.
 	 * Failing the second part leaves an empty map. Clean it up.
@@ -265,23 +318,23 @@ _dm_addmap_create (struct multipath *mpp, int ro) {
 #define ADDMAP_RO 1
 
 extern int
-dm_addmap_create (struct multipath *mpp) {
-	return _dm_addmap_create(mpp, ADDMAP_RW);
+dm_addmap_create (struct multipath *mpp, char *params) {
+	return _dm_addmap_create(mpp, params, ADDMAP_RW);
 }
 
 extern int
-dm_addmap_create_ro (struct multipath *mpp) {
-	return _dm_addmap_create(mpp, ADDMAP_RO);
+dm_addmap_create_ro (struct multipath *mpp, char *params) {
+	return _dm_addmap_create(mpp, params, ADDMAP_RO);
 }
 
 extern int
-dm_addmap_reload (struct multipath *mpp) {
-	return dm_addmap(DM_DEVICE_RELOAD, TGT_MPATH, mpp, 0, ADDMAP_RW);
+dm_addmap_reload (struct multipath *mpp, char *params) {
+	return dm_addmap(DM_DEVICE_RELOAD, TGT_MPATH, mpp, params, 0, ADDMAP_RW);
 }
 
 extern int
-dm_addmap_reload_ro (struct multipath *mpp) {
-	return dm_addmap(DM_DEVICE_RELOAD, TGT_MPATH, mpp, 0, ADDMAP_RO);
+dm_addmap_reload_ro (struct multipath *mpp, char *params) {
+	return dm_addmap(DM_DEVICE_RELOAD, TGT_MPATH, mpp, params, 0, ADDMAP_RO);
 }
 
 extern int
@@ -340,6 +393,10 @@ dm_get_map(char * name, unsigned long long * size, char * outparams)
 	if (size)
 		*size = length;
 
+	if (!outparams) {
+		r = 0;
+		goto out;
+	}
 	if (snprintf(outparams, PARAMS_SIZE, "%s", params) <= PARAMS_SIZE)
 		r = 0;
 out:
@@ -347,8 +404,8 @@ out:
 	return r;
 }
 
-extern int
-dm_get_uuid(char *name, char *uuid)
+static int
+dm_get_prefixed_uuid(const char *name, char *uuid)
 {
 	struct dm_task *dmt;
 	const char *uuidtmp;
@@ -365,12 +422,8 @@ dm_get_uuid(char *name, char *uuid)
 		goto uuidout;
 
 	uuidtmp = dm_task_get_uuid(dmt);
-	if (uuidtmp) {
-		if (!strncmp(uuidtmp, UUID_PREFIX, UUID_PREFIX_LEN))
-			strcpy(uuid, uuidtmp + UUID_PREFIX_LEN);
-		else
-			strcpy(uuid, uuidtmp);
-	}
+	if (uuidtmp)
+		strcpy(uuid, uuidtmp);
 	else
 		uuid[0] = '\0';
 
@@ -381,6 +434,47 @@ uuidout:
 }
 
 extern int
+dm_get_uuid(char *name, char *uuid)
+{
+	char uuidtmp[WWID_SIZE];
+
+	if (dm_get_prefixed_uuid(name, uuidtmp))
+		return 1;
+
+	if (!strncmp(uuidtmp, UUID_PREFIX, UUID_PREFIX_LEN))
+		strcpy(uuid, uuidtmp + UUID_PREFIX_LEN);
+	else
+		strcpy(uuid, uuidtmp);
+
+	return 0;
+}
+
+/*
+ * returns:
+ *    0 : if both uuids end with same suffix which starts with UUID_PREFIX
+ *    1 : otherwise
+ */
+int
+dm_compare_uuid(const char* mapname1, const char* mapname2)
+{
+	char *p1, *p2;
+	char uuid1[WWID_SIZE], uuid2[WWID_SIZE];
+
+	if (dm_get_prefixed_uuid(mapname1, uuid1))
+		return 1;
+
+	if (dm_get_prefixed_uuid(mapname2, uuid2))
+		return 1;
+
+	p1 = strstr(uuid1, UUID_PREFIX);
+	p2 = strstr(uuid2, UUID_PREFIX);
+	if (p1 && p2 && !strcmp(p1, p2))
+		return 0;
+
+	return 1;
+}
+
+extern int
 dm_get_status(char * name, char * outstatus)
 {
 	int r = 1;
@@ -511,6 +605,31 @@ out:
 }
 
 int
+dm_get_major (char * mapname)
+{
+	int r = -1;
+	struct dm_task *dmt;
+	struct dm_info info;
+
+	if (!(dmt = dm_task_create(DM_DEVICE_INFO)))
+		return 0;
+
+	if (!dm_task_set_name(dmt, mapname))
+		goto out;
+
+	if (!dm_task_run(dmt))
+		goto out;
+
+	if (!dm_task_get_info(dmt, &info))
+		goto out;
+
+	r = info.major;
+out:
+	dm_task_destroy(dmt);
+	return r;
+}
+
+int
 dm_get_minor (char * mapname)
 {
 	int r = -1;
@@ -564,6 +683,30 @@ _dm_flush_map (const char * mapname, int need_sync)
 }
 
 extern int
+dm_suspend_and_flush_map (const char * mapname)
+{
+	int s;
+
+	if (!dm_map_present(mapname))
+		return 0;
+
+	if (dm_type(mapname, TGT_MPATH) <= 0)
+		return 0; /* nothing to do */
+
+	s = dm_queue_if_no_path((char *)mapname, 0);
+	if (!s)
+		s = dm_simplecmd_flush(DM_DEVICE_SUSPEND, mapname, 0);
+
+	if (!dm_flush_map(mapname)) {
+		condlog(4, "multipath map %s removed", mapname);
+		return 0;
+	}
+	condlog(2, "failed to remove multipath map %s", mapname);
+	dm_simplecmd_noflush(DM_DEVICE_RESUME, mapname);
+	return 1;
+}
+
+extern int
 dm_flush_maps (void)
 {
 	int r = 0;
@@ -586,7 +729,7 @@ dm_flush_maps (void)
 		goto out;
 
 	do {
-		r |= dm_flush_map(names->name);
+		r |= dm_suspend_and_flush_map(names->name);
 		next = names->next;
 		names = (void *) names + next;
 	} while (next);
@@ -633,7 +776,7 @@ dm_fail_path(char * mapname, char * path)
 {
 	char message[32];
 
-	if (snprintf(message, 32, "fail_path %s\n", path) > 32)
+	if (snprintf(message, 32, "fail_path %s", path) > 32)
 		return 1;
 
 	return dm_message(mapname, message);
@@ -644,7 +787,7 @@ dm_reinstate_path(char * mapname, char * path)
 {
 	char message[32];
 
-	if (snprintf(message, 32, "reinstate_path %s\n", path) > 32)
+	if (snprintf(message, 32, "reinstate_path %s", path) > 32)
 		return 1;
 
 	return dm_message(mapname, message);
@@ -656,9 +799,9 @@ dm_queue_if_no_path(char *mapname, int enable)
 	char *message;
 
 	if (enable)
-		message = "queue_if_no_path\n";
+		message = "queue_if_no_path";
 	else
-		message = "fail_if_no_path\n";
+		message = "fail_if_no_path";
 
 	return dm_message(mapname, message);
 }
@@ -678,7 +821,7 @@ dm_groupmsg (char * msg, char * mapname, int index)
 {
 	char message[32];
 
-	if (snprintf(message, 32, "%s_group %i\n", msg, index) > 32)
+	if (snprintf(message, 32, "%s_group %i", msg, index) > 32)
 		return 1;
 
 	return dm_message(mapname, message);
@@ -748,10 +891,7 @@ dm_get_maps (vector mp)
 			goto out1;
 
 		if (info > 0) {
-			if (dm_get_map(names->name, &mpp->size, mpp->params))
-				goto out1;
-
-			if (dm_get_status(names->name, mpp->status))
+			if (dm_get_map(names->name, &mpp->size, NULL))
 				goto out1;
 
 			dm_get_uuid(names->name, mpp->wwid);
@@ -777,35 +917,49 @@ out:
 	return r;
 }
 
-extern int
-dm_get_name(char *uuid, char *name)
+extern char *
+dm_get_name(char *uuid)
 {
-	vector vec;
-	struct multipath *mpp;
-	int i, rc = 0;
-
-	vec = vector_alloc();
+	struct dm_task *dmt;
+	struct dm_info info;
+	char *prefixed_uuid, *name = NULL;
+	const char *nametmp;
 
-	if (!vec)
-		return 0;
+	dmt = dm_task_create(DM_DEVICE_INFO);
+	if (!dmt)
+		return NULL;
 
-	if (dm_get_maps(vec)) {
-		goto out;
+	prefixed_uuid = MALLOC(UUID_PREFIX_LEN + strlen(uuid) + 1);
+	if (!prefixed_uuid) {
+		condlog(0, "cannot create prefixed uuid : %s",
+			strerror(errno));
+		goto freeout;
 	}
+	sprintf(prefixed_uuid, UUID_PREFIX "%s", uuid);
+	if (!dm_task_set_uuid(dmt, prefixed_uuid))
+		goto freeout;
 
-	vector_foreach_slot(vec, mpp, i) {
-		if (!strcmp(uuid, mpp->wwid)) {
-			strcpy(name, mpp->alias);
-			rc=1;
-			break;
-		}
-	}
-out:
-	vector_foreach_slot(vec, mpp, i) {
-		free_multipath(mpp, KEEP_PATHS);
+	if (!dm_task_run(dmt))
+		goto freeout;
+
+	if (!dm_task_get_info(dmt, &info) || !info.exists)
+		goto freeout;
+
+	nametmp = dm_task_get_name(dmt);
+	if (nametmp && strlen(nametmp)) {
+		name = MALLOC(strlen(nametmp) + 1);
+		if (name)
+			strcpy(name, nametmp);
+	} else {
+		condlog(2, "%s: no device-mapper name found", uuid);
 	}
-	vector_free(vec);
-	return rc;
+
+freeout:
+	if (prefixed_uuid)
+		FREE(prefixed_uuid);
+	dm_task_destroy(dmt);
+
+	return name;
 }
 
 int
@@ -813,9 +967,10 @@ dm_geteventnr (char *name)
 {
 	struct dm_task *dmt;
 	struct dm_info info;
+	int event = -1;
 
 	if (!(dmt = dm_task_create(DM_DEVICE_INFO)))
-		return 0;
+		return -1;
 
 	if (!dm_task_set_name(dmt, name))
 		goto out;
@@ -825,20 +980,16 @@ dm_geteventnr (char *name)
 	if (!dm_task_run(dmt))
 		goto out;
 
-	if (!dm_task_get_info(dmt, &info)) {
-		info.event_nr = 0;
+	if (!dm_task_get_info(dmt, &info))
 		goto out;
-	}
 
-	if (!info.exists) {
-		info.event_nr = 0;
-		goto out;
-	}
+	if (info.exists)
+		event = info.event_nr;
 
 out:
 	dm_task_destroy(dmt);
 
-	return info.event_nr;
+	return event;
 }
 
 char *
@@ -927,15 +1078,10 @@ dm_remove_partmaps (const char * mapname, int need_sync)
 		    (dm_type(names->name, TGT_PART) > 0) &&
 
 		    /*
-		     * and the multipath mapname and the part mapname start
-		     * the same
-		     */
-		    !strncmp(names->name, mapname, strlen(mapname)) &&
-
-		    /*
-		     * and the opencount is 0 for us to allow removal
+		     * and both uuid end with same suffix starting
+		     * at UUID_PREFIX
 		     */
-		    !dm_get_opencount(names->name) &&
+		    (!dm_compare_uuid(names->name, mapname)) &&
 
 		    /*
 		     * and we can fetch the map table from the kernel
@@ -947,14 +1093,27 @@ dm_remove_partmaps (const char * mapname, int need_sync)
 		     */
 		    strstr(params, dev_t)
 		   ) {
-				/*
-				 * then it's a kpartx generated partition.
-				 * remove it.
-				 */
-				condlog(4, "partition map %s removed",
-					names->name);
-				dm_simplecmd_flush(DM_DEVICE_REMOVE, names->name, need_sync);
-		   }
+			/*
+			 * then it's a kpartx generated partition.
+			 * remove it.
+			 */
+			/*
+			 * if the opencount is 0 maybe some other
+			 * partitions depend on it.
+			 */
+			if (dm_get_opencount(names->name)) {
+				dm_remove_partmaps(names->name, need_sync);
+				if (dm_get_opencount(names->name)) {
+					condlog(2, "%s: map in use",
+						names->name);
+					goto out;
+				}
+			}
+			condlog(4, "partition map %s removed",
+				names->name);
+			dm_simplecmd_flush(DM_DEVICE_REMOVE, names->name,
+					   need_sync);
+		}
 
 		next = names->next;
 		names = (void *) names + next;
@@ -1109,13 +1268,188 @@ dm_rename (char * old, char * new)
 
 	dm_task_no_open_count(dmt);
 
-	if (!dm_task_set_cookie(dmt, &conf->cookie, 0))
+	if (!dm_task_set_cookie(dmt, &conf->cookie, (conf->daemon)? DM_UDEV_DISABLE_LIBRARY_FALLBACK : 0))
+		goto out;
+	if (!dm_task_run(dmt))
+		goto out;
+
+	r = 1;
+out:
+	dm_task_destroy(dmt);
+	return r;
+}
+
+void dm_reassign_deps(char *table, char *dep, char *newdep)
+{
+	char *p, *n;
+	char newtable[PARAMS_SIZE];
+
+	strcpy(newtable, table);
+	p = strstr(newtable, dep);
+	n = table + (p - newtable);
+	strcpy(n, newdep);
+	n += strlen(newdep);
+	p += strlen(dep);
+	strcat(n, p);
+}
+
+int dm_reassign_table(const char *name, char *old, char *new)
+{
+	int r, modified = 0;
+	uint64_t start, length;
+	struct dm_task *dmt, *reload_dmt;
+	char *target, *params = NULL;
+	char buff[PARAMS_SIZE];
+	void *next = NULL;
+
+	if (!(dmt = dm_task_create(DM_DEVICE_TABLE)))
+		return 0;
+
+	if (!dm_task_set_name(dmt, name))
+		goto out;
+
+	dm_task_no_open_count(dmt);
+
+	if (!dm_task_run(dmt))
+		goto out;
+	if (!(reload_dmt = dm_task_create(DM_DEVICE_RELOAD)))
+		goto out;
+	if (!dm_task_set_name(reload_dmt, name))
+		goto out_reload;
+
+	do {
+		next = dm_get_next_target(dmt, next, &start, &length,
+					  &target, &params);
+		memset(buff, 0, PARAMS_SIZE);
+		strcpy(buff, params);
+		if (strcmp(target, TGT_MPATH) && strstr(params, old)) {
+			condlog(3, "%s: replace target %s %s",
+				name, target, buff);
+			dm_reassign_deps(buff, old, new);
+			condlog(3, "%s: with target %s %s",
+				name, target, buff);
+			modified++;
+		}
+		dm_task_add_target(reload_dmt, start, length, target, buff);
+	} while (next);
+
+	if (modified) {
+		dm_task_no_open_count(reload_dmt);
+
+		if (!dm_task_run(reload_dmt)) {
+			condlog(3, "%s: failed to reassign targets", name);
+			goto out_reload;
+		}
+		dm_simplecmd_noflush(DM_DEVICE_RESUME, name);
+	}
+	r = 1;
+
+out_reload:
+	dm_task_destroy(reload_dmt);
+out:
+	dm_task_destroy(dmt);
+	return r;
+}
+
+
+/*
+ * Reassign existing device-mapper table(s) to not use
+ * the block devices but point to the multipathed
+ * device instead
+ */
+int dm_reassign(const char *mapname)
+{
+	struct dm_deps *deps;
+	struct dm_task *dmt;
+	struct dm_info info;
+	char dev_t[32], dm_dep[32];
+	int r = 0, i;
+
+	if (dm_dev_t(mapname, &dev_t[0], 32)) {
+		condlog(3, "%s: failed to get device number", mapname);
+		return 1;
+	}
+
+	if (!(dmt = dm_task_create(DM_DEVICE_DEPS))) {
+		condlog(3, "%s: couldn't make dm task", mapname);
+		return 0;
+	}
+
+	if (!dm_task_set_name(dmt, mapname))
 		goto out;
+
+	dm_task_no_open_count(dmt);
+
 	if (!dm_task_run(dmt))
 		goto out;
 
+	if (!dm_task_get_info(dmt, &info))
+		goto out;
+
+	if (!(deps = dm_task_get_deps(dmt)))
+		goto out;
+
+	if (!info.exists)
+		goto out;
+
+	for (i = 0; i < deps->count; i++) {
+		sprintf(dm_dep, "%d:%d",
+			major(deps->device[i]),
+			minor(deps->device[i]));
+		sysfs_check_holders(dm_dep, dev_t);
+	}
+
+	dm_task_destroy (dmt);
+
 	r = 1;
 out:
+	return r;
+}
+
+int dm_setgeometry(struct multipath *mpp)
+{
+	struct dm_task *dmt;
+	struct path *pp;
+	char heads[4], sectors[4];
+	char cylinders[10], start[32];
+	int r = 0;
+
+	if (!mpp)
+		return 1;
+
+	pp = first_path(mpp);
+	if (!pp) {
+		condlog(3, "%s: no path for geometry", mpp->alias);
+		return 1;
+	}
+	if (pp->geom.cylinders == 0 ||
+	    pp->geom.heads == 0 ||
+	    pp->geom.sectors == 0) {
+		condlog(3, "%s: invalid geometry on %s", mpp->alias, pp->dev);
+		return 1;
+	}
+
+	if (!(dmt = dm_task_create(DM_DEVICE_SET_GEOMETRY)))
+		return 0;
+
+	if (!dm_task_set_name(dmt, mpp->alias))
+		goto out;
+
+	dm_task_no_open_count(dmt);
+
+	/* What a sick interface ... */
+	snprintf(heads, 4, "%u", pp->geom.heads);
+	snprintf(sectors, 4, "%u", pp->geom.sectors);
+	snprintf(cylinders, 10, "%u", pp->geom.cylinders);
+	snprintf(start, 32, "%lu", pp->geom.start);
+	if (!dm_task_set_geometry(dmt, cylinders, heads, sectors, start)) {
+		condlog(3, "%s: Failed to set geometry", mpp->alias);
+		goto out;
+	}
+
+	r = dm_task_run(dmt);
+out:
 	dm_task_destroy(dmt);
+
 	return r;
 }
diff --git a/libmultipath/devmapper.h b/libmultipath/devmapper.h
index f3ffeaa..bf8ee91 100644
--- a/libmultipath/devmapper.h
+++ b/libmultipath/devmapper.h
@@ -8,12 +8,13 @@
 
 void dm_init(void);
 int dm_prereq (void);
+int dm_drv_version (unsigned int * version, char * str);
 int dm_simplecmd_flush (int, const char *, int);
 int dm_simplecmd_noflush (int, const char *);
-int dm_addmap_create (struct multipath *mpp);
-int dm_addmap_create_ro (struct multipath *mpp);
-int dm_addmap_reload (struct multipath *mpp);
-int dm_addmap_reload_ro (struct multipath *mpp);
+int dm_addmap_create (struct multipath *mpp, char *params);
+int dm_addmap_create_ro (struct multipath *mpp, char *params);
+int dm_addmap_reload (struct multipath *mpp, char *params);
+int dm_addmap_reload_ro (struct multipath *mpp, char *params);
 int dm_map_present (const char *);
 int dm_get_map(char *, unsigned long long *, char *);
 int dm_get_status(char *, char *);
@@ -21,6 +22,7 @@ int dm_type(const char *, char *);
 int _dm_flush_map (const char *, int);
 #define dm_flush_map(mapname) _dm_flush_map(mapname, 1)
 #define dm_flush_map_nosync(mapname) _dm_flush_map(mapname, 0)
+int dm_suspend_and_flush_map(const char * mapname);
 int dm_flush_maps (void);
 int dm_fail_path(char * mapname, char * path);
 int dm_reinstate_path(char * mapname, char * path);
@@ -31,12 +33,24 @@ int dm_enablegroup(char * mapname, int index);
 int dm_disablegroup(char * mapname, int index);
 int dm_get_maps (vector mp);
 int dm_geteventnr (char *name);
+int dm_get_major (char *name);
 int dm_get_minor (char *name);
 char * dm_mapname(int major, int minor);
 int dm_remove_partmaps (const char * mapname, int need_sync);
 int dm_get_uuid(char *name, char *uuid);
 int dm_get_info (char * mapname, struct dm_info ** dmi);
 int dm_rename (char * old, char * new);
-int dm_get_name(char * uuid, char * name);
+char * dm_get_name(char * uuid);
+int dm_reassign(const char * mapname);
+int dm_reassign_table(const char *name, char *old, char *new);
+int dm_setgeometry(struct multipath *mpp);
+void udev_wait(unsigned int c);
+void udev_set_sync_support(int c);
+
+#define VERSION_GE(v, minv) ( \
+ (v[0] > minv[0]) || \
+ ((v[0] == minv[0]) && (v[1] > minv[1])) || \
+ ((v[0] == minv[0]) && (v[1] == minv[1]) && (v[2] >= minv[2])) \
+)
 
 #endif /* _DEVMAPPER_H */
diff --git a/libmultipath/dict.c b/libmultipath/dict.c
index 02aa238..14e7c57 100644
--- a/libmultipath/dict.c
+++ b/libmultipath/dict.c
@@ -6,7 +6,7 @@
  */
 #include <sys/types.h>
 #include <pwd.h>
-
+#include <string.h>
 #include "checkers.h"
 #include "vector.h"
 #include "hwtable.h"
@@ -20,6 +20,7 @@
 #include "defaults.h"
 #include "prio.h"
 #include "errno.h"
+#include <inttypes.h>
 
 /*
  * default block handlers
@@ -43,10 +44,12 @@ def_fast_io_fail_handler(vector strvec)
 
 	buff = set_value(strvec);
 	if (strlen(buff) == 3 && !strcmp(buff, "off"))
-		conf->fast_io_fail = -1;
+		conf->fast_io_fail = MP_FAST_IO_FAIL_OFF;
 	else if (sscanf(buff, "%d", &conf->fast_io_fail) != 1 ||
-		 conf->fast_io_fail < -1)
-		conf->fast_io_fail = 0;
+		 conf->fast_io_fail < MP_FAST_IO_FAIL_ZERO)
+		conf->fast_io_fail = MP_FAST_IO_FAIL_UNSET;
+	else if (conf->fast_io_fail == 0)
+		conf->fast_io_fail = MP_FAST_IO_FAIL_ZERO;
 
 	FREE(buff);
 	return 0;
@@ -58,7 +61,12 @@ def_dev_loss_handler(vector strvec)
 	char * buff;
 
 	buff = set_value(strvec);
-	if (sscanf(buff, "%u", &conf->dev_loss) != 1)
+	if (!buff)
+		return 1;
+
+	if (strlen(buff) == 8 && !strcmp(buff, "infinity"))
+		conf->dev_loss = MAX_DEV_LOSS_TMO;
+	else if (sscanf(buff, "%u", &conf->dev_loss) != 1)
 		conf->dev_loss = 0;
 
 	FREE(buff);
@@ -77,11 +85,27 @@ verbosity_handler(vector strvec)
 }
 
 static int
-udev_dir_handler(vector strvec)
+max_polling_interval_handler(vector strvec)
+{
+	char *buff;
+
+	buff = VECTOR_SLOT(strvec, 1);
+	conf->max_checkint = atoi(buff);
+
+	return 0;
+}
+
+static int
+reassign_maps_handler(vector strvec)
 {
-	conf->udev_dir = set_value(strvec);
+	char * buff;
 
-	if (!conf->udev_dir)
+	buff = set_value(strvec);
+	if (!strcmp(buff, "yes"))
+		conf->reassign_maps = 1;
+	else if (!strcmp(buff, "no"))
+		conf->reassign_maps = 0;
+	else
 		return 1;
 
 	return 0;
@@ -126,11 +150,11 @@ def_pgpolicy_handler(vector strvec)
 }
 
 static int
-def_getuid_callout_handler(vector strvec)
+def_uid_attribute_handler(vector strvec)
 {
-	conf->getuid = set_value(strvec);
+	conf->uid_attribute = set_value(strvec);
 
-	if (!conf->getuid)
+	if (!conf->uid_attribute)
 		return 1;
 
 	return 0;
@@ -148,6 +172,17 @@ def_prio_handler(vector strvec)
 }
 
 static int
+def_alias_prefix_handler(vector strvec)
+{
+	conf->alias_prefix = set_value(strvec);
+
+	if (!conf->alias_prefix)
+		return 1;
+
+	return 0;
+}
+
+static int
 def_prio_args_handler(vector strvec)
 {
 	conf->prio_args = set_value(strvec);
@@ -197,6 +232,22 @@ def_minio_handler(vector strvec)
 }
 
 static int
+def_minio_rq_handler(vector strvec)
+{
+	char * buff;
+
+	buff = set_value(strvec);
+
+	if (!buff)
+		return 1;
+
+	conf->minio_rq = atoi(buff);
+	FREE(buff);
+
+	return 0;
+}
+
+int
 get_sys_max_fds(int *max_fds)
 {
 	FILE *file;
@@ -327,6 +378,10 @@ def_weight_handler(vector strvec)
 	    !strcmp(buff, "priorities"))
 		conf->rr_weight = RR_WEIGHT_PRIO;
 
+	if (strlen(buff) == strlen("uniform") &&
+	    !strcmp(buff, "uniform"))
+		conf->rr_weight = RR_WEIGHT_NONE;
+
 	FREE(buff);
 
 	return 0;
@@ -343,6 +398,8 @@ default_failback_handler(vector strvec)
 		conf->pgfailback = -FAILBACK_MANUAL;
 	else if (strlen(buff) == 9 && !strcmp(buff, "immediate"))
 		conf->pgfailback = -FAILBACK_IMMEDIATE;
+	else if (strlen(buff) == 10 && !strcmp(buff, "followover"))
+		conf->pgfailback = -FAILBACK_FOLLOWOVER;
 	else
 		conf->pgfailback = atoi(buff);
 
@@ -381,14 +438,30 @@ def_queue_without_daemon(vector strvec)
 	if (!buff)
 		return 1;
 
-	if (!strncmp(buff, "off", 3) || !strncmp(buff, "no", 2) ||
-	    !strncmp(buff, "0", 1))
-		conf->queue_without_daemon = QUE_NO_DAEMON_OFF;
-	else if (!strncmp(buff, "on", 2) || !strncmp(buff, "yes", 3) ||
+	if (!strncmp(buff, "on", 2) || !strncmp(buff, "yes", 3) ||
 		 !strncmp(buff, "1", 1))
 		conf->queue_without_daemon = QUE_NO_DAEMON_ON;
 	else
-		conf->queue_without_daemon = QUE_NO_DAEMON_UNDEF;
+		conf->queue_without_daemon = QUE_NO_DAEMON_OFF;
+
+	free(buff);
+	return 0;
+}
+
+static int
+def_checker_timeout_handler(vector strvec)
+{
+	unsigned int checker_timeout;
+	char *buff;
+
+	buff = set_value(strvec);
+	if (!buff)
+		return 1;
+
+	if (sscanf(buff, "%u", &checker_timeout) == 1)
+		conf->checker_timeout = checker_timeout;
+	else
+		conf->checker_timeout = 0;
 
 	free(buff);
 	return 0;
@@ -432,7 +505,7 @@ def_flush_on_last_del_handler(vector strvec)
 	if ((strlen(buff) == 2 && strcmp(buff, "no") == 0) ||
 	    (strlen(buff) == 1 && strcmp(buff, "0") == 0))
 		conf->flush_on_last_del = FLUSH_DISABLED;
-	if ((strlen(buff) == 3 && strcmp(buff, "yes") == 0) ||
+	else if ((strlen(buff) == 3 && strcmp(buff, "yes") == 0) ||
 	    (strlen(buff) == 1 && strcmp(buff, "1") == 0))
 		conf->flush_on_last_del = FLUSH_ENABLED;
 	else
@@ -443,7 +516,141 @@ def_flush_on_last_del_handler(vector strvec)
 }
 
 static int
-names_handler(vector strvec)
+def_log_checker_err_handler(vector strvec)
+{
+	char * buff;
+
+	buff = set_value(strvec);
+
+	if (!buff)
+		return 1;
+
+	if (strlen(buff) == 4 && !strcmp(buff, "once"))
+		conf->log_checker_err = LOG_CHKR_ERR_ONCE;
+	else if (strlen(buff) == 6 && !strcmp(buff, "always"))
+		conf->log_checker_err = LOG_CHKR_ERR_ALWAYS;
+
+	free(buff);
+	return 0;
+}
+
+static int
+def_reservation_key_handler(vector strvec)
+{
+	char *buff;
+	char *tbuff;
+	int j, k;
+	int len;
+	uint64_t prkey;
+
+	buff = set_value(strvec);
+	if (!buff)
+		return 1;
+
+	tbuff = buff;
+
+	if (!memcmp("0x",buff, 2))
+		buff = buff + 2;
+
+	len = strlen(buff);
+
+	k = strspn(buff, "0123456789aAbBcCdDeEfF");
+
+	if (len != k) {
+		FREE(tbuff);
+		return 1;
+	}
+
+	if (1 != sscanf (buff, "%" SCNx64 "", &prkey))
+	{
+		FREE(tbuff);
+		return 1;
+	}
+
+	if (!conf->reservation_key)
+		conf->reservation_key = (unsigned char *) malloc(8);
+
+	memset(conf->reservation_key, 0, 8);
+
+	for (j = 7; j >= 0; --j) {
+		conf->reservation_key[j] = (prkey & 0xff);
+		prkey >>= 8;
+	}
+
+	FREE(tbuff);
+	return 0;
+}
+
+static int
+def_names_handler(vector strvec)
+{
+	char * buff;
+
+	buff = set_value(strvec);
+
+	if (!buff)
+		return 1;
+
+	if ((strlen(buff) == 2 && !strcmp(buff, "no")) ||
+	    (strlen(buff) == 1 && !strcmp(buff, "0")))
+		conf->user_friendly_names = USER_FRIENDLY_NAMES_OFF;
+	else if ((strlen(buff) == 3 && !strcmp(buff, "yes")) ||
+		 (strlen(buff) == 1 && !strcmp(buff, "1")))
+		conf->user_friendly_names = USER_FRIENDLY_NAMES_ON;
+	else
+		conf->user_friendly_names = USER_FRIENDLY_NAMES_UNDEF;
+
+	FREE(buff);
+	return 0;
+}
+
+static int
+bindings_file_handler(vector strvec)
+{
+	conf->bindings_file = set_value(strvec);
+
+	if (!conf->bindings_file)
+		return 1;
+
+	return 0;
+}
+
+static int
+wwids_file_handler(vector strvec)
+{
+	conf->wwids_file = set_value(strvec);
+
+	if (!conf->wwids_file)
+		return 1;
+
+	return 0;
+}
+
+static int
+def_retain_hwhandler_handler(vector strvec)
+{
+	char * buff;
+
+	buff = set_value(strvec);
+
+	if (!buff)
+		return 1;
+
+	if ((strlen(buff) == 2 && !strcmp(buff, "no")) ||
+	    (strlen(buff) == 1 && !strcmp(buff, "0")))
+		conf->retain_hwhandler = RETAIN_HWHANDLER_OFF;
+	else if ((strlen(buff) == 3 && !strcmp(buff, "yes")) ||
+		 (strlen(buff) == 1 && !strcmp(buff, "1")))
+		conf->retain_hwhandler = RETAIN_HWHANDLER_ON;
+	else
+		conf->retain_hwhandler = RETAIN_HWHANDLER_UNDEF;
+
+	FREE(buff);
+	return 0;
+}
+
+static int
+def_detect_prio_handler(vector strvec)
 {
 	char * buff;
 
@@ -454,10 +661,12 @@ names_handler(vector strvec)
 
 	if ((strlen(buff) == 2 && !strcmp(buff, "no")) ||
 	    (strlen(buff) == 1 && !strcmp(buff, "0")))
-		conf->user_friendly_names = 0;
+		conf->detect_prio = DETECT_PRIO_OFF;
 	else if ((strlen(buff) == 3 && !strcmp(buff, "yes")) ||
 		 (strlen(buff) == 1 && !strcmp(buff, "1")))
-		conf->user_friendly_names = 1;
+		conf->detect_prio = DETECT_PRIO_ON;
+	else
+		conf->detect_prio = DETECT_PRIO_UNDEF;
 
 	FREE(buff);
 	return 0;
@@ -675,6 +884,22 @@ product_handler(vector strvec)
 }
 
 static int
+revision_handler(vector strvec)
+{
+	struct hwentry * hwe = VECTOR_LAST_SLOT(conf->hwtable);
+
+	if (!hwe)
+		return 1;
+
+	hwe->revision = set_value(strvec);
+
+	if (!hwe->revision)
+		return 1;
+
+	return 0;
+}
+
+static int
 bl_product_handler(vector strvec)
 {
 	struct hwentry * hwe = VECTOR_LAST_SLOT(conf->hwtable);
@@ -697,10 +922,12 @@ hw_fast_io_fail_handler(vector strvec)
 
 	buff = set_value(strvec);
 	if (strlen(buff) == 3 && !strcmp(buff, "off"))
-		hwe->fast_io_fail = -1;
+		hwe->fast_io_fail = MP_FAST_IO_FAIL_OFF;
 	else if (sscanf(buff, "%d", &hwe->fast_io_fail) != 1 ||
-		 hwe->fast_io_fail < -1)
-		hwe->fast_io_fail = 0;
+		 hwe->fast_io_fail < MP_FAST_IO_FAIL_ZERO)
+		hwe->fast_io_fail = MP_FAST_IO_FAIL_UNSET;
+	else if (hwe->fast_io_fail == 0)
+		hwe->fast_io_fail = MP_FAST_IO_FAIL_ZERO;
 
 	FREE(buff);
 	return 0;
@@ -713,7 +940,12 @@ hw_dev_loss_handler(vector strvec)
 	struct hwentry * hwe = VECTOR_LAST_SLOT(conf->hwtable);
 
 	buff = set_value(strvec);
-	if (sscanf(buff, "%u", &hwe->dev_loss) != 1)
+	if (!buff)
+		return 1;
+
+	if (strlen(buff) == 8 && !strcmp(buff, "infinity"))
+		hwe->dev_loss = MAX_DEV_LOSS_TMO;
+	else if (sscanf(buff, "%u", &hwe->dev_loss) != 1)
 		hwe->dev_loss = 0;
 
 	FREE(buff);
@@ -738,13 +970,13 @@ hw_pgpolicy_handler(vector strvec)
 }
 
 static int
-hw_getuid_callout_handler(vector strvec)
+hw_uid_attribute_handler(vector strvec)
 {
 	struct hwentry * hwe = VECTOR_LAST_SLOT(conf->hwtable);
 
-	hwe->getuid = set_value(strvec);
+	hwe->uid_attribute = set_value(strvec);
 
-	if (!hwe->getuid)
+	if (!hwe->uid_attribute)
 		return 1;
 
 	return 0;
@@ -831,6 +1063,22 @@ hw_prio_handler(vector strvec)
 }
 
 static int
+hw_alias_prefix_handler(vector strvec)
+{
+	struct hwentry * hwe = VECTOR_LAST_SLOT(conf->hwtable);
+
+	if (!hwe)
+		return 1;
+
+	hwe->alias_prefix = set_value(strvec);
+
+	if (!hwe->alias_prefix)
+		return 1;
+
+	return 0;
+}
+
+static int
 hw_prio_args_handler(vector strvec)
 {
 	struct hwentry * hwe = VECTOR_LAST_SLOT(conf->hwtable);
@@ -861,6 +1109,8 @@ hw_failback_handler(vector strvec)
 		hwe->pgfailback = -FAILBACK_MANUAL;
 	else if (strlen(buff) == 9 && !strcmp(buff, "immediate"))
 		hwe->pgfailback = -FAILBACK_IMMEDIATE;
+	else if (strlen(buff) == 10 && !strcmp(buff, "followover"))
+		hwe->pgfailback = -FAILBACK_FOLLOWOVER;
 	else
 		hwe->pgfailback = atoi(buff);
 
@@ -887,6 +1137,10 @@ hw_weight_handler(vector strvec)
 	    !strcmp(buff, "priorities"))
 		hwe->rr_weight = RR_WEIGHT_PRIO;
 
+	if (strlen(buff) == strlen("uniform") &&
+	    !strcmp(buff, "uniform"))
+		hwe->rr_weight = RR_WEIGHT_NONE;
+
 	FREE(buff);
 
 	return 0;
@@ -938,6 +1192,26 @@ hw_minio_handler(vector strvec)
 }
 
 static int
+hw_minio_rq_handler(vector strvec)
+{
+	struct hwentry *hwe = VECTOR_LAST_SLOT(conf->hwtable);
+	char * buff;
+
+	if (!hwe)
+		return 1;
+
+	buff = set_value(strvec);
+
+	if (!buff)
+		return 1;
+
+	hwe->minio_rq = atoi(buff);
+	FREE(buff);
+
+	return 0;
+}
+
+static int
 hw_pg_timeout_handler(vector strvec)
 {
 	int pg_timeout;
@@ -983,7 +1257,7 @@ hw_flush_on_last_del_handler(vector strvec)
 	if ((strlen(buff) == 2 && strcmp(buff, "no") == 0) ||
 	    (strlen(buff) == 1 && strcmp(buff, "0") == 0))
 		hwe->flush_on_last_del = FLUSH_DISABLED;
-	if ((strlen(buff) == 3 && strcmp(buff, "yes") == 0) ||
+	else if ((strlen(buff) == 3 && strcmp(buff, "yes") == 0) ||
 	    (strlen(buff) == 1 && strcmp(buff, "1") == 0))
 		hwe->flush_on_last_del = FLUSH_ENABLED;
 	else
@@ -993,70 +1267,150 @@ hw_flush_on_last_del_handler(vector strvec)
 	return 0;
 }
 
-/*
- * multipaths block handlers
- */
 static int
-multipaths_handler(vector strvec)
+hw_names_handler(vector strvec)
 {
-	conf->mptable = vector_alloc();
+	struct hwentry *hwe = VECTOR_LAST_SLOT(conf->hwtable);
+	char * buff;
 
-	if (!conf->mptable)
+	if (!hwe)
 		return 1;
 
-	return 0;
-}
-
-static int
-multipath_handler(vector strvec)
-{
-	struct mpentry * mpe;
-
-	mpe = alloc_mpe();
-
-	if (!mpe)
+	buff = set_value(strvec);
+	if (!buff)
 		return 1;
 
-	if (!vector_alloc_slot(conf->mptable)) {
-		free_mpe(mpe);
-		return 1;
-	}
-	vector_set_slot(conf->mptable, mpe);
+	if ((strlen(buff) == 2 && strcmp(buff, "no") == 0) ||
+	    (strlen(buff) == 1 && strcmp(buff, "0") == 0))
+		hwe->user_friendly_names = USER_FRIENDLY_NAMES_OFF;
+	else if ((strlen(buff) == 3 && strcmp(buff, "yes") == 0) ||
+		 (strlen(buff) == 1 && strcmp(buff, "1") == 0))
+		hwe->user_friendly_names = USER_FRIENDLY_NAMES_ON;
+	else
+		hwe->user_friendly_names = USER_FRIENDLY_NAMES_UNDEF;
 
+	FREE(buff);
 	return 0;
 }
 
 static int
-wwid_handler(vector strvec)
+hw_retain_hwhandler_handler(vector strvec)
 {
-	struct mpentry * mpe = VECTOR_LAST_SLOT(conf->mptable);
+	struct hwentry *hwe = VECTOR_LAST_SLOT(conf->hwtable);
+	char * buff;
 
-	if (!mpe)
+	if (!hwe)
 		return 1;
 
-	mpe->wwid = set_value(strvec);
+	buff = set_value(strvec);
 
-	if (!mpe->wwid)
+	if (!buff)
 		return 1;
 
+	if ((strlen(buff) == 2 && !strcmp(buff, "no")) ||
+	    (strlen(buff) == 1 && !strcmp(buff, "0")))
+		hwe->retain_hwhandler = RETAIN_HWHANDLER_OFF;
+	else if ((strlen(buff) == 3 && !strcmp(buff, "yes")) ||
+		 (strlen(buff) == 1 && !strcmp(buff, "1")))
+		hwe->retain_hwhandler = RETAIN_HWHANDLER_ON;
+	else
+		hwe->user_friendly_names = RETAIN_HWHANDLER_UNDEF;
+
+	FREE(buff);
 	return 0;
 }
 
 static int
-alias_handler(vector strvec)
+hw_detect_prio_handler(vector strvec)
 {
-	struct mpentry * mpe = VECTOR_LAST_SLOT(conf->mptable);
+	struct hwentry *hwe = VECTOR_LAST_SLOT(conf->hwtable);
+	char * buff;
 
-	if (!mpe)
+	if (!hwe)
 		return 1;
 
-	mpe->alias = set_value(strvec);
+	buff = set_value(strvec);
 
-	if (!mpe->alias)
+	if (!buff)
 		return 1;
 
-	return 0;
-}
+	if ((strlen(buff) == 2 && !strcmp(buff, "no")) ||
+	    (strlen(buff) == 1 && !strcmp(buff, "0")))
+		hwe->detect_prio = DETECT_PRIO_OFF;
+	else if ((strlen(buff) == 3 && !strcmp(buff, "yes")) ||
+		 (strlen(buff) == 1 && !strcmp(buff, "1")))
+		hwe->detect_prio = DETECT_PRIO_ON;
+	else
+		hwe->detect_prio = DETECT_PRIO_UNDEF;
+
+	FREE(buff);
+	return 0;
+}
+
+/*
+ * multipaths block handlers
+ */
+static int
+multipaths_handler(vector strvec)
+{
+	conf->mptable = vector_alloc();
+
+	if (!conf->mptable)
+		return 1;
+
+	return 0;
+}
+
+static int
+multipath_handler(vector strvec)
+{
+	struct mpentry * mpe;
+
+	mpe = alloc_mpe();
+
+	if (!mpe)
+		return 1;
+
+	if (!vector_alloc_slot(conf->mptable)) {
+		free_mpe(mpe);
+		return 1;
+	}
+	vector_set_slot(conf->mptable, mpe);
+
+	return 0;
+}
+
+static int
+wwid_handler(vector strvec)
+{
+	struct mpentry * mpe = VECTOR_LAST_SLOT(conf->mptable);
+
+	if (!mpe)
+		return 1;
+
+	mpe->wwid = set_value(strvec);
+
+	if (!mpe->wwid)
+		return 1;
+
+	return 0;
+}
+
+static int
+alias_handler(vector strvec)
+{
+	struct mpentry * mpe = VECTOR_LAST_SLOT(conf->mptable);
+
+	if (!mpe)
+		return 1;
+
+	mpe->alias = set_value(strvec);
+
+	if (!mpe->alias)
+		return 1;
+
+	return 0;
+}
 
 static int
 mp_pgpolicy_handler(vector strvec)
@@ -1109,6 +1463,8 @@ mp_failback_handler(vector strvec)
 		mpe->pgfailback = -FAILBACK_MANUAL;
 	else if (strlen(buff) == 9 && !strcmp(buff, "immediate"))
 		mpe->pgfailback = -FAILBACK_IMMEDIATE;
+	else if (strlen(buff) == 10 && !strcmp(buff, "followover"))
+		mpe->pgfailback = -FAILBACK_FOLLOWOVER;
 	else
 		mpe->pgfailback = atoi(buff);
 
@@ -1215,6 +1571,10 @@ mp_weight_handler(vector strvec)
 	    !strcmp(buff, "priorities"))
 		mpe->rr_weight = RR_WEIGHT_PRIO;
 
+	if (strlen(buff) == strlen("uniform") &&
+	    !strcmp(buff, "uniform"))
+		mpe->rr_weight = RR_WEIGHT_NONE;
+
 	FREE(buff);
 
 	return 0;
@@ -1266,6 +1626,26 @@ mp_minio_handler(vector strvec)
 }
 
 static int
+mp_minio_rq_handler(vector strvec)
+{
+	struct mpentry *mpe = VECTOR_LAST_SLOT(conf->mptable);
+	char * buff;
+
+	if (!mpe)
+		return 1;
+
+	buff = set_value(strvec);
+
+	if (!buff)
+		return 1;
+
+	mpe->minio_rq = atoi(buff);
+	FREE(buff);
+
+	return 0;
+}
+
+static int
 mp_pg_timeout_handler(vector strvec)
 {
 	int pg_timeout;
@@ -1295,6 +1675,22 @@ mp_pg_timeout_handler(vector strvec)
 }
 
 static int
+mp_features_handler(vector strvec)
+{
+	struct mpentry * mpe = VECTOR_LAST_SLOT(conf->mptable);
+
+	if (!mpe)
+		return 1;
+
+	mpe->features = set_value(strvec);
+
+	if (!mpe->features)
+		return 1;
+
+	return 0;
+}
+
+static int
 mp_flush_on_last_del_handler(vector strvec)
 {
 	struct mpentry *mpe = VECTOR_LAST_SLOT(conf->mptable);
@@ -1310,7 +1706,7 @@ mp_flush_on_last_del_handler(vector strvec)
 	if ((strlen(buff) == 2 && strcmp(buff, "no") == 0) ||
 	    (strlen(buff) == 1 && strcmp(buff, "0") == 0))
 		mpe->flush_on_last_del = FLUSH_DISABLED;
-	if ((strlen(buff) == 3 && strcmp(buff, "yes") == 0) ||
+	else if ((strlen(buff) == 3 && strcmp(buff, "yes") == 0) ||
 	    (strlen(buff) == 1 && strcmp(buff, "1") == 0))
 		mpe->flush_on_last_del = FLUSH_ENABLED;
 	else
@@ -1320,6 +1716,112 @@ mp_flush_on_last_del_handler(vector strvec)
 	return 0;
 }
 
+static int
+mp_prio_handler(vector strvec)
+{
+	struct mpentry * mpe = VECTOR_LAST_SLOT(conf->mptable);
+
+	if (!mpe)
+		return 1;
+
+	mpe->prio_name = set_value(strvec);
+
+	if (!mpe->prio_name)
+		return 1;
+
+	return 0;
+}
+
+static int
+mp_prio_args_handler (vector strvec)
+{
+	struct mpentry *mpe = VECTOR_LAST_SLOT(conf->mptable);
+
+	if (!mpe)
+		return 1;
+
+	mpe->prio_args = set_value(strvec);
+	if (!mpe->prio_args)
+		return 1;
+
+	return 0;
+}
+
+static int
+mp_reservation_key_handler (vector strvec)
+{
+	char *buff;
+	char *tbuff;
+	struct mpentry *mpe = VECTOR_LAST_SLOT(conf->mptable);
+
+	int j, k, len;
+	uint64_t prkey;
+
+	if (!mpe)
+		return 1;
+
+	buff = set_value(strvec);
+	if (!buff)
+		return 1;
+
+	tbuff = buff;
+	if (!memcmp(buff, "0x", 2))
+		buff = buff + 2;
+
+	len = strlen(buff);
+
+	k = strspn(buff, "0123456789aAbBcCdDeEfF");
+	if (len != k) {
+		FREE(tbuff);
+		return 1;
+	}
+
+	if (1 != sscanf (buff, "%" SCNx64 "", &prkey))
+	{
+		FREE(tbuff);
+		return 1;
+	}
+
+	if (!mpe->reservation_key)
+		mpe->reservation_key = (unsigned char *) malloc(8);
+
+	memset(mpe->reservation_key, 0, 8);
+
+	for (j = 7; j >= 0; --j) {
+		mpe->reservation_key[j] = (prkey & 0xff);
+		prkey >>= 8;
+	}
+
+	FREE(tbuff);
+	return 0;
+}
+
+static int
+mp_names_handler(vector strvec)
+{
+	struct mpentry *mpe = VECTOR_LAST_SLOT(conf->mptable);
+	char * buff;
+
+	if (!mpe)
+		return 1;
+
+	buff = set_value(strvec);
+	if (!buff)
+		return 1;
+
+	if ((strlen(buff) == 2 && strcmp(buff, "no") == 0) ||
+	    (strlen(buff) == 1 && strcmp(buff, "0") == 0))
+		mpe->user_friendly_names = USER_FRIENDLY_NAMES_OFF;
+	else if ((strlen(buff) == 3 && strcmp(buff, "yes") == 0) ||
+		 (strlen(buff) == 1 && strcmp(buff, "1") == 0))
+		mpe->user_friendly_names = USER_FRIENDLY_NAMES_ON;
+	else
+		mpe->user_friendly_names = USER_FRIENDLY_NAMES_UNDEF;
+
+	FREE(buff);
+	return 0;
+}
+
 /*
  * config file keywords printing
  */
@@ -1339,11 +1841,6 @@ snprint_mp_alias (char * buff, int len, void * data)
 	if (!mpe->alias)
 		return 0;
 
-	if (conf->user_friendly_names &&
-	    (strlen(mpe->alias) == strlen("mpath")) &&
-	    !strcmp(mpe->alias, "mpath"))
-		return 0;
-
 	return snprintf(buff, len, "%s", mpe->alias);
 }
 
@@ -1357,7 +1854,7 @@ snprint_mp_path_grouping_policy (char * buff, int len, void * data)
 		return 0;
 	get_pgpolicy_name(str, POLICY_NAME_SIZE, mpe->pgpolicy);
 
-	return snprintf(buff, len, "%s", str);
+	return snprintf(buff, len, "\"%s\"", str);
 }
 
 static int
@@ -1368,7 +1865,7 @@ snprint_mp_selector (char * buff, int len, void * data)
 	if (!mpe->selector)
 		return 0;
 
-	return snprintf(buff, len, "%s", mpe->selector);
+	return snprintf(buff, len, "\"%s\"", mpe->selector);
 }
 
 static int
@@ -1383,9 +1880,11 @@ snprint_mp_failback (char * buff, int len, void * data)
 	case  FAILBACK_UNDEF:
 		break;
 	case -FAILBACK_MANUAL:
-		return snprintf(buff, len, "manual");
+		return snprintf(buff, len, "\"manual\"");
 	case -FAILBACK_IMMEDIATE:
-		return snprintf(buff, len, "immediate");
+		return snprintf(buff, len, "\"immediate\"");
+	case -FAILBACK_FOLLOWOVER:
+		return snprintf(buff, len, "\"followover\"");
 	default:
 		return snprintf(buff, len, "%i", mpe->pgfailback);
 	}
@@ -1430,7 +1929,9 @@ snprint_mp_rr_weight (char * buff, int len, void * data)
 	if (!mpe->rr_weight)
 		return 0;
 	if (mpe->rr_weight == RR_WEIGHT_PRIO)
-		return snprintf(buff, len, "priorities");
+		return snprintf(buff, len, "\"priorities\"");
+	if (mpe->rr_weight == RR_WEIGHT_NONE)
+		return snprintf(buff, len, "\"uniform\"");
 
 	return 0;
 }
@@ -1447,9 +1948,9 @@ snprint_mp_no_path_retry (char * buff, int len, void * data)
 	case NO_PATH_RETRY_UNDEF:
 		break;
 	case NO_PATH_RETRY_FAIL:
-		return snprintf(buff, len, "fail");
+		return snprintf(buff, len, "\"fail\"");
 	case NO_PATH_RETRY_QUEUE:
-		return snprintf(buff, len, "queue");
+		return snprintf(buff, len, "\"queue\"");
 	default:
 		return snprintf(buff, len, "%i",
 				mpe->no_path_retry);
@@ -1469,6 +1970,17 @@ snprint_mp_rr_min_io (char * buff, int len, void * data)
 }
 
 static int
+snprint_mp_rr_min_io_rq (char * buff, int len, void * data)
+{
+	struct mpentry * mpe = (struct mpentry *)data;
+
+	if (!mpe->minio_rq)
+		return 0;
+
+	return snprintf(buff, len, "%u", mpe->minio_rq);
+}
+
+static int
 snprint_mp_pg_timeout (char * buff, int len, void * data)
 {
 	struct mpentry * mpe = (struct mpentry *)data;
@@ -1477,7 +1989,7 @@ snprint_mp_pg_timeout (char * buff, int len, void * data)
 	case PGTIMEOUT_UNDEF:
 		break;
 	case -PGTIMEOUT_NONE:
-		return snprintf(buff, len, "none");
+		return snprintf(buff, len, "\"none\"");
 	default:
 		return snprintf(buff, len, "%i", mpe->pg_timeout);
 	}
@@ -1485,27 +1997,101 @@ snprint_mp_pg_timeout (char * buff, int len, void * data)
 }
 
 static int
+snprint_mp_features (char * buff, int len, void * data)
+{
+	struct mpentry * mpe = (struct mpentry *)data;
+
+	if (!mpe->features)
+		return 0;
+	if (strlen(mpe->features) == strlen(conf->features) &&
+	    !strcmp(mpe->features, conf->features))
+		return 0;
+
+	return snprintf(buff, len, "\"%s\"", mpe->features);
+}
+
+static int
 snprint_mp_flush_on_last_del (char * buff, int len, void * data)
 {
 	struct mpentry * mpe = (struct mpentry *)data;
 
 	switch (mpe->flush_on_last_del) {
 	case FLUSH_DISABLED:
-		return snprintf(buff, len, "no");
+		return snprintf(buff, len, "\"no\"");
 	case FLUSH_ENABLED:
-		return snprintf(buff, len, "yes");
+		return snprintf(buff, len, "\"yes\"");
 	}
 	return 0;
 }
 
 static int
+snprint_mp_prio(char * buff, int len, void * data)
+{
+	struct mpentry * mpe = (struct mpentry *)data;
+
+	if (!mpe->prio_name)
+		return 0;
+
+	return snprintf(buff, len, "\"%s\"", mpe->prio_name);
+}
+
+static int
+snprint_mp_prio_args(char * buff, int len, void * data)
+{
+	struct mpentry * mpe = (struct mpentry *)data;
+
+	if (!mpe->prio_args)
+		return 0;
+
+	return snprintf(buff, len, "\"%s\"", mpe->prio_args);
+}
+
+static int
+snprint_mp_reservation_key (char * buff, int len, void * data)
+{
+	int i;
+	unsigned char *keyp;
+	uint64_t prkey = 0;
+	struct mpentry * mpe = (struct mpentry *)data;
+
+	if (!mpe->reservation_key)
+		return 0;
+	keyp = (unsigned char *)mpe->reservation_key;
+	for (i = 0; i < 8; i++) {
+		if (i > 0)
+			prkey <<= 8;
+		prkey |= *keyp;
+		keyp++;
+	}
+
+	return snprintf(buff, len, "0x%" PRIx64, prkey);
+}
+
+	static int
+snprint_mp_user_friendly_names (char * buff, int len, void * data)
+{
+	struct mpentry * mpe = (struct mpentry *)data;
+
+	if (mpe->user_friendly_names == USER_FRIENDLY_NAMES_UNDEF)
+		return 0;
+	else if (mpe->user_friendly_names == USER_FRIENDLY_NAMES_OFF)
+		return snprintf(buff, len, "\"no\"");
+	else
+		return snprintf(buff, len, "\"yes\"");
+}
+
+static int
 snprint_hw_fast_io_fail(char * buff, int len, void * data)
 {
 	struct hwentry * hwe = (struct hwentry *)data;
-	if (!hwe->fast_io_fail)
+	if (hwe->fast_io_fail == MP_FAST_IO_FAIL_UNSET)
+		return 0;
+	if (hwe->fast_io_fail == conf->fast_io_fail)
 		return 0;
-	if (hwe->fast_io_fail == -1)
-		return snprintf(buff, len, "off");
+	if (hwe->fast_io_fail == MP_FAST_IO_FAIL_OFF)
+		return snprintf(buff, len, "\"off\"");
+	if (hwe->fast_io_fail == MP_FAST_IO_FAIL_ZERO)
+		return snprintf(buff, len, "0");
 	return snprintf(buff, len, "%d", hwe->fast_io_fail);
 }
 
@@ -1515,6 +2101,11 @@ snprint_hw_dev_loss(char * buff, int len, void * data)
 	struct hwentry * hwe = (struct hwentry *)data;
 	if (!hwe->dev_loss)
 		return 0;
+	if (hwe->dev_loss == conf->dev_loss)
+		return 0;
+	if (hwe->dev_loss >= MAX_DEV_LOSS_TMO)
+		return snprintf(buff, len, "\"infinity\"");
+
 	return snprintf(buff, len, "%u", hwe->dev_loss);
 }
 
@@ -1541,6 +2132,17 @@ snprint_hw_product (char * buff, int len, void * data)
 }
 
 static int
+snprint_hw_revision (char * buff, int len, void * data)
+{
+	struct hwentry * hwe = (struct hwentry *)data;
+
+	if (!hwe->revision)
+		return 0;
+
+	return snprintf(buff, len, "\"%s\"", hwe->revision);
+}
+
+static int
 snprint_hw_bl_product (char * buff, int len, void * data)
 {
 	struct hwentry * hwe = (struct hwentry *)data;
@@ -1552,18 +2154,14 @@ snprint_hw_bl_product (char * buff, int len, void * data)
 }
 
 static int
-snprint_hw_getuid_callout (char * buff, int len, void * data)
+snprint_hw_uid_attribute (char * buff, int len, void * data)
 {
 	struct hwentry * hwe = (struct hwentry *)data;
 
-	if (!hwe->getuid)
-		return 0;
-	if (conf->getuid &&
-	    strlen(hwe->getuid) == strlen(conf->getuid) &&
-	    !strcmp(hwe->getuid, conf->getuid))
+	if (!hwe->uid_attribute)
 		return 0;
 
-	return snprintf(buff, len, "\"%s\"", hwe->getuid);
+	return snprintf(buff, len, "\"%s\"", hwe->uid_attribute);
 }
 
 static int
@@ -1571,12 +2169,21 @@ snprint_hw_prio (char * buff, int len, void * data)
 {
 	struct hwentry * hwe = (struct hwentry *)data;
 
-	if (!hwe->prio_name || (strlen(hwe->prio_name) == 0))
+	if (!hwe->prio_name)
 		return 0;
-	if (conf->prio_name && !strcmp(hwe->prio_name, conf->prio_name))
+
+	return snprintf(buff, len, "\"%s\"", hwe->prio_name);
+}
+
+static int
+snprint_hw_alias_prefix (char * buff, int len, void * data)
+{
+	struct hwentry * hwe = (struct hwentry *)data;
+
+	if (!hwe->alias_prefix)
 		return 0;
 
-	return snprintf(buff, len, "%s", hwe->prio_name);
+	return snprintf(buff, len, "\"%s\"", hwe->alias_prefix);
 }
 
 static int
@@ -1584,12 +2191,10 @@ snprint_hw_prio_args (char * buff, int len, void * data)
 {
 	struct hwentry * hwe = (struct hwentry *)data;
 
-        if (!hwe->prio_args || (strlen(hwe->prio_args) == 0))
-                return 0;
-        if (conf->prio_args && !strcmp(hwe->prio_args, conf->prio_args))
-                return 0;
+	if (!hwe->prio_args)
+		return 0;
 
-	return snprintf(buff, len, "%s", hwe->prio_args);
+	return snprintf(buff, len, "\"%s\"", hwe->prio_args);
 }
 
 static int
@@ -1599,10 +2204,6 @@ snprint_hw_features (char * buff, int len, void * data)
 
 	if (!hwe->features)
 		return 0;
-	if (conf->features &&
-	    strlen(hwe->features) == strlen(conf->features) &&
-	    !strcmp(hwe->features, conf->features))
-		return 0;
 
 	return snprintf(buff, len, "\"%s\"", hwe->features);
 }
@@ -1614,10 +2215,6 @@ snprint_hw_hardware_handler (char * buff, int len, void * data)
 
 	if (!hwe->hwhandler)
 		return 0;
-	if (conf->hwhandler &&
-	    strlen(hwe->hwhandler) == strlen(conf->hwhandler) &&
-	    !strcmp(hwe->hwhandler, conf->hwhandler))
-		return 0;
 
 	return snprintf(buff, len, "\"%s\"", hwe->hwhandler);
 }
@@ -1629,12 +2226,8 @@ snprint_hw_selector (char * buff, int len, void * data)
 
 	if (!hwe->selector)
 		return 0;
-	if (conf->selector &&
-	    strlen(hwe->selector) == strlen(conf->selector) &&
-	    !strcmp(hwe->selector, conf->selector))
-		return 0;
 
-	return snprintf(buff, len, "%s", hwe->selector);
+	return snprintf(buff, len, "\"%s\"", hwe->selector);
 }
 
 static int
@@ -1646,12 +2239,10 @@ snprint_hw_path_grouping_policy (char * buff, int len, void * data)
 
 	if (!hwe->pgpolicy)
 		return 0;
-	if (conf->pgpolicy && hwe->pgpolicy == conf->pgpolicy)
-		return 0;
 
 	get_pgpolicy_name(str, POLICY_NAME_SIZE, hwe->pgpolicy);
 
-	return snprintf(buff, len, "%s", str);
+	return snprintf(buff, len, "\"%s\"", str);
 }
 
 static int
@@ -1661,16 +2252,16 @@ snprint_hw_failback (char * buff, int len, void * data)
 
 	if (!hwe->pgfailback)
 		return 0;
-	if (conf->pgfailback && hwe->pgfailback == conf->pgfailback)
-		return 0;
 
 	switch(hwe->pgfailback) {
 	case  FAILBACK_UNDEF:
 		break;
 	case -FAILBACK_MANUAL:
-		return snprintf(buff, len, "manual");
+		return snprintf(buff, len, "\"manual\"");
 	case -FAILBACK_IMMEDIATE:
-		return snprintf(buff, len, "immediate");
+		return snprintf(buff, len, "\"immediate\"");
+	case -FAILBACK_FOLLOWOVER:
+		return snprintf(buff, len, "\"followover\"");
 	default:
 		return snprintf(buff, len, "%i", hwe->pgfailback);
 	}
@@ -1684,10 +2275,10 @@ snprint_hw_rr_weight (char * buff, int len, void * data)
 
 	if (!hwe->rr_weight)
 		return 0;
-	if (conf->rr_weight && hwe->rr_weight == conf->rr_weight)
-		return 0;
 	if (hwe->rr_weight == RR_WEIGHT_PRIO)
-		return snprintf(buff, len, "priorities");
+		return snprintf(buff, len, "\"priorities\"");
+	if (hwe->rr_weight == RR_WEIGHT_NONE)
+		return snprintf(buff, len, "\"uniform\"");
 
 	return 0;
 }
@@ -1699,16 +2290,14 @@ snprint_hw_no_path_retry (char * buff, int len, void * data)
 
 	if (!hwe->no_path_retry)
 		return 0;
-	if (hwe->no_path_retry == conf->no_path_retry)
-		return 0;
 
 	switch(hwe->no_path_retry) {
 	case NO_PATH_RETRY_UNDEF:
 		break;
 	case NO_PATH_RETRY_FAIL:
-		return snprintf(buff, len, "fail");
+		return snprintf(buff, len, "\"fail\"");
 	case NO_PATH_RETRY_QUEUE:
-		return snprintf(buff, len, "queue");
+		return snprintf(buff, len, "\"queue\"");
 	default:
 		return snprintf(buff, len, "%i",
 				hwe->no_path_retry);
@@ -1723,27 +2312,34 @@ snprint_hw_rr_min_io (char * buff, int len, void * data)
 
 	if (!hwe->minio)
 		return 0;
-	if (hwe->minio == conf->minio)
-		return 0;
 
 	return snprintf(buff, len, "%u", hwe->minio);
 }
 
 static int
+snprint_hw_rr_min_io_rq (char * buff, int len, void * data)
+{
+	struct hwentry * hwe = (struct hwentry *)data;
+
+	if (!hwe->minio_rq)
+		return 0;
+
+	return snprintf(buff, len, "%u", hwe->minio_rq);
+}
+
+static int
 snprint_hw_pg_timeout (char * buff, int len, void * data)
 {
 	struct hwentry * hwe = (struct hwentry *)data;
 
 	if (!hwe->pg_timeout)
 		return 0;
-	if (hwe->pg_timeout == conf->pg_timeout)
-		return 0;
 
 	switch (hwe->pg_timeout) {
 	case PGTIMEOUT_UNDEF:
 		break;
 	case -PGTIMEOUT_NONE:
-		return snprintf(buff, len, "none");
+		return snprintf(buff, len, "\"none\"");
 	default:
 		return snprintf(buff, len, "%i", hwe->pg_timeout);
 	}
@@ -1757,9 +2353,9 @@ snprint_hw_flush_on_last_del (char * buff, int len, void * data)
 
 	switch (hwe->flush_on_last_del) {
 	case FLUSH_DISABLED:
-		return snprintf(buff, len, "no");
+		return snprintf(buff, len, "\"no\"");
 	case FLUSH_ENABLED:
-		return snprintf(buff, len, "yes");
+		return snprintf(buff, len, "\"yes\"");
 	}
 	return 0;
 }
@@ -1771,28 +2367,64 @@ snprint_hw_path_checker (char * buff, int len, void * data)
 
 	if (!hwe->checker_name)
 		return 0;
-	if (conf->checker_name &&
-	    !strcmp(hwe->checker_name, conf->checker_name))
+
+	return snprintf(buff, len, "\"%s\"", hwe->checker_name);
+}
+
+	static int
+snprint_hw_user_friendly_names (char * buff, int len, void * data)
+{
+	struct hwentry * hwe = (struct hwentry *)data;
+
+	if (hwe->user_friendly_names == USER_FRIENDLY_NAMES_UNDEF)
+		return 0;
+	else if (hwe->user_friendly_names == USER_FRIENDLY_NAMES_OFF)
+		return snprintf(buff, len, "\"no\"");
+	else
+		return snprintf(buff, len, "\"yes\"");
+}
+
+static int
+snprint_hw_retain_hwhandler_handler(char * buff, int len, void * data)
+{
+	struct hwentry * hwe = (struct hwentry *)data;
+
+	if (hwe->retain_hwhandler == RETAIN_HWHANDLER_ON)
+		return snprintf(buff, len, "\"yes\"");
+	else if (hwe->retain_hwhandler == RETAIN_HWHANDLER_OFF)
+		return snprintf(buff, len, "\"no\"");
+	else
 		return 0;
+}
+
+static int
+snprint_detect_prio(char * buff, int len, void * data)
+{
+	struct hwentry * hwe = (struct hwentry *)data;
 
-	return snprintf(buff, len, "%s", hwe->checker_name);
+	if (hwe->detect_prio == DETECT_PRIO_ON)
+		return snprintf(buff, len, "\"yes\"");
+	else if (hwe->detect_prio == DETECT_PRIO_OFF)
+		return snprintf(buff, len, "\"no\"");
+	else
+		return 0;
 }
 
 static int
 snprint_def_polling_interval (char * buff, int len, void * data)
 {
-	if (conf->checkint == DEFAULT_CHECKINT)
-		return 0;
 	return snprintf(buff, len, "%i", conf->checkint);
 }
 
 static int
 snprint_def_fast_io_fail(char * buff, int len, void * data)
 {
-	if (!conf->fast_io_fail)
+	if (conf->fast_io_fail == MP_FAST_IO_FAIL_UNSET)
 		return 0;
-	if (conf->fast_io_fail == -1)
-		return snprintf(buff, len, "off");
+	if (conf->fast_io_fail == MP_FAST_IO_FAIL_OFF)
+		return snprintf(buff, len, "\"off\"");
+	if (conf->fast_io_fail == MP_FAST_IO_FAIL_ZERO)
+		return snprintf(buff, len, "0");
 	return snprintf(buff, len, "%d", conf->fast_io_fail);
 }
 
@@ -1801,36 +2433,38 @@ snprint_def_dev_loss(char * buff, int len, void * data)
 {
 	if (!conf->dev_loss)
 		return 0;
+	if (conf->dev_loss >= MAX_DEV_LOSS_TMO)
+		return snprintf(buff, len, "\"infinity\"");
 	return snprintf(buff, len, "%u", conf->dev_loss);
 }
 
 static int
 snprint_def_verbosity (char * buff, int len, void * data)
 {
-	if (conf->checkint == DEFAULT_VERBOSITY)
-		return 0;
 	return snprintf(buff, len, "%i", conf->verbosity);
 }
 
 static int
-snprint_def_udev_dir (char * buff, int len, void * data)
+snprint_def_max_polling_interval (char * buff, int len, void * data)
 {
-	if (!conf->udev_dir)
-		return 0;
-	if (strlen(DEFAULT_UDEVDIR) == strlen(conf->udev_dir) &&
-	    !strcmp(conf->udev_dir, DEFAULT_UDEVDIR))
+	if (conf->max_checkint == MAX_CHECKINT(conf->checkint))
 		return 0;
+	return snprintf(buff, len, "%i", conf->max_checkint);
+}
 
-	return snprintf(buff, len, "\"%s\"", conf->udev_dir);
+static int
+snprint_reassign_maps (char * buff, int len, void * data)
+{
+	if (conf->reassign_maps == DEFAULT_REASSIGN_MAPS)
+		return 0;
+	return snprintf(buff, len, "\"%s\"",
+			conf->reassign_maps?"yes":"no");
 }
 
 static int
 snprint_def_multipath_dir (char * buff, int len, void * data)
 {
-	if (!conf->udev_dir)
-		return 0;
-	if (strlen(DEFAULT_MULTIPATHDIR) == strlen(conf->multipath_dir) &&
-	    !strcmp(conf->multipath_dir, DEFAULT_MULTIPATHDIR))
+	if (!conf->multipath_dir)
 		return 0;
 
 	return snprintf(buff, len, "\"%s\"", conf->multipath_dir);
@@ -1840,75 +2474,57 @@ static int
 snprint_def_selector (char * buff, int len, void * data)
 {
 	if (!conf->selector)
-		return 0;
-	if (strlen(conf->selector) == strlen(DEFAULT_SELECTOR) &&
-	    !strcmp(conf->selector, DEFAULT_SELECTOR))
-		return 0;
+		return snprintf(buff, len, "\"%s\"", DEFAULT_SELECTOR);
 
-	return snprintf(buff, len, "%s", conf->selector);
+	return snprintf(buff, len, "\"%s\"", conf->selector);
 }
 
 static int
 snprint_def_path_grouping_policy (char * buff, int len, void * data)
 {
 	char str[POLICY_NAME_SIZE];
+	int pgpolicy = conf->pgpolicy;
 
-	if (!conf->pgpolicy)
-		return 0;
-	if (conf->pgpolicy == DEFAULT_PGPOLICY)
-		return 0;
+	if (!pgpolicy)
+		pgpolicy = DEFAULT_PGPOLICY;
 
-	get_pgpolicy_name(str, POLICY_NAME_SIZE, conf->pgpolicy);
+	get_pgpolicy_name(str, POLICY_NAME_SIZE, pgpolicy);
 
-	return snprintf(buff, len, "%s", str);
+	return snprintf(buff, len, "\"%s\"", str);
 }
 
 static int
-snprint_def_getuid_callout (char * buff, int len, void * data)
+snprint_def_uid_attribute (char * buff, int len, void * data)
 {
-	if (!conf->getuid)
-		return 0;
-	if (strlen(conf->getuid) == strlen(DEFAULT_GETUID) &&
-	    !strcmp(conf->getuid, DEFAULT_GETUID))
-		return 0;
+	if (!conf->uid_attribute)
+		return snprintf(buff, len, "\"%s\"", DEFAULT_UID_ATTRIBUTE);
 
-	return snprintf(buff, len, "\"%s\"", conf->getuid);
+	return snprintf(buff, len, "\"%s\"", conf->uid_attribute);
 }
 
 static int
 snprint_def_prio (char * buff, int len, void * data)
 {
 	if (!conf->prio_name)
-		return 0;
-
-	if (strlen(conf->prio_name) == strlen(DEFAULT_PRIO) &&
-	    !strcmp(conf->prio_name, DEFAULT_PRIO))
-		return 0;
+		return snprintf(buff, len, "\"%s\"", DEFAULT_PRIO);
 
-	return snprintf(buff, len, "%s", conf->prio_name);
+	return snprintf(buff, len, "\"%s\"", conf->prio_name);
 }
 
 static int
 snprint_def_prio_args (char * buff, int len, void * data)
 {
 	if (!conf->prio_args)
-		return 0;
-
-	if (strlen(conf->prio_args) == strlen(DEFAULT_PRIO_ARGS) &&
-	    !strcmp(conf->prio_args, DEFAULT_PRIO_ARGS))
-		return 0;
+		return snprintf(buff, len, "\"%s\"", DEFAULT_PRIO_ARGS);
 
-	return snprintf(buff, len, "%s", conf->prio_args);
+	return snprintf(buff, len, "\"%s\"", conf->prio_args);
 }
 
 static int
 snprint_def_features (char * buff, int len, void * data)
 {
 	if (!conf->features)
-		return 0;
-	if (strlen(conf->features) == strlen(DEFAULT_FEATURES) &&
-	    !strcmp(conf->features, DEFAULT_FEATURES))
-		return 0;
+		return snprintf(buff, len, "\"%s\"", DEFAULT_FEATURES);
 
 	return snprintf(buff, len, "\"%s\"", conf->features);
 }
@@ -1917,29 +2533,27 @@ static int
 snprint_def_path_checker (char * buff, int len, void * data)
 {
 	if (!conf->checker_name)
-		return 0;
-	if (strlen(conf->checker_name) == strlen(DEFAULT_CHECKER) &&
-	    !strcmp(conf->checker_name, DEFAULT_CHECKER))
-		return 0;
+		return snprintf(buff, len, "\"%s\"", DEFAULT_CHECKER);
 
-	return snprintf(buff, len, "%s", conf->checker_name);
+	return snprintf(buff, len, "\"%s\"", conf->checker_name);
 }
 
 static int
 snprint_def_failback (char * buff, int len, void * data)
 {
-	if (!conf->pgfailback)
-		return 0;
-	if (conf->pgfailback == DEFAULT_FAILBACK)
-		return 0;
+	int pgfailback = conf->pgfailback;
+	if (!pgfailback)
+		pgfailback = DEFAULT_FAILBACK;
 
 	switch(conf->pgfailback) {
 	case  FAILBACK_UNDEF:
 		break;
 	case -FAILBACK_MANUAL:
-		return snprintf(buff, len, "manual");
+		return snprintf(buff, len, "\"manual\"");
 	case -FAILBACK_IMMEDIATE:
-		return snprintf(buff, len, "immediate");
+		return snprintf(buff, len, "\"immediate\"");
+	case -FAILBACK_FOLLOWOVER:
+		return snprintf(buff, len, "\"followover\"");
 	default:
 		return snprintf(buff, len, "%i", conf->pgfailback);
 	}
@@ -1951,13 +2565,20 @@ snprint_def_rr_min_io (char * buff, int len, void * data)
 {
 	if (!conf->minio)
 		return 0;
-	if (conf->minio == DEFAULT_MINIO)
-		return 0;
 
 	return snprintf(buff, len, "%u", conf->minio);
 }
 
 static int
+snprint_def_rr_min_io_rq (char * buff, int len, void * data)
+{
+	if (!conf->minio_rq)
+		return 0;
+
+	return snprintf(buff, len, "%u", conf->minio_rq);
+}
+
+static int
 snprint_max_fds (char * buff, int len, void * data)
 {
 	if (!conf->max_fds)
@@ -1993,12 +2614,10 @@ snprint_def_gid(char * buff, int len, void * data)
 static int
 snprint_def_rr_weight (char * buff, int len, void * data)
 {
-	if (!conf->rr_weight)
-		return 0;
-	if (conf->rr_weight == DEFAULT_RR_WEIGHT)
-		return 0;
+	if (!conf->rr_weight || conf->rr_weight == RR_WEIGHT_NONE)
+		return snprintf(buff, len, "\"uniform\"");
 	if (conf->rr_weight == RR_WEIGHT_PRIO)
-		return snprintf(buff, len, "priorities");
+		return snprintf(buff, len, "\"priorities\"");
 
 	return 0;
 }
@@ -2006,16 +2625,13 @@ snprint_def_rr_weight (char * buff, int len, void * data)
 static int
 snprint_def_no_path_retry (char * buff, int len, void * data)
 {
-	if (conf->no_path_retry == DEFAULT_NO_PATH_RETRY)
-		return 0;
-
 	switch(conf->no_path_retry) {
 	case NO_PATH_RETRY_UNDEF:
 		break;
 	case NO_PATH_RETRY_FAIL:
-		return snprintf(buff, len, "fail");
+		return snprintf(buff, len, "\"fail\"");
 	case NO_PATH_RETRY_QUEUE:
-		return snprintf(buff, len, "queue");
+		return snprintf(buff, len, "\"queue\"");
 	default:
 		return snprintf(buff, len, "%i",
 				conf->no_path_retry);
@@ -2028,24 +2644,31 @@ snprint_def_queue_without_daemon (char * buff, int len, void * data)
 {
 	switch (conf->queue_without_daemon) {
 	case QUE_NO_DAEMON_OFF:
-		return snprintf(buff, len, "no");
+		return snprintf(buff, len, "\"no\"");
 	case QUE_NO_DAEMON_ON:
-		return snprintf(buff, len, "yes");
+		return snprintf(buff, len, "\"yes\"");
+	case QUE_NO_DAEMON_FORCE:
+		return snprintf(buff, len, "\"forced\"");
 	}
 	return 0;
 }
 
 static int
-snprint_def_pg_timeout (char * buff, int len, void * data)
+snprint_def_checker_timeout (char *buff, int len, void *data)
 {
-	if (conf->pg_timeout == DEFAULT_PGTIMEOUT)
+	if (!conf->checker_timeout)
 		return 0;
 
+	return snprintf(buff, len, "%u", conf->checker_timeout);
+}
+
+static int
+snprint_def_pg_timeout (char * buff, int len, void * data)
+{
 	switch (conf->pg_timeout) {
 	case PGTIMEOUT_UNDEF:
-		break;
 	case -PGTIMEOUT_NONE:
-		return snprintf(buff, len, "none");
+		return snprintf(buff, len, "\"none\"");
 	default:
 		return snprintf(buff, len, "%i", conf->pg_timeout);
 	}
@@ -2056,23 +2679,92 @@ static int
 snprint_def_flush_on_last_del (char * buff, int len, void * data)
 {
 	switch (conf->flush_on_last_del) {
+	case FLUSH_UNDEF:
 	case FLUSH_DISABLED:
-		return snprintf(buff, len, "no");
+		return snprintf(buff, len, "\"no\"");
 	case FLUSH_ENABLED:
-		return snprintf(buff, len, "yes");
+	case FLUSH_IN_PROGRESS:
+		return snprintf(buff, len, "\"yes\"");
 	}
 	return 0;
 }
 
 static int
+snprint_def_log_checker_err (char * buff, int len, void * data)
+{
+	if (conf->log_checker_err == LOG_CHKR_ERR_ONCE)
+		return snprintf(buff, len, "once");
+	return snprintf(buff, len, "always");
+}
+
+static int
 snprint_def_user_friendly_names (char * buff, int len, void * data)
 {
-	if (conf->user_friendly_names == DEFAULT_USER_FRIENDLY_NAMES)
+	if (conf->user_friendly_names  == USER_FRIENDLY_NAMES_ON)
+		return snprintf(buff, len, "\"yes\"");
+	else
+		return snprintf(buff, len, "\"no\"");
+}
+
+static int
+snprint_def_alias_prefix (char * buff, int len, void * data)
+{
+	if (!conf->alias_prefix)
+		return snprintf(buff, len, "\"%s\"", DEFAULT_ALIAS_PREFIX);
+	return snprintf(buff, len, "\"%s\"", conf->alias_prefix);
+}
+
+static int
+snprint_def_bindings_file (char * buff, int len, void * data)
+{
+	if (conf->bindings_file == NULL)
 		return 0;
-	if (!conf->user_friendly_names)
+	return snprintf(buff, len, "\"%s\"", conf->bindings_file);
+}
+
+static int
+snprint_def_wwids_file (char * buff, int len, void * data)
+{
+	if (conf->wwids_file == NULL)
+		return 0;
+	return snprintf(buff, len, "%s", conf->wwids_file);
+}
+
+static int
+snprint_def_reservation_key(char * buff, int len, void * data)
+{
+	int i;
+	unsigned char *keyp;
+	uint64_t prkey = 0;
+
+	if (!conf->reservation_key)
+		return 0;
+	keyp = (unsigned char *)conf->reservation_key;
+	for (i = 0; i < 8; i++) {
+		if (i > 0)
+			prkey <<= 8;
+		prkey |= *keyp;
+		keyp++;
+	}
+	return snprintf(buff, len, "0x%" PRIx64, prkey);
+}
+
+static int
+snprint_def_retain_hwhandler_handler(char * buff, int len, void * data)
+{
+	if (conf->retain_hwhandler == RETAIN_HWHANDLER_ON)
+		return snprintf(buff, len, "yes");
+	else
 		return snprintf(buff, len, "no");
+}
 
-	return snprintf(buff, len, "yes");
+static int
+snprint_def_detect_prio(char * buff, int len, void * data)
+{
+	if (conf->detect_prio == DETECT_PRIO_ON)
+		return snprintf(buff, len, "yes");
+	else
+		return snprintf(buff, len, "no");
 }
 
 static int
@@ -2107,48 +2799,58 @@ init_keywords(void)
 	install_keyword_root("defaults", NULL);
 	install_keyword("verbosity", &verbosity_handler, &snprint_def_verbosity);
 	install_keyword("polling_interval", &polling_interval_handler, &snprint_def_polling_interval);
-	install_keyword("udev_dir", &udev_dir_handler, &snprint_def_udev_dir);
+	install_keyword("max_polling_interval", &max_polling_interval_handler, &snprint_def_max_polling_interval);
+	install_keyword("reassign_maps", &reassign_maps_handler, &snprint_reassign_maps);
 	install_keyword("multipath_dir", &multipath_dir_handler, &snprint_def_multipath_dir);
-	install_keyword("selector", &def_selector_handler, &snprint_def_selector);
+	install_keyword("path_selector", &def_selector_handler, &snprint_def_selector);
 	install_keyword("path_grouping_policy", &def_pgpolicy_handler, &snprint_def_path_grouping_policy);
-	install_keyword("getuid_callout", &def_getuid_callout_handler, &snprint_def_getuid_callout);
+	install_keyword("uid_attribute", &def_uid_attribute_handler, &snprint_def_uid_attribute);
 	install_keyword("prio", &def_prio_handler, &snprint_def_prio);
 	install_keyword("prio_args", &def_prio_args_handler, &snprint_def_prio_args);
 	install_keyword("features", &def_features_handler, &snprint_def_features);
 	install_keyword("path_checker", &def_path_checker_handler, &snprint_def_path_checker);
-	install_keyword("checker", &def_path_checker_handler, &snprint_def_path_checker);
+	install_keyword("checker", &def_path_checker_handler, NULL);
+	install_keyword("alias_prefix", &def_alias_prefix_handler, &snprint_def_alias_prefix);
 	install_keyword("failback", &default_failback_handler, &snprint_def_failback);
 	install_keyword("rr_min_io", &def_minio_handler, &snprint_def_rr_min_io);
+	install_keyword("rr_min_io_rq", &def_minio_rq_handler, &snprint_def_rr_min_io_rq);
 	install_keyword("max_fds", &max_fds_handler, &snprint_max_fds);
 	install_keyword("rr_weight", &def_weight_handler, &snprint_def_rr_weight);
 	install_keyword("no_path_retry", &def_no_path_retry_handler, &snprint_def_no_path_retry);
 	install_keyword("queue_without_daemon", &def_queue_without_daemon, &snprint_def_queue_without_daemon);
+	install_keyword("checker_timeout", &def_checker_timeout_handler, &snprint_def_checker_timeout);
 	install_keyword("pg_timeout", &def_pg_timeout_handler, &snprint_def_pg_timeout);
 	install_keyword("flush_on_last_del", &def_flush_on_last_del_handler, &snprint_def_flush_on_last_del);
-	install_keyword("user_friendly_names", &names_handler, &snprint_def_user_friendly_names);
+	install_keyword("user_friendly_names", &def_names_handler, &snprint_def_user_friendly_names);
 	install_keyword("mode", &def_mode_handler, &snprint_def_mode);
 	install_keyword("uid", &def_uid_handler, &snprint_def_uid);
 	install_keyword("gid", &def_gid_handler, &snprint_def_gid);
 	install_keyword("fast_io_fail_tmo", &def_fast_io_fail_handler, &snprint_def_fast_io_fail);
 	install_keyword("dev_loss_tmo", &def_dev_loss_handler, &snprint_def_dev_loss);
+	install_keyword("bindings_file", &bindings_file_handler, &snprint_def_bindings_file);
+	install_keyword("wwids_file", &wwids_file_handler, &snprint_def_wwids_file);
+	install_keyword("log_checker_err", &def_log_checker_err_handler, &snprint_def_log_checker_err);
+	install_keyword("reservation_key", &def_reservation_key_handler, &snprint_def_reservation_key);
+	install_keyword("retain_attached_hw_handler", &def_retain_hwhandler_handler, &snprint_def_retain_hwhandler_handler);
+	install_keyword("detect_prio", &def_detect_prio_handler, &snprint_def_detect_prio);
 	__deprecated install_keyword("default_selector", &def_selector_handler, NULL);
 	__deprecated install_keyword("default_path_grouping_policy", &def_pgpolicy_handler, NULL);
-	__deprecated install_keyword("default_getuid_callout", &def_getuid_callout_handler, NULL);
+	__deprecated install_keyword("default_uid_attribute", &def_uid_attribute_handler, NULL);
 	__deprecated install_keyword("default_features", &def_features_handler, NULL);
 	__deprecated install_keyword("default_path_checker", &def_path_checker_handler, NULL);
 
 	install_keyword_root("blacklist", &blacklist_handler);
-	install_keyword("devnode", &ble_devnode_handler, &snprint_ble_simple);
-	install_keyword("wwid", &ble_wwid_handler, &snprint_ble_simple);
-	install_keyword("device", &ble_device_handler, NULL);
+	install_keyword_multi("devnode", &ble_devnode_handler, &snprint_ble_simple);
+	install_keyword_multi("wwid", &ble_wwid_handler, &snprint_ble_simple);
+	install_keyword_multi("device", &ble_device_handler, NULL);
 	install_sublevel();
 	install_keyword("vendor", &ble_vendor_handler, &snprint_bled_vendor);
 	install_keyword("product", &ble_product_handler, &snprint_bled_product);
 	install_sublevel_end();
 	install_keyword_root("blacklist_exceptions", &blacklist_exceptions_handler);
-	install_keyword("devnode", &ble_except_devnode_handler, &snprint_ble_simple);
-	install_keyword("wwid", &ble_except_wwid_handler, &snprint_ble_simple);
-	install_keyword("device", &ble_except_device_handler, NULL);
+	install_keyword_multi("devnode", &ble_except_devnode_handler, &snprint_ble_simple);
+	install_keyword_multi("wwid", &ble_except_wwid_handler, &snprint_ble_simple);
+	install_keyword_multi("device", &ble_except_device_handler, NULL);
 	install_sublevel();
 	install_keyword("vendor", &ble_except_vendor_handler, &snprint_bled_vendor);
 	install_keyword("product", &ble_except_product_handler, &snprint_bled_product);
@@ -2166,16 +2868,18 @@ init_keywords(void)
 #endif
 
 	install_keyword_root("devices", &devices_handler);
-	install_keyword("device", &device_handler, NULL);
+	install_keyword_multi("device", &device_handler, NULL);
 	install_sublevel();
 	install_keyword("vendor", &vendor_handler, &snprint_hw_vendor);
 	install_keyword("product", &product_handler, &snprint_hw_product);
+	install_keyword("revision", &revision_handler, &snprint_hw_revision);
 	install_keyword("product_blacklist", &bl_product_handler, &snprint_hw_bl_product);
 	install_keyword("path_grouping_policy", &hw_pgpolicy_handler, &snprint_hw_path_grouping_policy);
-	install_keyword("getuid_callout", &hw_getuid_callout_handler, &snprint_hw_getuid_callout);
+	install_keyword("uid_attribute", &hw_uid_attribute_handler, &snprint_hw_uid_attribute);
 	install_keyword("path_selector", &hw_selector_handler, &snprint_hw_selector);
 	install_keyword("path_checker", &hw_path_checker_handler, &snprint_hw_path_checker);
-	install_keyword("checker", &hw_path_checker_handler, &snprint_hw_path_checker);
+	install_keyword("checker", &hw_path_checker_handler, NULL);
+	install_keyword("alias_prefix", &hw_alias_prefix_handler, &snprint_hw_alias_prefix);
 	install_keyword("features", &hw_features_handler, &snprint_hw_features);
 	install_keyword("hardware_handler", &hw_handler_handler, &snprint_hw_hardware_handler);
 	install_keyword("prio", &hw_prio_handler, &snprint_hw_prio);
@@ -2184,27 +2888,37 @@ init_keywords(void)
 	install_keyword("rr_weight", &hw_weight_handler, &snprint_hw_rr_weight);
 	install_keyword("no_path_retry", &hw_no_path_retry_handler, &snprint_hw_no_path_retry);
 	install_keyword("rr_min_io", &hw_minio_handler, &snprint_hw_rr_min_io);
+	install_keyword("rr_min_io_rq", &hw_minio_rq_handler, &snprint_hw_rr_min_io_rq);
 	install_keyword("pg_timeout", &hw_pg_timeout_handler, &snprint_hw_pg_timeout);
 	install_keyword("flush_on_last_del", &hw_flush_on_last_del_handler, &snprint_hw_flush_on_last_del);
 	install_keyword("fast_io_fail_tmo", &hw_fast_io_fail_handler, &snprint_hw_fast_io_fail);
 	install_keyword("dev_loss_tmo", &hw_dev_loss_handler, &snprint_hw_dev_loss);
+	install_keyword("user_friendly_names", &hw_names_handler, &snprint_hw_user_friendly_names);
+	install_keyword("retain_attached_hw_handler", &hw_retain_hwhandler_handler, &snprint_hw_retain_hwhandler_handler);
+	install_keyword("detect_prio", &hw_detect_prio_handler, &snprint_detect_prio);
 	install_sublevel_end();
 
 	install_keyword_root("multipaths", &multipaths_handler);
-	install_keyword("multipath", &multipath_handler, NULL);
+	install_keyword_multi("multipath", &multipath_handler, NULL);
 	install_sublevel();
 	install_keyword("wwid", &wwid_handler, &snprint_mp_wwid);
 	install_keyword("alias", &alias_handler, &snprint_mp_alias);
 	install_keyword("path_grouping_policy", &mp_pgpolicy_handler, &snprint_mp_path_grouping_policy);
 	install_keyword("path_selector", &mp_selector_handler, &snprint_mp_selector);
+	install_keyword("prio", &mp_prio_handler, &snprint_mp_prio);
+	install_keyword("prio_args", &mp_prio_args_handler, &snprint_mp_prio_args);
 	install_keyword("failback", &mp_failback_handler, &snprint_mp_failback);
 	install_keyword("rr_weight", &mp_weight_handler, &snprint_mp_rr_weight);
 	install_keyword("no_path_retry", &mp_no_path_retry_handler, &snprint_mp_no_path_retry);
 	install_keyword("rr_min_io", &mp_minio_handler, &snprint_mp_rr_min_io);
+	install_keyword("rr_min_io_rq", &mp_minio_rq_handler, &snprint_mp_rr_min_io_rq);
 	install_keyword("pg_timeout", &mp_pg_timeout_handler, &snprint_mp_pg_timeout);
 	install_keyword("flush_on_last_del", &mp_flush_on_last_del_handler, &snprint_mp_flush_on_last_del);
+	install_keyword("features", &mp_features_handler, &snprint_mp_features);
 	install_keyword("mode", &mp_mode_handler, &snprint_mp_mode);
 	install_keyword("uid", &mp_uid_handler, &snprint_mp_uid);
 	install_keyword("gid", &mp_gid_handler, &snprint_mp_gid);
+	install_keyword("reservation_key", &mp_reservation_key_handler, &snprint_mp_reservation_key);
+	install_keyword("user_friendly_names", &mp_names_handler, &snprint_mp_user_friendly_names);
 	install_sublevel_end();
 }
diff --git a/libmultipath/dict.h b/libmultipath/dict.h
index 5f77473..688eab7 100644
--- a/libmultipath/dict.h
+++ b/libmultipath/dict.h
@@ -6,5 +6,6 @@
 #endif
 
 void init_keywords(void);
+int get_sys_max_fds(int *);
 
 #endif /* _DICT_H */
diff --git a/libmultipath/discovery.c b/libmultipath/discovery.c
index 122eb8f..26983ca 100644
--- a/libmultipath/discovery.c
+++ b/libmultipath/discovery.c
@@ -10,6 +10,8 @@
 #include <sys/stat.h>
 #include <dirent.h>
 #include <errno.h>
+#include <libgen.h>
+#include <libudev.h>
 
 #include "checkers.h"
 #include "vector.h"
@@ -18,70 +20,78 @@
 #include "structs.h"
 #include "config.h"
 #include "blacklist.h"
-#include "callout.h"
 #include "debug.h"
 #include "propsel.h"
 #include "sg_include.h"
 #include "sysfs.h"
 #include "discovery.h"
 #include "prio.h"
+#include "defaults.h"
 
-struct path *
-store_pathinfo (vector pathvec, vector hwtable, char * devname, int flag)
+int
+store_pathinfo (vector pathvec, vector hwtable, struct udev_device *udevice,
+		int flag, struct path **pp_ptr)
 {
+	int err = 1;
 	struct path * pp;
+	const char * devname;
+
+	if (pp_ptr)
+		*pp_ptr = NULL;
+
+	devname = udev_device_get_sysname(udevice);
+	if (!devname)
+		return 1;
 
 	pp = alloc_path();
 
 	if (!pp)
-		return NULL;
+		return 1;
 
 	if(safe_sprintf(pp->dev, "%s", devname)) {
 		condlog(0, "pp->dev too small");
 		goto out;
 	}
-	if (pathinfo(pp, hwtable, flag))
+	pp->udev = udev_device_ref(udevice);
+	err = pathinfo(pp, hwtable,
+		       (conf->dry_run == 3)? flag : (flag | DI_BLACKLIST));
+	if (err)
 		goto out;
 
-	if (store_path(pathvec, pp))
+	err = store_path(pathvec, pp);
+	if (err)
 		goto out;
 
-	return pp;
 out:
-	free_path(pp);
-	return NULL;
+	if (err)
+		free_path(pp);
+	else if (pp_ptr)
+		*pp_ptr = pp;
+	return err;
 }
 
 static int
-path_discover (vector pathvec, struct config * conf, char * devname, int flag)
+path_discover (vector pathvec, struct config * conf,
+	       struct udev_device *udevice, int flag)
 {
-	char path[FILE_NAME_SIZE];
 	struct path * pp;
+	const char * devname;
 
+	devname = udev_device_get_sysname(udevice);
 	if (!devname)
 		return 0;
 
 	if (filter_devnode(conf->blist_devnode, conf->elist_devnode,
-			   devname) > 0)
+			   (char *)devname) > 0)
 		return 0;
 
-	if(safe_sprintf(path, "%s/block/%s/device", sysfs_path,
-			devname)) {
-		condlog(0, "path too small");
-		return 1;
-	}
-
-	if (strncmp(devname,"cciss",5) && !filepresent(path)) {
-		condlog(4, "path %s not present", path);
-		return 0;
-	}
-
-	pp = find_path_by_dev(pathvec, devname);
-
+	pp = find_path_by_dev(pathvec, (char *)devname);
 	if (!pp) {
-		pp = store_pathinfo(pathvec, conf->hwtable,
-				    devname, flag);
-		return (pp ? 0 : 1);
+		if (store_pathinfo(pathvec, conf->hwtable,
+				   udevice, flag, NULL) != 1)
+			return 0;
+		else
+			return 1;
 	}
 	return pathinfo(pp, conf->hwtable, flag);
 }
@@ -89,54 +99,62 @@ path_discover (vector pathvec, struct config * conf, char * devname, int flag)
 int
 path_discovery (vector pathvec, struct config * conf, int flag)
 {
-	DIR *blkdir;
-	struct dirent *blkdev;
-	struct stat statbuf;
-	char devpath[PATH_MAX];
-	char *devptr;
+	struct udev_enumerate *udev_iter;
+	struct udev_list_entry *entry;
+	struct udev_device *udevice;
+	const char *devpath;
 	int r = 0;
 
-	if (!(blkdir = opendir("/sys/block")))
+	udev_iter = udev_enumerate_new(conf->udev);
+	if (!udev_iter)
 		return 1;
 
-	strcpy(devpath,"/sys/block");
-	while ((blkdev = readdir(blkdir)) != NULL) {
-		if ((strcmp(blkdev->d_name,".") == 0) ||
-		    (strcmp(blkdev->d_name,"..") == 0))
-			continue;
-
-		devptr = devpath + 10;
-		*devptr = '\0';
-		strcat(devptr,"/");
-		strcat(devptr,blkdev->d_name);
-		if (stat(devpath, &statbuf) < 0)
-			continue;
-
-		if (S_ISDIR(statbuf.st_mode) == 0)
-			continue;
+	udev_enumerate_add_match_subsystem(udev_iter, "block");
+	udev_enumerate_scan_devices(udev_iter);
 
+	udev_list_entry_foreach(entry,
+				udev_enumerate_get_list_entry(udev_iter)) {
+		const char *devtype;
+		devpath = udev_list_entry_get_name(entry);
 		condlog(4, "Discover device %s", devpath);
-
-		r += path_discover(pathvec, conf, blkdev->d_name, flag);
+		udevice = udev_device_new_from_syspath(conf->udev, devpath);
+		if (!udevice) {
+			condlog(4, "%s: no udev information", devpath);
+			r++;
+			continue;
+		}
+		devtype = udev_device_get_devtype(udevice);
+		if(devtype && !strncmp(devtype, "disk", 4))
+			r += path_discover(pathvec, conf, udevice, flag);
+		udev_device_unref(udevice);
 	}
-	closedir(blkdir);
+	udev_enumerate_unref(udev_iter);
 	condlog(4, "Discovery status %d", r);
 	return r;
 }
 
-#define declare_sysfs_get_str(fname) \
-extern int \
-sysfs_get_##fname (struct sysfs_device * dev, char * buff, size_t len) \
-{ \
-	char *attr; \
-\
-	attr = sysfs_attr_get_value(dev->devpath, #fname); \
-	if (!attr) \
-		return 1; \
-	if (strlcpy(buff, attr, len) != strlen(attr)) \
-		return 2; \
-	strchop(buff); \
-	return 0; \
+#define declare_sysfs_get_str(fname)					\
+extern int								\
+sysfs_get_##fname (struct udev_device * udev, char * buff, size_t len)	\
+{									\
+	const char * attr;						\
+	const char * devname;						\
+									\
+	devname = udev_device_get_sysname(udev);			\
+									\
+	attr = udev_device_get_sysattr_value(udev, #fname);		\
+	if (!attr) {							\
+		condlog(3, "%s: attribute %s not found in sysfs",	\
+			devname, #fname);				\
+		return 1;						\
+	}								\
+	if (strlen(attr) > len) {					\
+		condlog(3, "%s: overflow in attribute %s",		\
+			devname, #fname);				\
+		return 2;						\
+	}								\
+	strlcpy(buff, attr, len);					\
+	return 0;							\
 }
 
 declare_sysfs_get_str(devtype);
@@ -145,175 +163,316 @@ declare_sysfs_get_str(vendor);
 declare_sysfs_get_str(model);
 declare_sysfs_get_str(rev);
 declare_sysfs_get_str(state);
+declare_sysfs_get_str(dev);
 
 int
-sysfs_get_dev (struct sysfs_device * dev, char * buff, size_t len)
+sysfs_get_timeout(struct path *pp, unsigned int *timeout)
 {
-	char *attr;
+	const char *attr = NULL;
+	const char *subsys;
+	struct udev_device *parent;
+	int r;
+	unsigned int t;
 
-	attr = sysfs_attr_get_value(dev->devpath, "dev");
-	if (!attr) {
-		condlog(3, "%s: no 'dev' attribute in sysfs", dev->kernel);
+	if (!pp->udev || pp->bus != SYSFS_BUS_SCSI)
 		return 1;
+
+	parent = pp->udev;
+	while (parent) {
+		subsys = udev_device_get_subsystem(parent);
+		attr = udev_device_get_sysattr_value(parent, "timeout");
+		if (subsys && attr)
+			break;
+		parent = udev_device_get_parent(parent);
 	}
-	if (strlcpy(buff, attr, len) != strlen(attr)) {
-		condlog(3, "%s: overflow in 'dev' attribute", dev->kernel);
-		return 2;
+	if (!attr) {
+		condlog(3, "%s: No timeout value in sysfs", pp->dev);
+		return 1;
 	}
-	return 0;
-}
 
-int
-sysfs_get_size (struct sysfs_device * dev, unsigned long long * size)
-{
-	char *attr;
-	int r;
+	r = sscanf(attr, "%u\n", &t);
 
-	attr = sysfs_attr_get_value(dev->devpath, "size");
-	if (!attr)
+	if (r != 1) {
+		condlog(3, "%s: Cannot parse timeout attribute '%s'",
+			pp->dev, attr);
 		return 1;
+	}
 
-	r = sscanf(attr, "%llu\n", size);
-
-	if (r != 1)
-		return 1;
+	*timeout = t * 1000;
 
 	return 0;
 }
 
 int
-sysfs_get_fc_nodename (struct sysfs_device * dev, char * node,
-		       unsigned int host, unsigned int channel,
-		       unsigned int target)
+sysfs_get_tgt_nodename (struct path *pp, char * node)
 {
-	char attr_path[SYSFS_PATH_SIZE], *attr;
+	const char *tgtname, *value;
+	struct udev_device *parent, *tgtdev;
+	int host, channel, tgtid = -1;
 
-	if (safe_sprintf(attr_path,
-			 "/class/fc_transport/target%i:%i:%i",
-			 host, channel, target)) {
-		condlog(0, "attr_path too small");
+	parent = udev_device_get_parent_with_subsystem_devtype(pp->udev, "scsi", "scsi_device");
+	if (!parent)
 		return 1;
+	/* Check for SAS */
+	value = udev_device_get_sysattr_value(parent, "sas_address");
+	if (value) {
+		tgtdev = udev_device_get_parent(parent);
+		while (tgtdev) {
+			tgtname = udev_device_get_sysname(tgtdev);
+			if (sscanf(tgtname, "end_device-%d:%d",
+				   &host, &tgtid) == 2)
+				break;
+			tgtdev = udev_device_get_parent(tgtdev);
+			tgtid = -1;
+		}
+		if (tgtid >= 0) {
+			pp->sg_id.proto_id = SCSI_PROTOCOL_SAS;
+			pp->sg_id.transport_id = tgtid;
+			strncpy(node, value, NODE_NAME_SIZE);
+			return 0;
+		}
 	}
 
-	attr = sysfs_attr_get_value(attr_path, "node_name");
-	if (attr) {
-		strlcpy(node, attr, strlen(attr));
-		return 0;
+	parent = udev_device_get_parent_with_subsystem_devtype(pp->udev, "scsi", "scsi_target");
+	if (!parent)
+		return 1;
+	/* Check for FibreChannel */
+	tgtdev = udev_device_get_parent(parent);
+	value = udev_device_get_sysname(tgtdev);
+	if (sscanf(value, "rport-%d:%d-%d",
+		   &host, &channel, &tgtid) == 3) {
+		tgtdev = udev_device_new_from_subsystem_sysname(conf->udev,
+				"fc_remote_ports", value);
+		if (tgtdev) {
+			condlog(3, "SCSI target %d:%d:%d -> "
+				"FC rport %d:%d-%d",
+				pp->sg_id.host_no, pp->sg_id.channel,
+				pp->sg_id.scsi_id, host, channel,
+				tgtid);
+			value = udev_device_get_sysattr_value(tgtdev,
+							      "node_name");
+			if (value) {
+				pp->sg_id.proto_id = SCSI_PROTOCOL_FCP;
+				pp->sg_id.transport_id = tgtid;
+				strncpy(node, value, NODE_NAME_SIZE);
+				udev_device_unref(tgtdev);
+				return 0;
+			} else
+				udev_device_unref(tgtdev);
+		}
 	}
 
+	/* Check for iSCSI */
+	parent = pp->udev;
+	tgtname = NULL;
+	while (parent) {
+		tgtname = udev_device_get_sysname(parent);
+		if (tgtname && sscanf(tgtname , "session%d", &tgtid) == 1)
+			break;
+		parent = udev_device_get_parent(parent);
+		tgtname = NULL;
+		tgtid = -1;
+	}
+	if (parent && tgtname) {
+		tgtdev = udev_device_new_from_subsystem_sysname(conf->udev,
+				"iscsi_session", tgtname);
+		if (tgtdev) {
+			const char *value;
+
+			value = udev_device_get_sysattr_value(tgtdev, "tgtname");
+			if (value) {
+				pp->sg_id.proto_id = SCSI_PROTOCOL_ISCSI;
+				pp->sg_id.transport_id = tgtid;
+				strncpy(node, value, NODE_NAME_SIZE);
+				udev_device_unref(tgtdev);
+				return 0;
+			}
+			else
+				udev_device_unref(tgtdev);
+		}
+	}
+	/* Check for libata */
+	parent = pp->udev;
+	tgtname = NULL;
+	while (parent) {
+		tgtname = udev_device_get_sysname(parent);
+		if (tgtname && sscanf(tgtname, "ata%d", &tgtid) == 1)
+			break;
+		parent = udev_device_get_parent(parent);
+		tgtname = NULL;
+	}
+	if (tgtname) {
+		pp->sg_id.proto_id = SCSI_PROTOCOL_ATA;
+		pp->sg_id.transport_id = tgtid;
+		snprintf(node, NODE_NAME_SIZE, "ata-%d.00", tgtid);
+		return 0;
+	}
+	pp->sg_id.proto_id = SCSI_PROTOCOL_UNSPEC;
 	return 1;
 }
 
-int
-sysfs_set_scsi_tmo (struct multipath *mpp)
+static void
+sysfs_set_rport_tmo(struct multipath *mpp, struct path *pp)
 {
-	char attr_path[SYSFS_PATH_SIZE];
-	struct path *pp;
-	int i;
+	struct udev_device *rport_dev = NULL;
 	char value[11];
-
-	if (!mpp->dev_loss && !mpp->fast_io_fail)
-		return 0;
-	vector_foreach_slot(mpp->paths, pp, i) {
-		if (safe_snprintf(attr_path, SYSFS_PATH_SIZE,
-				  "/class/fc_remote_ports/rport-%d:%d-%d",
-				  pp->sg_id.host_no, pp->sg_id.channel,
-				  pp->sg_id.scsi_id)) {
-			condlog(0, "attr_path '/class/fc_remote_ports/rport-%d:%d-%d' too large", pp->sg_id.host_no, pp->sg_id.channel, pp->sg_id.scsi_id);
-			return 1;
-		}
-		if (mpp->dev_loss){
-			snprintf(value, 11, "%u", mpp->dev_loss);
-			if (sysfs_attr_set_value(attr_path, "dev_loss_tmo",
-						 value))
-				return 1;
+	char rport_id[32];
+
+	sprintf(rport_id, "rport-%d:%d-%d",
+		pp->sg_id.host_no, pp->sg_id.channel, pp->sg_id.transport_id);
+	rport_dev = udev_device_new_from_subsystem_sysname(conf->udev,
+				"fc_remote_ports", rport_id);
+	if (!rport_dev) {
+		condlog(1, "%s: No fc_remote_port device for '%s'", pp->dev,
+			rport_id);
+		return;
+	}
+	condlog(4, "target%d:%d:%d -> %s", pp->sg_id.host_no,
+		pp->sg_id.channel, pp->sg_id.scsi_id, rport_id);
+
+	snprintf(value, 11, "%u", mpp->dev_loss);
+	if (mpp->dev_loss &&
+	    sysfs_attr_set_value(rport_dev, "dev_loss_tmo", value, 11) <= 0) {
+		if ((mpp->fast_io_fail == MP_FAST_IO_FAIL_UNSET ||
+		     mpp->fast_io_fail == MP_FAST_IO_FAIL_OFF)
+		    && mpp->dev_loss > 600) {
+			condlog(3, "%s: limiting dev_loss_tmo to 600, since "
+				"fast_io_fail is not set", mpp->alias);
+			snprintf(value, 11, "%u", 600);
+			if (sysfs_attr_set_value(rport_dev, "dev_loss_tmo",
+						 value, 11) <= 0)
+				condlog(0, "%s failed to set dev_loss_tmo",
+					mpp->alias);
+			goto out;
 		}
-		if (mpp->fast_io_fail){
-			if (mpp->fast_io_fail == -1)
-				sprintf(value, "off");
-			else
-				snprintf(value, 11, "%u", mpp->fast_io_fail);
-			if (sysfs_attr_set_value(attr_path, "fast_io_fail_tmo",
-						 value))
-				return 1;
+	}
+	if (mpp->fast_io_fail != MP_FAST_IO_FAIL_UNSET){
+		if (mpp->fast_io_fail == MP_FAST_IO_FAIL_OFF)
+			sprintf(value, "off");
+		else if (mpp->fast_io_fail == MP_FAST_IO_FAIL_ZERO)
+			sprintf(value, "0");
+		else
+			snprintf(value, 11, "%u", mpp->fast_io_fail);
+		if (sysfs_attr_set_value(rport_dev, "fast_io_fail_tmo",
+					 value, 11) <= 0) {
+			condlog(0, "%s failed to set fast_io_fail_tmo",
+				mpp->alias);
 		}
 	}
-	return 0;
+out:
+	udev_device_unref(rport_dev);
 }
 
-static int
-opennode (char * dev, int mode)
+static void
+sysfs_set_session_tmo(struct multipath *mpp, struct path *pp)
 {
-	char devpath[FILE_NAME_SIZE], *ptr;
+	struct udev_device *session_dev = NULL;
+	char session_id[64];
+	char value[11];
 
-	if (safe_sprintf(devpath, "%s/%s", conf->udev_dir, dev)) {
-		condlog(0, "devpath too small");
-		return -1;
+	sprintf(session_id, "session%d", pp->sg_id.transport_id);
+	session_dev = udev_device_new_from_subsystem_sysname(conf->udev,
+				"iscsi_session", session_id);
+	if (!session_dev) {
+		condlog(1, "%s: No iscsi session for '%s'", pp->dev,
+			session_id);
+		return;
 	}
-	/*
-	 * Translate '!' into '/'
-	 */
-	ptr = devpath;
-	while ((ptr = strchr(ptr, '!'))) {
-		*ptr = '/';
-		ptr++;
+	condlog(4, "target%d:%d:%d -> %s", pp->sg_id.host_no,
+		pp->sg_id.channel, pp->sg_id.scsi_id, session_id);
+
+	if (mpp->dev_loss) {
+		condlog(3, "%s: ignoring dev_loss_tmo on iSCSI", pp->dev);
+	}
+	if (mpp->fast_io_fail != MP_FAST_IO_FAIL_UNSET) {
+		if (mpp->fast_io_fail == MP_FAST_IO_FAIL_OFF) {
+			condlog(3, "%s: can't switch off fast_io_fail_tmo "
+				"on iSCSI", pp->dev);
+		} else if (mpp->fast_io_fail == MP_FAST_IO_FAIL_ZERO) {
+			condlog(3, "%s: can't set fast_io_fail_tmo to '0'"
+				"on iSCSI", pp->dev);
+		} else {
+			snprintf(value, 11, "%u", mpp->fast_io_fail);
+			if (sysfs_attr_set_value(session_dev, "recovery_tmo",
+						 value, 11)) {
+				condlog(3, "%s: Failed to set recovery_tmo, "
+					" error %d", pp->dev, errno);
+			}
+		}
 	}
-	return open(devpath, mode);
+	udev_device_unref(session_dev);
+	return;
 }
 
-extern int
-devt2devname (char *devname, char *devt)
+static void
+sysfs_set_nexus_loss_tmo(struct multipath *mpp, struct path *pp)
 {
-	FILE *fd;
-	unsigned int tmpmaj, tmpmin, major, minor;
-	char dev[FILE_NAME_SIZE];
-	char block_path[FILE_NAME_SIZE];
-	struct stat statbuf;
-
-	memset(block_path, 0, FILE_NAME_SIZE);
-	if (sscanf(devt, "%u:%u", &major, &minor) != 2) {
-		condlog(0, "Invalid device number %s", devt);
-		return 1;
-	}
+	struct udev_device *sas_dev = NULL;
+	char end_dev_id[64];
+	char value[11];
 
-	if (!(fd = fopen("/proc/partitions", "r"))) {
-		condlog(0, "Cannot open /proc/partitions");
-		return 1;
+	sprintf(end_dev_id, "end_device-%d:%d",
+		pp->sg_id.host_no, pp->sg_id.transport_id);
+	sas_dev = udev_device_new_from_subsystem_sysname(conf->udev,
+				"sas_end_device", end_dev_id);
+	if (!sas_dev) {
+		condlog(1, "%s: No SAS end device for '%s'", pp->dev,
+			end_dev_id);
+		return;
 	}
-
-	while (!feof(fd)) {
-		int r = fscanf(fd,"%u %u %*d %s",&tmpmaj, &tmpmin, dev);
-		if (!r) {
-			r = fscanf(fd,"%*s\n");
-			continue;
-		}
-		if (r != 3)
-			continue;
-
-		if ((major == tmpmaj) && (minor == tmpmin)) {
-			if (snprintf(block_path, FILE_NAME_SIZE, "/sys/block/%s", dev) >= FILE_NAME_SIZE) {
-				condlog(0, "device name %s is too long\n", dev);
-				fclose(fd);
-				return 1;
-			}
-			break;
-		}
+	condlog(4, "target%d:%d:%d -> %s", pp->sg_id.host_no,
+		pp->sg_id.channel, pp->sg_id.scsi_id, end_dev_id);
+
+	if (mpp->dev_loss) {
+		snprintf(value, 11, "%u", mpp->dev_loss);
+		if (sysfs_attr_set_value(sas_dev, "I_T_nexus_loss_timeout",
+					 value, 11) <= 0)
+			condlog(3, "%s: failed to update "
+				"I_T Nexus loss timeout, error %d",
+				pp->dev, errno);
 	}
-	fclose(fd);
-
-	if (strncmp(block_path,"/sys/block", 10))
-		return 1;
+	udev_device_unref(sas_dev);
+	return;
+}
 
-	if (stat(block_path, &statbuf) < 0) {
-		condlog(0, "No sysfs entry for %s\n", block_path);
-		return 1;
+int
+sysfs_set_scsi_tmo (struct multipath *mpp)
+{
+	struct path *pp;
+	int i;
+	int dev_loss_tmo = mpp->dev_loss;
+
+	if (mpp->no_path_retry > 0) {
+		int no_path_retry_tmo = mpp->no_path_retry * conf->checkint;
+
+		if (no_path_retry_tmo > MAX_DEV_LOSS_TMO)
+			no_path_retry_tmo = MAX_DEV_LOSS_TMO;
+		if (no_path_retry_tmo > dev_loss_tmo)
+			dev_loss_tmo = no_path_retry_tmo;
+		condlog(3, "%s: update dev_loss_tmo to %d",
+			mpp->alias, dev_loss_tmo);
+	} else if (mpp->no_path_retry == NO_PATH_RETRY_QUEUE) {
+		dev_loss_tmo = MAX_DEV_LOSS_TMO;
+		condlog(3, "%s: update dev_loss_tmo to %d",
+			mpp->alias, dev_loss_tmo);
 	}
+	mpp->dev_loss = dev_loss_tmo;
+	if (mpp->dev_loss && mpp->fast_io_fail >= (int)mpp->dev_loss) {
+		condlog(3, "%s: turning off fast_io_fail (%d is not smaller than dev_loss_tmo)",
+			mpp->alias, mpp->fast_io_fail);
+		mpp->fast_io_fail = MP_FAST_IO_FAIL_OFF;
+	}
+	if (!mpp->dev_loss && mpp->fast_io_fail == MP_FAST_IO_FAIL_UNSET)
+		return 0;
 
-	if (S_ISDIR(statbuf.st_mode) == 0) {
-		condlog(0, "sysfs entry %s is not a directory\n", block_path);
-		return 1;
+	vector_foreach_slot(mpp->paths, pp, i) {
+		if (pp->sg_id.proto_id == SCSI_PROTOCOL_FCP)
+			sysfs_set_rport_tmo(mpp, pp);
+		if (pp->sg_id.proto_id == SCSI_PROTOCOL_ISCSI)
+			sysfs_set_session_tmo(mpp, pp);
+		if (pp->sg_id.proto_id == SCSI_PROTOCOL_SAS)
+			sysfs_set_nexus_loss_tmo(mpp, pp);
 	}
-	basenamecpy(block_path, devname);
 	return 0;
 }
 
@@ -334,6 +493,7 @@ do_inq(int sg_fd, int cmddt, int evpd, unsigned int pg_op,
 	inqCmdBlk[3] = (unsigned char)((mx_resp_len >> 8) & 0xff);
 	inqCmdBlk[4] = (unsigned char) (mx_resp_len & 0xff);
 	memset(&io_hdr, 0, sizeof (struct sg_io_hdr));
+	memset(sense_b, 0, SENSE_BUFF_LEN);
 	io_hdr.interface_id = 'S';
 	io_hdr.cmd_len = sizeof (inqCmdBlk);
 	io_hdr.mx_sb_len = sizeof (sense_b);
@@ -392,75 +552,46 @@ get_serial (char * str, int maxlen, int fd)
 }
 
 static int
-get_inq (char * dev, char * vendor, char * product, char * rev, int fd)
+get_geometry(struct path *pp)
 {
-	unsigned char buff[MX_ALLOC_LEN + 1] = {0};
-	int len;
-
-	if (fd < 0)
-		return 1;
-
-	if (0 != do_inq(fd, 0, 0, 0, buff, MX_ALLOC_LEN))
+	if (pp->fd < 0)
 		return 1;
 
-	/* Check peripheral qualifier */
-	if ((buff[0] >> 5) != 0) {
-		int pqual = (buff[0] >> 5);
-		switch (pqual) {
-		case 1:
-			condlog(3, "%s: INQUIRY failed, LU not connected", dev);
-			break;
-		case 3:
-			condlog(3, "%s: INQUIRY failed, LU not supported", dev);
-			break;
-		default:
-			condlog(3, "%s: INQUIRY failed, Invalid PQ %x",
-				dev, pqual);
-			break;
-		}
-
+	if (ioctl(pp->fd, HDIO_GETGEO, &pp->geom)) {
+		condlog(2, "%s: HDIO_GETGEO failed with %d", pp->dev, errno);
+		memset(&pp->geom, 0, sizeof(pp->geom));
 		return 1;
 	}
-
-	len = buff[4] + 4;
-
-	if (len < 8) {
-		condlog(3, "%s: INQUIRY response too short (len %d)",
-			dev, len);
-		return 1;
-	}
-
-	len -= 8;
-	memset(vendor, 0x0, 8);
-	memcpy(vendor, buff + 8, len > 8 ? 8 : len);
-	vendor[8] = '\0';
-	strchop(vendor);
-	if (len <= 8)
-		return 0;
-
-	len -= 8;
-
-	memset(product, 0x0, 16);
-	memcpy(product, buff + 16, len > 16 ? 16 : len);
-	product[16] = '\0';
-	strchop(product);
-	if (len <= 16)
-		return 0;
-
-	len -= 16;
-
-	memset(rev, 0x0, 4);
-	memcpy(rev, buff + 32, 4);
-	rev[4] = '\0';
-	strchop(rev);
-
+	condlog(3, "%s: %u cyl, %u heads, %u sectors/track, start at %lu",
+		pp->dev, pp->geom.cylinders, pp->geom.heads,
+		pp->geom.sectors, pp->geom.start);
 	return 0;
 }
 
 static int
-scsi_sysfs_pathinfo (struct path * pp, struct sysfs_device * parent)
+scsi_sysfs_pathinfo (struct path * pp)
 {
-	char attr_path[FILE_NAME_SIZE];
+	struct udev_device *parent;
+	const char *attr_path = NULL;
+
+	parent = pp->udev;
+	while (parent) {
+		const char *subsys = udev_device_get_subsystem(parent);
+		if (subsys && !strncmp(subsys, "scsi", 4)) {
+			attr_path = udev_device_get_sysname(parent);
+			if (!attr_path)
+				break;
+			if (sscanf(attr_path, "%i:%i:%i:%i",
+				   &pp->sg_id.host_no,
+				   &pp->sg_id.channel,
+				   &pp->sg_id.scsi_id,
+				   &pp->sg_id.lun) == 4)
+				break;
+		}
+		parent = udev_device_get_parent(parent);
+	}
+	if (!attr_path || pp->sg_id.host_no == -1)
+		return 1;
 
 	if (sysfs_get_vendor(parent, pp->vendor_id, SCSI_VENDOR_SIZE))
 		return 1;
@@ -485,13 +616,6 @@ scsi_sysfs_pathinfo (struct path * pp, struct sysfs_device * parent)
 	/*
 	 * host / bus / target / lun
 	 */
-	basenamecpy(parent->devpath, attr_path);
-
-	sscanf(attr_path, "%i:%i:%i:%i",
-			&pp->sg_id.host_no,
-			&pp->sg_id.channel,
-			&pp->sg_id.scsi_id,
-			&pp->sg_id.lun);
 	condlog(3, "%s: h:b:t:l = %i:%i:%i:%i",
 			pp->dev,
 			pp->sg_id.host_no,
@@ -502,10 +626,7 @@ scsi_sysfs_pathinfo (struct path * pp, struct sysfs_device * parent)
 	/*
 	 * target node name
 	 */
-	if(!sysfs_get_fc_nodename(parent, pp->tgt_node_name,
-				 pp->sg_id.host_no,
-				 pp->sg_id.channel,
-				 pp->sg_id.scsi_id)) {
+	if(!sysfs_get_tgt_nodename(pp, pp->tgt_node_name)) {
 		condlog(3, "%s: tgt_node_name = %s",
 			pp->dev, pp->tgt_node_name);
 	}
@@ -514,10 +635,21 @@ scsi_sysfs_pathinfo (struct path * pp, struct sysfs_device * parent)
 }
 
 static int
-ccw_sysfs_pathinfo (struct path * pp, struct sysfs_device * parent)
+ccw_sysfs_pathinfo (struct path * pp)
 {
-	char attr_path[FILE_NAME_SIZE];
-	char attr_buff[FILE_NAME_SIZE];
+	struct udev_device *parent;
+	char attr_buff[NAME_SIZE];
+	const char *attr_path;
+
+	parent = pp->udev;
+	while (parent) {
+		const char *subsys = udev_device_get_subsystem(parent);
+		if (subsys && !strncmp(subsys, "ccw", 3))
+			break;
+		parent = udev_device_get_parent(parent);
+	}
+	if (!parent)
+		return 1;
 
 	sprintf(pp->vendor_id, "IBM");
 
@@ -544,7 +676,7 @@ ccw_sysfs_pathinfo (struct path * pp, struct sysfs_device * parent)
 	/*
 	 * host / bus / target / lun
 	 */
-	basenamecpy(parent->devpath, attr_path);
+	attr_path = udev_device_get_sysname(parent);
 	pp->sg_id.lun = 0;
 	sscanf(attr_path, "%i.%i.%x",
 			&pp->sg_id.host_no,
@@ -561,43 +693,77 @@ ccw_sysfs_pathinfo (struct path * pp, struct sysfs_device * parent)
 }
 
 static int
-cciss_sysfs_pathinfo (struct path * pp, struct sysfs_device * dev)
+cciss_sysfs_pathinfo (struct path * pp)
 {
-	char attr_path[FILE_NAME_SIZE];
+	const char * attr_path = NULL;
+	struct udev_device *parent;
+
+	parent = pp->udev;
+	while (parent) {
+		const char *subsys = udev_device_get_subsystem(parent);
+		if (subsys && !strncmp(subsys, "cciss", 5)) {
+			attr_path = udev_device_get_sysname(parent);
+			if (!attr_path)
+				break;
+			if (sscanf(attr_path, "c%id%i",
+				   &pp->sg_id.host_no,
+				   &pp->sg_id.scsi_id) == 2)
+				break;
+		}
+		parent = udev_device_get_parent(parent);
+	}
+	if (!attr_path || pp->sg_id.host_no == -1)
+		return 1;
+
+	if (sysfs_get_vendor(parent, pp->vendor_id, SCSI_VENDOR_SIZE))
+		return 1;
+
+	condlog(3, "%s: vendor = %s", pp->dev, pp->vendor_id);
+
+	if (sysfs_get_model(parent, pp->product_id, SCSI_PRODUCT_SIZE))
+		return 1;
+
+	condlog(3, "%s: product = %s", pp->dev, pp->product_id);
+
+	if (sysfs_get_rev(parent, pp->rev, SCSI_REV_SIZE))
+		return 1;
+
+	condlog(3, "%s: rev = %s", pp->dev, pp->rev);
+
+	/*
+	 * set the hwe configlet pointer
+	 */
+	pp->hwe = find_hwe(conf->hwtable, pp->vendor_id, pp->product_id, pp->rev);
 
 	/*
 	 * host / bus / target / lun
 	 */
-	basenamecpy(dev->devpath, attr_path);
 	pp->sg_id.lun = 0;
 	pp->sg_id.channel = 0;
-	sscanf(attr_path, "cciss!c%id%i",
-			&pp->sg_id.host_no,
-			&pp->sg_id.scsi_id);
 	condlog(3, "%s: h:b:t:l = %i:%i:%i:%i",
-			pp->dev,
-			pp->sg_id.host_no,
-			pp->sg_id.channel,
-			pp->sg_id.scsi_id,
-			pp->sg_id.lun);
+		pp->dev,
+		pp->sg_id.host_no,
+		pp->sg_id.channel,
+		pp->sg_id.scsi_id,
+		pp->sg_id.lun);
 	return 0;
 }
 
 static int
-common_sysfs_pathinfo (struct path * pp, struct sysfs_device *dev)
+common_sysfs_pathinfo (struct path * pp)
 {
-	char *attr;
-
-	attr = sysfs_attr_get_value(dev->devpath, "dev");
-	if (!attr) {
+	if (!pp->udev) {
+		condlog(4, "%s: udev not initialised", pp->dev);
+		return 1;
+	}
+	if (sysfs_get_dev(pp->udev, pp->dev_t, BLK_DEV_SIZE)) {
 		condlog(3, "%s: no 'dev' attribute in sysfs", pp->dev);
 		return 1;
 	}
-	strlcpy(pp->dev_t, attr, BLK_DEV_SIZE);
 
 	condlog(3, "%s: dev_t = %s", pp->dev, pp->dev_t);
 
-	if (sysfs_get_size(dev, &pp->size))
+	if (sysfs_get_size(pp, &pp->size))
 		return 1;
 
 	condlog(3, "%s: size = %llu", pp->dev, pp->size);
@@ -605,49 +771,40 @@ common_sysfs_pathinfo (struct path * pp, struct sysfs_device *dev)
 	return 0;
 }
 
-struct sysfs_device *sysfs_device_from_path(struct path *pp)
-{
-	char sysdev[FILE_NAME_SIZE];
-
-	strlcpy(sysdev,"/block/", FILE_NAME_SIZE);
-	strlcat(sysdev,pp->dev, FILE_NAME_SIZE);
-
-	return sysfs_device_get(sysdev);
-}
-
 int
 path_offline (struct path * pp)
 {
-	struct sysfs_device * parent;
+	struct udev_device * parent;
 	char buff[SCSI_STATE_SIZE];
 
-	pp->sysdev = sysfs_device_from_path(pp);
-	if (!pp->sysdev) {
-		condlog(1, "%s: failed to get sysfs information", pp->dev);
-		return PATH_WILD;
+	if (pp->bus != SYSFS_BUS_SCSI)
+		return PATH_UP;
+
+	parent = pp->udev;
+	while (parent) {
+		const char *subsys = udev_device_get_subsystem(parent);
+		if (subsys && !strncmp(subsys, "scsi", 4))
+			break;
+		parent = udev_device_get_parent(parent);
 	}
 
-	parent = sysfs_device_get_parent(pp->sysdev);
-	if (!parent)
-		parent = pp->sysdev;
-	if (parent && !strncmp(parent->kernel, "block",5))
-		parent = sysfs_device_get_parent(parent);
 	if (!parent) {
-		condlog(1, "%s: failed to get parent", pp->dev);
-		return PATH_WILD;
+		condlog(1, "%s: failed to get sysfs information", pp->dev);
+		return PATH_DOWN;
 	}
 
 	if (sysfs_get_state(parent, buff, SCSI_STATE_SIZE))
-		return PATH_WILD;
+		return PATH_DOWN;
 
-	condlog(3, "%s: state = %s", pp->dev, buff);
+	condlog(3, "%s: path state = %s", pp->dev, buff);
 
-	if (!strncmp(buff, "offline", 7)) {
+	if (!strncmp(buff, "offline", 7) ||
+	    !strncmp(buff, "transport-offline", 17)) {
 		pp->offline = 1;
 		return PATH_DOWN;
 	}
 	pp->offline = 0;
-	if (!strncmp(buff, "blocked", 7))
+	if (!strncmp(buff, "blocked", 7) || !strncmp(buff, "quiesce", 7))
 		return PATH_PENDING;
 	else if (!strncmp(buff, "running", 7))
 		return PATH_UP;
@@ -655,52 +812,30 @@ path_offline (struct path * pp)
 	return PATH_DOWN;
 }
 
-extern int
+int
 sysfs_pathinfo(struct path * pp)
 {
-	struct sysfs_device *parent;
-
-	pp->sysdev = sysfs_device_from_path(pp);
-	if (!pp->sysdev) {
-		condlog(1, "%s: failed to get sysfs information", pp->dev);
-		return 1;
-	}
-
-	if (common_sysfs_pathinfo(pp, pp->sysdev))
+	if (common_sysfs_pathinfo(pp))
 		return 1;
 
-	parent = sysfs_device_get_parent(pp->sysdev);
-	if (!parent)
-		parent = pp->sysdev;
-	if (parent && !strncmp(parent->kernel, "block",5))
-		parent = sysfs_device_get_parent(parent);
-	if (!parent) {
-		condlog(1, "%s: failed to get parent", pp->dev);
-		return 1;
-	}
-
+	pp->bus = SYSFS_BUS_UNDEF;
 	if (!strncmp(pp->dev,"cciss",5))
-		strcpy(parent->subsystem,"cciss");
-
-	condlog(3, "%s: subsystem = %s", pp->dev, parent->subsystem);
-
-	if (!strncmp(parent->subsystem, "scsi",4))
-		pp->bus = SYSFS_BUS_SCSI;
-	if (!strncmp(parent->subsystem, "ccw",3))
-		pp->bus = SYSFS_BUS_CCW;
-	if (!strncmp(parent->subsystem,"cciss",5))
 		pp->bus = SYSFS_BUS_CCISS;
+	if (!strncmp(pp->dev,"dasd", 4))
+		pp->bus = SYSFS_BUS_CCW;
+	if (!strncmp(pp->dev,"sd", 2))
+		pp->bus = SYSFS_BUS_SCSI;
 
 	if (pp->bus == SYSFS_BUS_UNDEF)
 		return 0;
 	else if (pp->bus == SYSFS_BUS_SCSI) {
-		if (scsi_sysfs_pathinfo(pp, parent))
+		if (scsi_sysfs_pathinfo(pp))
 			return 1;
 	} else if (pp->bus == SYSFS_BUS_CCW) {
-		if (ccw_sysfs_pathinfo(pp, parent))
+		if (ccw_sysfs_pathinfo(pp))
 			return 1;
 	} else if (pp->bus == SYSFS_BUS_CCISS) {
-		if (cciss_sysfs_pathinfo(pp, pp->sysdev))
+		if (cciss_sysfs_pathinfo(pp))
 			return 1;
 	}
 	return 0;
@@ -720,23 +855,9 @@ scsi_ioctl_pathinfo (struct path * pp, int mask)
 static int
 cciss_ioctl_pathinfo (struct path * pp, int mask)
 {
-	int ret;
-
-	if (mask & DI_SYSFS) {
-		ret = get_inq(pp->dev, pp->vendor_id, pp->product_id,
-			      pp->rev, pp->fd);
-		if (ret)
-			return ret;
-
-		condlog(3, "%s: vendor = %s", pp->dev, pp->vendor_id);
-		condlog(3, "%s: product = %s", pp->dev, pp->product_id);
-		condlog(3, "%s: revision = %s", pp->dev, pp->rev);
-		/*
-		 * set the hwe configlet pointer
-		 */
-		pp->hwe = find_hwe(conf->hwtable, pp->vendor_id,
-				   pp->product_id, pp->rev);
-
+	if (mask & DI_SERIAL) {
+		get_serial(pp->serial, SERIAL_SIZE, pp->fd);
+		condlog(3, "%s: serial = %s", pp->dev, pp->serial);
 	}
 	return 0;
 }
@@ -750,8 +871,13 @@ get_state (struct path * pp, int daemon)
 	condlog(3, "%s: get_state", pp->dev);
 
 	if (!checker_selected(c)) {
-		if (daemon)
-			pathinfo(pp, conf->hwtable, DI_SYSFS);
+		if (daemon) {
+			if (pathinfo(pp, conf->hwtable, DI_SYSFS) != 0) {
+				condlog(3, "%s: couldn't get sysfs pathinfo",
+					pp->dev);
+				return PATH_UNCHECKED;
+			}
+		}
 		select_checker(pp);
 		if (!checker_selected(c)) {
 			condlog(3, "%s: No checker selected", pp->dev);
@@ -759,20 +885,22 @@ get_state (struct path * pp, int daemon)
 		}
 		checker_set_fd(c, pp->fd);
 		if (checker_init(c, pp->mpp?&pp->mpp->mpcontext:NULL)) {
+			memset(c, 0x0, sizeof(struct checker));
 			condlog(3, "%s: checker init failed", pp->dev);
 			return PATH_UNCHECKED;
 		}
 	}
-	state = path_offline(pp);
-	if (state != PATH_UP) {
-		condlog(3, "%s: path inaccessible", pp->dev);
-		return state;
-	}
+	checker_clear_message(c);
 	if (daemon)
 		checker_set_async(c);
+	if (!conf->checker_timeout &&
+	    (pp->bus != SYSFS_BUS_SCSI ||
+	     sysfs_get_timeout(pp, &(c->timeout))))
+		c->timeout = DEF_TIMEOUT;
 	state = checker_check(c);
-	condlog(3, "%s: state = %i", pp->dev, state);
-	if (state == PATH_DOWN && strlen(checker_message(c)))
+	condlog(3, "%s: state = %s", pp->dev, checker_state_name(state));
+	if (state != PATH_UP && state != PATH_GHOST &&
+	    strlen(checker_message(c)))
 		condlog(3, "%s: checker msg is \"%s\"",
 			pp->dev, checker_message(c));
 	return state;
@@ -784,54 +912,76 @@ get_prio (struct path * pp)
 	if (!pp)
 		return 0;
 
-	if (!pp->prio) {
+	struct prio * p = &pp->prio;
+
+	if (!prio_selected(p)) {
+		select_detect_prio(pp);
 		select_prio(pp);
-		if (!pp->prio) {
+		if (!prio_selected(p)) {
 			condlog(3, "%s: no prio selected", pp->dev);
 			return 1;
 		}
 	}
-	pp->priority = prio_getprio(pp->prio, pp);
+	pp->priority = prio_getprio(p, pp);
 	if (pp->priority < 0) {
-		condlog(3, "%s: %s prio error", pp->dev, prio_name(pp->prio));
+		condlog(3, "%s: %s prio error", pp->dev, prio_name(p));
 		pp->priority = PRIO_UNDEF;
 		return 1;
 	}
 	condlog(3, "%s: %s prio = %u",
-		pp->dev, prio_name(pp->prio), pp->priority);
+		pp->dev, prio_name(p), pp->priority);
 	return 0;
 }
 
 static int
 get_uid (struct path * pp)
 {
-	char buff[CALLOUT_MAX_SIZE];
-	int i;
+	char *c;
+	const char *value;
 
-	if (!pp->getuid)
+	if (!pp->uid_attribute)
 		select_getuid(pp);
 
-	if (apply_format(pp->getuid, &buff[0], pp)) {
-		condlog(0, "error formatting uid callout command");
-		memset(pp->wwid, 0, WWID_SIZE);
-	} else if (execute_program(buff, pp->wwid, WWID_SIZE)) {
-		condlog(3, "error calling out %s", buff);
-		memset(pp->wwid, 0, WWID_SIZE);
+	if (!pp->udev) {
+		condlog(1, "%s: no udev information", pp->dev);
 		return 1;
 	}
+
+	memset(pp->wwid, 0, WWID_SIZE);
+	value = udev_device_get_property_value(pp->udev, pp->uid_attribute);
+	if ((!value || strlen(value) == 0) && conf->dry_run == 2)
+		value = getenv(pp->uid_attribute);
+	if (value && strlen(value)) {
+		size_t len = WWID_SIZE;
+
+		if (strlen(value) + 1 > WWID_SIZE) {
+			condlog(0, "%s: wwid overflow", pp->dev);
+		} else {
+			len = strlen(value);
+		}
+		strncpy(pp->wwid, value, len);
+	} else {
+		condlog(3, "%s: no %s attribute", pp->dev,
+			pp->uid_attribute);
+	}
+
 	/* Strip any trailing blanks */
-	i = WWID_SIZE - 1;
-	while (i > 0 && pp->wwid[i] == ' ') {
-		pp->wwid[i] = '\0';
-		i--;
+	c = strchr(pp->wwid, '\0');
+	c--;
+	while (c && c >= pp->wwid && *c == ' ') {
+		*c = '\0';
+		c--;
 	}
-	condlog(3, "%s: uid = %s (callout)", pp->dev ,pp->wwid);
+	condlog(3, "%s: uid = %s (udev)", pp->dev,
+		*pp->wwid == '\0' ? "<empty>" : pp->wwid);
 	return 0;
 }
 
 extern int
 pathinfo (struct path *pp, vector hwtable, int mask)
 {
+	int path_state;
+
 	condlog(3, "%s: mask = 0x%x", pp->dev, mask);
 
 	/*
@@ -840,11 +990,20 @@ pathinfo (struct path *pp, vector hwtable, int mask)
 	if (mask & DI_SYSFS && sysfs_pathinfo(pp))
 		return 1;
 
+	if (mask & DI_BLACKLIST && mask & DI_SYSFS) {
+		if (filter_device(conf->blist_device, conf->elist_device,
+				  pp->vendor_id, pp->product_id) > 0) {
+			return 2;
+		}
+	}
+
+	path_state = path_offline(pp);
+
 	/*
 	 * fetch info not available through sysfs
 	 */
 	if (pp->fd < 0)
-		pp->fd = opennode(pp->dev, O_RDONLY);
+		pp->fd = open(udev_device_get_devnode(pp->udev), O_RDONLY);
 
 	if (pp->fd < 0) {
 		condlog(4, "Couldn't open node for %s: %s",
@@ -852,7 +1011,10 @@ pathinfo (struct path *pp, vector hwtable, int mask)
 		goto blank;
 	}
 
-	if (pp->bus == SYSFS_BUS_SCSI &&
+	if (mask & DI_SERIAL)
+		get_geometry(pp);
+
+	if (path_state == PATH_UP && pp->bus == SYSFS_BUS_SCSI &&
 	    scsi_ioctl_pathinfo(pp, mask))
 		goto blank;
 
@@ -861,21 +1023,39 @@ pathinfo (struct path *pp, vector hwtable, int mask)
 		goto blank;
 
 	if (mask & DI_CHECKER) {
-		pp->state = get_state(pp, 0);
-		if (pp->state == PATH_UNCHECKED || pp->state == PATH_WILD)
-			goto blank;
+		if (path_state == PATH_UP) {
+			pp->chkrstate = pp->state = get_state(pp, 0);
+			if (pp->state == PATH_UNCHECKED ||
+			    pp->state == PATH_WILD)
+				goto blank;
+		} else {
+			condlog(3, "%s: path inaccessible", pp->dev);
+			pp->chkrstate = pp->state = path_state;
+		}
+	}
+
+	if ((mask & DI_WWID) && !strlen(pp->wwid))
+		get_uid(pp);
+	if (mask & DI_BLACKLIST && mask & DI_WWID) {
+		if (filter_wwid(conf->blist_wwid, conf->elist_wwid,
+				pp->wwid) > 0) {
+			return 2;
+		}
 	}
 
 	 /*
 	  * Retrieve path priority, even for PATH_DOWN paths if it has never
 	  * been successfully obtained before.
 	  */
-	if (mask & DI_PRIO &&
-	    (pp->state != PATH_DOWN || pp->priority == PRIO_UNDEF))
-		get_prio(pp);
-
-	if (mask & DI_WWID && !strlen(pp->wwid))
-		get_uid(pp);
+	if ((mask & DI_PRIO) && path_state == PATH_UP) {
+		if (pp->state != PATH_DOWN || pp->priority == PRIO_UNDEF) {
+			if (!strlen(pp->wwid))
+				get_uid(pp);
+			get_prio(pp);
+		} else {
+			pp->priority = PRIO_UNDEF;
+		}
+	}
 
 	return 0;
 
@@ -884,7 +1064,7 @@ blank:
 	 * Recoverable error, for example faulty or offline path
 	 */
 	memset(pp->wwid, 0, WWID_SIZE);
-	pp->state = PATH_DOWN;
+	pp->chkrstate = pp->state = PATH_DOWN;
 
 	return 0;
 }
diff --git a/libmultipath/discovery.h b/libmultipath/discovery.h
index ec3a358..1a614ee 100644
--- a/libmultipath/discovery.h
+++ b/libmultipath/discovery.h
@@ -24,17 +24,20 @@
 #define SCSI_COMMAND_TERMINATED 0x22
 #define SG_ERR_DRIVER_SENSE     0x08
 
-int sysfs_get_dev (struct sysfs_device * dev, char * buff, size_t len);
+struct config;
+
+int sysfs_get_dev (struct udev_device *udev, char * buff, size_t len);
 int path_discovery (vector pathvec, struct config * conf, int flag);
 
 int do_tur (char *);
-int devt2devname (char *, char *);
 int path_offline (struct path *);
 int get_state (struct path * pp, int daemon);
 int pathinfo (struct path *, vector hwtable, int mask);
-struct path * store_pathinfo (vector pathvec, vector hwtable,
-			      char * devname, int flag);
+int store_pathinfo (vector pathvec, vector hwtable,
+		    struct udev_device *udevice, int flag,
+		    struct path **pp_ptr);
 int sysfs_set_scsi_tmo (struct multipath *mpp);
+int sysfs_get_timeout(struct path *pp, unsigned int *timeout);
 
 /*
  * discovery bitmask
@@ -44,14 +47,16 @@ enum discovery_mode {
 	__DI_SERIAL,
 	__DI_CHECKER,
 	__DI_PRIO,
-	__DI_WWID
+	__DI_WWID,
+	__DI_BLACKLIST,
 };
 
 #define DI_SYSFS	(1 << __DI_SYSFS)
 #define DI_SERIAL	(1 << __DI_SERIAL)
 #define DI_CHECKER	(1 << __DI_CHECKER)
 #define DI_PRIO		(1 << __DI_PRIO)
-#define DI_WWID 	(1 << __DI_WWID)
+#define DI_WWID		(1 << __DI_WWID)
+#define DI_BLACKLIST	(1 << __DI_BLACKLIST)
 
 #define DI_ALL		(DI_SYSFS  | DI_SERIAL | DI_CHECKER | DI_PRIO | \
 			 DI_WWID)
diff --git a/libmultipath/dmparser.c b/libmultipath/dmparser.c
index 1ef3aad..2562ba1 100644
--- a/libmultipath/dmparser.c
+++ b/libmultipath/dmparser.c
@@ -13,6 +13,7 @@
 #include "structs.h"
 #include "util.h"
 #include "debug.h"
+#include "config.h"
 
 #define WORD_SIZE 64
 
@@ -47,25 +48,51 @@ merge_words (char ** dst, char * word, int space)
  * Transforms the path group vector into a proper device map string
  */
 int
-assemble_map (struct multipath * mp)
+assemble_map (struct multipath * mp, char * params, int len)
 {
 	int i, j;
 	int shift, freechar;
 	int minio;
-	char * p;
+	int nr_priority_groups, initial_pg_nr;
+	char * p, * f;
+	char no_path_retry[] = "queue_if_no_path";
+	char retain_hwhandler[] = "retain_attached_hw_handler";
 	struct pathgroup * pgp;
 	struct path * pp;
 
 	minio = mp->minio;
-	p = mp->params;
-	freechar = sizeof(mp->params);
+	p = params;
+	freechar = len;
+
+	nr_priority_groups = VECTOR_SIZE(mp->pg);
+	initial_pg_nr = (nr_priority_groups ? mp->bestpg : 0);
+
+	f = STRDUP(mp->features);
+
+	/*
+	 * We have to set 'queue_if_no_path' here even
+	 * to avoid path failures during map reload.
+	 */
+	if (mp->no_path_retry == NO_PATH_RETRY_UNDEF ||
+	    mp->no_path_retry == NO_PATH_RETRY_FAIL) {
+		/* remove queue_if_no_path settings */
+		condlog(3, "%s: remove queue_if_no_path from '%s'",
+			mp->alias, mp->features);
+		remove_feature(&f, no_path_retry);
+	} else {
+		add_feature(&f, no_path_retry);
+	}
+	if (mp->retain_hwhandler == RETAIN_HWHANDLER_ON)
+		add_feature(&f, retain_hwhandler);
 
 	shift = snprintf(p, freechar, "%s %s %i %i",
-			 mp->features, mp->hwhandler,
-			 VECTOR_SIZE(mp->pg), mp->bestpg);
+			 f, mp->hwhandler,
+			 nr_priority_groups, initial_pg_nr);
+
+	FREE(f);
 
 	if (shift >= freechar) {
-		fprintf(stderr, "mp->params too small\n");
+		condlog(0, "%s: params too small", mp->alias);
 		return 1;
 	}
 	p += shift;
@@ -76,7 +103,7 @@ assemble_map (struct multipath * mp)
 		shift = snprintf(p, freechar, " %s %i 1", mp->selector,
 				 VECTOR_SIZE(pgp->paths));
 		if (shift >= freechar) {
-			fprintf(stderr, "mp->params too small\n");
+			condlog(0, "%s: params too small", mp->alias);
 			return 1;
 		}
 		p += shift;
@@ -88,11 +115,14 @@ assemble_map (struct multipath * mp)
 			if (mp->rr_weight == RR_WEIGHT_PRIO
 			    && pp->priority > 0)
 				tmp_minio = minio * pp->priority;
-
+			if (!strlen(pp->dev_t) ) {
+				condlog(0, "dev_t not set for '%s'", pp->dev);
+				return 1;
+			}
 			shift = snprintf(p, freechar, " %s %d",
 					 pp->dev_t, tmp_minio);
 			if (shift >= freechar) {
-				fprintf(stderr, "mp->params too small\n");
+				condlog(0, "%s: params too small", mp->alias);
 				return 1;
 			}
 			p += shift;
@@ -100,10 +130,12 @@ assemble_map (struct multipath * mp)
 		}
 	}
 	if (freechar < 1) {
-		fprintf(stderr, "mp->params too small\n");
+		condlog(0, "%s: params too small", mp->alias);
 		return 1;
 	}
 	snprintf(p, 1, "\n");
+
+	condlog(3, "%s: assembled map [%s]", mp->alias, params);
 	return 0;
 }
 
@@ -120,11 +152,14 @@ disassemble_map (vector pathvec, char * params, struct multipath * mpp)
 	int num_paths = 0;
 	int num_paths_args = 0;
 	int def_minio = 0;
+	int no_path_retry = NO_PATH_RETRY_UNDEF;
 	struct path * pp;
 	struct pathgroup * pgp;
 
 	p = params;
 
+	condlog(3, "%s: disassemble map [%s]", mpp->alias, params);
+
 	/*
 	 * features
 	 */
@@ -134,6 +169,8 @@ disassemble_map (vector pathvec, char * params, struct multipath * mpp)
 		return 1;
 
 	num_features = atoi(mpp->features);
+	no_path_retry = mpp->no_path_retry;
+	mpp->no_path_retry = NO_PATH_RETRY_UNDEF;
 
 	for (i = 0; i < num_features; i++) {
 		p += get_word(p, &word);
@@ -154,6 +191,17 @@ disassemble_map (vector pathvec, char * params, struct multipath * mpp)
 	}
 
 	/*
+	 * Reset no_path_retry.
+	 * - if not set from features
+	 * - if queue_if_no_path is set from features but
+	 *   no_path_retry > 0 is selected.
+	 */
+	if ((mpp->no_path_retry == NO_PATH_RETRY_UNDEF ||
+	     mpp->no_path_retry == NO_PATH_RETRY_QUEUE) &&
+	    mpp->no_path_retry != no_path_retry)
+		mpp->no_path_retry = no_path_retry;
+
+	/*
 	 * hwhandler
 	 */
 	p += get_word(p, &mpp->hwhandler);
@@ -187,13 +235,16 @@ disassemble_map (vector pathvec, char * params, struct multipath * mpp)
 	num_pg = atoi(word);
 	FREE(word);
 
-	if (num_pg > 0 && !mpp->pg) {
-		mpp->pg = vector_alloc();
-
-		if (!mpp->pg)
-			return 1;
-	} else
+	if (num_pg > 0) {
+		if (!mpp->pg) {
+			mpp->pg = vector_alloc();
+			if (!mpp->pg)
+				return 1;
+		}
+	} else {
+		free_pgvec(mpp->pg, KEEP_PATHS);
 		mpp->pg = NULL;
+	}
 
 	/*
 	 * first pg to try
@@ -228,7 +279,6 @@ disassemble_map (vector pathvec, char * params, struct multipath * mpp)
 			num_pg_args = atoi(word);
 
 			if (merge_words(&mpp->selector, word, 1)) {
-				FREE(word);
 				goto out1;
 			}
 			FREE(word);
@@ -286,7 +336,7 @@ disassemble_map (vector pathvec, char * params, struct multipath * mpp)
 				strncpy(pp->dev_t, word, BLK_DEV_SIZE);
 
 				/* Only call this in multipath client mode */
-				if (!mpp->waiter && store_path(pathvec, pp))
+				if (!conf->daemon && store_path(pathvec, pp))
 					goto out1;
 			}
 			FREE(word);
@@ -362,6 +412,8 @@ disassemble_status (char * params, struct multipath * mpp)
 
 	p = params;
 
+	condlog(3, "%s: disassemble status [%s]", mpp->alias, params);
+
 	/*
 	 * features
 	 */
diff --git a/libmultipath/dmparser.h b/libmultipath/dmparser.h
index bf4b2c3..1b45df0 100644
--- a/libmultipath/dmparser.h
+++ b/libmultipath/dmparser.h
@@ -1,3 +1,3 @@
-int assemble_map (struct multipath *);
+int assemble_map (struct multipath *, char *, int);
 int disassemble_map (vector, char *, struct multipath *);
 int disassemble_status (char *, struct multipath *);
diff --git a/libmultipath/file.c b/libmultipath/file.c
new file mode 100644
index 0000000..74cde64
--- /dev/null
+++ b/libmultipath/file.c
@@ -0,0 +1,180 @@
+/*
+ * Copyright (c) 2005 Christophe Varoqui
+ * Copyright (c) 2005 Benjamin Marzinski, Redhat
+ */
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <unistd.h>
+#include <string.h>
+#include <limits.h>
+#include <stdio.h>
+#include <signal.h>
+
+#include "file.h"
+#include "debug.h"
+#include "uxsock.h"
+
+
+/*
+ * significant parts of this file were taken from iscsi-bindings.c of the
+ * linux-iscsi project.
+ * Copyright (C) 2002 Cisco Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * See the file COPYING included with this distribution for more details.
+ */
+
+static int
+ensure_directories_exist(char *str, mode_t dir_mode)
+{
+	char *pathname;
+	char *end;
+	int err;
+
+	pathname = strdup(str);
+	if (!pathname){
+		condlog(0, "Cannot copy file pathname %s : %s",
+			str, strerror(errno));
+		return -1;
+	}
+	end = pathname;
+	/* skip leading slashes */
+	while (end && *end && (*end == '/'))
+		end++;
+
+	while ((end = strchr(end, '/'))) {
+		/* if there is another slash, make the dir. */
+		*end = '\0';
+		err = mkdir(pathname, dir_mode);
+		if (err && errno != EEXIST) {
+			condlog(0, "Cannot make directory [%s] : %s",
+				pathname, strerror(errno));
+			free(pathname);
+			return -1;
+		}
+		if (!err)
+			condlog(3, "Created dir [%s]", pathname);
+		*end = '/';
+		end++;
+	}
+	free(pathname);
+	return 0;
+}
+
+static void
+sigalrm(int sig)
+{
+	/* do nothing */
+}
+
+static int
+lock_file(int fd, char *file_name)
+{
+	struct sigaction act, oldact;
+	sigset_t set, oldset;
+	struct flock lock;
+	int err;
+
+	memset(&lock, 0, sizeof(lock));
+	lock.l_type = F_WRLCK;
+	lock.l_whence = SEEK_SET;
+
+	act.sa_handler = sigalrm;
+	sigemptyset(&act.sa_mask);
+	act.sa_flags = 0;
+	sigemptyset(&set);
+	sigaddset(&set, SIGALRM);
+
+	sigaction(SIGALRM, &act, &oldact);
+	pthread_sigmask(SIG_UNBLOCK, &set, &oldset);
+
+	alarm(FILE_TIMEOUT);
+	err = fcntl(fd, F_SETLKW, &lock);
+	alarm(0);
+
+	if (err) {
+		if (errno != EINTR)
+			condlog(0, "Cannot lock %s : %s", file_name,
+				strerror(errno));
+		else
+			condlog(0, "%s is locked. Giving up.", file_name);
+	}
+
+	pthread_sigmask(SIG_SETMASK, &oldset, NULL);
+	sigaction(SIGALRM, &oldact, NULL);
+	return err;
+}
+
+int
+open_file(char *file, int *can_write, char *header)
+{
+	int fd;
+	struct stat s;
+
+	if (ensure_directories_exist(file, 0700))
+		return -1;
+	*can_write = 1;
+	fd = open(file, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);
+	if (fd < 0) {
+		if (errno == EROFS) {
+			*can_write = 0;
+			condlog(3, "Cannot open file [%s] read/write. "
+				" trying readonly", file);
+			fd = open(file, O_RDONLY);
+			if (fd < 0) {
+				condlog(0, "Cannot open file [%s] "
+					"readonly : %s", file, strerror(errno));
+				return -1;
+			}
+		}
+		else {
+			condlog(0, "Cannot open file [%s] : %s", file,
+				strerror(errno));
+			return -1;
+		}
+	}
+	if (*can_write && lock_file(fd, file) < 0)
+		goto fail;
+
+	memset(&s, 0, sizeof(s));
+	if (fstat(fd, &s) < 0){
+		condlog(0, "Cannot stat file %s : %s", file, strerror(errno));
+		goto fail;
+	}
+	if (s.st_size == 0) {
+		if (*can_write == 0)
+			goto fail;
+		/* If file is empty, write the header */
+		size_t len = strlen(header);
+		if (write_all(fd, header, len) != len) {
+			condlog(0,
+				"Cannot write header to file %s : %s", file,
+				strerror(errno));
+			/* cleanup partially written header */
+			if (ftruncate(fd, 0))
+				condlog(0, "Cannot truncate header : %s",
+					strerror(errno));
+			goto fail;
+		}
+		fsync(fd);
+		condlog(3, "Initialized new file [%s]", file);
+	}
+
+	return fd;
+
+fail:
+	close(fd);
+	return -1;
+}
diff --git a/libmultipath/file.h b/libmultipath/file.h
new file mode 100644
index 0000000..4f96dbf
--- /dev/null
+++ b/libmultipath/file.h
@@ -0,0 +1,11 @@
+/*
+ * Copyright (c) 2010 Benjamin Marzinski, Redhat
+ */
+
+#ifndef _FILE_H
+#define _FILE_H
+
+#define FILE_TIMEOUT 30
+int open_file(char *file, int *can_write, char *header);
+
+#endif /* _FILE_H */
diff --git a/libmultipath/hwtable.c b/libmultipath/hwtable.c
index e4fe380..c317cde 100644
--- a/libmultipath/hwtable.c
+++ b/libmultipath/hwtable.c
@@ -26,15 +26,12 @@ static struct hwentry default_hw[] = {
 	{
 		.vendor        = "COMPELNT",
 		.product       = "Compellent Vol",
-		.getuid        = DEFAULT_GETUID,
 		.features      = DEFAULT_FEATURES,
 		.hwhandler     = DEFAULT_HWHANDLER,
-		.selector      = DEFAULT_SELECTOR,
 		.pgpolicy      = MULTIBUS,
 		.pgfailback    = -FAILBACK_IMMEDIATE,
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_QUEUE,
-		.minio         = DEFAULT_MINIO,
 		.checker_name  = TUR,
 		.prio_name     = DEFAULT_PRIO,
 		.prio_args     = NULL,
@@ -48,15 +45,12 @@ static struct hwentry default_hw[] = {
 	{
 		.vendor        = "APPLE*",
 		.product       = "Xserve RAID ",
-		.getuid        = DEFAULT_GETUID,
 		.features      = DEFAULT_FEATURES,
 		.hwhandler     = DEFAULT_HWHANDLER,
-		.selector      = DEFAULT_SELECTOR,
 		.pgpolicy      = MULTIBUS,
 		.pgfailback    = FAILBACK_UNDEF,
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_UNDEF,
-		.minio         = DEFAULT_MINIO,
 		.checker_name  = DEFAULT_CHECKER,
 		.prio_name     = DEFAULT_PRIO,
 		.prio_args     = NULL,
@@ -70,15 +64,12 @@ static struct hwentry default_hw[] = {
 	{
 		.vendor        = "3PARdata",
 		.product       = "VV",
-		.getuid        = DEFAULT_GETUID,
 		.features      = DEFAULT_FEATURES,
 		.hwhandler     = DEFAULT_HWHANDLER,
-		.selector      = DEFAULT_SELECTOR,
 		.pgpolicy      = MULTIBUS,
 		.pgfailback    = FAILBACK_UNDEF,
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_UNDEF,
-		.minio         = DEFAULT_MINIO,
 		.checker_name  = DEFAULT_CHECKER,
 		.prio_name     = DEFAULT_PRIO,
 		.prio_args     = NULL,
@@ -86,15 +77,12 @@ static struct hwentry default_hw[] = {
 	{
 		.vendor        = "DEC",
 		.product       = "HSG80",
-		.getuid        = DEFAULT_GETUID,
 		.features      = "1 queue_if_no_path",
 		.hwhandler     = "1 hp_sw",
-		.selector      = DEFAULT_SELECTOR,
 		.pgpolicy      = GROUP_BY_PRIO,
 		.pgfailback    = FAILBACK_UNDEF,
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_UNDEF,
-		.minio         = DEFAULT_MINIO,
 		.checker_name  = HP_SW,
 		.prio_name     = PRIO_HP_SW,
 		.prio_args     = NULL,
@@ -102,15 +90,12 @@ static struct hwentry default_hw[] = {
 	{
 		.vendor        = "HP",
 		.product       = "A6189A",
-		.getuid        = DEFAULT_GETUID,
 		.features      = DEFAULT_FEATURES,
 		.hwhandler     = DEFAULT_HWHANDLER,
-		.selector      = DEFAULT_SELECTOR,
 		.pgpolicy      = MULTIBUS,
 		.pgfailback    = FAILBACK_UNDEF,
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = 12,
-		.minio         = DEFAULT_MINIO,
 		.checker_name  = DIRECTIO,
 		.prio_name     = DEFAULT_PRIO,
 		.prio_args     = NULL,
@@ -119,10 +104,8 @@ static struct hwentry default_hw[] = {
 		/* MSA 1000/MSA1500 EVA 3000/5000 with old firmware */
 		.vendor        = "(COMPAQ|HP)",
 		.product       = "(MSA|HSV)1.0.*",
-		.getuid        = DEFAULT_GETUID,
 		.features      = "1 queue_if_no_path",
 		.hwhandler     = "1 hp_sw",
-		.selector      = DEFAULT_SELECTOR,
 		.pgpolicy      = GROUP_BY_PRIO,
 		.pgfailback    = FAILBACK_UNDEF,
 		.rr_weight     = RR_WEIGHT_NONE,
@@ -136,10 +119,8 @@ static struct hwentry default_hw[] = {
 		/* MSA 1000/1500 with new firmware */
 		.vendor        = "(COMPAQ|HP)",
 		.product       = "MSA VOLUME",
-		.getuid        = DEFAULT_GETUID,
 		.features      = DEFAULT_FEATURES,
 		.hwhandler     = DEFAULT_HWHANDLER,
-		.selector      = DEFAULT_SELECTOR,
 		.pgpolicy      = GROUP_BY_PRIO,
 		.pgfailback    = -FAILBACK_IMMEDIATE,
 		.rr_weight     = RR_WEIGHT_NONE,
@@ -152,11 +133,9 @@ static struct hwentry default_hw[] = {
 	{
 		/* EVA 3000/5000 with new firmware, EVA 4000/6000/8000 */
 		.vendor        = "(COMPAQ|HP)",
-		.product       = "HSV1[01]1|HSV2[01]0|HSV300|HSV4[05]0",
-		.getuid        = DEFAULT_GETUID,
+		.product       = "HSV1[01]1|HSV2[01]0|HSV3[046]0|HSV4[05]0",
 		.features      = DEFAULT_FEATURES,
 		.hwhandler     = DEFAULT_HWHANDLER,
-		.selector      = DEFAULT_SELECTOR,
 		.pgpolicy      = GROUP_BY_PRIO,
 		.pgfailback    = -FAILBACK_IMMEDIATE,
 		.rr_weight     = RR_WEIGHT_NONE,
@@ -170,10 +149,8 @@ static struct hwentry default_hw[] = {
 		/* HP MSA2000 product family with old firmware */
 		.vendor        = "HP",
 		.product       = "MSA2[02]12fc|MSA2012i",
-		.getuid        = DEFAULT_GETUID,
 		.features      = DEFAULT_FEATURES,
 		.hwhandler     = DEFAULT_HWHANDLER,
-		.selector      = DEFAULT_SELECTOR,
 		.pgpolicy      = MULTIBUS,
 		.pgfailback    = -FAILBACK_IMMEDIATE,
 		.rr_weight     = RR_WEIGHT_NONE,
@@ -187,10 +164,8 @@ static struct hwentry default_hw[] = {
 		/* HP MSA2000 product family with new firmware */
 		.vendor        = "HP",
 		.product       = "MSA2012sa|MSA23(12|24)(fc|i|sa)|MSA2000s VOLUME",
-		.getuid        = DEFAULT_GETUID,
 		.features      = DEFAULT_FEATURES,
 		.hwhandler     = DEFAULT_HWHANDLER,
-		.selector      = DEFAULT_SELECTOR,
 		.pgpolicy      = GROUP_BY_PRIO,
 		.pgfailback    = -FAILBACK_IMMEDIATE,
 		.rr_weight     = RR_WEIGHT_NONE,
@@ -205,10 +180,8 @@ static struct hwentry default_hw[] = {
 		/* HP SVSP */
 		.vendor        = "HP",
 		.product       = "HSVX700",
-		.getuid        = DEFAULT_GETUID,
 		.features      = DEFAULT_FEATURES,
 		.hwhandler     = "1 alua",
-		.selector      = DEFAULT_SELECTOR,
 		.pgpolicy      = GROUP_BY_PRIO,
 		.pgfailback    = -FAILBACK_IMMEDIATE,
 		.rr_weight     = RR_WEIGHT_NONE,
@@ -223,19 +196,31 @@ static struct hwentry default_hw[] = {
 		/* HP Smart Array */
 		.vendor        = "HP",
 		.product       = "LOGICAL VOLUME.*",
-		.getuid        = DEFAULT_GETUID,
 		.features      = DEFAULT_FEATURES,
 		.hwhandler     = DEFAULT_HWHANDLER,
-		.selector      = DEFAULT_SELECTOR,
 		.pgpolicy      = MULTIBUS,
 		.pgfailback    = FAILBACK_UNDEF,
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = 12,
-		.minio         = DEFAULT_MINIO,
-		.checker_name  = CCISS_TUR,
+		.checker_name  = TUR,
 		.prio_name     = DEFAULT_PRIO,
 		.prio_args     = NULL,
 	},
+	{
+		/* HP P2000 family arrays */
+		.vendor        = "HP",
+		.product       = "P2000 G3 FC|P2000G3 FC/iSCSI|P2000 G3 SAS|P2000 G3 iSCSI",
+		.features      = DEFAULT_FEATURES,
+		.hwhandler     = DEFAULT_HWHANDLER,
+		.pgpolicy      = GROUP_BY_PRIO,
+		.pgfailback    = -FAILBACK_IMMEDIATE,
+		.rr_weight     = RR_WEIGHT_NONE,
+		.no_path_retry = 18,
+		.minio         = 100,
+		.checker_name  = TUR,
+		.prio_name     = PRIO_ALUA,
+		.prio_args     = NULL,
+	},
 	/*
 	 * DDN controller family
 	 *
@@ -245,15 +230,12 @@ static struct hwentry default_hw[] = {
 	{
 		.vendor        = "DDN",
 		.product       = "SAN DataDirector",
-		.getuid        = DEFAULT_GETUID,
 		.features      = DEFAULT_FEATURES,
 		.hwhandler     = DEFAULT_HWHANDLER,
-		.selector      = DEFAULT_SELECTOR,
 		.pgpolicy      = MULTIBUS,
 		.pgfailback    = FAILBACK_UNDEF,
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_UNDEF,
-		.minio         = DEFAULT_MINIO,
 		.checker_name  = DIRECTIO,
 		.prio_name     = DEFAULT_PRIO,
 		.prio_args     = NULL,
@@ -267,16 +249,13 @@ static struct hwentry default_hw[] = {
 	{
 		.vendor        = "EMC",
 		.product       = "SYMMETRIX",
-		.getuid        = "/lib/udev/scsi_id --page=pre-spc3-83 --whitelisted --device=/dev/%n",
 		.features      = DEFAULT_FEATURES,
 		.hwhandler     = DEFAULT_HWHANDLER,
-		.selector      = DEFAULT_SELECTOR,
 		.pgpolicy      = MULTIBUS,
 		.pgfailback    = FAILBACK_UNDEF,
 		.rr_weight     = RR_WEIGHT_NONE,
-		.no_path_retry = NO_PATH_RETRY_UNDEF,
-		.minio         = DEFAULT_MINIO,
-		.checker_name  = DIRECTIO,
+		.no_path_retry = 6,
+		.checker_name  = TUR,
 		.prio_name     = DEFAULT_PRIO,
 		.prio_args     = NULL,
 	},
@@ -284,15 +263,12 @@ static struct hwentry default_hw[] = {
 		.vendor        = "DGC",
 		.product       = ".*",
 		.bl_product    = "LUNZ",
-		.getuid        = DEFAULT_GETUID,
 		.features      = "1 queue_if_no_path",
 		.hwhandler     = "1 emc",
-		.selector      = DEFAULT_SELECTOR,
 		.pgpolicy      = GROUP_BY_PRIO,
 		.pgfailback    = -FAILBACK_IMMEDIATE,
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = (300 / DEFAULT_CHECKINT),
-		.minio         = DEFAULT_MINIO,
 		.checker_name  = EMC_CLARIION,
 		.prio_name     = PRIO_EMC,
 		.prio_args     = NULL,
@@ -301,15 +277,13 @@ static struct hwentry default_hw[] = {
 		.vendor        = "EMC",
 		.product       = "Invista",
 		.bl_product    = "LUNZ",
-		.getuid        = DEFAULT_GETUID,
 		.features      = DEFAULT_FEATURES,
 		.hwhandler     = DEFAULT_HWHANDLER,
-		.selector      = DEFAULT_SELECTOR,
 		.pgpolicy      = MULTIBUS,
 		.pgfailback    = FAILBACK_UNDEF,
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = 5,
-		.minio         = DEFAULT_MINIO,
+		.checker_name  = TUR,
 		.prio_name     = DEFAULT_PRIO,
 		.prio_args     = NULL,
 	},
@@ -322,34 +296,27 @@ static struct hwentry default_hw[] = {
 	{
 		.vendor        = "FSC",
 		.product       = "CentricStor",
-		.getuid        = DEFAULT_GETUID,
 		.features      = DEFAULT_FEATURES,
 		.hwhandler     = DEFAULT_HWHANDLER,
-		.selector      = DEFAULT_SELECTOR,
 		.pgpolicy      = GROUP_BY_SERIAL,
 		.pgfailback    = FAILBACK_UNDEF,
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_UNDEF,
-		.minio         = DEFAULT_MINIO,
 		.checker_name  = DIRECTIO,
 		.prio_name     = DEFAULT_PRIO,
 		.prio_args     = NULL,
 	},
 	{
-		.vendor        = "EMC",
-		.product       = "Invista",
-		.bl_product    = "LUNZ",
-		.getuid        = DEFAULT_GETUID,
-		.features      = DEFAULT_FEATURES,
+		.vendor        = "FUJITSU",
+		.product       = "ETERNUS_DX(L|400|8000)",
+		.features      = "1 queue_if_no_path",
 		.hwhandler     = DEFAULT_HWHANDLER,
-		.selector      = DEFAULT_SELECTOR,
-		.pgpolicy      = FAILOVER,
-		.pgfailback    = FAILBACK_UNDEF,
+		.pgpolicy      = GROUP_BY_PRIO,
+		.pgfailback    = -FAILBACK_IMMEDIATE,
 		.rr_weight     = RR_WEIGHT_NONE,
-		.no_path_retry = 5,
-		.minio         = DEFAULT_MINIO,
+		.no_path_retry = 10,
 		.checker_name  = TUR,
-		.prio_name     = DEFAULT_PRIO,
+		.prio_name     = PRIO_ALUA,
 		.prio_args     = NULL,
 	},
 	/*
@@ -361,15 +328,12 @@ static struct hwentry default_hw[] = {
 	{
 		.vendor        = "(HITACHI|HP)",
 		.product       = "OPEN-.*",
-		.getuid        = DEFAULT_GETUID,
 		.features      = DEFAULT_FEATURES,
 		.hwhandler     = DEFAULT_HWHANDLER,
-		.selector      = DEFAULT_SELECTOR,
 		.pgpolicy      = MULTIBUS,
 		.pgfailback    = FAILBACK_UNDEF,
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_UNDEF,
-		.minio         = DEFAULT_MINIO,
 		.checker_name  = TUR,
 		.prio_name     = DEFAULT_PRIO,
 		.prio_args     = NULL,
@@ -377,15 +341,12 @@ static struct hwentry default_hw[] = {
 	{
 		.vendor        = "HITACHI",
 		.product       = "DF.*",
-		.getuid        = DEFAULT_GETUID,
 		.features      = "1 queue_if_no_path",
 		.hwhandler     = DEFAULT_HWHANDLER,
-		.selector      = DEFAULT_SELECTOR,
 		.pgpolicy      = GROUP_BY_PRIO,
 		.pgfailback    = -FAILBACK_IMMEDIATE,
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_UNDEF,
-		.minio         = DEFAULT_MINIO,
 		.checker_name  = TUR,
 		.prio_name     = PRIO_HDS,
 		.prio_args     = NULL,
@@ -399,15 +360,12 @@ static struct hwentry default_hw[] = {
 	{
 		.vendor        = "IBM",
 		.product       = "ProFibre 4000R",
-		.getuid        = DEFAULT_GETUID,
 		.features      = DEFAULT_FEATURES,
 		.hwhandler     = DEFAULT_HWHANDLER,
-		.selector      = DEFAULT_SELECTOR,
 		.pgpolicy      = MULTIBUS,
 		.pgfailback    = FAILBACK_UNDEF,
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_UNDEF,
-		.minio         = DEFAULT_MINIO,
 		.checker_name  = DIRECTIO,
 		.prio_name     = DEFAULT_PRIO,
 		.prio_args     = NULL,
@@ -415,16 +373,14 @@ static struct hwentry default_hw[] = {
 	{
 		/* IBM FAStT 1722-600 */
 		.vendor        = "IBM",
-		.product       = "1722-600",
-		.getuid        = DEFAULT_GETUID,
+		.product       = "^1722-600",
+		.bl_product    = "Universal Xport",
 		.features      = "1 queue_if_no_path",
 		.hwhandler     = "1 rdac",
-		.selector      = DEFAULT_SELECTOR,
 		.pgpolicy      = GROUP_BY_PRIO,
 		.pgfailback    = -FAILBACK_IMMEDIATE,
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = 300,
-		.minio         = DEFAULT_MINIO,
 		.checker_name  = RDAC,
 		.prio_name     = PRIO_RDAC,
 		.prio_args     = NULL,
@@ -432,16 +388,14 @@ static struct hwentry default_hw[] = {
 	{
 		/* IBM DS4100 */
 		.vendor        = "IBM",
-		.product       = "1724",
-		.getuid        = DEFAULT_GETUID,
+		.product       = "^1724",
+		.bl_product    = "Universal Xport",
 		.features      = "1 queue_if_no_path",
 		.hwhandler     = "1 rdac",
-		.selector      = DEFAULT_SELECTOR,
 		.pgpolicy      = GROUP_BY_PRIO,
 		.pgfailback    = -FAILBACK_IMMEDIATE,
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = 300,
-		.minio         = DEFAULT_MINIO,
 		.checker_name  = RDAC,
 		.prio_name     = PRIO_RDAC,
 		.prio_args     = NULL,
@@ -449,16 +403,14 @@ static struct hwentry default_hw[] = {
 	{
 		/* IBM DS3200 / DS3300 / DS3400 */
 		.vendor        = "IBM",
-		.product       = "1726",
-		.getuid        = DEFAULT_GETUID,
+		.product       = "^1726",
+		.bl_product    = "Universal Xport",
 		.features      = "1 queue_if_no_path",
 		.hwhandler     = "1 rdac",
-		.selector      = DEFAULT_SELECTOR,
 		.pgpolicy      = GROUP_BY_PRIO,
 		.pgfailback    = -FAILBACK_IMMEDIATE,
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = 300,
-		.minio         = DEFAULT_MINIO,
 		.checker_name  = RDAC,
 		.prio_name     = PRIO_RDAC,
 		.prio_args     = NULL,
@@ -466,32 +418,28 @@ static struct hwentry default_hw[] = {
 	{
 		/* IBM DS4400 / DS4500 / FAStT700 */
 		.vendor        = "IBM",
-		.product       = "1742",
-		.getuid        = DEFAULT_GETUID,
+		.product       = "^1742",
+		.bl_product    = "Universal Xport",
 		.features      = DEFAULT_FEATURES,
 		.hwhandler     = "1 rdac",
-		.selector      = DEFAULT_SELECTOR,
 		.pgpolicy      = GROUP_BY_PRIO,
 		.pgfailback    = -FAILBACK_IMMEDIATE,
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_QUEUE,
-		.minio         = DEFAULT_MINIO,
 		.checker_name  = RDAC,
 		.prio_name     = PRIO_RDAC,
 		.prio_args     = NULL,
 	},
 	{
 		.vendor        = "IBM",
-		.product       = "1745|1746",
-		.getuid        = DEFAULT_GETUID,
+		.product       = "^1745|^1746",
+		.bl_product    = "Universal Xport",
 		.features      = "2 pg_init_retries 50",
 		.hwhandler     = "1 rdac",
-		.selector      = DEFAULT_SELECTOR,
 		.pgpolicy      = GROUP_BY_PRIO,
 		.pgfailback    = -FAILBACK_IMMEDIATE,
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = 15,
-		.minio         = DEFAULT_MINIO,
 		.checker_name  = RDAC,
 		.prio_name     = PRIO_RDAC,
 		.prio_args     = NULL,
@@ -499,16 +447,14 @@ static struct hwentry default_hw[] = {
 	{
 	    /* IBM DS4700 */
 		.vendor        = "IBM",
-		.product       = "1814",
-		.getuid        = DEFAULT_GETUID,
+		.product       = "^1814",
+		.bl_product    = "Universal Xport",
 		.features      = DEFAULT_FEATURES,
 		.hwhandler     = "1 rdac",
-		.selector      = DEFAULT_SELECTOR,
 		.pgpolicy      = GROUP_BY_PRIO,
 		.pgfailback    = -FAILBACK_IMMEDIATE,
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_QUEUE,
-		.minio         = DEFAULT_MINIO,
 		.checker_name  = RDAC,
 		.prio_name     = PRIO_RDAC,
 		.prio_args     = NULL,
@@ -516,16 +462,14 @@ static struct hwentry default_hw[] = {
 	{
 	    /* IBM DS4800 */
 		.vendor        = "IBM",
-		.product       = "1815",
-		.getuid        = DEFAULT_GETUID,
+		.product       = "^1815",
+		.bl_product    = "Universal Xport",
 		.features      = DEFAULT_FEATURES,
 		.hwhandler     = "1 rdac",
-		.selector      = DEFAULT_SELECTOR,
 		.pgpolicy      = GROUP_BY_PRIO,
 		.pgfailback    = -FAILBACK_IMMEDIATE,
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_QUEUE,
-		.minio         = DEFAULT_MINIO,
 		.checker_name  = RDAC,
 		.prio_name     = PRIO_RDAC,
 		.prio_args     = NULL,
@@ -533,16 +477,14 @@ static struct hwentry default_hw[] = {
 	{
 	    /* IBM DS5000 */
 		.vendor        = "IBM",
-		.product       = "1818",
-		.getuid        = DEFAULT_GETUID,
+		.product       = "^1818",
+		.bl_product    = "Universal Xport",
 		.features      = DEFAULT_FEATURES,
 		.hwhandler     = "1 rdac",
-		.selector      = DEFAULT_SELECTOR,
 		.pgpolicy      = GROUP_BY_PRIO,
 		.pgfailback    = -FAILBACK_IMMEDIATE,
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_QUEUE,
-		.minio         = DEFAULT_MINIO,
 		.checker_name  = RDAC,
 		.prio_name     = PRIO_RDAC,
 		.prio_args     = NULL,
@@ -550,16 +492,14 @@ static struct hwentry default_hw[] = {
 	{
 		/* IBM Netfinity Fibre Channel RAID Controller Unit */
 		.vendor        = "IBM",
-		.product       = "3526",
-		.getuid        = DEFAULT_GETUID,
+		.product       = "^3526",
+		.bl_product    = "Universal Xport",
 		.features      = DEFAULT_FEATURES,
 		.hwhandler     = "1 rdac",
-		.selector      = DEFAULT_SELECTOR,
 		.pgpolicy      = GROUP_BY_PRIO,
 		.pgfailback    = -FAILBACK_IMMEDIATE,
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_QUEUE,
-		.minio         = DEFAULT_MINIO,
 		.checker_name  = RDAC,
 		.prio_name     = PRIO_RDAC,
 		.prio_args     = NULL,
@@ -567,16 +507,13 @@ static struct hwentry default_hw[] = {
 	{
 		/* IBM DS4200 / FAStT200 */
 		.vendor        = "IBM",
-		.product       = "3542",
-		.getuid        = DEFAULT_GETUID,
+		.product       = "^3542",
 		.features      = DEFAULT_FEATURES,
 		.hwhandler     = DEFAULT_HWHANDLER,
-		.selector      = DEFAULT_SELECTOR,
 		.pgpolicy      = GROUP_BY_SERIAL,
 		.pgfailback    = FAILBACK_UNDEF,
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_UNDEF,
-		.minio         = DEFAULT_MINIO,
 		.checker_name  = TUR,
 		.prio_name     = DEFAULT_PRIO,
 		.prio_args     = NULL,
@@ -584,16 +521,13 @@ static struct hwentry default_hw[] = {
 	{
 		/* IBM ESS F20 aka Shark */
 		.vendor        = "IBM",
-		.product       = "2105800",
-		.getuid        = DEFAULT_GETUID,
+		.product       = "^2105800",
 		.features      = "1 queue_if_no_path",
 		.hwhandler     = DEFAULT_HWHANDLER,
-		.selector      = DEFAULT_SELECTOR,
 		.pgpolicy      = GROUP_BY_SERIAL,
 		.pgfailback    = FAILBACK_UNDEF,
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_UNDEF,
-		.minio         = DEFAULT_MINIO,
 		.checker_name  = TUR,
 		.prio_name     = DEFAULT_PRIO,
 		.prio_args     = NULL,
@@ -601,16 +535,13 @@ static struct hwentry default_hw[] = {
 	{
 		/* IBM ESS F20 aka Shark */
 		.vendor        = "IBM",
-		.product       = "2105F20",
-		.getuid        = DEFAULT_GETUID,
+		.product       = "^2105F20",
 		.features      = "1 queue_if_no_path",
 		.hwhandler     = DEFAULT_HWHANDLER,
-		.selector      = DEFAULT_SELECTOR,
 		.pgpolicy      = GROUP_BY_SERIAL,
 		.pgfailback    = FAILBACK_UNDEF,
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_UNDEF,
-		.minio         = DEFAULT_MINIO,
 		.checker_name  = TUR,
 		.prio_name     = DEFAULT_PRIO,
 		.prio_args     = NULL,
@@ -618,16 +549,13 @@ static struct hwentry default_hw[] = {
 	{
 		/* IBM DS6000 */
 		.vendor        = "IBM",
-		.product       = "1750500",
-		.getuid        = DEFAULT_GETUID,
+		.product       = "^1750500",
 		.features      = "1 queue_if_no_path",
 		.hwhandler     = DEFAULT_HWHANDLER,
-		.selector      = DEFAULT_SELECTOR,
 		.pgpolicy      = GROUP_BY_PRIO,
 		.pgfailback    = -FAILBACK_IMMEDIATE,
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_UNDEF,
-		.minio         = DEFAULT_MINIO,
 		.checker_name  = TUR,
 		.prio_name     = PRIO_ALUA,
 		.prio_args     = NULL,
@@ -635,16 +563,13 @@ static struct hwentry default_hw[] = {
 	{
 		/* IBM DS8000 */
 		.vendor        = "IBM",
-		.product       = "2107900",
-		.getuid        = DEFAULT_GETUID,
+		.product       = "^2107900",
 		.features      = "1 queue_if_no_path",
 		.hwhandler     = DEFAULT_HWHANDLER,
-		.selector      = DEFAULT_SELECTOR,
 		.pgpolicy      = MULTIBUS,
 		.pgfailback    = FAILBACK_UNDEF,
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_UNDEF,
-		.minio         = DEFAULT_MINIO,
 		.checker_name  = TUR,
 		.prio_name     = DEFAULT_PRIO,
 		.prio_args     = NULL,
@@ -652,16 +577,13 @@ static struct hwentry default_hw[] = {
 	{
 		/* IBM SAN Volume Controller */
 		.vendor        = "IBM",
-		.product       = "2145",
-		.getuid        = DEFAULT_GETUID,
+		.product       = "^2145",
 		.features      = "1 queue_if_no_path",
 		.hwhandler     = DEFAULT_HWHANDLER,
-		.selector      = DEFAULT_SELECTOR,
 		.pgpolicy      = GROUP_BY_PRIO,
 		.pgfailback    = -FAILBACK_IMMEDIATE,
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_UNDEF,
-		.minio         = DEFAULT_MINIO,
 		.checker_name  = TUR,
 		.prio_name     = PRIO_ALUA,
 		.prio_args     = NULL,
@@ -671,15 +593,13 @@ static struct hwentry default_hw[] = {
 		.vendor        = "IBM",
 		.product       = "S/390 DASD ECKD",
 		.bl_product       = "S/390.*",
-		.getuid        = "/sbin/dasdinfo -u -b %n",
+		.uid_attribute = "ID_UID",
 		.features      = "1 queue_if_no_path",
 		.hwhandler     = DEFAULT_HWHANDLER,
-		.selector      = DEFAULT_SELECTOR,
 		.pgpolicy      = MULTIBUS,
 		.pgfailback    = FAILBACK_UNDEF,
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_UNDEF,
-		.minio         = DEFAULT_MINIO,
 		.checker_name  = DIRECTIO,
 		.prio_name     = DEFAULT_PRIO,
 		.prio_args     = NULL,
@@ -689,15 +609,13 @@ static struct hwentry default_hw[] = {
 		.vendor        = "IBM",
 		.product       = "S/390 DASD FBA",
 		.bl_product       = "S/390.*",
-		.getuid        = "/sbin/dasdinfo -u -b %n",
+		.uid_attribute = "ID_UID",
 		.features      = "1 queue_if_no_path",
 		.hwhandler     = DEFAULT_HWHANDLER,
-		.selector      = DEFAULT_SELECTOR,
 		.pgpolicy      = MULTIBUS,
 		.pgfailback    = FAILBACK_UNDEF,
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_UNDEF,
-		.minio         = DEFAULT_MINIO,
 		.checker_name  = DIRECTIO,
 		.prio_name     = DEFAULT_PRIO,
 		.prio_args     = NULL,
@@ -705,20 +623,47 @@ static struct hwentry default_hw[] = {
 	{
 		/* IBM IPR */
 		.vendor        = "IBM",
-		.product       = "IPR.*",
-		.getuid        = DEFAULT_GETUID,
+		.product       = "^IPR.*",
 		.features      = "1 queue_if_no_path",
 		.hwhandler     = "1 alua",
-		.selector      = DEFAULT_SELECTOR,
 		.pgpolicy      = GROUP_BY_PRIO,
 		.pgfailback    = -FAILBACK_IMMEDIATE,
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_UNDEF,
-		.minio         = DEFAULT_MINIO,
 		.checker_name  = TUR,
 		.prio_name     = PRIO_ALUA,
 		.prio_args     = NULL,
 	},
+	{
+		/* IBM RSSM */
+		.vendor        = "IBM",
+		.product       = "1820N00",
+		.features      = DEFAULT_FEATURES,
+		.hwhandler     = DEFAULT_HWHANDLER,
+		.pgpolicy      = GROUP_BY_PRIO,
+		.pgfailback    = -FAILBACK_IMMEDIATE,
+		.rr_weight     = RR_WEIGHT_NONE,
+		.no_path_retry = NO_PATH_RETRY_QUEUE,
+		.minio         = 100,
+		.checker_name  = TUR,
+		.prio_name     = PRIO_ALUA,
+		.prio_args     = NULL,
+	},
+	{
+	    /* IBM XIV Storage System */
+		.vendor        = "IBM",
+		.product       = "2810XIV",
+		.features      = "1 queue_if_no_path",
+		.hwhandler     = DEFAULT_HWHANDLER,
+		.pgpolicy      = MULTIBUS,
+		.pgfailback    = 15,
+		.rr_weight     = RR_WEIGHT_NONE,
+		.no_path_retry = NO_PATH_RETRY_UNDEF,
+		.minio         = 15,
+		.checker_name  = TUR,
+		.prio_name     = DEFAULT_PRIO,
+		.prio_args     = NULL,
+	},
 	/*
 	 * IBM Power Virtual SCSI Devices
 	 *
@@ -729,15 +674,12 @@ static struct hwentry default_hw[] = {
 		/* AIX VDASD */
 		.vendor        = "AIX",
 		.product       = "VDASD",
-		.getuid        = DEFAULT_GETUID,
 		.features      = DEFAULT_FEATURES,
 		.hwhandler     = DEFAULT_HWHANDLER,
-		.selector      = DEFAULT_SELECTOR,
 		.pgpolicy      = MULTIBUS,
 		.pgfailback    = -FAILBACK_IMMEDIATE,
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = (300 / DEFAULT_CHECKINT),
-		.minio         = DEFAULT_MINIO,
 		.checker_name  = DIRECTIO,
 		.prio_name     = DEFAULT_PRIO,
 		.prio_args     = NULL,
@@ -746,33 +688,41 @@ static struct hwentry default_hw[] = {
 		/* IBM 3303      NVDISK */
 		.vendor        = "IBM",
 		.product       = "3303      NVDISK",
-		.getuid        = DEFAULT_GETUID,
 		.features      = DEFAULT_FEATURES,
 		.hwhandler     = DEFAULT_HWHANDLER,
-		.selector      = DEFAULT_SELECTOR,
 		.pgpolicy      = FAILOVER,
 		.pgfailback    = -FAILBACK_IMMEDIATE,
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = (300 / DEFAULT_CHECKINT),
-		.minio         = DEFAULT_MINIO,
 		.checker_name  = TUR,
 		.prio_name     = DEFAULT_PRIO,
 		.prio_args     = NULL,
 	},
-
+	{
+		/* AIX NVDISK */
+		.vendor        = "AIX",
+		.product       = "NVDISK",
+		.features      = DEFAULT_FEATURES,
+		.hwhandler     = "1 alua",
+		.pgpolicy      = GROUP_BY_PRIO,
+		.pgfailback    = -FAILBACK_IMMEDIATE,
+		.rr_weight     = RR_WEIGHT_NONE,
+		.no_path_retry = (300 / DEFAULT_CHECKINT),
+		.checker_name  = TUR,
+		.prio_name     = PRIO_ALUA,
+		.prio_args     = NULL,
+	},
 	{
 		/* DELL MD3000 */
 		.vendor        = "DELL",
 		.product       = "MD3000",
-		.getuid        = DEFAULT_GETUID,
+		.bl_product    = "Universal Xport",
 		.features      = "2 pg_init_retries 50",
 		.hwhandler     = "1 rdac",
-		.selector      = DEFAULT_SELECTOR,
 		.pgpolicy      = GROUP_BY_PRIO,
 		.pgfailback    = -FAILBACK_IMMEDIATE,
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = 15,
-		.minio         = DEFAULT_MINIO,
 		.checker_name  = RDAC,
 		.prio_name     = PRIO_RDAC,
 		.prio_args     = NULL,
@@ -781,15 +731,13 @@ static struct hwentry default_hw[] = {
 		/* DELL MD3000i */
 		.vendor        = "DELL",
 		.product       = "MD3000i",
-		.getuid        = DEFAULT_GETUID,
+		.bl_product    = "Universal Xport",
 		.features      = "2 pg_init_retries 50",
 		.hwhandler     = "1 rdac",
-		.selector      = DEFAULT_SELECTOR,
 		.pgpolicy      = GROUP_BY_PRIO,
 		.pgfailback    = -FAILBACK_IMMEDIATE,
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = 15,
-		.minio         = DEFAULT_MINIO,
 		.checker_name  = RDAC,
 		.prio_name     = PRIO_RDAC,
 		.prio_args     = NULL,
@@ -798,15 +746,13 @@ static struct hwentry default_hw[] = {
 		/* DELL MD32xx */
 		.vendor        = "DELL",
 		.product       = "MD32xx",
-		.getuid        = DEFAULT_GETUID,
+		.bl_product    = "Universal Xport",
 		.features      = "2 pg_init_retries 50",
 		.hwhandler     = "1 rdac",
-		.selector      = DEFAULT_SELECTOR,
 		.pgpolicy      = GROUP_BY_PRIO,
 		.pgfailback    = -FAILBACK_IMMEDIATE,
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = 15,
-		.minio         = DEFAULT_MINIO,
 		.checker_name  = RDAC,
 		.prio_name     = PRIO_RDAC,
 		.prio_args     = NULL,
@@ -815,15 +761,13 @@ static struct hwentry default_hw[] = {
 		/* DELL MD32xxi */
 		.vendor        = "DELL",
 		.product       = "MD32xxi",
-		.getuid        = DEFAULT_GETUID,
+		.bl_product    = "Universal Xport",
 		.features      = "2 pg_init_retries 50",
 		.hwhandler     = "1 rdac",
-		.selector      = DEFAULT_SELECTOR,
 		.pgpolicy      = GROUP_BY_PRIO,
 		.pgfailback    = -FAILBACK_IMMEDIATE,
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = 15,
-		.minio         = DEFAULT_MINIO,
 		.checker_name  = RDAC,
 		.prio_name     = PRIO_RDAC,
 		.prio_args     = NULL,
@@ -837,18 +781,20 @@ static struct hwentry default_hw[] = {
 	{
 		.vendor        = "NETAPP",
 		.product       = "LUN.*",
-		.getuid        = DEFAULT_GETUID,
-		.features      = "1 queue_if_no_path",
+		.features      = "3 queue_if_no_path pg_init_retries 50",
 		.hwhandler     = DEFAULT_HWHANDLER,
-		.selector      = DEFAULT_SELECTOR,
 		.pgpolicy      = GROUP_BY_PRIO,
 		.pgfailback    = -FAILBACK_IMMEDIATE,
+		.flush_on_last_del = FLUSH_ENABLED,
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_UNDEF,
 		.minio         = 128,
-		.checker_name  = DIRECTIO,
-		.prio_name     = PRIO_NETAPP,
+		.dev_loss      = MAX_DEV_LOSS_TMO,
+		.checker_name  = TUR,
+		.prio_name     = PRIO_ONTAP,
 		.prio_args     = NULL,
+		.retain_hwhandler = RETAIN_HWHANDLER_ON,
+		.detect_prio   = DETECT_PRIO_ON,
 	},
 	/*
 	 * NEXENTA/COMSTAR controller family
@@ -859,10 +805,8 @@ static struct hwentry default_hw[] = {
 	{
 		.vendor        = "NEXENTA",
 		.product       = "COMSTAR",
-		.getuid        = DEFAULT_GETUID,
 		.features      = "1 queue_if_no_path",
 		.hwhandler     = DEFAULT_HWHANDLER,
-		.selector      = DEFAULT_SELECTOR,
 		.pgpolicy      = GROUP_BY_SERIAL,
 		.pgfailback    = -FAILBACK_IMMEDIATE,
 		.rr_weight     = RR_WEIGHT_NONE,
@@ -881,17 +825,15 @@ static struct hwentry default_hw[] = {
 	{
 		.vendor        = "IBM",
 		.product       = "Nseries.*",
-		.getuid        = DEFAULT_GETUID,
 		.features      = "1 queue_if_no_path",
 		.hwhandler     = DEFAULT_HWHANDLER,
-		.selector      = DEFAULT_SELECTOR,
 		.pgpolicy      = GROUP_BY_PRIO,
 		.pgfailback    = -FAILBACK_IMMEDIATE,
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_UNDEF,
 		.minio         = 128,
 		.checker_name  = DIRECTIO,
-		.prio_name     = PRIO_NETAPP,
+		.prio_name     = PRIO_ONTAP,
 		.prio_args     = NULL,
 	},
 	/*
@@ -903,19 +845,17 @@ static struct hwentry default_hw[] = {
 	{
 		.vendor        = "Pillar",
 		.product       = "Axiom.*",
-		.getuid        = DEFAULT_GETUID,
 		.features      = DEFAULT_FEATURES,
 		.hwhandler     = DEFAULT_HWHANDLER,
-		.selector      = DEFAULT_SELECTOR,
 		.pgpolicy      = GROUP_BY_PRIO,
 		.pgfailback    = FAILBACK_UNDEF,
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_UNDEF,
-		.minio         = DEFAULT_MINIO,
 		.checker_name  = TUR,
 		.prio_name     = PRIO_ALUA,
 		.prio_args     = NULL,
 	},
+
 	/*
 	 * SGI arrays
 	 *
@@ -925,15 +865,12 @@ static struct hwentry default_hw[] = {
 	{
 		.vendor        = "SGI",
 		.product       = "TP9[13]00",
-		.getuid        = DEFAULT_GETUID,
 		.features      = DEFAULT_FEATURES,
 		.hwhandler     = DEFAULT_HWHANDLER,
-		.selector      = DEFAULT_SELECTOR,
 		.pgpolicy      = MULTIBUS,
 		.pgfailback    = FAILBACK_UNDEF,
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_UNDEF,
-		.minio         = DEFAULT_MINIO,
 		.checker_name  = DIRECTIO,
 		.prio_name     = DEFAULT_PRIO,
 		.prio_args     = NULL,
@@ -941,15 +878,13 @@ static struct hwentry default_hw[] = {
 	{
 		.vendor        = "SGI",
 		.product       = "TP9[45]00",
-		.getuid        = DEFAULT_GETUID,
+		.bl_product    = "Universal Xport",
 		.features      = DEFAULT_FEATURES,
 		.hwhandler     = "1 rdac",
-		.selector      = DEFAULT_SELECTOR,
 		.pgpolicy      = GROUP_BY_PRIO,
 		.pgfailback    = -FAILBACK_IMMEDIATE,
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_QUEUE,
-		.minio         = DEFAULT_MINIO,
 		.checker_name  = RDAC,
 		.prio_name     = PRIO_RDAC,
 		.prio_args     = NULL,
@@ -957,19 +892,31 @@ static struct hwentry default_hw[] = {
 	{
 		.vendor        = "SGI",
 		.product       = "IS.*",
-		.getuid        = DEFAULT_GETUID,
-		.features      = DEFAULT_FEATURES,
+		.bl_product    = "Universal Xport",
+		.features      = "2 pg_init_retries 50",
 		.hwhandler     = "1 rdac",
-		.selector      = DEFAULT_SELECTOR,
 		.pgpolicy      = GROUP_BY_PRIO,
 		.pgfailback    = -FAILBACK_IMMEDIATE,
 		.rr_weight     = RR_WEIGHT_NONE,
-		.no_path_retry = NO_PATH_RETRY_QUEUE,
-		.minio         = DEFAULT_MINIO,
+		.no_path_retry = 15,
 		.checker_name  = RDAC,
 		.prio_name     = PRIO_RDAC,
 		.prio_args     = NULL,
 	},
+	/* NEC Storage M Series */
+	{
+		.vendor        = "NEC",
+		.product       = "DISK ARRAY",
+		.features      = DEFAULT_FEATURES,
+		.hwhandler     = "1 alua",
+		.pgpolicy      = GROUP_BY_PRIO,
+		.pgfailback    = -FAILBACK_IMMEDIATE,
+		.rr_weight     = RR_WEIGHT_NONE,
+		.no_path_retry = NO_PATH_RETRY_UNDEF,
+		.checker_name  = TUR,
+		.prio_name     = PRIO_ALUA,
+		.prio_args     = NULL,
+	},
 	/*
 	 * STK arrays
 	 *
@@ -979,15 +926,13 @@ static struct hwentry default_hw[] = {
 	{
 		.vendor        = "STK",
 		.product       = "OPENstorage D280",
-		.getuid        = DEFAULT_GETUID,
+		.bl_product    = "Universal Xport",
 		.features      = DEFAULT_FEATURES,
 		.hwhandler     = "1 rdac",
-		.selector      = DEFAULT_SELECTOR,
 		.pgpolicy      = GROUP_BY_PRIO,
 		.pgfailback    = -FAILBACK_IMMEDIATE,
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_UNDEF,
-		.minio         = DEFAULT_MINIO,
 		.checker_name  = TUR,
 		.prio_name     = PRIO_RDAC,
 		.prio_args     = NULL,
@@ -1001,19 +946,42 @@ static struct hwentry default_hw[] = {
 	{
 		.vendor        = "SUN",
 		.product       = "(StorEdge 3510|T4)",
-		.getuid        = DEFAULT_GETUID,
 		.features      = DEFAULT_FEATURES,
 		.hwhandler     = DEFAULT_HWHANDLER,
-		.selector      = DEFAULT_SELECTOR,
 		.pgpolicy      = MULTIBUS,
 		.pgfailback    = FAILBACK_UNDEF,
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_UNDEF,
-		.minio         = DEFAULT_MINIO,
 		.checker_name  = DIRECTIO,
 		.prio_name     = DEFAULT_PRIO,
 		.prio_args     = NULL,
 	},
+	{
+		.vendor        = "SUN",
+		.product       = "STK6580_6780",
+		.features      = DEFAULT_FEATURES,
+		.hwhandler     = "1 rdac",
+		.pgpolicy      = GROUP_BY_PRIO,
+		.pgfailback    = -FAILBACK_IMMEDIATE,
+		.rr_weight     = RR_WEIGHT_NONE,
+		.no_path_retry = NO_PATH_RETRY_UNDEF,
+		.checker_name  = TUR,
+		.prio_name     = PRIO_RDAC,
+		.prio_args     = NULL,
+	},
+	{
+		.vendor        = "EUROLOGC",
+		.product       = "FC2502",
+		.features      = DEFAULT_FEATURES,
+		.hwhandler     = DEFAULT_HWHANDLER,
+		.pgpolicy      = GROUP_BY_PRIO,
+		.pgfailback    = FAILBACK_UNDEF,
+		.rr_weight     = RR_WEIGHT_NONE,
+		.no_path_retry = NO_PATH_RETRY_UNDEF,
+		.checker_name  = DEFAULT_CHECKER,
+		.prio_name     = DEFAULT_PRIO,
+		.prio_args     = NULL,
+	},
 	/*
 	 * Pivot3 RAIGE
 	 *
@@ -1023,10 +991,8 @@ static struct hwentry default_hw[] = {
 	{
 		.vendor        = "PIVOT3",
 		.product       = "RAIGE VOLUME",
-		.getuid        = "/lib/udev/scsi_id --page=0x80 --whitelisted --device=/dev/%n",
 		.features      = "1 queue_if_no_path",
 		.hwhandler     = DEFAULT_HWHANDLER,
-		.selector      = DEFAULT_SELECTOR,
 		.pgpolicy      = MULTIBUS,
 		.pgfailback    = FAILBACK_UNDEF,
 		.rr_weight     = RR_WEIGHT_NONE,
@@ -1039,15 +1005,13 @@ static struct hwentry default_hw[] = {
 	{
 		.vendor        = "SUN",
 		.product       = "CSM200_R",
-		.getuid        = DEFAULT_GETUID,
+		.bl_product    = "Universal Xport",
 		.features      = DEFAULT_FEATURES,
 		.hwhandler     = "1 rdac",
-		.selector      = DEFAULT_SELECTOR,
 		.pgpolicy      = GROUP_BY_PRIO,
 		.pgfailback    = -FAILBACK_IMMEDIATE,
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_QUEUE,
-		.minio         = DEFAULT_MINIO,
 		.checker_name  = RDAC,
 		.prio_name     = PRIO_RDAC,
 		.prio_args     = NULL,
@@ -1056,60 +1020,99 @@ static struct hwentry default_hw[] = {
 	{
 		.vendor        = "SUN",
 		.product       = "LCSM100_[IEFS]",
-		.getuid        = DEFAULT_GETUID,
+		.bl_product    = "Universal Xport",
 		.features      = DEFAULT_FEATURES,
 		.hwhandler     = "1 rdac",
-		.selector      = DEFAULT_SELECTOR,
 		.pgpolicy      = GROUP_BY_PRIO,
 		.pgfailback    = -FAILBACK_IMMEDIATE,
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_QUEUE,
-		.minio         = DEFAULT_MINIO,
 		.checker_name  = RDAC,
 		.prio_name     = PRIO_RDAC,
 		.prio_args     = NULL,
 	},
-	/* LSI Generic rdac storage */
+	/* StorageTek 6180 */
 	{
-		.vendor        = "(LSI|ENGENIO)",
+		.vendor        = "SUN",
+		.product       = "SUN_6180",
+		.features      = DEFAULT_FEATURES,
+		.hwhandler     = "1 rdac",
+		.pgpolicy      = GROUP_BY_PRIO,
+		.pgfailback    = -FAILBACK_IMMEDIATE,
+		.rr_weight     = RR_WEIGHT_NONE,
+		.no_path_retry = NO_PATH_RETRY_QUEUE,
+		.minio         = DEFAULT_MINIO,
+		.minio_rq      = DEFAULT_MINIO_RQ,
+		.checker_name  = RDAC,
+		.prio_name     = PRIO_RDAC,
+	},
+	/* LSI/Engenio/NetApp E-Series RDAC storage
+	 *
+	 * Maintainer : Sean Stewart
+	 * Mail : sean.stewart@netapp.com
+	 */
+	{
+		.vendor        = "(NETAPP|LSI|ENGENIO)",
 		.product       = "INF-01-00",
-		.getuid        = DEFAULT_GETUID,
+		.bl_product    = "Universal Xport",
 		.features      = "2 pg_init_retries 50",
 		.hwhandler     = "1 rdac",
-		.selector      = DEFAULT_SELECTOR,
 		.pgpolicy      = GROUP_BY_PRIO,
 		.pgfailback    = -FAILBACK_IMMEDIATE,
 		.rr_weight     = RR_WEIGHT_NONE,
-		.no_path_retry = 15,
-		.minio         = DEFAULT_MINIO,
+		.no_path_retry = 30,
 		.checker_name  = RDAC,
 		.prio_name     = PRIO_RDAC,
 		.prio_args     = NULL,
+		.detect_prio   = DETECT_PRIO_ON,
+		.retain_hwhandler = RETAIN_HWHANDLER_ON,
 	},
 	{
 		.vendor        = "STK",
 		.product       = "FLEXLINE 380",
 		.bl_product    = "Universal Xport",
-		.getuid        = DEFAULT_GETUID,
 		.features      = DEFAULT_FEATURES,
 		.hwhandler     = "1 rdac",
-		.selector      = DEFAULT_SELECTOR,
 		.pgpolicy      = GROUP_BY_PRIO,
 		.pgfailback    = -FAILBACK_IMMEDIATE,
 		.rr_weight     = RR_WEIGHT_NONE,
 		.no_path_retry = NO_PATH_RETRY_QUEUE,
-		.minio         = DEFAULT_MINIO,
 		.checker_name  = RDAC,
 		.prio_name     = PRIO_RDAC,
 		.prio_args     = NULL,
 	},
+	{
+		.vendor	       = "Intel",
+		.product       = "Multi-Flex",
+		.features      = DEFAULT_FEATURES,
+		.hwhandler     = "1 alua",
+		.pgpolicy      = GROUP_BY_PRIO,
+		.pgfailback    = -FAILBACK_IMMEDIATE,
+		.rr_weight     = RR_WEIGHT_NONE,
+		.no_path_retry = NO_PATH_RETRY_QUEUE,
+		.checker_name  = TUR,
+		.prio_name     = PRIO_ALUA,
+		.prio_args     = NULL,
+	},
+	{
+		.vendor	       = "DataCore",
+		.product       = "SANmelody",
+		.features      = DEFAULT_FEATURES,
+		.hwhandler     = DEFAULT_HWHANDLER,
+		.pgpolicy      = GROUP_BY_PRIO,
+		.pgfailback    = -FAILBACK_IMMEDIATE,
+		.rr_weight     = RR_WEIGHT_NONE,
+		.no_path_retry = NO_PATH_RETRY_QUEUE,
+		.checker_name  = TUR,
+		.prio_name     = PRIO_ALUA,
+		.prio_args     = NULL,
+	},
 	/*
 	 * EOL
 	 */
 	{
 		.vendor        = NULL,
 		.product       = NULL,
-		.getuid        = NULL,
 		.features      = NULL,
 		.hwhandler     = NULL,
 		.selector      = NULL,
@@ -1118,6 +1121,7 @@ static struct hwentry default_hw[] = {
 		.rr_weight     = 0,
 		.no_path_retry = 0,
 		.minio         = 0,
+		.minio_rq      = 0,
 		.checker_name  = NULL,
 		.prio_name     = NULL,
 		.prio_args     = NULL,
diff --git a/libmultipath/lock.c b/libmultipath/lock.c
index 4439a51..6ce9a74 100644
--- a/libmultipath/lock.c
+++ b/libmultipath/lock.c
@@ -1,16 +1,7 @@
 #include <pthread.h>
-#include <signal.h>
 #include "lock.h"
 #include <stdio.h>
 
-void block_signal (int signum, sigset_t *old)
-{
-	sigset_t set;
-	sigemptyset(&set);
-	sigaddset(&set, signum);
-	pthread_sigmask(SIG_BLOCK, &set, old);
-}
-
 void cleanup_lock (void * data)
 {
 	unlock ((*(struct mutex_lock *)data));
diff --git a/libmultipath/lock.h b/libmultipath/lock.h
index 6897a74..04ef78d 100644
--- a/libmultipath/lock.h
+++ b/libmultipath/lock.h
@@ -29,6 +29,5 @@ struct mutex_lock {
 #endif
 
 void cleanup_lock (void * data);
-void block_signal(int signum, sigset_t *old);
 
 #endif /* _LOCK_H */
diff --git a/libmultipath/log.c b/libmultipath/log.c
index e56e46b..37c7cd7 100644
--- a/libmultipath/log.c
+++ b/libmultipath/log.c
@@ -96,6 +96,12 @@ void log_close (void)
 	return;
 }
 
+void log_reset (char *program_name)
+{
+	closelog();
+	openlog(program_name, 0, LOG_DAEMON);
+}
+
 int log_enqueue (int prio, const char * fmt, va_list ap)
 {
 	int len, fwd;
@@ -142,7 +148,7 @@ int log_enqueue (int prio, const char * fmt, va_list ap)
 	la->empty = 0;
 	msg = (struct logmsg *)la->tail;
 	msg->prio = prio;
-	strcpy((void *)&msg->str, buff);
+	memcpy((void *)&msg->str, buff, strlen(buff) + 1);
 	lastmsg->next = la->tail;
 	msg->next = la->head;
 
diff --git a/libmultipath/log.h b/libmultipath/log.h
index c697118..984f047 100644
--- a/libmultipath/log.h
+++ b/libmultipath/log.h
@@ -1,8 +1,8 @@
 #ifndef LOG_H
 #define LOG_H
 
-#define DEFAULT_AREA_SIZE 8192
-#define MAX_MSG_SIZE 128
+#define DEFAULT_AREA_SIZE 16384
+#define MAX_MSG_SIZE 256
 
 #ifndef LOGLEVEL
 #define LOGLEVEL 5
@@ -17,7 +17,7 @@
 struct logmsg {
 	short int prio;
 	void * next;
-	char * str;
+	char str[0];
 };
 
 struct logarea {
@@ -33,6 +33,7 @@ struct logarea * la;
 
 int log_init (char * progname, int size);
 void log_close (void);
+void log_reset (char * progname);
 int log_enqueue (int prio, const char * fmt, va_list ap);
 int log_dequeue (void *);
 void log_syslog (void *);
diff --git a/libmultipath/log_pthread.c b/libmultipath/log_pthread.c
index ed7b200..47d75a1 100644
--- a/libmultipath/log_pthread.c
+++ b/libmultipath/log_pthread.c
@@ -4,6 +4,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <stdarg.h>
+#include <syslog.h>
 #include <pthread.h>
 #include <sys/mman.h>
 
@@ -13,22 +14,41 @@
 #include "log.h"
 #include "lock.h"
 
+pthread_t log_thr;
+
+pthread_mutex_t logq_lock;
+pthread_mutex_t logev_lock;
+pthread_cond_t logev_cond;
+
+int logq_running;
+
 void log_safe (int prio, const char * fmt, va_list ap)
 {
-	sigset_t old;
-
-	block_signal(SIGUSR1, &old);
-	block_signal(SIGHUP, NULL);
+	if (log_thr == (pthread_t)0) {
+		syslog(prio, fmt, ap);
+		return;
+	}
 
-	pthread_mutex_lock(logq_lock);
+	pthread_mutex_lock(&logq_lock);
 	log_enqueue(prio, fmt, ap);
-	pthread_mutex_unlock(logq_lock);
+	pthread_mutex_unlock(&logq_lock);
+
+	pthread_mutex_lock(&logev_lock);
+	pthread_cond_signal(&logev_cond);
+	pthread_mutex_unlock(&logev_lock);
+}
 
-	pthread_mutex_lock(logev_lock);
-	pthread_cond_signal(logev_cond);
-	pthread_mutex_unlock(logev_lock);
+void log_thread_flush (void)
+{
+	int empty;
 
-	pthread_sigmask(SIG_SETMASK, &old, NULL);
+	do {
+		pthread_mutex_lock(&logq_lock);
+		empty = log_dequeue(la->buff);
+		pthread_mutex_unlock(&logq_lock);
+		if (!empty)
+			log_syslog(la->buff);
+	} while (empty == 0);
 }
 
 static void flush_logqueue (void)
@@ -36,9 +56,9 @@ static void flush_logqueue (void)
 	int empty;
 
 	do {
-		pthread_mutex_lock(logq_lock);
+		pthread_mutex_lock(&logq_lock);
 		empty = log_dequeue(la->buff);
-		pthread_mutex_unlock(logq_lock);
+		pthread_mutex_unlock(&logq_lock);
 		if (!empty)
 			log_syslog(la->buff);
 	} while (empty == 0);
@@ -46,15 +66,23 @@ static void flush_logqueue (void)
 
 static void * log_thread (void * et)
 {
+	int running;
+
+	pthread_mutex_lock(&logev_lock);
+	logq_running = 1;
+	pthread_mutex_unlock(&logev_lock);
+
 	mlockall(MCL_CURRENT | MCL_FUTURE);
 	logdbg(stderr,"enter log_thread\n");
 
 	while (1) {
-		pthread_mutex_lock(logev_lock);
-		pthread_cond_wait(logev_cond, logev_lock);
-		pthread_mutex_unlock(logev_lock);
-
-		flush_logqueue();
+		pthread_mutex_lock(&logev_lock);
+		pthread_cond_wait(&logev_cond, &logev_lock);
+		running = logq_running;
+		pthread_mutex_unlock(&logev_lock);
+		if (!running)
+			break;
+		log_thread_flush();
 	}
 	return NULL;
 }
@@ -63,19 +91,18 @@ void log_thread_start (pthread_attr_t *attr)
 {
 	logdbg(stderr,"enter log_thread_start\n");
 
-	logq_lock = (pthread_mutex_t *) malloc(sizeof(pthread_mutex_t));
-	logev_lock = (pthread_mutex_t *) malloc(sizeof(pthread_mutex_t));
-	logev_cond = (pthread_cond_t *) malloc(sizeof(pthread_cond_t));
-
-	pthread_mutex_init(logq_lock, NULL);
-	pthread_mutex_init(logev_lock, NULL);
-	pthread_cond_init(logev_cond, NULL);
+	pthread_mutex_init(&logq_lock, NULL);
+	pthread_mutex_init(&logev_lock, NULL);
+	pthread_cond_init(&logev_cond, NULL);
 
 	if (log_init("multipathd", 0)) {
 		fprintf(stderr,"can't initialize log buffer\n");
 		exit(1);
 	}
-	pthread_create(&log_thr, attr, log_thread, NULL);
+	if (pthread_create(&log_thr, attr, log_thread, NULL)) {
+		fprintf(stderr,"can't start log thread\n");
+		exit(1);
+	}
 
 	return;
 }
@@ -84,21 +111,23 @@ void log_thread_stop (void)
 {
 	logdbg(stderr,"enter log_thread_stop\n");
 
-	pthread_mutex_lock(logq_lock);
+	pthread_mutex_lock(&logev_lock);
+	logq_running = 0;
+	pthread_cond_signal(&logev_cond);
+	pthread_mutex_unlock(&logev_lock);
+
+	pthread_mutex_lock(&logq_lock);
 	pthread_cancel(log_thr);
-	pthread_mutex_unlock(logq_lock);
+	pthread_mutex_unlock(&logq_lock);
+	pthread_join(log_thr, NULL);
+	log_thr = (pthread_t)0;
 
 	flush_logqueue();
 
-	pthread_mutex_destroy(logq_lock);
-	pthread_mutex_destroy(logev_lock);
-	pthread_cond_destroy(logev_cond);
-
-	free(logq_lock);
-	logq_lock = NULL;
-	free(logev_lock);
-	logev_lock = NULL;
-	free(logev_cond);
-	logev_cond = NULL;
-	free_logarea();
+	pthread_mutex_destroy(&logq_lock);
+	pthread_mutex_destroy(&logev_lock);
+	pthread_cond_destroy(&logev_cond);
+
+	log_close();
 }
+
diff --git a/libmultipath/log_pthread.h b/libmultipath/log_pthread.h
index 77780d8..e5c6499 100644
--- a/libmultipath/log_pthread.h
+++ b/libmultipath/log_pthread.h
@@ -3,14 +3,17 @@
 
 #include <pthread.h>
 
-pthread_t log_thr;
+extern pthread_t log_thr;
 
-pthread_mutex_t *logq_lock;
-pthread_mutex_t *logev_lock;
-pthread_cond_t *logev_cond;
+extern pthread_mutex_t logq_lock;
+extern pthread_mutex_t logev_lock;
+extern pthread_cond_t logev_cond;
+
+extern int logq_running;
 
 void log_safe(int prio, const char * fmt, va_list ap);
 void log_thread_start(pthread_attr_t *attr);
 void log_thread_stop(void);
+void log_thread_flush(void);
 
 #endif /* _LOG_PTHREAD_H */
diff --git a/libmultipath/parser.c b/libmultipath/parser.c
index eb3815e..526c45b 100644
--- a/libmultipath/parser.c
+++ b/libmultipath/parser.c
@@ -21,11 +21,13 @@
 
 #include "parser.h"
 #include "memory.h"
+#include "debug.h"
 
 /* local vars */
 static int sublevel = 0;
-vector keywords = NULL;
-vector *keywords_addr = NULL;
+static vector keywords = NULL;
+static vector *keywords_addr = NULL;
+static int line_nr;
 
 void set_current_keywords (vector *k)
 {
@@ -35,7 +37,7 @@ void set_current_keywords (vector *k)
 
 int
 keyword_alloc(vector keywords, char *string, int (*handler) (vector),
-		int (*print) (char *, int, void *))
+		int (*print) (char *, int, void *), int unique)
 {
 	struct keyword *keyword;
 
@@ -51,6 +53,7 @@ keyword_alloc(vector keywords, char *string, int (*handler) (vector),
 	keyword->string = string;
 	keyword->handler = handler;
 	keyword->print = print;
+	keyword->unique = unique;
 
 	vector_set_slot(keywords, keyword);
 
@@ -60,7 +63,7 @@ keyword_alloc(vector keywords, char *string, int (*handler) (vector),
 int
 install_keyword_root(char *string, int (*handler) (vector))
 {
-	int r = keyword_alloc(keywords, string, handler, NULL);
+	int r = keyword_alloc(keywords, string, handler, NULL, 1);
 	if (!r)
 		*keywords_addr = keywords;
 	return r;
@@ -79,8 +82,8 @@ install_sublevel_end(void)
 }
 
 int
-install_keyword(char *string, int (*handler) (vector),
-		int (*print) (char *, int, void *))
+_install_keyword(char *string, int (*handler) (vector),
+		int (*print) (char *, int, void *), int unique)
 {
 	int i = 0;
 	struct keyword *keyword;
@@ -101,7 +104,7 @@ install_keyword(char *string, int (*handler) (vector),
 		return 1;
 
 	/* add new sub keyword */
-	return keyword_alloc(keyword->sub, string, handler, print);
+	return keyword_alloc(keyword->sub, string, handler, print, unique);
 }
 
 void
@@ -308,8 +311,10 @@ read_value_block(void)
 
 	buf = (char *) MALLOC(MAXBUF);
 
-	if (!buf)
+	if (!buf) {
+		vector_free(elements);
 		return NULL;
+	}
 
 	while (read_line(buf, MAXBUF)) {
 		vec = alloc_strvec(buf);
@@ -320,21 +325,20 @@ read_value_block(void)
 				break;
 			}
 
-			if (VECTOR_SIZE(vec))
-				for (i = 0; i < VECTOR_SIZE(vec); i++) {
-					str = VECTOR_SLOT(vec, i);
-					dup = (char *) MALLOC(strlen(str) + 1);
-					if (!dup)
-						goto out;
-					memcpy(dup, str, strlen(str));
+			for (i = 0; i < VECTOR_SIZE(vec); i++) {
+				str = VECTOR_SLOT(vec, i);
+				dup = (char *) MALLOC(strlen(str) + 1);
+				if (!dup)
+					goto out;
+				memcpy(dup, str, strlen(str));
 
-					if (!vector_alloc_slot(elements)) {
-						free_strvec(vec);
-						goto out1;
-					}
-
-					vector_set_slot(elements, dup);
+				if (!vector_alloc_slot(elements)) {
+					free_strvec(vec);
+					goto out1;
 				}
+
+				vector_set_slot(elements, dup);
+			}
 			free_strvec(vec);
 		}
 		memset(buf, 0, MAXBUF);
@@ -345,6 +349,7 @@ out1:
 	FREE(dup);
 out:
 	FREE(buf);
+	vector_free(elements);
 	return NULL;
 }
 
@@ -384,12 +389,19 @@ void *
 set_value(vector strvec)
 {
 	char *str = VECTOR_SLOT(strvec, 1);
-	int size = strlen(str);
+	size_t size;
 	int i = 0;
 	int len = 0;
 	char *alloc = NULL;
 	char *tmp;
 
+	if (!str)
+		return NULL;
+
+	size = strlen(str);
+	if (size == 0)
+		return NULL;
+
 	if (*str == '"') {
 		for (i = 2; i < VECTOR_SIZE(strvec); i++) {
 			str = VECTOR_SLOT(strvec, i);
@@ -419,6 +431,39 @@ set_value(vector strvec)
 
 /* non-recursive configuration stream handler */
 static int kw_level = 0;
+
+int warn_on_duplicates(vector uniques, char *str)
+{
+	char *tmp;
+	int i;
+
+	vector_foreach_slot(uniques, tmp, i) {
+		if (!strcmp(str, tmp)) {
+			condlog(1, "multipath.conf line %d, duplicate keyword: %s", line_nr, str);
+			return 0;
+		}
+	}
+	tmp = strdup(str);
+	if (!tmp)
+		return 1;
+	if (!vector_alloc_slot(uniques)) {
+		free(tmp);
+		return 1;
+	}
+	vector_set_slot(uniques, tmp);
+	return 0;
+}
+
+void free_uniques(vector uniques)
+{
+	char *tmp;
+	int i;
+
+	vector_foreach_slot(uniques, tmp, i)
+		free(tmp);
+	vector_free(uniques);
+}
+
 int
 process_stream(vector keywords)
 {
@@ -428,13 +473,21 @@ process_stream(vector keywords)
 	char *str;
 	char *buf;
 	vector strvec;
+	vector uniques;
+
+	uniques = vector_alloc();
+	if (!uniques)
+		return 1;
 
 	buf = MALLOC(MAXBUF);
 
-	if (!buf)
+	if (!buf) {
+		vector_free(uniques);
 		return 1;
+	}
 
 	while (read_line(buf, MAXBUF)) {
+		line_nr++;
 		strvec = alloc_strvec(buf);
 		memset(buf,0, MAXBUF);
 
@@ -452,6 +505,12 @@ process_stream(vector keywords)
 			keyword = VECTOR_SLOT(keywords, i);
 
 			if (!strcmp(keyword->string, str)) {
+				if (keyword->unique &&
+				    warn_on_duplicates(uniques, str)) {
+						r = 1;
+						free_strvec(strvec);
+						goto out;
+				}
 				if (keyword->handler)
 					r += (*keyword->handler) (strvec);
 
@@ -463,24 +522,36 @@ process_stream(vector keywords)
 				break;
 			}
 		}
+		if (i >= VECTOR_SIZE(keywords))
+			condlog(1, "multipath.conf +%d, invalid keyword: %s",
+				line_nr, str);
 
 		free_strvec(strvec);
 	}
 
+out:
 	FREE(buf);
+	free_uniques(uniques);
 	return r;
 }
 
+int alloc_keywords(void)
+{
+	if (!keywords)
+		keywords = vector_alloc();
+
+	if (!keywords)
+		return 1;
+
+	return 0;
+}
+
 /* Data initialization */
 int
 init_data(char *conf_file, void (*init_keywords) (void))
 {
 	int r;
 
-	if (!keywords)
-		keywords = vector_alloc();
-	if (!keywords)
-		return 1;
 	stream = fopen(conf_file, "r");
 	if (!stream) {
 		syslog(LOG_WARNING, "Configuration file open problem");
@@ -496,6 +567,7 @@ init_data(char *conf_file, void (*init_keywords) (void))
 */
 
 	/* Stream handling */
+	line_nr = 0;
 	r = process_stream(keywords);
 	fclose(stream);
 	//free_keywords(keywords);
diff --git a/libmultipath/parser.h b/libmultipath/parser.h
index 95d4e6f..8bf1c76 100644
--- a/libmultipath/parser.h
+++ b/libmultipath/parser.h
@@ -44,6 +44,7 @@ struct keyword {
 	int (*handler) (vector);
 	int (*print) (char *, int, void *);
 	vector sub;
+	int unique;
 };
 
 /* global var exported */
@@ -60,12 +61,14 @@ FILE *stream;
 
 /* Prototypes */
 extern int keyword_alloc(vector keywords, char *string, int (*handler) (vector),
-			 int (*print) (char *, int, void *));
+			 int (*print) (char *, int, void *), int unique);
 extern int install_keyword_root(char *string, int (*handler) (vector));
 extern void install_sublevel(void);
 extern void install_sublevel_end(void);
-extern int install_keyword(char *string, int (*handler) (vector),
-			   int (*print) (char *, int, void *));
+extern int _install_keyword(char *string, int (*handler) (vector),
+			    int (*print) (char *, int, void *), int unique);
+#define install_keyword(str, vec, pri) _install_keyword(str, vec, pri, 1)
+#define install_keyword_multi(str, vec, pri) _install_keyword(str, vec, pri, 0)
 extern void dump_keywords(vector keydump, int level);
 extern void free_keywords(vector keywords);
 extern vector alloc_strvec(char *string);
@@ -74,6 +77,7 @@ extern vector read_value_block(void);
 extern int alloc_value_block(vector strvec, void (*alloc_func) (vector));
 extern void *set_value(vector strvec);
 extern int process_stream(vector keywords);
+extern int alloc_keywords(void);
 extern int init_data(char *conf_file, void (*init_keywords) (void));
 extern struct keyword * find_keyword(vector v, char * name);
 void set_current_keywords (vector *k);
diff --git a/libmultipath/pgpolicies.c b/libmultipath/pgpolicies.c
index cfaf1c3..f76ad60 100644
--- a/libmultipath/pgpolicies.c
+++ b/libmultipath/pgpolicies.c
@@ -11,6 +11,7 @@
 #include "vector.h"
 #include "structs.h"
 #include "pgpolicies.h"
+#include "switchgroup.h"
 
 extern int
 get_pgpolicy_id (char * str)
@@ -57,6 +58,34 @@ get_pgpolicy_name (char * buff, int len, int id)
 	return snprintf(buff, POLICY_NAME_SIZE, "%s", s);
 }
 
+
+void
+sort_pathgroups (struct multipath *mp) {
+	int i, j;
+	struct pathgroup * pgp1, * pgp2;
+
+	if (!mp->pg)
+		return;
+
+	vector_foreach_slot(mp->pg, pgp1, i) {
+		path_group_prio_update(pgp1);
+		for (j = i - 1; j >= 0; j--) {
+			pgp2 = VECTOR_SLOT(mp->pg, j);
+			if (!pgp2)
+				continue;
+			if (pgp2->priority > pgp1->priority ||
+			    (pgp2->priority == pgp1->priority &&
+			     pgp2->enabled_paths >= pgp1->enabled_paths)) {
+				vector_move_up(mp->pg, i, j + 1);
+				break;
+			}
+		}
+		if (j < 0 && i != 0)
+		vector_move_up(mp->pg, i, 0);
+	}
+}
+
+
 /*
  * One path group per unique tgt_node_name present in the path vector
  */
@@ -119,6 +148,7 @@ group_by_node_name (struct multipath * mp) {
 		}
 	}
 	FREE(bitmap);
+	sort_pathgroups(mp);
 	free_pathvec(mp->paths, KEEP_PATHS);
 	mp->paths = NULL;
 	return 0;
@@ -191,6 +221,7 @@ group_by_serial (struct multipath * mp) {
 		}
 	}
 	FREE(bitmap);
+	sort_pathgroups(mp);
 	free_pathvec(mp->paths, KEEP_PATHS);
 	mp->paths = NULL;
 	return 0;
@@ -228,6 +259,7 @@ one_path_per_group (struct multipath * mp)
 		if (store_path(pgp->paths, pp))
 			goto out;
 	}
+	sort_pathgroups(mp);
 	free_pathvec(mp->paths, KEEP_PATHS);
 	mp->paths = NULL;
 	return 0;
diff --git a/libmultipath/print.c b/libmultipath/print.c
index 4279fe9..274f5e7 100644
--- a/libmultipath/print.c
+++ b/libmultipath/print.c
@@ -8,6 +8,8 @@
 #include <sys/stat.h>
 #include <dirent.h>
 #include <unistd.h>
+#include <string.h>
+#include <errno.h>
 
 #include "checkers.h"
 #include "vector.h"
@@ -24,6 +26,7 @@
 #include "switchgroup.h"
 #include "devmapper.h"
 #include "uevent.h"
+#include "debug.h"
 
 #define MAX(x,y) (x > y) ? x : y
 #define TAIL     (line + len - 1 - c)
@@ -143,6 +146,8 @@ snprint_failback (char * buff, size_t len, struct multipath * mpp)
 {
 	if (mpp->pgfailback == -FAILBACK_IMMEDIATE)
 		return snprintf(buff, len, "immediate");
+	if (mpp->pgfailback == -FAILBACK_FOLLOWOVER)
+		return snprintf(buff, len, "followover");
 
 	if (!mpp->failback_tick)
 		return snprintf(buff, len, "-");
@@ -379,7 +384,6 @@ snprint_pg_selector (char * buff, size_t len, struct pathgroup * pgp)
 static int
 snprint_pg_pri (char * buff, size_t len, struct pathgroup * pgp)
 {
-	int avg_priority = 0;
 	/*
 	 * path group priority is not updated for every path prio change,
 	 * but only on switch group code path.
@@ -387,9 +391,7 @@ snprint_pg_pri (char * buff, size_t len, struct pathgroup * pgp)
 	 * Printing is another reason to update.
 	 */
 	path_group_prio_update(pgp);
-	if (pgp->enabled_paths)
-		avg_priority = pgp->priority / pgp->enabled_paths;
-	return snprint_int(buff, len, avg_priority);
+	return snprint_int(buff, len, pgp->priority);
 }
 
 static int
@@ -755,11 +757,30 @@ snprint_pathgroup (char * line, int len, char * format,
 extern void
 print_multipath_topology (struct multipath * mpp, int verbosity)
 {
-	char buff[MAX_LINE_LEN * MAX_LINES] = {};
+	int resize;
+	char *buff = NULL;
+	char *old = NULL;
+	int len, maxlen = MAX_LINE_LEN * MAX_LINES;
+
+	buff = MALLOC(maxlen);
+	do {
+		if (!buff) {
+			if (old)
+				FREE(old);
+			condlog(0, "couldn't allocate memory for list: %s\n",
+				strerror(errno));
+			return;
+		}
+
+		len = snprint_multipath_topology(buff, maxlen, mpp, verbosity);
+		resize = (len == maxlen - 1);
 
-	memset(&buff[0], 0, MAX_LINE_LEN * MAX_LINES);
-	snprint_multipath_topology(&buff[0], MAX_LINE_LEN * MAX_LINES,
-				   mpp, verbosity);
+		if (resize) {
+			maxlen *= 2;
+			old = buff;
+			buff = REALLOC(buff, maxlen);
+		}
+	} while (resize);
 	printf("%s", buff);
 }
 
@@ -1352,11 +1373,11 @@ print_pathgroup (struct pathgroup * pgp, char * style)
 }
 
 extern void
-print_map (struct multipath * mpp)
+print_map (struct multipath * mpp, char * params)
 {
-	if (mpp->size && mpp->params)
+	if (mpp->size && params)
 		printf("0 %llu %s %s\n",
-			 mpp->size, TGT_MPATH, mpp->params);
+			 mpp->size, TGT_MPATH, params);
 	return;
 }
 
diff --git a/libmultipath/print.h b/libmultipath/print.h
index 47f4257..aef182b 100644
--- a/libmultipath/print.h
+++ b/libmultipath/print.h
@@ -55,7 +55,7 @@ void print_multipath_topology (struct multipath * mpp, int verbosity);
 void print_path (struct path * pp, char * style);
 void print_multipath (struct multipath * mpp, char * style);
 void print_pathgroup (struct pathgroup * pgp, char * style);
-void print_map (struct multipath * mpp);
+void print_map (struct multipath * mpp, char * params);
 void print_all_paths (vector pathvec, int banner);
 void print_all_paths_custo (vector pathvec, int banner, char *fmt);
 void print_hwtable (vector hwtable);
diff --git a/libmultipath/prio.c b/libmultipath/prio.c
index 7491682..05a8cf1 100644
--- a/libmultipath/prio.c
+++ b/libmultipath/prio.c
@@ -2,6 +2,7 @@
 #include <string.h>
 #include <stddef.h>
 #include <dlfcn.h>
+#include <sys/stat.h>
 
 #include "debug.h"
 #include "prio.h"
@@ -18,11 +19,34 @@ int init_prio (void)
 
 static struct prio * alloc_prio (void)
 {
-	return MALLOC(sizeof(struct prio));
+	struct prio *p;
+
+	p = MALLOC(sizeof(struct prio));
+	if (p) {
+		INIT_LIST_HEAD(&p->node);
+		p->refcount = 1;
+	}
+	return p;
 }
 
 void free_prio (struct prio * p)
 {
+	if (!p)
+		return;
+	p->refcount--;
+	if (p->refcount) {
+		condlog(3, "%s prioritizer refcount %d",
+			p->name, p->refcount);
+		return;
+	}
+	condlog(3, "unloading %s prioritizer", p->name);
+	list_del(&p->node);
+	if (p->handle) {
+		if (dlclose(p->handle) != 0) {
+			condlog(0, "Cannot unload prioritizer %s: %s",
+				p->name, dlerror());
+		}
+	}
 	FREE(p);
 }
 
@@ -32,7 +56,6 @@ void cleanup_prio(void)
 	struct prio * prio_temp;
 
 	list_for_each_entry_safe(prio_loop, prio_temp, &prioritizers, node) {
-		list_del(&prio_loop->node);
 		free_prio(prio_loop);
 	}
 }
@@ -41,6 +64,9 @@ struct prio * prio_lookup (char * name)
 {
 	struct prio * p;
 
+	if (!name || !strlen(name))
+		return NULL;
+
 	list_for_each_entry(p, &prioritizers, node) {
 		if (!strncmp(name, p->name, PRIO_NAME_LEN))
 			return p;
@@ -56,29 +82,35 @@ int prio_set_args (struct prio * p, char * args)
 struct prio * add_prio (char * name)
 {
 	char libname[LIB_PRIO_NAMELEN];
-	void * handle;
+	struct stat stbuf;
 	struct prio * p;
 	char *errstr;
 
 	p = alloc_prio();
 	if (!p)
 		return NULL;
+	snprintf(p->name, PRIO_NAME_LEN, "%s", name);
 	snprintf(libname, LIB_PRIO_NAMELEN, "%s/libprio%s.so",
 		 conf->multipath_dir, name);
+	if (stat(libname,&stbuf) < 0) {
+		condlog(0,"Prioritizer '%s' not found in %s",
+			name, conf->multipath_dir);
+		goto out;
+	}
 	condlog(3, "loading %s prioritizer", libname);
-	handle = dlopen(libname, RTLD_NOW);
-	errstr = dlerror();
-	if (errstr != NULL)
-	condlog(0, "A dynamic linking error occurred: (%s)", errstr);
-	if (!handle)
+	p->handle = dlopen(libname, RTLD_NOW);
+	if (!p->handle) {
+		if ((errstr = dlerror()) != NULL)
+			condlog(0, "A dynamic linking error occurred: (%s)",
+				errstr);
 		goto out;
-	p->getprio = (int (*)(struct path *, char *)) dlsym(handle, "getprio");
+	}
+	p->getprio = (int (*)(struct path *, char *)) dlsym(p->handle, "getprio");
 	errstr = dlerror();
 	if (errstr != NULL)
-	condlog(0, "A dynamic linking error occurred: (%s)", errstr);
+		condlog(0, "A dynamic linking error occurred: (%s)", errstr);
 	if (!p->getprio)
 		goto out;
-	snprintf(p->name, PRIO_NAME_LEN, "%s", name);
 	list_add(&p->node, &prioritizers);
 	return p;
 out:
@@ -91,6 +123,13 @@ int prio_getprio (struct prio * p, struct path * pp)
 	return p->getprio(pp, p->args);
 }
 
+int prio_selected (struct prio * p)
+{
+	if (!p || !p->getprio)
+		return 0;
+	return (p->getprio) ? 1 : 0;
+}
+
 char * prio_name (struct prio * p)
 {
 	return p->name;
@@ -100,3 +139,33 @@ char * prio_args (struct prio * p)
 {
 	return p->args;
 }
+
+void prio_get (struct prio * dst, char * name, char * args)
+{
+	struct prio * src = prio_lookup(name);
+
+	if (!src) {
+		dst->getprio = NULL;
+		return;
+	}
+
+	strncpy(dst->name, src->name, PRIO_NAME_LEN);
+	if (args)
+		strncpy(dst->args, args, PRIO_ARGS_LEN);
+	dst->getprio = src->getprio;
+	dst->handle = NULL;
+
+	src->refcount++;
+}
+
+void prio_put (struct prio * dst)
+{
+	struct prio * src;
+
+	if (!dst)
+		return;
+
+	src = prio_lookup(dst->name);
+	memset(dst, 0x0, sizeof(struct prio));
+	free_prio(src);
+}
diff --git a/libmultipath/prio.h b/libmultipath/prio.h
index fd4a326..4eeb216 100644
--- a/libmultipath/prio.h
+++ b/libmultipath/prio.h
@@ -6,7 +6,10 @@
  */
 #include "checkers.h"
 #include "vector.h"
-#include "structs.h"
+
+/* forward declaration to avoid circular dependency */
+struct path;
+
 #include "list.h"
 #include "memory.h"
 
@@ -21,10 +24,11 @@
 #define PRIO_EMC "emc"
 #define PRIO_HDS "hds"
 #define PRIO_HP_SW "hp_sw"
-#define PRIO_NETAPP "netapp"
+#define PRIO_ONTAP "ontap"
 #define PRIO_RANDOM "random"
 #define PRIO_RDAC "rdac"
 #define PRIO_DATACORE "datacore"
+#define PRIO_WEIGHTED_PATH "weightedpath"
 
 /*
  * Value used to mark the fact prio was not defined
@@ -39,6 +43,8 @@
 #define PRIO_ARGS_LEN 255
 
 struct prio {
+	void *handle;
+	int refcount;
 	struct list_head node;
 	char name[PRIO_NAME_LEN];
 	char args[PRIO_ARGS_LEN];
@@ -50,6 +56,9 @@ void cleanup_prio (void);
 struct prio * add_prio (char *);
 struct prio * prio_lookup (char *);
 int prio_getprio (struct prio *, struct path *);
+void prio_get (struct prio *, char *, char *);
+void prio_put (struct prio *);
+int prio_selected (struct prio *);
 char * prio_name (struct prio *);
 char * prio_args (struct prio *);
 int prio_set_args (struct prio *, char *);
diff --git a/libmultipath/prioritizers/Makefile b/libmultipath/prioritizers/Makefile
index 132b39e..6cfac88 100644
--- a/libmultipath/prioritizers/Makefile
+++ b/libmultipath/prioritizers/Makefile
@@ -11,19 +11,21 @@ LIBS = \
 	libprioemc.so \
 	libpriordac.so \
 	libprioalua.so \
-	libprionetapp.so \
+	libprioontap.so \
 	libpriodatacore.so \
-	libpriohds.so
+	libpriohds.so \
+	libprioweightedpath.so \
+	libprioiet.so
 
 CFLAGS += -I..
 
 all: $(LIBS)
 
 libprioalua.so: alua.o alua_rtpg.o
-	$(CC) $(SHARED_FLAGS) -o $@ $^
+	$(CC) $(LDFLAGS) $(SHARED_FLAGS) -o $@ $^
 
 libprio%.so: %.o
-	$(CC) $(SHARED_FLAGS) -o $@ $^
+	$(CC) $(LDFLAGS) $(SHARED_FLAGS) -o $@ $^
 
 install: $(LIBS)
 	$(INSTALL_PROGRAM) -m 755 libprio*.so $(DESTDIR)$(libdir)
diff --git a/libmultipath/prioritizers/alua.c b/libmultipath/prioritizers/alua.c
index e33e17c..b9493a4 100644
--- a/libmultipath/prioritizers/alua.c
+++ b/libmultipath/prioritizers/alua.c
@@ -16,6 +16,7 @@
 
 #include <debug.h>
 #include <prio.h>
+#include <structs.h>
 
 #include "alua.h"
 
@@ -25,16 +26,33 @@
 #define ALUA_PRIO_TPGS_FAILED			4
 #define ALUA_PRIO_NO_INFORMATION		5
 
+static const char * aas_string[] = {
+	[AAS_OPTIMIZED]		= "active/optimized",
+	[AAS_NON_OPTIMIZED]	= "active/non-optimized",
+	[AAS_STANDBY]		= "standby",
+	[AAS_UNAVAILABLE]	= "unavailable",
+	[AAS_LBA_DEPENDENT]	= "lba dependent",
+	[AAS_RESERVED]		= "invalid/reserved",
+	[AAS_OFFLINE]		= "offline",
+	[AAS_TRANSITIONING]	= "transitioning between states",
+};
+
+static const char *aas_print_string(int rc)
+{
+	rc &= 0x7f;
+
+	if (rc & 0x70)
+		return aas_string[AAS_RESERVED];
+	rc &= 0x0f;
+	if (rc > AAS_RESERVED && rc < AAS_OFFLINE)
+		return aas_string[AAS_RESERVED];
+	else
+		return aas_string[rc];
+}
+
 int
 get_alua_info(int fd)
 {
-	char *	aas_string[] = {
-		[AAS_OPTIMIZED]		= "active/optimized",
-		[AAS_NON_OPTIMIZED]	= "active/non-optimized",
-		[AAS_STANDBY]		= "standby",
-		[AAS_UNAVAILABLE]	= "unavailable",
-		[AAS_TRANSITIONING]	= "transitioning between states",
-	};
 	int	rc;
 	int	tpg;
 	int	aas;
@@ -56,8 +74,8 @@ get_alua_info(int fd)
 		return -ALUA_PRIO_GETAAS_FAILED;
 	aas = (rc & 0x0f);
 
-	condlog(3, "aas = [%s]",
-		(aas < 4) ? aas_string[aas] : "invalid/reserved");
+	condlog(3, "aas = %02x [%s]%s", rc, aas_print_string(rc),
+		(rc & 0x80) ? " [preferred]" : "");
 	return rc;
 }
 
@@ -81,6 +99,9 @@ int getprio (struct path * pp, char * args)
 			case AAS_NON_OPTIMIZED:
 				rc = 10;
 				break;
+			case AAS_LBA_DEPENDENT:
+				rc = 5;
+				break;
 			case AAS_STANDBY:
 				rc = 1;
 				break;
diff --git a/libmultipath/prioritizers/alua_rtpg.c b/libmultipath/prioritizers/alua_rtpg.c
index 0531052..981ba06 100644
--- a/libmultipath/prioritizers/alua_rtpg.c
+++ b/libmultipath/prioritizers/alua_rtpg.c
@@ -24,7 +24,7 @@
 #include "alua_rtpg.h"
 
 #define SENSE_BUFF_LEN  32
-#define DEF_TIMEOUT     300000
+#define DEF_TIMEOUT     60000
 
 /*
  * Macro used to print debug messaged.
@@ -172,41 +172,62 @@ get_target_port_group_support(int fd)
 int
 get_target_port_group(int fd)
 {
-	unsigned char		buf[128];
+	unsigned char		*buf;
 	struct vpd83_data *	vpd83;
 	struct vpd83_dscr *	dscr;
 	int			rc;
+	int			buflen, scsi_buflen;
 
-	memset(buf, 0, sizeof(buf));
-	rc = do_inquiry(fd, 1, 0x83, buf, sizeof(buf));
-	if (!rc) {
-		vpd83 = (struct vpd83_data *) buf;
-
-		rc = -RTPG_NO_TPG_IDENTIFIER;
-		FOR_EACH_VPD83_DSCR(vpd83, dscr) {
-			if ((((char *) dscr) - ((char *) vpd83)) > sizeof(buf))
-				break;
+	buflen = 128; /* Lets start from 128 */
+	buf = (unsigned char *)malloc(buflen);
+	if (!buf) {
+		PRINT_DEBUG("malloc failed: could not allocate"
+			     "%u bytes\n", buflen);
+		return -RTPG_RTPG_FAILED;
+	}
 
-			if (vpd83_dscr_istype(dscr, IDTYPE_TARGET_PORT_GROUP)) {
-				struct vpd83_tpg_dscr *	p;
+	memset(buf, 0, buflen);
+	rc = do_inquiry(fd, 1, 0x83, buf, buflen);
+	if (rc < 0)
+		goto out;
 
-				if (rc != -RTPG_NO_TPG_IDENTIFIER) {
-					PRINT_DEBUG("get_target_port_group: "
-						"more than one TPG identifier "
-						"found!\n");
-					continue;
-				}
+	scsi_buflen = (buf[2] << 8 | buf[3]) + 4;
+	if (buflen < scsi_buflen) {
+		free(buf);
+		buf = (unsigned char *)malloc(scsi_buflen);
+		if (!buf) {
+			PRINT_DEBUG("malloc failed: could not allocate"
+				     "%u bytes\n", scsi_buflen);
+			return -RTPG_RTPG_FAILED;
+		}
+		buflen = scsi_buflen;
+		memset(buf, 0, buflen);
+		rc = do_inquiry(fd, 1, 0x83, buf, buflen);
+		if (rc < 0)
+			goto out;
+	}
 
-				p  = (struct vpd83_tpg_dscr *) dscr->data;
-				rc = get_uint16(p->tpg);
+	vpd83 = (struct vpd83_data *) buf;
+	rc = -RTPG_NO_TPG_IDENTIFIER;
+	FOR_EACH_VPD83_DSCR(vpd83, dscr) {
+		if (vpd83_dscr_istype(dscr, IDTYPE_TARGET_PORT_GROUP)) {
+			struct vpd83_tpg_dscr *p;
+			if (rc != -RTPG_NO_TPG_IDENTIFIER) {
+				PRINT_DEBUG("get_target_port_group: more "
+					    "than one TPG identifier found!\n");
+				continue;
 			}
-		}
-		if (rc == -RTPG_NO_TPG_IDENTIFIER) {
-			PRINT_DEBUG("get_target_port_group: "
-				"no TPG identifier found!\n");
+			p  = (struct vpd83_tpg_dscr *)dscr->data;
+			rc = get_uint16(p->tpg);
 		}
 	}
 
+	if (rc == -RTPG_NO_TPG_IDENTIFIER) {
+		PRINT_DEBUG("get_target_port_group: "
+			    "no TPG identifier found!\n");
+	}
+out:
+	free(buf);
 	return rc;
 }
 
@@ -266,7 +287,7 @@ get_asymmetric_access_state(int fd, unsigned int tpg)
 	memset(buf, 0, buflen);
 	rc = do_rtpg(fd, buf, buflen);
 	if (rc < 0)
-		return rc;
+		goto out;
 	scsi_buflen = (buf[0] << 24 | buf[1] << 16 | buf[2] << 8 | buf[3]) + 4;
 	if (buflen < scsi_buflen) {
 		free(buf);
diff --git a/libmultipath/prioritizers/alua_spc3.h b/libmultipath/prioritizers/alua_spc3.h
index 4bbdded..e78b6c3 100644
--- a/libmultipath/prioritizers/alua_spc3.h
+++ b/libmultipath/prioritizers/alua_spc3.h
@@ -273,6 +273,9 @@ struct rtpg_tp_dscr {
 #define AAS_NON_OPTIMIZED		0x1
 #define AAS_STANDBY			0x2
 #define AAS_UNAVAILABLE			0x3
+#define AAS_LBA_DEPENDENT		0x4
+#define AAS_RESERVED			0x5
+#define AAS_OFFLINE			0xe
 #define AAS_TRANSITIONING		0xf
 
 #define TPG_STATUS_NONE			0x0
@@ -283,7 +286,8 @@ struct rtpg_tpg_dscr {
 	unsigned char	b0;		/* x....... = pref(ered) port        */
 					/* .xxx.... = reserved               */
 					/* ....xxxx = asymetric access state */
-	unsigned char	b1;		/* xxxx.... = reserved               */
+	unsigned char	b1;		/* xxx..... = reserved               */
+					/* ...x.... = LBA dependent support  */
 					/* ....x... = unavailable support    */
 					/* .....x.. = standby support        */
 					/* ......x. = non-optimized support  */
diff --git a/libmultipath/prioritizers/datacore.c b/libmultipath/prioritizers/datacore.c
index 6b7b202..e3e6a51 100644
--- a/libmultipath/prioritizers/datacore.c
+++ b/libmultipath/prioritizers/datacore.c
@@ -24,6 +24,7 @@
 #include <sg_include.h>
 #include <debug.h>
 #include <prio.h>
+#include <structs.h>
 
 #define INQ_REPLY_LEN 255
 #define INQ_CMD_CODE 0x12
@@ -94,7 +95,7 @@ int datacore_prio (const char *dev, int sg_fd, char * args)
 	if ((io_hdr.info & SG_INFO_OK_MASK) != SG_INFO_OK)
 		return 0;
 
-	snprintf(vendor, 9, "%.8s\n", inqBuffp + 8);
+	snprintf(vendor, 8, "%.8s\n", inqBuffp + 8);
 	snprintf(product, 17, "%.16s", inqBuffp + 16);
 	snprintf(luname, 21, "%.19s", inqBuffp + 36);
 	snprintf(wwpn, 17, "%.16s", inqBuffp + 96);
diff --git a/libmultipath/prioritizers/emc.c b/libmultipath/prioritizers/emc.c
index bbf5750..87e9a8d 100644
--- a/libmultipath/prioritizers/emc.c
+++ b/libmultipath/prioritizers/emc.c
@@ -5,6 +5,7 @@
 #include <sg_include.h>
 #include <debug.h>
 #include <prio.h>
+#include <structs.h>
 
 #define INQUIRY_CMD     0x12
 #define INQUIRY_CMDLEN  6
@@ -18,9 +19,10 @@ int emc_clariion_prio(const char *dev, int fd)
 	unsigned char inqCmdBlk[INQUIRY_CMDLEN] = {INQUIRY_CMD, 1, 0xC0, 0,
 						sizeof(sb), 0};
 	struct sg_io_hdr io_hdr;
-	int ret = 0;
+	int ret = PRIO_UNDEF;
 
 	memset(&io_hdr, 0, sizeof (struct sg_io_hdr));
+	memset(&sense_buffer, 0, 256);
 	io_hdr.interface_id = 'S';
 	io_hdr.cmd_len = sizeof (inqCmdBlk);
 	io_hdr.mx_sb_len = sizeof (sb);
@@ -45,9 +47,9 @@ int emc_clariion_prio(const char *dev, int fd)
 		pp_emc_log(0, "path unit report page in unknown format");
 		goto out;
 	}
-	
+
 	if ( /* Effective initiator type */
-	    	sense_buffer[27] != 0x03
+		sense_buffer[27] != 0x03
 		/*
 		 * Failover mode should be set to 1 (PNR failover mode)
 		 * or 4 (ALUA failover mode).
@@ -57,18 +59,24 @@ int emc_clariion_prio(const char *dev, int fd)
 		/* Arraycommpath should be set to 1 */
 		|| (sense_buffer[30] & 0x04) != 0x04) {
 		pp_emc_log(0, "path not correctly configured for failover");
+		goto out;
 	}
 
 	if ( /* LUN operations should indicate normal operations */
 		sense_buffer[48] != 0x00) {
 		pp_emc_log(0, "path not available for normal operations");
+		goto out;
 	}
 
+	/* LUN state: unbound, bound, or owned */
+	ret = sense_buffer[4];
+
 	/* Is the default owner equal to this path? */
 	/* Note this will switch to the default priority group, even if
 	 * it is not the currently active one. */
-	ret = (sense_buffer[5] == sense_buffer[8]) ? 1 : 0;
-	
+	if (sense_buffer[5] == sense_buffer[8])
+		ret+=2;
+
 out:
 	return(ret);
 }
diff --git a/libmultipath/prioritizers/hds.c b/libmultipath/prioritizers/hds.c
index 7b354b2..f748707 100644
--- a/libmultipath/prioritizers/hds.c
+++ b/libmultipath/prioritizers/hds.c
@@ -75,6 +75,7 @@
 #include <sg_include.h>
 #include <debug.h>
 #include <prio.h>
+#include <structs.h>
 
 #define INQ_REPLY_LEN 255
 #define INQ_CMD_CODE 0x12
@@ -86,7 +87,7 @@
 int hds_modular_prio (const char *dev, int fd)
 {
 	int k;
-	char vendor[8];
+	char vendor[9];
 	char product[32];
 	char serial[32];
 	char ldev[32];
@@ -104,6 +105,7 @@ int hds_modular_prio (const char *dev, int fd)
 	}
 
 	memset (&io_hdr, 0, sizeof (sg_io_hdr_t));
+	memset (inqBuff, 0, INQ_REPLY_LEN);
 	io_hdr.interface_id = 'S';
 	io_hdr.cmd_len = sizeof (inqCmdBlk);
 	io_hdr.mx_sb_len = sizeof (sense_buffer);
diff --git a/libmultipath/prioritizers/hp_sw.c b/libmultipath/prioritizers/hp_sw.c
index 2de460f..c24baad 100644
--- a/libmultipath/prioritizers/hp_sw.c
+++ b/libmultipath/prioritizers/hp_sw.c
@@ -15,6 +15,7 @@
 #include <sg_include.h>
 #include <debug.h>
 #include <prio.h>
+#include <structs.h>
 
 #define TUR_CMD_LEN		6
 #define SCSI_CHECK_CONDITION	0x2
diff --git a/libmultipath/prioritizers/iet.c b/libmultipath/prioritizers/iet.c
new file mode 100644
index 0000000..94406df
--- /dev/null
+++ b/libmultipath/prioritizers/iet.c
@@ -0,0 +1,141 @@
+#include <dirent.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <stdio.h>
+#include <string.h>
+#include <regex.h>
+#include <prio.h>
+#include <debug.h>
+#include <unistd.h>
+#include <structs.h>
+
+//
+// This prioritizer suits iSCSI needs, makes it possible to prefer one path.
+//
+// (It's a bit of a misnomer since supports the client side [eg. open-iscsi]
+//  instead of just "iet".)
+//
+// Usage: 
+//   prio      "iet"
+//   prio_args "preferredip=10.11.12.13"
+//
+// Uses /dev/disk/by-path to find the IP of the device.
+// Assigns prio 20 (high) to the preferred IP and prio 10 (low) to the rest.
+//
+// by Olivier Lambert <lambert.olivier.gmail.com>
+//
+
+#define dc_log(prio, msg) condlog(prio, "%s: iet prio: " msg, dev)
+//
+// name: find_regex
+// @param string: string you want to search into
+// @param regex: the pattern used
+// @return result: string finded in string with regex, "none" if none
+char *find_regex(char * string, char * regex)
+{
+	int err;
+	regex_t preg;
+	err = regcomp(&preg, regex, REG_EXTENDED);
+
+	if (err == 0) {
+		int match;
+		size_t nmatch = 0;
+		regmatch_t *pmatch = NULL;
+		nmatch = preg.re_nsub;
+		pmatch = malloc(sizeof(*pmatch) * nmatch);
+
+		if (pmatch) {
+			match = regexec(&preg, string, nmatch, pmatch, 0);
+			regfree(&preg);
+
+			if (match == 0) {
+				char *result = NULL;
+				int start = pmatch[0].rm_so;
+				int end = pmatch[0].rm_eo;
+				size_t size = end - start;
+				result = malloc (sizeof(*result) * (size + 1));
+
+				if (result) {
+					strncpy(result, &string[start], size);
+					result[size] = '\0';
+					return result;
+				}
+			}
+			else return NULL;
+		}
+	}
+	return NULL;
+}
+
+//
+// name: inet_prio
+// @param
+// @return prio
+int iet_prio(const char *dev, char * args)
+{
+	char preferredip_buff[255] = "";
+	char *preferredip = &preferredip_buff[0];
+	// Phase 1 : checks. If anyone fails, return prio 0.
+	// check if args exists
+	if (!args) {
+		dc_log(0, "need prio_args with preferredip set");
+		return 0;
+	}
+	// check if args format is OK
+	if (sscanf(args, "preferredip=%s", preferredip) ==1) {}
+	else {
+		dc_log(0, "unexpected prio_args format");
+		return 0;
+	}
+	// check if ip is not too short
+	if (strlen(preferredip) <= 7) {
+		dc_log(0, "prio args: preferredip too short");
+		return 0;
+	}
+	// Phase 2 : find device in /dev/disk/by-path to match device/ip
+	DIR           *dir_p;
+	struct dirent *dir_entry_p;
+	enum { BUFFERSIZE = 1024 };
+	char buffer[BUFFERSIZE];
+	char fullpath[BUFFERSIZE] = "/dev/disk/by-path/";
+	dir_p = opendir(fullpath);
+
+	// loop to find device in /dev/disk/by-path
+	while( NULL != (dir_entry_p = readdir(dir_p))) {
+		if (dir_entry_p->d_name[0] != '.') {
+			char path[BUFFERSIZE] = "/dev/disk/by-path/";
+			strcat(path,dir_entry_p->d_name);
+			ssize_t nchars = readlink(path, buffer, sizeof(buffer)-1);
+			if (nchars != -1) {
+				char *device;
+				device = find_regex(buffer,"(sd[a-z]+)");
+				// if device parsed is the right one
+				if (device!=NULL && strncmp(device, dev, strlen(device)) == 0) {
+					char *ip;
+					ip = find_regex(dir_entry_p->d_name,"([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3})");
+					// if prefferedip and ip fetched matches
+					if (ip!=NULL && strncmp(ip, preferredip, strlen(ip)) == 0) {
+						// high prio
+						free(ip);
+						closedir(dir_p);
+						return 20;
+					}
+					free(ip);
+				}
+				free(device);
+			}
+			else {
+				printf("error\n");
+			}
+		}
+	}
+	// nothing found, low prio
+	closedir(dir_p);
+	return 10;
+}
+
+int getprio(struct path * pp, char * args)
+{
+	return iet_prio(pp->dev, args);
+}
diff --git a/libmultipath/prioritizers/netapp.c b/libmultipath/prioritizers/netapp.c
deleted file mode 100644
index c695cd3..0000000
--- a/libmultipath/prioritizers/netapp.c
+++ /dev/null
@@ -1,243 +0,0 @@
-/* 
- * Copyright 2005 Network Appliance, Inc., All Rights Reserved
- * Author:  David Wysochanski available at davidw@netapp.com
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of 
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- * General Public License v2 for more details.
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <sys/ioctl.h>
-#include <errno.h>
-#include <assert.h>
-
-#include <sg_include.h>
-#include <debug.h>
-#include <prio.h>
-
-#define INQUIRY_CMD	0x12
-#define INQUIRY_CMDLEN	6
-#define DEFAULT_PRIOVAL	10
-#define RESULTS_MAX	256
-#define SG_TIMEOUT	30000
-
-#define pp_netapp_log(prio, fmt, args...) \
-        condlog(prio, "%s: netapp prio: " fmt, dev, ##args)
-
-static void dump_cdb(unsigned char *cdb, int size)
-{
-	int i;
-	char buf[10*5+1];
-	char * p = &buf[0];
-	
-	condlog(0, "- SCSI CDB: ");
-	for (i=0; i<size; i++) {
-		p += snprintf(p, 10*(size-i), "0x%02x ", cdb[i]);
-	}
-	condlog(0, "%s", buf);
-}
-
-static void process_sg_error(struct sg_io_hdr *io_hdr)
-{
-	int i;
-	char buf[128*5+1];
-	char * p = &buf[0];
-	
-	condlog(0, "- masked_status=0x%02x, host_status=0x%02x, "
-		"driver_status=0x%02x", io_hdr->masked_status,
-		io_hdr->host_status, io_hdr->driver_status);
-	if (io_hdr->sb_len_wr > 0) {
-		condlog(0, "- SCSI sense data: ");
-		for (i=0; i<io_hdr->sb_len_wr; i++) {
-			p += snprintf(p, 128*(io_hdr->sb_len_wr-i), "0x%02x ",
-				      io_hdr->sbp[i]);
-		}
-		condlog(0, "%s", buf);
-	}
-}
-
-/*
- * Returns:
- * -1: error, errno set
- *  0: success
- */
-static int send_gva(const char *dev, int fd, unsigned char pg,
-		    unsigned char *results, int *results_size)
-{
-	unsigned char sb[128];
-	unsigned char cdb[10] = {0xc0, 0, 0x1, 0xa, 0x98, 0xa,
-				 pg, sizeof(sb), 0, 0};
-	struct sg_io_hdr io_hdr;
-	int ret = -1;
-
-	memset(&io_hdr, 0, sizeof (struct sg_io_hdr));
-	io_hdr.interface_id = 'S';
-	io_hdr.cmd_len = sizeof (cdb);
-	io_hdr.mx_sb_len = sizeof (sb);
-	io_hdr.dxfer_direction = SG_DXFER_FROM_DEV;
-	io_hdr.dxfer_len = *results_size;
-	io_hdr.dxferp = results;
-	io_hdr.cmdp = cdb;
-	io_hdr.sbp = sb;
-	io_hdr.timeout = SG_TIMEOUT;
-	io_hdr.pack_id = 0;
-	if (ioctl(fd, SG_IO, &io_hdr) < 0) {
-		pp_netapp_log(0, "SG_IO ioctl failed, errno=%d", errno);
-		dump_cdb(cdb, sizeof(cdb));
-		goto out;
-	}
-	if (io_hdr.info & SG_INFO_OK_MASK) {
-		pp_netapp_log(0, "SCSI error");
-		dump_cdb(cdb, sizeof(cdb));
-		process_sg_error(&io_hdr);
-		goto out;
-	}
-
-	if (results[4] != 0x0a || results[5] != 0x98 ||
-	    results[6] != 0x0a ||results[7] != 0x01) {
-		dump_cdb(cdb, sizeof(cdb));
-		pp_netapp_log(0, "GVA return wrong format ");
-		pp_netapp_log(0, "results[4-7] = 0x%02x 0x%02x 0x%02x 0x%02x",
-			results[4], results[5], results[6], results[7]);
-		goto out;
-	}
-	ret = 0;
- out:
-	return(ret);
-}
-
-/*
- * Retuns:
- * -1: Unable to obtain proxy info
- *  0: Device _not_ proxy path
- *  1: Device _is_ proxy path
- */
-static int get_proxy(const char *dev, int fd)
-{
-	unsigned char results[256];
-	unsigned char sb[128];
-	unsigned char cdb[INQUIRY_CMDLEN] = {INQUIRY_CMD, 1, 0xc1, 0,
-						   sizeof(sb), 0};
-	struct sg_io_hdr io_hdr;
-	int ret = -1;
-
-	memset(&results, 0, sizeof (results));
-	memset(&io_hdr, 0, sizeof (struct sg_io_hdr));
-	io_hdr.interface_id = 'S';
-	io_hdr.cmd_len = sizeof (cdb);
-	io_hdr.mx_sb_len = sizeof (sb);
-	io_hdr.dxfer_direction = SG_DXFER_FROM_DEV;
-	io_hdr.dxfer_len = sizeof (results);
-	io_hdr.dxferp = results;
-	io_hdr.cmdp = cdb;
-	io_hdr.sbp = sb;
-	io_hdr.timeout = SG_TIMEOUT;
-	io_hdr.pack_id = 0;
-	if (ioctl(fd, SG_IO, &io_hdr) < 0) {
-		pp_netapp_log(0, "ioctl sending inquiry command failed, "
-			"errno=%d", errno);
-		dump_cdb(cdb, sizeof(cdb));
-		goto out;
-	}
-	if (io_hdr.info & SG_INFO_OK_MASK) {
-		pp_netapp_log(0, "SCSI error");
-		dump_cdb(cdb, sizeof(cdb));
-		process_sg_error(&io_hdr);
-		goto out;
-	}
-
-	if (results[1] != 0xc1 || results[8] != 0x0a ||
-	    results[9] != 0x98 || results[10] != 0x0a ||
-	    results[11] != 0x0 || results[12] != 0xc1 ||
-	    results[13] != 0x0) {
-		pp_netapp_log(0,"proxy info page in unknown format - ");
-		pp_netapp_log(0,"results[8-13]=0x%02x 0x%02x 0x%02x 0x%02x "
-			"0x%02x 0x%02x",
-			results[8], results[9], results[10],
-			results[11], results[12], results[13]);
-		dump_cdb(cdb, sizeof(cdb));
-		goto out;
-	}
-	ret = (results[19] & 0x02) >> 1;
-
- out:
-	return(ret);
-}
-
-/*
- * Returns priority of device based on device info.
- *
- * 4: FCP non-proxy, FCP proxy unknown, or unable to determine protocol
- * 3: iSCSI HBA
- * 2: iSCSI software
- * 1: FCP proxy
- */
-static int netapp_prio(const char *dev, int fd)
-{
-	unsigned char results[RESULTS_MAX];
-	int results_size=RESULTS_MAX;
-	int rc;
-	int is_proxy;
-	int is_iscsi_software;
-	int is_iscsi_hardware;
-	int tot_len;
-
-	is_iscsi_software = is_iscsi_hardware = is_proxy = 0;
-
-	memset(&results, 0, sizeof (results));
-	rc = send_gva(dev, fd, 0x41, results, &results_size);
-	if (rc == 0) {
-		tot_len = results[0] << 24 | results[1] << 16 |
-			  results[2] << 8 | results[3];
-		if (tot_len <= 8) {
-			goto try_fcp_proxy;
-		}
-		if (results[8] != 0x41) {
-			pp_netapp_log(0, "GVA page 0x41 error - "
-				"results[8] = 0x%x", results[8]);
-			goto try_fcp_proxy;
-		}
-		if ((strncmp((char *)&results[12], "ism_sw", 6) == 0) ||
-		    (strncmp((char *)&results[12], "iswt", 4) == 0)) {
-			is_iscsi_software = 1;
-			goto prio_select;
-		}
-		else if (strncmp((char *)&results[12], "ism_sn", 6) == 0) {
-			is_iscsi_hardware = 1;
-			goto prio_select;
-		}
-	}
-	
- try_fcp_proxy:	
-	rc = get_proxy(dev, fd);
-	if (rc >= 0) {
-		is_proxy = rc;
-	}
-
- prio_select:
-	if (is_iscsi_hardware) {
-		return 3;
-	} else if (is_iscsi_software) {
-		return 2;
-	} else {
-		if (is_proxy) {
-			return 1;
-		} else {
-			/* Either non-proxy, or couldn't get proxy info */
-			return 4;
-		}
-	}
-}
-
-int getprio (struct path * pp, char * args)
-{
-	return netapp_prio(pp->dev, pp->fd);
-}
diff --git a/libmultipath/prioritizers/ontap.c b/libmultipath/prioritizers/ontap.c
new file mode 100644
index 0000000..026d45d
--- /dev/null
+++ b/libmultipath/prioritizers/ontap.c
@@ -0,0 +1,247 @@
+/*
+ * Copyright 2005 Network Appliance, Inc., All Rights Reserved
+ * Author:  David Wysochanski available at davidw@netapp.com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License v2 for more details.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <errno.h>
+#include <assert.h>
+
+#include <sg_include.h>
+#include <debug.h>
+#include <prio.h>
+#include <structs.h>
+
+#define INQUIRY_CMD	0x12
+#define INQUIRY_CMDLEN	6
+#define DEFAULT_PRIOVAL	10
+#define RESULTS_MAX	256
+#define SG_TIMEOUT	60000
+
+#define pp_ontap_log(prio, fmt, args...) \
+        condlog(prio, "%s: ontap prio: " fmt, dev, ##args)
+
+static void dump_cdb(unsigned char *cdb, int size)
+{
+	int i;
+	char buf[10*5+1];
+	char * p = &buf[0];
+
+	condlog(0, "- SCSI CDB: ");
+	for (i=0; i<size; i++) {
+		p += snprintf(p, 10*(size-i), "0x%02x ", cdb[i]);
+	}
+	condlog(0, "%s", buf);
+}
+
+static void process_sg_error(struct sg_io_hdr *io_hdr)
+{
+	int i;
+	char buf[128*5+1];
+	char * p = &buf[0];
+
+	condlog(0, "- masked_status=0x%02x, host_status=0x%02x, "
+		"driver_status=0x%02x", io_hdr->masked_status,
+		io_hdr->host_status, io_hdr->driver_status);
+	if (io_hdr->sb_len_wr > 0) {
+		condlog(0, "- SCSI sense data: ");
+		for (i=0; i<io_hdr->sb_len_wr; i++) {
+			p += snprintf(p, 128*(io_hdr->sb_len_wr-i), "0x%02x ",
+				      io_hdr->sbp[i]);
+		}
+		condlog(0, "%s", buf);
+	}
+}
+
+/*
+ * Returns:
+ * -1: error, errno set
+ *  0: success
+ */
+static int send_gva(const char *dev, int fd, unsigned char pg,
+		    unsigned char *results, int *results_size)
+{
+	unsigned char sb[128];
+	unsigned char cdb[10] = {0xc0, 0, 0x1, 0xa, 0x98, 0xa,
+				 pg, sizeof(sb), 0, 0};
+	struct sg_io_hdr io_hdr;
+	int ret = -1;
+
+	memset(&io_hdr, 0, sizeof (struct sg_io_hdr));
+	memset(results, 0, *results_size);
+	io_hdr.interface_id = 'S';
+	io_hdr.cmd_len = sizeof (cdb);
+	io_hdr.mx_sb_len = sizeof (sb);
+	io_hdr.dxfer_direction = SG_DXFER_FROM_DEV;
+	io_hdr.dxfer_len = *results_size;
+	io_hdr.dxferp = results;
+	io_hdr.cmdp = cdb;
+	io_hdr.sbp = sb;
+	io_hdr.timeout = SG_TIMEOUT;
+	io_hdr.pack_id = 0;
+	if (ioctl(fd, SG_IO, &io_hdr) < 0) {
+		pp_ontap_log(0, "SG_IO ioctl failed, errno=%d", errno);
+		dump_cdb(cdb, sizeof(cdb));
+		goto out;
+	}
+	if (io_hdr.info & SG_INFO_OK_MASK) {
+		pp_ontap_log(0, "SCSI error");
+		dump_cdb(cdb, sizeof(cdb));
+		process_sg_error(&io_hdr);
+		goto out;
+	}
+
+	if (results[4] != 0x0a || results[5] != 0x98 ||
+	    results[6] != 0x0a ||results[7] != 0x01) {
+		dump_cdb(cdb, sizeof(cdb));
+		pp_ontap_log(0, "GVA return wrong format ");
+		pp_ontap_log(0, "results[4-7] = 0x%02x 0x%02x 0x%02x 0x%02x",
+			results[4], results[5], results[6], results[7]);
+		goto out;
+	}
+	ret = 0;
+ out:
+	return(ret);
+}
+
+/*
+ * Retuns:
+ * -1: Unable to obtain proxy info
+ *  0: Device _not_ proxy path
+ *  1: Device _is_ proxy path
+ */
+static int get_proxy(const char *dev, int fd)
+{
+	unsigned char results[256];
+	unsigned char sb[128];
+	unsigned char cdb[INQUIRY_CMDLEN] = {INQUIRY_CMD, 1, 0xc1, 0,
+						   sizeof(sb), 0};
+	struct sg_io_hdr io_hdr;
+	int ret = -1;
+
+	memset(&results, 0, sizeof (results));
+	memset(&io_hdr, 0, sizeof (struct sg_io_hdr));
+	io_hdr.interface_id = 'S';
+	io_hdr.cmd_len = sizeof (cdb);
+	io_hdr.mx_sb_len = sizeof (sb);
+	io_hdr.dxfer_direction = SG_DXFER_FROM_DEV;
+	io_hdr.dxfer_len = sizeof (results);
+	io_hdr.dxferp = results;
+	io_hdr.cmdp = cdb;
+	io_hdr.sbp = sb;
+	io_hdr.timeout = SG_TIMEOUT;
+	io_hdr.pack_id = 0;
+	if (ioctl(fd, SG_IO, &io_hdr) < 0) {
+		pp_ontap_log(0, "ioctl sending inquiry command failed, "
+			"errno=%d", errno);
+		dump_cdb(cdb, sizeof(cdb));
+		goto out;
+	}
+	if (io_hdr.info & SG_INFO_OK_MASK) {
+		pp_ontap_log(0, "SCSI error");
+		dump_cdb(cdb, sizeof(cdb));
+		process_sg_error(&io_hdr);
+		goto out;
+	}
+
+	if (results[1] != 0xc1 || results[8] != 0x0a ||
+	    results[9] != 0x98 || results[10] != 0x0a ||
+	    results[11] != 0x0 || results[12] != 0xc1 ||
+	    results[13] != 0x0) {
+		pp_ontap_log(0,"proxy info page in unknown format - ");
+		pp_ontap_log(0,"results[8-13]=0x%02x 0x%02x 0x%02x 0x%02x "
+			"0x%02x 0x%02x",
+			results[8], results[9], results[10],
+			results[11], results[12], results[13]);
+		dump_cdb(cdb, sizeof(cdb));
+		goto out;
+	}
+	ret = (results[19] & 0x02) >> 1;
+
+ out:
+	return(ret);
+}
+
+/*
+ * Returns priority of device based on device info.
+ *
+ * 4: FCP non-proxy, FCP proxy unknown, or unable to determine protocol
+ * 3: iSCSI HBA
+ * 2: iSCSI software
+ * 1: FCP proxy
+ */
+static int ontap_prio(const char *dev, int fd)
+{
+	unsigned char results[RESULTS_MAX];
+	int results_size=RESULTS_MAX;
+	int rc;
+	int is_proxy;
+	int is_iscsi_software;
+	int is_iscsi_hardware;
+	int tot_len;
+
+	is_iscsi_software = is_iscsi_hardware = is_proxy = 0;
+
+	memset(&results, 0, sizeof (results));
+	rc = send_gva(dev, fd, 0x41, results, &results_size);
+	if (rc >= 0) {
+		tot_len = results[0] << 24 | results[1] << 16 |
+			  results[2] << 8 | results[3];
+		if (tot_len <= 8) {
+			goto try_fcp_proxy;
+		}
+		if (results[8] != 0x41) {
+			pp_ontap_log(0, "GVA page 0x41 error - "
+				"results[8] = 0x%x", results[8]);
+			goto try_fcp_proxy;
+		}
+		if ((strncmp((char *)&results[12], "ism_sw", 6) == 0) ||
+		    (strncmp((char *)&results[12], "iswt", 4) == 0)) {
+			is_iscsi_software = 1;
+			goto prio_select;
+		}
+		else if (strncmp((char *)&results[12], "ism_sn", 6) == 0) {
+			is_iscsi_hardware = 1;
+			goto prio_select;
+		}
+	} else {
+		return 0;
+	}
+
+ try_fcp_proxy:
+	rc = get_proxy(dev, fd);
+	if (rc >= 0) {
+		is_proxy = rc;
+	}
+
+ prio_select:
+	if (is_iscsi_hardware) {
+		return 3;
+	} else if (is_iscsi_software) {
+		return 2;
+	} else {
+		if (is_proxy) {
+			return 1;
+		} else {
+			/* Either non-proxy, or couldn't get proxy info */
+			return 4;
+		}
+	}
+}
+
+int getprio (struct path * pp, char * args)
+{
+	return ontap_prio(pp->dev, pp->fd);
+}
diff --git a/libmultipath/prioritizers/rdac.c b/libmultipath/prioritizers/rdac.c
index 27d51ab..441b3b0 100644
--- a/libmultipath/prioritizers/rdac.c
+++ b/libmultipath/prioritizers/rdac.c
@@ -5,6 +5,7 @@
 #include <sg_include.h>
 #include <debug.h>
 #include <prio.h>
+#include <structs.h>
 
 #define INQUIRY_CMD     0x12
 #define INQUIRY_CMDLEN  6
@@ -21,6 +22,7 @@ int rdac_prio(const char *dev, int fd)
 	int ret = 0;
 
 	memset(&io_hdr, 0, sizeof (struct sg_io_hdr));
+	memset(sense_buffer, 0, 256);
 	io_hdr.interface_id = 'S';
 	io_hdr.cmd_len = sizeof (inqCmdBlk);
 	io_hdr.mx_sb_len = sizeof (sb);
@@ -81,6 +83,10 @@ int rdac_prio(const char *dev, int fd)
 		break;
 	}
 
+	/* For ioship mode set the bit 3 (00001000) */
+	if ((sense_buffer[8] >> 5) & 0x01)
+		ret |= 0x08;
+
 out:
 	return(ret);
 }
diff --git a/libmultipath/prioritizers/weightedpath.c b/libmultipath/prioritizers/weightedpath.c
new file mode 100644
index 0000000..54c9039
--- /dev/null
+++ b/libmultipath/prioritizers/weightedpath.c
@@ -0,0 +1,103 @@
+/*
+ *
+ *  (C)  Copyright 2008 Hewlett-Packard Development Company, L.P
+ *
+ *  This file is released under the GPL
+ */
+
+/*
+ * Prioritizer for device mapper multipath, where specific paths and the
+ * corresponding priority values are provided as arguments.
+ *
+ * This prioritizer assigns the priority value provided in the configuration
+ * file based on the comparison made between the specified paths and the path
+ * instance for which this is called.
+ * Paths can be specified as a regular expression of devname of the path or
+ * as hbtl information of the path.
+ *
+ * Examples:
+ *	prio            "weightedpath hbtl 1:.:.:. 2 4:.:.:. 4"
+ *	prio            "weightedpath devname sda 10 sde 20"
+ *
+ * Returns zero as the default priority.
+ */
+
+#include <stdio.h>
+#include <string.h>
+
+#include <prio.h>
+#include "weightedpath.h"
+#include <config.h>
+#include <structs.h>
+#include <memory.h>
+#include <debug.h>
+#include <regex.h>
+
+char *get_next_string(char **temp, char *split_char)
+{
+	char *token = NULL;
+	token = strsep(temp, split_char);
+	while (token != NULL && !strcmp(token, ""))
+		token = strsep(temp, split_char);
+	return token;
+}
+
+/* main priority routine */
+int prio_path_weight(struct path *pp, char *prio_args)
+{
+	char path[FILE_NAME_SIZE];
+	char *arg;
+	char *temp, *regex, *prio;
+	char split_char[] = " \t";
+	int priority = DEFAULT_PRIORITY, path_found = 0;
+	regex_t pathe;
+
+	/* Return default priority if there is no argument */
+	if (!prio_args)
+		return priority;
+
+	arg = temp = STRDUP(prio_args);
+
+	regex = get_next_string(&temp, split_char);
+
+	/* Return default priority if the argument is not parseable */
+	if (!regex)
+		return priority;
+
+	if (!strcmp(regex, HBTL)) {
+		sprintf(path, "%d:%d:%d:%d", pp->sg_id.host_no,
+			pp->sg_id.channel, pp->sg_id.scsi_id, pp->sg_id.lun);
+	} else if (!strcmp(regex, DEV_NAME)) {
+		strcpy(path, pp->dev);
+	} else {
+		condlog(0, "%s: %s - Invalid arguments", pp->dev,
+			pp->prio.name);
+		return priority;
+	}
+
+	while (!path_found) {
+		if (!temp)
+			break;
+		if (!(regex = get_next_string(&temp, split_char)))
+			break;
+		if (!(prio = get_next_string(&temp, split_char)))
+			break;
+
+		if (!regcomp(&pathe, regex, REG_EXTENDED|REG_NOSUB)) {
+			if (!regexec(&pathe, path, 0, NULL, 0)) {
+				path_found = 1;
+				priority = atoi(prio);
+			}
+			regfree(&pathe);
+		}
+	}
+
+	FREE(arg);
+	return priority;
+}
+
+int getprio(struct path *pp, char *args)
+{
+	return prio_path_weight(pp, args);
+}
+
diff --git a/libmultipath/prioritizers/weightedpath.h b/libmultipath/prioritizers/weightedpath.h
new file mode 100644
index 0000000..509f215
--- /dev/null
+++ b/libmultipath/prioritizers/weightedpath.h
@@ -0,0 +1,11 @@
+#ifndef _WEIGHTED_PATH_H
+#define _WEIGHTED_PATH_H
+
+#define PRIO_WEIGHTED_PATH "weightedpath"
+#define HBTL "hbtl"
+#define DEV_NAME "devname"
+#define DEFAULT_PRIORITY 0
+
+int prio_path_weight(struct path *pp, char *prio_args);
+
+#endif
diff --git a/libmultipath/propsel.c b/libmultipath/propsel.c
index 2187558..a7e1fc2 100644
--- a/libmultipath/propsel.c
+++ b/libmultipath/propsel.c
@@ -16,6 +16,9 @@
 #include "defaults.h"
 #include "devmapper.h"
 #include "prio.h"
+#include "discovery.h"
+#include "prioritizers/alua_rtpg.h"
+#include <inttypes.h>
 
 pgpolicyfn *pgpolicies[] = {
 	NULL,
@@ -215,50 +218,89 @@ select_selector (struct multipath * mp)
 	return 0;
 }
 
+static void
+select_alias_prefix (struct multipath * mp)
+{
+	if (mp->hwe && mp->hwe->alias_prefix) {
+		mp->alias_prefix = mp->hwe->alias_prefix;
+		condlog(3, "%s: alias_prefix = %s (controller setting)",
+			mp->wwid, mp->alias_prefix);
+		return;
+	}
+	if (conf->alias_prefix) {
+		mp->alias_prefix = conf->alias_prefix;
+		condlog(3, "%s: alias_prefix = %s (config file default)",
+			mp->wwid, mp->alias_prefix);
+		return;
+	}
+	mp->alias_prefix = set_default(DEFAULT_ALIAS_PREFIX);
+	condlog(3, "%s: alias_prefix = %s (internal default)",
+		mp->wwid, mp->alias_prefix);
+}
+
+static int
+want_user_friendly_names(struct multipath * mp)
+{
+	if (mp->mpe &&
+	    mp->mpe->user_friendly_names != USER_FRIENDLY_NAMES_UNDEF)
+		return (mp->mpe->user_friendly_names == USER_FRIENDLY_NAMES_ON);
+	if (mp->hwe &&
+	    mp->hwe->user_friendly_names != USER_FRIENDLY_NAMES_UNDEF)
+		return (mp->hwe->user_friendly_names == USER_FRIENDLY_NAMES_ON);
+	return (conf->user_friendly_names  == USER_FRIENDLY_NAMES_ON);
+}
+
 extern int
 select_alias (struct multipath * mp)
 {
 	if (mp->mpe && mp->mpe->alias)
-		mp->alias = mp->mpe->alias;
+		mp->alias = STRDUP(mp->mpe->alias);
 	else {
 		mp->alias = NULL;
-		if (conf->user_friendly_names)
+		if (want_user_friendly_names(mp)) {
+			select_alias_prefix(mp);
 			mp->alias = get_user_friendly_alias(mp->wwid,
-					conf->bindings_file);
-		if (mp->alias == NULL){
-			char *alias;
-			if ((alias = MALLOC(WWID_SIZE)) != NULL){
-				if (dm_get_name(mp->wwid, alias) == 1)
-					mp->alias = alias;
-				else
-					FREE(alias);
-			}
+					conf->bindings_file, mp->alias_prefix, conf->bindings_read_only);
 		}
 		if (mp->alias == NULL)
-			mp->alias = mp->wwid;
+			mp->alias = dm_get_name(mp->wwid);
+		if (mp->alias == NULL)
+			mp->alias = STRDUP(mp->wwid);
 	}
 
-	return 0;
+	return mp->alias ? 0 : 1;
 }
 
 extern int
 select_features (struct multipath * mp)
 {
-	if (mp->hwe && mp->hwe->features) {
-		mp->features = mp->hwe->features;
-		condlog(3, "%s: features = %s (controller setting)",
-			mp->alias, mp->features);
-		return 0;
-	}
-	if (conf->features) {
-		mp->features = conf->features;
-		condlog(3, "%s: features = %s (config file default)",
-			mp->alias, mp->features);
-		return 0;
+	struct mpentry * mpe;
+	char *origin;
+
+	if ((mpe = find_mpe(mp->wwid)) && mpe->features) {
+		mp->features = STRDUP(mpe->features);
+		origin = "LUN setting";
+	} else if (mp->hwe && mp->hwe->features) {
+		mp->features = STRDUP(mp->hwe->features);
+		origin = "controller setting";
+	} else if (conf->features) {
+		mp->features = STRDUP(conf->features);
+		origin = "config file default";
+	} else {
+		mp->features = set_default(DEFAULT_FEATURES);
+		origin = "internal default";
+	}
+	condlog(3, "%s: features = %s (%s)",
+		mp->alias, mp->features, origin);
+	if (strstr(mp->features, "queue_if_no_path")) {
+		if (mp->no_path_retry == NO_PATH_RETRY_UNDEF)
+			mp->no_path_retry = NO_PATH_RETRY_QUEUE;
+		else if (mp->no_path_retry == NO_PATH_RETRY_FAIL) {
+			condlog(1, "%s: config error, overriding 'no_path_retry' value",
+				mp->alias);
+			mp->no_path_retry = NO_PATH_RETRY_QUEUE;
+		}
 	}
-	mp->features = set_default(DEFAULT_FEATURES);
-	condlog(3, "%s: features = %s (internal default)",
-		mp->alias, mp->features);
 	return 0;
 }
 
@@ -292,47 +334,90 @@ select_checker(struct path *pp)
 		checker_get(c, pp->hwe->checker_name);
 		condlog(3, "%s: path checker = %s (controller setting)",
 			pp->dev, checker_name(c));
-		return 0;
+		goto out;
 	}
 	if (conf->checker_name) {
 		checker_get(c, conf->checker_name);
 		condlog(3, "%s: path checker = %s (config file default)",
 			pp->dev, checker_name(c));
-		return 0;
+		goto out;
 	}
 	checker_get(c, DEFAULT_CHECKER);
 	condlog(3, "%s: path checker = %s (internal default)",
 		pp->dev, checker_name(c));
+out:
+	if (conf->checker_timeout) {
+		c->timeout = conf->checker_timeout * 1000;
+		condlog(3, "%s: checker timeout = %u ms (config file default)",
+				pp->dev, c->timeout);
+	}
+	else if (pp->udev && sysfs_get_timeout(pp, &c->timeout) == 0)
+		condlog(3, "%s: checker timeout = %u ms (sysfs setting)",
+				pp->dev, c->timeout);
+	else {
+		c->timeout = DEF_TIMEOUT;
+		condlog(3, "%s: checker timeout = %u ms (internal default)",
+				pp->dev, c->timeout);
+	}
 	return 0;
 }
 
 extern int
 select_getuid (struct path * pp)
 {
-	if (pp->hwe && pp->hwe->getuid) {
-		pp->getuid = pp->hwe->getuid;
-		condlog(3, "%s: getuid = %s (controller setting)",
-			pp->dev, pp->getuid);
+	if (pp->hwe && pp->hwe->uid_attribute) {
+		pp->uid_attribute = pp->hwe->uid_attribute;
+		condlog(3, "%s: uid_attribute = %s (controller setting)",
+			pp->dev, pp->uid_attribute);
 		return 0;
 	}
-	if (conf->getuid) {
-		pp->getuid = conf->getuid;
-		condlog(3, "%s: getuid = %s (config file default)",
-			pp->dev, pp->getuid);
+	if (conf->uid_attribute) {
+		pp->uid_attribute = conf->uid_attribute;
+		condlog(3, "%s: uid_attribute = %s (config file default)",
+			pp->dev, pp->uid_attribute);
 		return 0;
 	}
-	pp->getuid = STRDUP(DEFAULT_GETUID);
-	condlog(3, "%s: getuid = %s (internal default)",
-		pp->dev, pp->getuid);
+	pp->uid_attribute = STRDUP(DEFAULT_UID_ATTRIBUTE);
+	condlog(3, "%s: uid_attribute = %s (internal default)",
+		pp->dev, pp->uid_attribute);
 	return 0;
 }
 
+void
+detect_prio(struct path * pp)
+{
+	struct prio *p = &pp->prio;
+
+	if (get_target_port_group_support(pp->fd) > 0)
+		prio_get(p, PRIO_ALUA, DEFAULT_PRIO_ARGS);
+}
+
 extern int
 select_prio (struct path * pp)
 {
+	struct mpentry * mpe;
+	struct prio * p = &pp->prio;
+
+	if (pp->detect_prio == DETECT_PRIO_ON) {
+		detect_prio(pp);
+		if (prio_selected(p)) {
+			condlog(3, "%s: prio = %s (detected setting)",
+				pp->dev, prio_name(p));
+			return 0;
+		}
+	}
+
+	if ((mpe = find_mpe(pp->wwid))) {
+		if (mpe->prio_name) {
+			prio_get(p, mpe->prio_name, mpe->prio_args);
+			condlog(3, "%s: prio = %s (LUN setting)",
+				pp->dev, prio_name(p));
+			return 0;
+		}
+	}
+
 	if (pp->hwe && pp->hwe->prio_name) {
-		pp->prio = prio_lookup(pp->hwe->prio_name);
-		prio_set_args(pp->prio, pp->hwe->prio_args);
+		prio_get(p, pp->hwe->prio_name, pp->hwe->prio_args);
 		condlog(3, "%s: prio = %s (controller setting)",
 			pp->dev, pp->hwe->prio_name);
 		condlog(3, "%s: prio args = %s (controller setting)",
@@ -340,16 +425,14 @@ select_prio (struct path * pp)
 		return 0;
 	}
 	if (conf->prio_name) {
-		pp->prio = prio_lookup(conf->prio_name);
-		prio_set_args(pp->prio, conf->prio_args);
+		prio_get(p, conf->prio_name, conf->prio_args);
 		condlog(3, "%s: prio = %s (config file default)",
 			pp->dev, conf->prio_name);
 		condlog(3, "%s: prio args = %s (config file default)",
 			pp->dev, conf->prio_args);
 		return 0;
 	}
-	pp->prio = prio_lookup(DEFAULT_PRIO);
-        prio_set_args(pp->prio, DEFAULT_PRIO_ARGS);
+	prio_get(p, DEFAULT_PRIO, DEFAULT_PRIO_ARGS);
 	condlog(3, "%s: prio = %s (internal default)",
 		pp->dev, DEFAULT_PRIO);
 	condlog(3, "%s: prio = %s (internal default)",
@@ -363,6 +446,7 @@ select_no_path_retry(struct multipath *mp)
 	if (mp->flush_on_last_del == FLUSH_IN_PROGRESS) {
 		condlog(0, "flush_on_last_del in progress");
 		mp->no_path_retry = NO_PATH_RETRY_FAIL;
+		return 0;
 	}
 	if (mp->mpe && mp->mpe->no_path_retry != NO_PATH_RETRY_UNDEF) {
 		mp->no_path_retry = mp->mpe->no_path_retry;
@@ -382,14 +466,44 @@ select_no_path_retry(struct multipath *mp)
 			mp->alias, mp->no_path_retry);
 		return 0;
 	}
-	mp->no_path_retry = NO_PATH_RETRY_UNDEF;
-	condlog(3, "%s: no_path_retry = NONE (internal default)",
-		mp->alias);
+	if (mp->no_path_retry != NO_PATH_RETRY_UNDEF)
+		condlog(3, "%s: no_path_retry = %i (inherited setting)",
+			mp->alias, mp->no_path_retry);
+	else
+		condlog(3, "%s: no_path_retry = %i (internal default)",
+			mp->alias, mp->no_path_retry);
 	return 0;
 }
 
-extern int
-select_minio (struct multipath * mp)
+int
+select_minio_rq (struct multipath * mp)
+{
+	if (mp->mpe && mp->mpe->minio_rq) {
+		mp->minio = mp->mpe->minio_rq;
+		condlog(3, "%s: minio = %i rq (LUN setting)",
+			mp->alias, mp->minio);
+		return 0;
+	}
+	if (mp->hwe && mp->hwe->minio_rq) {
+		mp->minio = mp->hwe->minio_rq;
+		condlog(3, "%s: minio = %i rq (controller setting)",
+			mp->alias, mp->minio);
+		return 0;
+	}
+	if (conf->minio) {
+		mp->minio = conf->minio_rq;
+		condlog(3, "%s: minio = %i rq (config file default)",
+			mp->alias, mp->minio);
+		return 0;
+	}
+	mp->minio = DEFAULT_MINIO_RQ;
+	condlog(3, "%s: minio = %i rq (internal default)",
+		mp->alias, mp->minio);
+	return 0;
+}
+
+int
+select_minio_bio (struct multipath * mp)
 {
 	if (mp->mpe && mp->mpe->minio) {
 		mp->minio = mp->mpe->minio;
@@ -416,6 +530,17 @@ select_minio (struct multipath * mp)
 }
 
 extern int
+select_minio (struct multipath * mp)
+{
+	unsigned int minv_dmrq[3] = {1, 1, 0};
+
+	if (VERSION_GE(conf->version, minv_dmrq))
+		return select_minio_rq(mp);
+	else
+		return select_minio_bio(mp);
+}
+
+extern int
 select_pg_timeout(struct multipath *mp)
 {
 	if (mp->mpe && mp->mpe->pg_timeout != PGTIMEOUT_UNDEF) {
@@ -450,30 +575,36 @@ select_pg_timeout(struct multipath *mp)
 		return 0;
 	}
 	mp->pg_timeout = PGTIMEOUT_UNDEF;
-	condlog(3, "pg_timeout = NONE (internal default)");
+	condlog(3, "%s: pg_timeout = NONE (internal default)", mp->alias);
 	return 0;
 }
 
 extern int
 select_fast_io_fail(struct multipath *mp)
 {
-	if (mp->hwe && mp->hwe->fast_io_fail) {
+	if (mp->hwe && mp->hwe->fast_io_fail != MP_FAST_IO_FAIL_UNSET) {
 		mp->fast_io_fail = mp->hwe->fast_io_fail;
-		if (mp->fast_io_fail == -1)
-			condlog(3, "%s: fast_io_fail_tmo = off (controller default)", mp->alias);
+		if (mp->fast_io_fail == MP_FAST_IO_FAIL_OFF)
+			condlog(3, "%s: fast_io_fail_tmo = off "
+				"(controller setting)", mp->alias);
 		else
-			condlog(3, "%s: fast_io_fail_tmo = %d (controller default)", mp->alias, mp->fast_io_fail);
+			condlog(3, "%s: fast_io_fail_tmo = %d "
+				"(controller setting)", mp->alias,
+				mp->fast_io_fail == MP_FAST_IO_FAIL_ZERO ? 0 : mp->fast_io_fail);
 		return 0;
 	}
-	if (conf->fast_io_fail) {
+	if (conf->fast_io_fail != MP_FAST_IO_FAIL_UNSET) {
 		mp->fast_io_fail = conf->fast_io_fail;
-		if (mp->fast_io_fail == -1)
-			condlog(3, "%s: fast_io_fail_tmo = off (config file default)", mp->alias);
+		if (mp->fast_io_fail == MP_FAST_IO_FAIL_OFF)
+			condlog(3, "%s: fast_io_fail_tmo = off "
+				"(config file default)", mp->alias);
 		else
-			condlog(3, "%s: fast_io_fail_tmo = %d (config file default)", mp->alias, mp->fast_io_fail);
+			condlog(3, "%s: fast_io_fail_tmo = %d "
+				"(config file default)", mp->alias,
+				mp->fast_io_fail == MP_FAST_IO_FAIL_ZERO ? 0 : mp->fast_io_fail);
 		return 0;
 	}
-	mp->fast_io_fail = 0;
+	mp->fast_io_fail = MP_FAST_IO_FAIL_UNSET;
 	return 0;
 }
 
@@ -503,23 +634,112 @@ select_flush_on_last_del(struct multipath *mp)
 		return 0;
 	if (mp->mpe && mp->mpe->flush_on_last_del != FLUSH_UNDEF) {
 		mp->flush_on_last_del = mp->mpe->flush_on_last_del;
-		condlog(3, "flush_on_last_del = %i (multipath setting)",
-				mp->flush_on_last_del);
+		condlog(3, "%s: flush_on_last_del = %i (multipath setting)",
+			mp->alias, mp->flush_on_last_del);
 		return 0;
 	}
 	if (mp->hwe && mp->hwe->flush_on_last_del != FLUSH_UNDEF) {
 		mp->flush_on_last_del = mp->hwe->flush_on_last_del;
-		condlog(3, "flush_on_last_del = %i (controler setting)",
-				mp->flush_on_last_del);
+		condlog(3, "%s: flush_on_last_del = %i (controler setting)",
+			mp->alias, mp->flush_on_last_del);
 		return 0;
 	}
 	if (conf->flush_on_last_del != FLUSH_UNDEF) {
 		mp->flush_on_last_del = conf->flush_on_last_del;
-		condlog(3, "flush_on_last_del = %i (config file default)",
-				mp->flush_on_last_del);
+		condlog(3, "%s: flush_on_last_del = %i (config file default)",
+			mp->alias, mp->flush_on_last_del);
 		return 0;
 	}
 	mp->flush_on_last_del = FLUSH_UNDEF;
-	condlog(3, "flush_on_last_del = DISABLED (internal default)");
+	condlog(3, "%s: flush_on_last_del = DISABLED (internal default)",
+		mp->alias);
+	return 0;
+}
+
+extern int
+select_reservation_key (struct multipath * mp)
+{
+	int j;
+	unsigned char *keyp;
+	uint64_t prkey = 0;
+
+	mp->reservation_key = NULL;
+
+	if (mp->mpe && mp->mpe->reservation_key) {
+		keyp =  mp->mpe->reservation_key;
+		for (j = 0; j < 8; ++j) {
+			if (j > 0)
+				prkey <<= 8;
+			prkey |= *keyp;
+			++keyp;
+		}
+
+		condlog(3, "%s: reservation_key = 0x%" PRIx64 " "
+				"(multipath setting)",  mp->alias, prkey);
+
+		mp->reservation_key = mp->mpe->reservation_key;
+		return 0;
+	}
+
+	if (conf->reservation_key) {
+		keyp = conf->reservation_key;
+		for (j = 0; j < 8; ++j) {
+			if (j > 0)
+				prkey <<= 8;
+			prkey |= *keyp;
+			++keyp;
+		}
+
+		condlog(3, "%s: reservation_key  = 0x%" PRIx64
+				" (config file default)", mp->alias, prkey);
+
+		mp->reservation_key = conf->reservation_key;
+		return 0;
+	}
+
+	return 0;
+}
+
+extern int
+select_retain_hwhandler (struct multipath * mp)
+{
+	unsigned int minv_dm_retain[3] = {1, 5, 0};
+
+	if (!VERSION_GE(conf->version, minv_dm_retain)) {
+		mp->retain_hwhandler = RETAIN_HWHANDLER_OFF;
+		condlog(3, "%s: retain_attached_hw_hander disabled (requires kernel version >= 1.5.0)", mp->alias);
+		return 0;
+	}
+
+	if (mp->hwe && mp->hwe->retain_hwhandler) {
+		mp->retain_hwhandler = mp->hwe->retain_hwhandler;
+		condlog(3, "%s: retain_attached_hw_handler = %d (controller default)", mp->alias, mp->retain_hwhandler);
+		return 0;
+	}
+	if (conf->retain_hwhandler) {
+		mp->retain_hwhandler = conf->retain_hwhandler;
+		condlog(3, "%s: retain_attached_hw_handler = %d (config file default)", mp->alias, mp->retain_hwhandler);
+		return 0;
+	}
+	mp->retain_hwhandler = 0;
+	condlog(3, "%s: retain_attached_hw_handler = %d (compiled in default)", mp->alias, mp->retain_hwhandler);
+	return 0;
+}
+
+extern int
+select_detect_prio (struct path * pp)
+{
+	if (pp->hwe && pp->hwe->detect_prio) {
+		pp->detect_prio = pp->hwe->detect_prio;
+		condlog(3, "%s: detect_prio = %d (controller default)", pp->dev, pp->detect_prio);
+		return 0;
+	}
+	if (conf->detect_prio) {
+		pp->detect_prio = conf->detect_prio;
+		condlog(3, "%s: detect_prio = %d (config file default)", pp->dev, pp->detect_prio);
+		return 0;
+	}
+	pp->detect_prio = 0;
+	condlog(3, "%s: detect_prio = %d (compiled in default)", pp->dev, pp->detect_prio);
 	return 0;
 }
diff --git a/libmultipath/propsel.h b/libmultipath/propsel.h
index 57bea5b..eb1e534 100644
--- a/libmultipath/propsel.h
+++ b/libmultipath/propsel.h
@@ -17,3 +17,6 @@ int select_uid(struct multipath *mp);
 int select_gid(struct multipath *mp);
 int select_fast_io_fail(struct multipath *mp);
 int select_dev_loss(struct multipath *mp);
+int select_reservation_key(struct multipath *mp);
+int select_retain_hwhandler (struct multipath * mp);
+int select_detect_prio(struct path * pp);
diff --git a/libmultipath/structs.c b/libmultipath/structs.c
index a4b86d2..049f17d 100644
--- a/libmultipath/structs.c
+++ b/libmultipath/structs.c
@@ -5,6 +5,7 @@
 #include <stdio.h>
 #include <unistd.h>
 #include <libdevmapper.h>
+#include <libudev.h>
 
 #include "checkers.h"
 #include "memory.h"
@@ -15,7 +16,6 @@
 #include "debug.h"
 #include "structs_vec.h"
 #include "blacklist.h"
-#include "waiter.h"
 #include "prio.h"
 
 struct path *
@@ -45,14 +45,22 @@ free_path (struct path * pp)
 	if (checker_selected(&pp->checker))
 		checker_put(&pp->checker);
 
+	if (prio_selected(&pp->prio))
+		prio_put(&pp->prio);
+
 	if (pp->fd >= 0)
 		close(pp->fd);
 
+	if (pp->udev) {
+		udev_device_unref(pp->udev);
+		pp->udev = NULL;
+	}
+
 	FREE(pp);
 }
 
 void
-free_pathvec (vector vec, int free_paths)
+free_pathvec (vector vec, enum free_path_mode free_paths)
 {
 	int i;
 	struct path * pp;
@@ -60,7 +68,7 @@ free_pathvec (vector vec, int free_paths)
 	if (!vec)
 		return;
 
-	if (free_paths)
+	if (free_paths == FREE_PATHS)
 		vector_foreach_slot(vec, pp, i)
 			free_path(pp);
 
@@ -88,7 +96,7 @@ alloc_pathgroup (void)
 }
 
 void
-free_pathgroup (struct pathgroup * pgp, int free_paths)
+free_pathgroup (struct pathgroup * pgp, enum free_path_mode free_paths)
 {
 	if (!pgp)
 		return;
@@ -98,7 +106,7 @@ free_pathgroup (struct pathgroup * pgp, int free_paths)
 }
 
 void
-free_pgvec (vector pgvec, int free_paths)
+free_pgvec (vector pgvec, enum free_path_mode free_paths)
 {
 	int i;
 	struct pathgroup * pgp;
@@ -122,6 +130,8 @@ alloc_multipath (void)
 	if (mpp) {
 		mpp->bestpg = 1;
 		mpp->mpcontext = NULL;
+		mpp->no_path_retry = NO_PATH_RETRY_UNDEF;
+		mpp->fast_io_fail = MP_FAST_IO_FAIL_UNSET;
 	}
 	return mpp;
 }
@@ -140,9 +150,7 @@ free_multipath_attributes (struct multipath * mpp)
 		mpp->selector = NULL;
 	}
 
-	if (mpp->features &&
-	    mpp->features != conf->features &&
-	    (!mpp->hwe || (mpp->hwe && mpp->features != mpp->hwe->features))) {
+	if (mpp->features) {
 		FREE(mpp->features);
 		mpp->features = NULL;
 	}
@@ -156,16 +164,14 @@ free_multipath_attributes (struct multipath * mpp)
 }
 
 void
-free_multipath (struct multipath * mpp, int free_paths)
+free_multipath (struct multipath * mpp, enum free_path_mode free_paths)
 {
 	if (!mpp)
 		return;
 
 	free_multipath_attributes(mpp);
 
-	if (mpp->alias &&
-	    (!mpp->mpe || (mpp->mpe && mpp->alias != mpp->mpe->alias)) &&
-	    (mpp->wwid && mpp->alias != mpp->wwid)) {
+	if (mpp->alias) {
 		FREE(mpp->alias);
 		mpp->alias = NULL;
 	}
@@ -175,12 +181,6 @@ free_multipath (struct multipath * mpp, int free_paths)
 		mpp->dmi = NULL;
 	}
 
-	/*
-	 * better own vecs->lock here
-	 */
-	if (mpp->waiter)
-		((struct event_thread *)mpp->waiter)->mpp = NULL;
-
 	free_pathvec(mpp->paths, free_paths);
 	free_pgvec(mpp->pg, free_paths);
 	FREE_PTR(mpp->mpcontext);
@@ -188,7 +188,7 @@ free_multipath (struct multipath * mpp, int free_paths)
 }
 
 void
-drop_multipath (vector mpvec, char * wwid, int free_paths)
+drop_multipath (vector mpvec, char * wwid, enum free_path_mode free_paths)
 {
 	int i;
 	struct multipath * mpp;
@@ -206,7 +206,7 @@ drop_multipath (vector mpvec, char * wwid, int free_paths)
 }
 
 void
-free_multipathvec (vector mpvec, int free_paths)
+free_multipathvec (vector mpvec, enum free_path_mode free_paths)
 {
 	int i;
 	struct multipath * mpp;
@@ -321,7 +321,7 @@ find_path_by_dev (vector pathvec, char * dev)
 		return NULL;
 
 	vector_foreach_slot (pathvec, pp, i)
-		if (!strcmp_chomp(pp->dev, dev))
+		if (!strcmp(pp->dev, dev))
 			return pp;
 
 	condlog(3, "%s: not found in pathvec", dev);
@@ -338,7 +338,7 @@ find_path_by_devt (vector pathvec, char * dev_t)
 		return NULL;
 
 	vector_foreach_slot (pathvec, pp, i)
-		if (!strcmp_chomp(pp->dev_t, dev_t))
+		if (!strcmp(pp->dev_t, dev_t))
 			return pp;
 
 	condlog(3, "%s: not found in pathvec", dev_t);
@@ -373,6 +373,26 @@ pathcount (struct multipath * mpp, int state)
 	return count;
 }
 
+extern int
+pathcmp (struct pathgroup *pgp, struct pathgroup *cpgp)
+{
+	int i, j;
+	struct path *pp, *cpp;
+	int pnum = 0, found = 0;
+
+	vector_foreach_slot(pgp->paths, pp, i) {
+		pnum++;
+		vector_foreach_slot(cpgp->paths, cpp, j) {
+			if ((long)pp == (long)cpp) {
+				found++;
+				break;
+			}
+		}
+	}
+
+	return pnum - found;
+}
+
 struct path *
 first_path (struct multipath * mpp)
 {
@@ -387,6 +407,190 @@ first_path (struct multipath * mpp)
 extern void
 setup_feature(struct multipath * mpp, char *feature)
 {
-	if (!strncmp(feature, "queue_if_no_path", 16))
-		mpp->no_path_retry = NO_PATH_RETRY_QUEUE;
+	if (!strncmp(feature, "queue_if_no_path", 16)) {
+		if (mpp->no_path_retry <= NO_PATH_RETRY_UNDEF)
+			mpp->no_path_retry = NO_PATH_RETRY_QUEUE;
+	}
 }
+
+extern int
+add_feature (char **f, char *n)
+{
+	int c = 0, d, l;
+	char *e, *p, *t;
+
+	if (!f)
+		return 1;
+
+	/* Nothing to do */
+	if (!n || *n == '0')
+		return 0;
+
+	/* Check if feature is already present */
+	if (strstr(*f, n))
+		return 0;
+
+	/* Get feature count */
+	c = strtoul(*f, &e, 10);
+	if (*f == e)
+		/* parse error */
+		return 1;
+
+	/* Check if we need to increase feature count space */
+	l = strlen(*f) + strlen(n) + 1;
+
+	/* Count new features */
+	if ((c % 10) == 9)
+		l++;
+	c++;
+	p = n;
+	while (*p != '\0') {
+		if (*p == ' ' && p[1] != '\0' && p[1] != ' ') {
+			if ((c % 10) == 9)
+				l++;
+			c++;
+		}
+		p++;
+	}
+
+	t = MALLOC(l + 1);
+	if (!t)
+		return 1;
+
+	memset(t, 0, l + 1);
+
+	/* Update feature count */
+	d = c;
+	l = 1;
+	while (d > 9) {
+		d /= 10;
+		l++;
+	}
+	p = t;
+	snprintf(p, l + 2, "%0d ", c);
+
+	/* Copy the feature string */
+	p = strchr(*f, ' ');
+	if (p) {
+		while (*p == ' ')
+			p++;
+		strcat(t, p);
+		strcat(t, " ");
+	} else {
+		p = t + strlen(t);
+	}
+	strcat(t, n);
+
+	FREE(*f);
+	*f = t;
+
+	return 0;
+}
+
+extern int
+remove_feature(char **f, char *o)
+{
+	int c = 0, d, l;
+	char *e, *p, *n;
+
+	if (!f || !*f)
+		return 1;
+
+	/* Nothing to do */
+	if (!o || *o == '\0')
+		return 0;
+
+	/* Check if not present */
+	if (!strstr(*f, o))
+		return 0;
+
+	/* Get feature count */
+	c = strtoul(*f, &e, 10);
+	if (*f == e)
+		/* parse error */
+		return 1;
+
+	/* Normalize features */
+	while (*o == ' ') {
+		o++;
+	}
+	/* Just spaces, return */
+	if (*o == '\0')
+		return 0;
+	e = o + strlen(o);
+	while (*e == ' ')
+		e--;
+	d = (int)(e - o);
+
+	/* Update feature count */
+	c--;
+	p = o;
+	while (p[0] != '\0') {
+		if (p[0] == ' ' && p[1] != ' ' && p[1] != '\0')
+			c--;
+		p++;
+	}
+
+	/* Quick exit if all features have been removed */
+	if (c == 0) {
+		n = MALLOC(2);
+		if (!n)
+			return 1;
+		strcpy(n, "0");
+		goto out;
+	}
+
+	/* Search feature to be removed */
+	e = strstr(*f, o);
+	if (!e)
+		/* Not found, return */
+		return 0;
+
+	/* Update feature count space */
+	l = strlen(*f) - d;
+	n =  MALLOC(l + 1);
+	if (!n)
+		return 1;
+
+	/* Copy the feature count */
+	sprintf(n, "%0d", c);
+	/*
+	 * Copy existing features up to the feature
+	 * about to be removed
+	 */
+	p = strchr(*f, ' ');
+	if (!p)
+		/* Internal error, feature string inconsistent */
+		return 1;
+	while (*p == ' ')
+		p++;
+	p--;
+	if (e != p) {
+		do {
+			e--;
+			d++;
+		} while (*e == ' ');
+		e++; d--;
+		strncat(n, p, (size_t)(e - p));
+		p += (size_t)(e - p);
+	}
+	/* Skip feature to be removed */
+	p += d;
+
+	/* Copy remaining features */
+	if (strlen(p)) {
+		while (*p == ' ')
+			p++;
+		if (strlen(p)) {
+			p--;
+			strcat(n, p);
+		}
+	}
+
+out:
+	FREE(*f);
+	*f = n;
+
+	return 0;
+}
+
diff --git a/libmultipath/structs.h b/libmultipath/structs.h
index c559838..59387d6 100644
--- a/libmultipath/structs.h
+++ b/libmultipath/structs.h
@@ -3,13 +3,15 @@
 
 #include <sys/types.h>
 
+#include "prio.h"
+
 #define WWID_SIZE		128
-#define SERIAL_SIZE		64
-#define NODE_NAME_SIZE		19
-#define PATH_STR_SIZE  		16
-#define PARAMS_SIZE		1024
+#define SERIAL_SIZE		65
+#define NODE_NAME_SIZE		224
+#define PATH_STR_SIZE		16
+#define PARAMS_SIZE		4096
 #define FILE_NAME_SIZE		256
-#define CALLOUT_MAX_SIZE	128
+#define CALLOUT_MAX_SIZE	256
 #define BLK_DEV_SIZE		33
 #define PATH_SIZE		512
 #define NAME_SIZE		512
@@ -18,14 +20,14 @@
 #define SCSI_VENDOR_SIZE	9
 #define SCSI_PRODUCT_SIZE	17
 #define SCSI_REV_SIZE		5
-#define SCSI_STATE_SIZE		9
+#define SCSI_STATE_SIZE		19
 
 #define NO_PATH_RETRY_UNDEF	0
 #define NO_PATH_RETRY_FAIL	-1
 #define NO_PATH_RETRY_QUEUE	-2
 
 
-enum free_path_switch {
+enum free_path_mode {
 	KEEP_PATHS,
 	FREE_PATHS
 };
@@ -39,7 +41,8 @@ enum rr_weight_mode {
 enum failback_mode {
 	FAILBACK_UNDEF,
 	FAILBACK_MANUAL,
-	FAILBACK_IMMEDIATE
+	FAILBACK_IMMEDIATE,
+	FAILBACK_FOLLOWOVER
 };
 
 enum sysfs_buses {
@@ -64,9 +67,9 @@ enum pgstates {
 };
 
 enum queue_without_daemon_states {
-	QUE_NO_DAEMON_UNDEF,
 	QUE_NO_DAEMON_OFF,
 	QUE_NO_DAEMON_ON,
+	QUE_NO_DAEMON_FORCE,
 };
 
 enum pgtimeouts {
@@ -87,10 +90,40 @@ enum flush_states {
 	FLUSH_IN_PROGRESS,
 };
 
-struct scsi_idlun {
-	int dev_id;
-	int host_unique_id;
-	int host_no;
+enum log_checker_err_states {
+	LOG_CHKR_ERR_ALWAYS,
+	LOG_CHKR_ERR_ONCE,
+};
+
+enum user_friendly_names_states {
+	USER_FRIENDLY_NAMES_UNDEF,
+	USER_FRIENDLY_NAMES_OFF,
+	USER_FRIENDLY_NAMES_ON,
+};
+
+enum retain_hwhandler_states {
+	RETAIN_HWHANDLER_UNDEF,
+	RETAIN_HWHANDLER_OFF,
+	RETAIN_HWHANDLER_ON,
+};
+
+enum detect_prio_states {
+	DETECT_PRIO_UNDEF,
+	DETECT_PRIO_OFF,
+	DETECT_PRIO_ON,
+};
+
+enum scsi_protocol {
+	SCSI_PROTOCOL_FCP = 0,	/* Fibre Channel */
+	SCSI_PROTOCOL_SPI = 1,	/* parallel SCSI */
+	SCSI_PROTOCOL_SSA = 2,	/* Serial Storage Architecture - Obsolete */
+	SCSI_PROTOCOL_SBP = 3,	/* firewire */
+	SCSI_PROTOCOL_SRP = 4,	/* Infiniband RDMA */
+	SCSI_PROTOCOL_ISCSI = 5,
+	SCSI_PROTOCOL_SAS = 6,
+	SCSI_PROTOCOL_ADT = 7,	/* Media Changers */
+	SCSI_PROTOCOL_ATA = 8,
+	SCSI_PROTOCOL_UNSPEC = 0xf, /* No specific protocol */
 };
 
 struct sg_id {
@@ -100,31 +133,27 @@ struct sg_id {
 	int lun;
 	short h_cmd_per_lun;
 	short d_queue_depth;
-	int unused1;
-	int unused2;
+	enum scsi_protocol proto_id;
+	int transport_id;
 };
 
-struct scsi_dev {
-	char dev[FILE_NAME_SIZE];
-	struct scsi_idlun scsi_id;
-	int host_no;
-};
+# ifndef HDIO_GETGEO
+#  define HDIO_GETGEO	0x0301	/* get device geometry */
 
-struct sysfs_device {
-	struct sysfs_device *parent;		/* parent device */
-	char devpath[PATH_SIZE];
-	char subsystem[NAME_SIZE];		/* $class, $bus, drivers, module */
-	char kernel[NAME_SIZE];			/* device instance name */
-	char kernel_number[NAME_SIZE];
-	char driver[NAME_SIZE];			/* device driver name */
+struct hd_geometry {
+      unsigned char heads;
+      unsigned char sectors;
+      unsigned short cylinders;
+      unsigned long start;
 };
+#endif
 
 struct path {
 	char dev[FILE_NAME_SIZE];
 	char dev_t[BLK_DEV_SIZE];
-	struct sysfs_device *sysdev;
-	struct scsi_idlun scsi_id;
+	struct udev_device *udev;
 	struct sg_id sg_id;
+	struct hd_geometry geom;
 	char wwid[WWID_SIZE];
 	char vendor_id[SCSI_VENDOR_SIZE];
 	char product_id[SCSI_PRODUCT_SIZE];
@@ -138,15 +167,18 @@ struct path {
 	int offline;
 	int state;
 	int dmstate;
+	int chkrstate;
 	int failcount;
 	int priority;
 	int pgindex;
-	char * getuid;
-	struct prio * prio;
+	int detect_prio;
+	char * uid_attribute;
+	struct prio prio;
+	char * prio_args;
 	struct checker checker;
 	struct multipath * mpp;
 	int fd;
-	
+
 	/* configlet pointers */
 	struct hwentry * hwe;
 };
@@ -173,6 +205,7 @@ struct multipath {
 	int flush_on_last_del;
 	int attribute_flags;
 	int fast_io_fail;
+	int retain_hwhandler;
 	unsigned int dev_loss;
 	uid_t uid;
 	gid_t gid;
@@ -180,12 +213,11 @@ struct multipath {
 	unsigned long long size;
 	vector paths;
 	vector pg;
-	char params[PARAMS_SIZE];
-	char status[PARAMS_SIZE];
 	struct dm_info * dmi;
 
 	/* configlet pointers */
 	char * alias;
+	char * alias_prefix;
 	char * selector;
 	char * features;
 	char * hwhandler;
@@ -193,7 +225,7 @@ struct multipath {
 	struct hwentry * hwe;
 
 	/* threads */
-	void * waiter;
+	pthread_t waiter;
 
 	/* stats */
 	unsigned int stat_switchgroup;
@@ -204,6 +236,10 @@ struct multipath {
 
 	/* checkers shared data */
 	void * mpcontext;
+	
+	/* persistent management data*/
+	unsigned char * reservation_key;
+	unsigned char prflag;
 };
 
 struct pathgroup {
@@ -219,13 +255,13 @@ struct path * alloc_path (void);
 struct pathgroup * alloc_pathgroup (void);
 struct multipath * alloc_multipath (void);
 void free_path (struct path *);
-void free_pathvec (vector vec, int free_paths);
-void free_pathgroup (struct pathgroup * pgp, int free_paths);
-void free_pgvec (vector pgvec, int free_paths);
-void free_multipath (struct multipath *, int free_paths);
+void free_pathvec (vector vec, enum free_path_mode free_paths);
+void free_pathgroup (struct pathgroup * pgp, enum free_path_mode free_paths);
+void free_pgvec (vector pgvec, enum free_path_mode free_paths);
+void free_multipath (struct multipath *, enum free_path_mode free_paths);
 void free_multipath_attributes (struct multipath *);
-void drop_multipath (vector mpvec, char * wwid, int free_paths);
-void free_multipathvec (vector mpvec, int free_paths);
+void drop_multipath (vector mpvec, char * wwid, enum free_path_mode free_paths);
+void free_multipathvec (vector mpvec, enum free_path_mode free_paths);
 
 int store_path (vector pathvec, struct path * pp);
 int store_pathgroup (vector pgvec, struct pathgroup * pgp);
@@ -241,7 +277,10 @@ struct path * first_path (struct multipath * mpp);
 
 int pathcountgr (struct pathgroup *, int);
 int pathcount (struct multipath *, int);
+int pathcmp (struct pathgroup *, struct pathgroup *);
 void setup_feature(struct multipath *, char *);
+int add_feature (char **, char *);
+int remove_feature (char **, char *);
 
 extern char sysfs_path[PATH_SIZE];
 
diff --git a/libmultipath/structs_vec.c b/libmultipath/structs_vec.c
index 699efa1..72622b0 100644
--- a/libmultipath/structs_vec.c
+++ b/libmultipath/structs_vec.c
@@ -13,7 +13,6 @@
 #include "dmparser.h"
 #include "config.h"
 #include "propsel.h"
-#include "sysfs.h"
 #include "discovery.h"
 #include "prio.h"
 
@@ -46,7 +45,7 @@ update_mpp_paths(struct multipath * mpp, vector pathvec)
 }
 
 extern int
-adopt_paths (vector pathvec, struct multipath * mpp)
+adopt_paths (vector pathvec, struct multipath * mpp, int get_info)
 {
 	int i;
 	struct path * pp;
@@ -69,7 +68,9 @@ adopt_paths (vector pathvec, struct multipath * mpp)
 			if (!find_path_by_dev(mpp->paths, pp->dev) &&
 			    store_path(mpp->paths, pp))
 					return 1;
-			pathinfo(pp, conf->hwtable, DI_PRIO | DI_CHECKER);
+			if (get_info && pathinfo(pp, conf->hwtable,
+						 DI_PRIO | DI_CHECKER))
+				return 1;
 		}
 	}
 	return 0;
@@ -80,8 +81,8 @@ orphan_path (struct path * pp)
 {
 	pp->mpp = NULL;
 	pp->dmstate = PSTATE_UNDEF;
-	pp->getuid = NULL;
-	pp->prio = NULL;
+	pp->uid_attribute = NULL;
+	prio_put(&pp->prio);
 	checker_put(&pp->checker);
 	if (pp->fd >= 0)
 		close(pp->fd);
@@ -105,7 +106,7 @@ orphan_paths (vector pathvec, struct multipath * mpp)
 static void
 set_multipath_wwid (struct multipath * mpp)
 {
-	if (mpp->wwid)
+	if (strlen(mpp->wwid))
 		return;
 
 	dm_get_uuid(mpp->alias, mpp->wwid);
@@ -240,14 +241,20 @@ extract_hwe_from_path(struct multipath * mpp)
 static int
 update_multipath_table (struct multipath *mpp, vector pathvec)
 {
+	char params[PARAMS_SIZE] = {0};
+
 	if (!mpp)
 		return 1;
 
-	if (dm_get_map(mpp->alias, &mpp->size, mpp->params))
+	if (dm_get_map(mpp->alias, &mpp->size, params)) {
+		condlog(3, "%s: cannot get map", mpp->alias);
 		return 1;
+	}
 
-	if (disassemble_map(pathvec, mpp->params, mpp))
+	if (disassemble_map(pathvec, params, mpp)) {
+		condlog(3, "%s: cannot disassemble map", mpp->alias);
 		return 1;
+	}
 
 	return 0;
 }
@@ -255,14 +262,20 @@ update_multipath_table (struct multipath *mpp, vector pathvec)
 static int
 update_multipath_status (struct multipath *mpp)
 {
+	char status[PARAMS_SIZE] = {0};
+
 	if (!mpp)
 		return 1;
 
-	if(dm_get_status(mpp->alias, mpp->status))
+	if (dm_get_status(mpp->alias, status)) {
+		condlog(3, "%s: cannot get status", mpp->alias);
 		return 1;
+	}
 
-	if (disassemble_status(mpp->status, mpp))
+	if (disassemble_status(status, mpp)) {
+		condlog(3, "%s: cannot disassemble status", mpp->alias);
 		return 1;
+	}
 
 	return 0;
 }
@@ -270,6 +283,9 @@ update_multipath_status (struct multipath *mpp)
 extern int
 update_multipath_strings (struct multipath *mpp, vector pathvec)
 {
+	if (!mpp)
+		return 1;
+
 	condlog(4, "%s: %s", mpp->alias, __FUNCTION__);
 
 	free_multipath_attributes(mpp);
@@ -290,8 +306,7 @@ set_no_path_retry(struct multipath *mpp)
 {
 	mpp->retry_tick = 0;
 	mpp->nr_active = pathcount(mpp, PATH_UP) + pathcount(mpp, PATH_GHOST);
-	if (mpp->nr_active > 0)
-		select_no_path_retry(mpp);
+	select_no_path_retry(mpp);
 
 	switch (mpp->no_path_retry) {
 	case NO_PATH_RETRY_UNDEF:
@@ -315,9 +330,8 @@ set_no_path_retry(struct multipath *mpp)
 }
 
 extern int
-setup_multipath (struct vectors * vecs, struct multipath * mpp)
+__setup_multipath (struct vectors * vecs, struct multipath * mpp, int reset)
 {
-retry:
 	if (dm_get_info(mpp->alias, &mpp->dmi)) {
 		/* Error accessing table */
 		condlog(3, "%s: cannot access table", mpp->alias);
@@ -335,38 +349,23 @@ retry:
 	condlog(3, "%s: discover", mpp->alias);
 
 	if (update_multipath_strings(mpp, vecs->pathvec)) {
-		char new_alias[WWID_SIZE];
-
-		/*
-		 * detect an external rename of the multipath device
-		 */
-		if (dm_get_name(mpp->wwid, new_alias)) {
-			condlog(3, "%s multipath mapped device name has "
-				"changed from %s to %s", mpp->wwid,
-				mpp->alias, new_alias);
-			strcpy(mpp->alias, new_alias);
-
-			if (mpp->waiter)
-				strncpy(((struct event_thread *)mpp->waiter)->mapname,
-					new_alias, WWID_SIZE);
-			goto retry;
-		}
 		condlog(0, "%s: failed to setup multipath", mpp->alias);
 		goto out;
 	}
 
-	//adopt_paths(vecs->pathvec, mpp);
 	if (!mpp->hwe)
 		mpp->hwe = extract_hwe_from_path(mpp);
 	if (!mpp->hwe) {
 		condlog(3, "%s: no hardware entry found, using defaults",
 			mpp->alias);
 	}
-	select_rr_weight(mpp);
-	select_pgfailback(mpp);
-	set_no_path_retry(mpp);
-	select_pg_timeout(mpp);
-	select_flush_on_last_del(mpp);
+	if (reset) {
+		select_rr_weight(mpp);
+		select_pgfailback(mpp);
+		set_no_path_retry(mpp);
+		select_pg_timeout(mpp);
+		select_flush_on_last_del(mpp);
+	}
 
 	return 0;
 out:
@@ -375,22 +374,19 @@ out:
 }
 
 extern struct multipath *
-add_map_without_path (struct vectors * vecs,
-		      int minor, char * alias)
+add_map_without_path (struct vectors * vecs, char * alias)
 {
 	struct multipath * mpp = alloc_multipath();
 
-	if (!mpp)
+	if (!mpp || !alias)
 		return NULL;
 
-	mpp->alias = alias;
+	mpp->alias = STRDUP(alias);
 
-	if (setup_multipath(vecs, mpp)) {
-		mpp->alias = NULL;
+	if (setup_multipath(vecs, mpp))
 		return NULL; /* mpp freed in setup_multipath */
-	}
 
-	if (adopt_paths(vecs->pathvec, mpp))
+	if (adopt_paths(vecs->pathvec, mpp, 1))
 		goto out;
 
 	if (!vector_alloc_slot(vecs->mpvec))
@@ -420,10 +416,11 @@ add_map_with_path (struct vectors * vecs,
 	mpp->hwe = pp->hwe;
 
 	strcpy(mpp->wwid, pp->wwid);
-	select_alias(mpp);
+	if (select_alias(mpp))
+		goto out;
 	mpp->size = pp->size;
 
-	if (adopt_paths(vecs->pathvec, mpp))
+	if (adopt_paths(vecs->pathvec, mpp, 1))
 		goto out;
 
 	if (add_vec) {
@@ -454,10 +451,15 @@ verify_paths(struct multipath * mpp, struct vectors * vecs, vector rpvec)
 		/*
 		 * see if path is in sysfs
 		 */
-		if (!pp->sysdev || sysfs_get_dev(pp->sysdev,
-						 pp->dev_t, BLK_DEV_SIZE)) {
-			condlog(0, "%s: failed to access path %s", mpp->alias,
-				pp->sysdev ? pp->sysdev->devpath : pp->dev_t);
+		if (!pp->udev || sysfs_get_dev(pp->udev, pp->dev_t,
+					       BLK_DEV_SIZE)) {
+			if (pp->state != PATH_DOWN) {
+				condlog(1, "%s: removing valid path %s in state %d",
+					mpp->alias, pp->dev, pp->state);
+			} else {
+				condlog(3, "%s: failed to access path %s",
+					mpp->alias, pp->dev);
+			}
 			count++;
 			vector_del_slot(mpp->paths, i);
 			i--;
@@ -478,7 +480,7 @@ verify_paths(struct multipath * mpp, struct vectors * vecs, vector rpvec)
 	return count;
 }
 
-int update_multipath (struct vectors *vecs, char *mapname)
+int update_multipath (struct vectors *vecs, char *mapname, int reset)
 {
 	struct multipath *mpp;
 	struct pathgroup  *pgp;
@@ -488,16 +490,17 @@ int update_multipath (struct vectors *vecs, char *mapname)
 	mpp = find_mp_by_alias(vecs->mpvec, mapname);
 
 	if (!mpp) {
-		condlog(3, "%s: multipath map not found\n", mapname);
+		condlog(3, "%s: multipath map not found", mapname);
 		return 2;
 	}
 
 	free_pgvec(mpp->pg, KEEP_PATHS);
 	mpp->pg = NULL;
 
-	if (setup_multipath(vecs, mpp))
+	if (__setup_multipath(vecs, mpp, reset))
 		return 1; /* mpp freed in setup_multipath */
 
+	adopt_paths(vecs->pathvec, mpp, 0);
 	/*
 	 * compare checkers states with DM states
 	 */
diff --git a/libmultipath/structs_vec.h b/libmultipath/structs_vec.h
index 78e468a..a907e85 100644
--- a/libmultipath/structs_vec.h
+++ b/libmultipath/structs_vec.h
@@ -15,13 +15,15 @@ struct vectors {
 
 void set_no_path_retry(struct multipath *mpp);
 
-int adopt_paths (vector pathvec, struct multipath * mpp);
+int adopt_paths (vector pathvec, struct multipath * mpp, int get_info);
 void orphan_paths (vector pathvec, struct multipath * mpp);
 void orphan_path (struct path * pp);
 
 int verify_paths(struct multipath * mpp, struct vectors * vecs, vector rpvec);
 int update_mpp_paths(struct multipath * mpp, vector pathvec);
-int setup_multipath (struct vectors * vecs, struct multipath * mpp);
+int __setup_multipath (struct vectors * vecs, struct multipath * mpp,
+		       int reset);
+#define setup_multipath(vecs, mpp) __setup_multipath(vecs, mpp, 1)
 int update_multipath_strings (struct multipath *mpp, vector pathvec);
 	
 void remove_map (struct multipath * mpp, struct vectors * vecs, int purge_vec);
@@ -29,11 +31,10 @@ void remove_map_and_stop_waiter (struct multipath * mpp, struct vectors * vecs,
 void remove_maps (struct vectors * vecs);
 void remove_maps_and_stop_waiters (struct vectors * vecs);
 
-struct multipath * add_map_without_path (struct vectors * vecs,
-				int minor, char * alias);
+struct multipath * add_map_without_path (struct vectors * vecs, char * alias);
 struct multipath * add_map_with_path (struct vectors * vecs,
 				struct path * pp, int add_vec);
-int update_multipath (struct vectors *vecs, char *mapname);
+int update_multipath (struct vectors *vecs, char *mapname, int reset);
 void update_queue_mode_del_path(struct multipath *mpp);
 void update_queue_mode_add_path(struct multipath *mpp);
 
diff --git a/libmultipath/switchgroup.c b/libmultipath/switchgroup.c
index d995cd3..031c3d7 100644
--- a/libmultipath/switchgroup.c
+++ b/libmultipath/switchgroup.c
@@ -20,19 +20,23 @@ path_group_prio_update (struct pathgroup * pgp)
 		return;
 	}
 	vector_foreach_slot (pgp->paths, pp, i) {
-		if (pp->state != PATH_DOWN) {
+		if (pp->state == PATH_UP ||
+		    pp->state == PATH_GHOST) {
 			priority += pp->priority;
 			pgp->enabled_paths++;
 		}
 	}
-	pgp->priority = priority;
+	if (pgp->enabled_paths)
+		pgp->priority = priority / pgp->enabled_paths;
+	else
+		pgp->priority = 0;
 }
 
 extern int
 select_path_group (struct multipath * mpp)
 {
 	int i;
-	int max_priority = 0, avg_priority;
+	int max_priority = 0;
 	int bestpg = 1;
 	int max_enabled_paths = 1;
 	struct pathgroup * pgp;
@@ -46,12 +50,11 @@ select_path_group (struct multipath * mpp)
 
 		path_group_prio_update(pgp);
 		if (pgp->enabled_paths) {
-			avg_priority = pgp->priority / pgp->enabled_paths;
-			if (avg_priority > max_priority) {
-				max_priority = avg_priority;
+			if (pgp->priority > max_priority) {
+				max_priority = pgp->priority;
 				max_enabled_paths = pgp->enabled_paths;
 				bestpg = i + 1;
-			} else if (avg_priority == max_priority) {
+			} else if (pgp->priority == max_priority) {
 				if (pgp->enabled_paths > max_enabled_paths) {
 					max_enabled_paths = pgp->enabled_paths;
 					bestpg = i + 1;
diff --git a/libmultipath/sysfs.c b/libmultipath/sysfs.c
index efbe7c1..d33747f 100644
--- a/libmultipath/sysfs.c
+++ b/libmultipath/sysfs.c
@@ -26,6 +26,8 @@
 #include <errno.h>
 #include <sys/stat.h>
 #include <string.h>
+#include <dirent.h>
+#include <libudev.h>
 
 #include "checkers.h"
 #include "vector.h"
@@ -34,578 +36,132 @@
 #include "list.h"
 #include "util.h"
 #include "debug.h"
+#include "devmapper.h"
 
-char sysfs_path[PATH_SIZE];
-
-/* attribute value cache */
-static LIST_HEAD(attr_list);
-struct sysfs_attr {
-	struct list_head node;
-	char path[PATH_SIZE];
-	char *value;			/* points to value_local if value is cached */
-	char value_local[NAME_SIZE];
-};
-
-/* list of sysfs devices */
-static LIST_HEAD(sysfs_dev_list);
-struct sysfs_dev {
-	struct list_head node;
-	struct sysfs_device dev;
-};
-
-int sysfs_init(char *path, size_t len)
-{
-	if (path) {
-		strlcpy(sysfs_path, path, len);
-		remove_trailing_chars(sysfs_path, '/');
-	} else
-		strlcpy(sysfs_path, "/sys", sizeof(sysfs_path));
-	dbg("sysfs_path='%s'", sysfs_path);
-
-	INIT_LIST_HEAD(&attr_list);
-	INIT_LIST_HEAD(&sysfs_dev_list);
-	return 0;
-}
-
-void sysfs_cleanup(void)
-{
-	struct sysfs_attr *attr_loop;
-	struct sysfs_attr *attr_temp;
-
-	struct sysfs_dev *sysdev_loop;
-	struct sysfs_dev *sysdev_temp;
-
-	list_for_each_entry_safe(attr_loop, attr_temp, &attr_list, node) {
-		list_del(&attr_loop->node);
-		free(attr_loop);
-	}
-
-	list_for_each_entry_safe(sysdev_loop, sysdev_temp, &sysfs_dev_list, node) {
-		list_del(&sysdev_loop->node);
-		free(sysdev_loop);
-	}
-}
-
-void sysfs_device_set_values(struct sysfs_device *dev, const char *devpath,
-			     const char *subsystem, const char *driver)
-{
-	char *pos;
-
-	strlcpy(dev->devpath, devpath, sizeof(dev->devpath));
-	if (subsystem != NULL)
-		strlcpy(dev->subsystem, subsystem, sizeof(dev->subsystem));
-	if (driver != NULL)
-		strlcpy(dev->driver, driver, sizeof(dev->driver));
-
-	/* set kernel name */
-	pos = strrchr(dev->devpath, '/');
-	if (pos == NULL)
-		return;
-	strlcpy(dev->kernel, &pos[1], sizeof(dev->kernel));
-	dbg("kernel='%s'", dev->kernel);
-
-	/* some devices have '!' in their name, change that to '/' */
-	pos = dev->kernel;
-	while (pos[0] != '\0') {
-		if (pos[0] == '!')
-			pos[0] = '/';
-		pos++;
-	}
-
-	/* get kernel number */
-	pos = &dev->kernel[strlen(dev->kernel)];
-	while (isdigit(pos[-1]))
-		pos--;
-	strlcpy(dev->kernel_number, pos, sizeof(dev->kernel_number));
-	dbg("kernel_number='%s'", dev->kernel_number);
-}
-
-int sysfs_resolve_link(char *devpath, size_t size)
-{
-	char link_path[PATH_SIZE];
-	char link_target[PATH_SIZE];
-	int len;
-	int i;
-	int back;
-
-	strlcpy(link_path, sysfs_path, sizeof(link_path));
-	strlcat(link_path, devpath, sizeof(link_path));
-	len = readlink(link_path, link_target, sizeof(link_target));
-	if (len <= 0)
-		return -1;
-	link_target[len] = '\0';
-	dbg("path link '%s' points to '%s'", devpath, link_target);
-
-	for (back = 0; strncmp(&link_target[back * 3], "../", 3) == 0; back++)
-		;
-	dbg("base '%s', tail '%s', back %i", devpath, &link_target[back * 3], back);
-	for (i = 0; i <= back; i++) {
-		char *pos = strrchr(devpath, '/');
-
-		if (pos == NULL)
-			return -1;
-		pos[0] = '\0';
-	}
-	dbg("after moving back '%s'", devpath);
-	strlcat(devpath, "/", size);
-	strlcat(devpath, &link_target[back * 3], size);
-	return 0;
-}
-
-struct sysfs_device *sysfs_device_get(const char *devpath)
+ssize_t sysfs_attr_set_value(struct udev_device *dev, const char *attr_name,
+			     char * value, size_t value_len)
 {
-	char path[PATH_SIZE];
-	char devpath_real[PATH_SIZE];
-	struct sysfs_device *dev = NULL;
-	struct sysfs_dev *sysdev_loop, *sysdev;
+	char devpath[PATH_SIZE];
 	struct stat statbuf;
-	char link_path[PATH_SIZE];
-	char link_target[PATH_SIZE];
-	int len;
-	char *pos;
-
-	/* we handle only these devpathes */
-	if (devpath != NULL &&
-	    strncmp(devpath, "/devices/", 9) != 0 &&
-	    strncmp(devpath, "/subsystem/", 11) != 0 &&
-	    strncmp(devpath, "/module/", 8) != 0 &&
-	    strncmp(devpath, "/bus/", 5) != 0 &&
-	    strncmp(devpath, "/class/", 7) != 0 &&
-	    strncmp(devpath, "/block/", 7) != 0) {
-		dbg("invalid devpath '%s'", devpath);
-		return NULL;
-	}
-
-	dbg("open '%s'", devpath);
-	strlcpy(devpath_real, devpath, sizeof(devpath_real));
-	remove_trailing_chars(devpath_real, '/');
-	if (devpath[0] == '\0' )
-		return NULL;
-
-	/* if we got a link, resolve it to the real device */
-	strlcpy(path, sysfs_path, sizeof(path));
-	strlcat(path, devpath_real, sizeof(path));
-	if (lstat(path, &statbuf) != 0) {
-		/* if stat fails look in the cache */
-		dbg("stat '%s' failed: %s", path, strerror(errno));
-		list_for_each_entry(sysdev_loop, &sysfs_dev_list, node) {
-			if (strcmp(sysdev_loop->dev.devpath, devpath_real) == 0) {
-				dbg("found vanished dev in cache '%s'",
-				    sysdev_loop->dev.devpath);
-				return &sysdev_loop->dev;
-			}
-		}
-		return NULL;
-	}
-
-	if (S_ISLNK(statbuf.st_mode)) {
-		if (sysfs_resolve_link(devpath_real, sizeof(devpath_real)) != 0)
-			return NULL;
-	}
-
-	list_for_each_entry(sysdev_loop, &sysfs_dev_list, node) {
-		if (strcmp(sysdev_loop->dev.devpath, devpath_real) == 0) {
-			dbg("found dev in cache '%s'", sysdev_loop->dev.devpath);
-			dev = &sysdev_loop->dev;
-		}
-	}
-
-	if(!dev) {
-		/* it is a new device */
-		dbg("new device '%s'", devpath_real);
-		sysdev = malloc(sizeof(struct sysfs_dev));
-		if (sysdev == NULL)
-			return NULL;
-		memset(sysdev, 0x00, sizeof(struct sysfs_dev));
-		list_add(&sysdev->node, &sysfs_dev_list);
-		dev = &sysdev->dev;
-	}
-
-	sysfs_device_set_values(dev, devpath_real, NULL, NULL);
-
-	/* get subsystem name */
-	strlcpy(link_path, sysfs_path, sizeof(link_path));
-	strlcat(link_path, dev->devpath, sizeof(link_path));
-	strlcat(link_path, "/subsystem", sizeof(link_path));
-	len = readlink(link_path, link_target, sizeof(link_target));
-	if (len > 0) {
-		/* get subsystem from "subsystem" link */
-		link_target[len] = '\0';
-		dbg("subsystem link '%s' points to '%s'", link_path, link_target);
-		pos = strrchr(link_target, '/');
-		if (pos != NULL)
-			strlcpy(dev->subsystem, &pos[1], sizeof(dev->subsystem));
-	} else if (strstr(dev->devpath, "/drivers/") != NULL) {
-		strlcpy(dev->subsystem, "drivers", sizeof(dev->subsystem));
-	} else if (strncmp(dev->devpath, "/module/", 8) == 0) {
-		strlcpy(dev->subsystem, "module", sizeof(dev->subsystem));
-	} else if (strncmp(dev->devpath, "/subsystem/", 11) == 0) {
-		pos = strrchr(dev->devpath, '/');
-		if (pos == &dev->devpath[10])
-			strlcpy(dev->subsystem, "subsystem",
-				sizeof(dev->subsystem));
-	} else if (strncmp(dev->devpath, "/class/", 7) == 0) {
-		pos = strrchr(dev->devpath, '/');
-		if (pos == &dev->devpath[6])
-			strlcpy(dev->subsystem, "subsystem",
-				sizeof(dev->subsystem));
-	} else if (strncmp(dev->devpath, "/bus/", 5) == 0) {
-		pos = strrchr(dev->devpath, '/');
-		if (pos == &dev->devpath[4])
-			strlcpy(dev->subsystem, "subsystem",
-				sizeof(dev->subsystem));
-	}
-
-	/* get driver name */
-	strlcpy(link_path, sysfs_path, sizeof(link_path));
-	strlcat(link_path, dev->devpath, sizeof(link_path));
-	strlcat(link_path, "/driver", sizeof(link_path));
-	len = readlink(link_path, link_target, sizeof(link_target));
-	if (len > 0) {
-		link_target[len] = '\0';
-		dbg("driver link '%s' points to '%s'", link_path, link_target);
-		pos = strrchr(link_target, '/');
-		if (pos != NULL)
-			strlcpy(dev->driver, &pos[1], sizeof(dev->driver));
-	}
-
-	return dev;
-}
-
-struct sysfs_device *sysfs_device_get_parent(struct sysfs_device *dev)
-{
-	char parent_devpath[PATH_SIZE];
-	char *pos;
-
-	dbg("open '%s'", dev->devpath);
-
-	/* look if we already know the parent */
-	if (dev->parent != NULL)
-		return dev->parent;
-
-	strlcpy(parent_devpath, dev->devpath, sizeof(parent_devpath));
-	dbg("'%s'", parent_devpath);
-
-	/* strip last element */
-	pos = strrchr(parent_devpath, '/');
-	if (pos == NULL || pos == parent_devpath)
-		return NULL;
-	pos[0] = '\0';
-
-	if (strncmp(parent_devpath, "/class", 6) == 0) {
-		pos = strrchr(parent_devpath, '/');
-		if (pos == &parent_devpath[6] || pos == parent_devpath) {
-			dbg("/class top level, look for device link");
-			goto device_link;
-		}
-	}
-	if (strcmp(parent_devpath, "/block") == 0) {
-		dbg("/block top level, look for device link");
-		goto device_link;
-	}
-
-	/* are we at the top level? */
-	pos = strrchr(parent_devpath, '/');
-	if (pos == NULL || pos == parent_devpath)
-		return NULL;
-
-	/* get parent and remember it */
-	dev->parent = sysfs_device_get(parent_devpath);
-	return dev->parent;
-
-device_link:
-	strlcpy(parent_devpath, dev->devpath, sizeof(parent_devpath));
-	strlcat(parent_devpath, "/device", sizeof(parent_devpath));
-	if (sysfs_resolve_link(parent_devpath, sizeof(parent_devpath)) != 0)
-		return NULL;
-
-	/* get parent and remember it */
-	dev->parent = sysfs_device_get(parent_devpath);
-	return dev->parent;
-}
-
-struct sysfs_device *sysfs_device_get_parent_with_subsystem(struct sysfs_device *dev, const char *subsystem)
-{
-	struct sysfs_device *dev_parent;
-
-	dev_parent = sysfs_device_get_parent(dev);
-	while (dev_parent != NULL) {
-		if (strcmp(dev_parent->subsystem, subsystem) == 0)
-			return dev_parent;
-		dev_parent = sysfs_device_get_parent(dev_parent);
-	}
-	return NULL;
-}
-
-void sysfs_device_put(struct sysfs_device *dev)
-{
-	struct sysfs_dev *sysdev_loop;
-
-	list_for_each_entry(sysdev_loop, &sysfs_dev_list, node) {
-		if (&sysdev_loop->dev == dev) {
-			dbg("removed dev '%s' from cache",
-			    sysdev_loop->dev.devpath);
-			list_del(&sysdev_loop->node);
-			free(sysdev_loop);
-			return;
-		}
-	}
-	dbg("dev '%s' not found in cache",
-	    sysdev_loop->dev.devpath);
-
-	return;
-}
-
-int
-sysfs_attr_set_value(const char *devpath, const char *attr_name,
-		     const char *value)
-{
-	char path_full[PATH_SIZE];
-	int sysfs_len;
-	struct stat statbuf;
-	int fd, value_len, ret = -1;
+	int fd;
+	ssize_t size = -1;
 
-	dbg("open '%s'/'%s'", devpath, attr_name);
-	sysfs_len = snprintf(path_full, PATH_SIZE, "%s%s/%s", sysfs_path,
-			     devpath, attr_name);
-	if (sysfs_len >= PATH_SIZE || sysfs_len < 0) {
-		if (sysfs_len < 0)
-			dbg("cannot copy sysfs path %s%s/%s : %s", sysfs_path,
-			    devpath, attr_name, strerror(errno));
-		else
-			dbg("sysfs_path %s%s/%s too large", sysfs_path,
-			    devpath, attr_name);
-		goto out;
-	}
+	if (!dev || !attr_name || !value)
+		return 0;
 
-	if (stat(path_full, &statbuf) != 0) {
-		dbg("stat '%s' failed: %s" path_full, strerror(errno));
-		goto out;
+	snprintf(devpath, PATH_SIZE, "%s/%s", udev_device_get_syspath(dev),
+		 attr_name);
+	condlog(4, "open '%s'", devpath);
+	if (stat(devpath, &statbuf) != 0) {
+		condlog(4, "stat '%s' failed: %s", devpath, strerror(errno));
+		return 0;
 	}
 
 	/* skip directories */
-        if (S_ISDIR(statbuf.st_mode))
-                goto out;
+	if (S_ISDIR(statbuf.st_mode))
+		return 0;
 
+	/* skip non-writeable files */
 	if ((statbuf.st_mode & S_IWUSR) == 0)
-		goto out;
+		return 0;
 
-	fd = open(path_full, O_WRONLY);
+	/* write attribute value */
+	fd = open(devpath, O_WRONLY);
 	if (fd < 0) {
-		dbg("attribute '%s' can not be opened: %s",
-		    path_full, strerror(errno));
-		goto out;
+		condlog(4, "attribute '%s' can not be opened: %s",
+			devpath, strerror(errno));
+		return 0;
 	}
-	value_len = strlen(value) + 1;
-	ret = write(fd, value, value_len);
-	if (ret == value_len)
-		ret = 0;
-	else if (ret < 0)
-		dbg("write to %s failed: %s", path_full, strerror(errno));
-	else {
-		dbg("tried to write %d to %s. Wrote %d\n", value_len,
-		    path_full, ret);
-		ret = -1;
+	size = write(fd, value, value_len);
+	if (size < 0) {
+		condlog(4, "write to %s failed: %s", devpath, strerror(errno));
+		size = 0;
+	} else if (size < value_len) {
+		condlog(4, "tried to write %ld to %s. Wrote %ld",
+			(long)value_len, devpath, (long)size);
+		size = 0;
 	}
+
 	close(fd);
-out:
-	return ret;
+	return size;
 }
 
-
-char *sysfs_attr_get_value(const char *devpath, const char *attr_name)
+int
+sysfs_get_size (struct path *pp, unsigned long long * size)
 {
-	char path_full[PATH_SIZE];
-	const char *path;
-	char value[NAME_SIZE];
-	struct sysfs_attr *attr_loop;
-	struct sysfs_attr *attr = NULL;
-	struct stat statbuf;
-	int fd;
-	ssize_t size;
-	size_t sysfs_len;
+	const char * attr;
+	int r;
 
-	dbg("open '%s'/'%s'", devpath, attr_name);
-	sysfs_len = strlcpy(path_full, sysfs_path, sizeof(path_full));
-	if(sysfs_len >= sizeof(path_full))
-		sysfs_len = sizeof(path_full) - 1;
-	path = &path_full[sysfs_len];
-	strlcat(path_full, devpath, sizeof(path_full));
-	strlcat(path_full, "/", sizeof(path_full));
-	strlcat(path_full, attr_name, sizeof(path_full));
+	if (!pp->udev)
+		return 1;
 
-	/* look for attribute in cache */
-	list_for_each_entry(attr_loop, &attr_list, node) {
-		if (strcmp(attr_loop->path, path) == 0) {
-			dbg("found in cache '%s'", attr_loop->path);
-			attr = attr_loop;
-		}
-	}
+	attr = udev_device_get_sysattr_value(pp->udev, "size");
 	if (!attr) {
-		/* store attribute in cache */
-		dbg("new uncached attribute '%s'", path_full);
-		attr = malloc(sizeof(struct sysfs_attr));
-		if (attr == NULL)
-			return NULL;
-		memset(attr, 0x00, sizeof(struct sysfs_attr));
-		strlcpy(attr->path, path, sizeof(attr->path));
-		dbg("add to cache '%s'", path_full);
-		list_add(&attr->node, &attr_list);
-	} else {
-		/* clear old value */
-		if(attr->value)
-			memset(attr->value, 0x00, sizeof(attr->value));
-	}
-
-	if (lstat(path_full, &statbuf) != 0) {
-		dbg("stat '%s' failed: %s", path_full, strerror(errno));
-		goto out;
+		condlog(3, "%s: No size attribute in sysfs", pp->dev);
+		return 1;
 	}
 
-	if (S_ISLNK(statbuf.st_mode)) {
-		/* links return the last element of the target path */
-		char link_target[PATH_SIZE];
-		int len;
-		const char *pos;
-
-		len = readlink(path_full, link_target, sizeof(link_target));
-		if (len > 0) {
-			link_target[len] = '\0';
-			pos = strrchr(link_target, '/');
-			if (pos != NULL) {
-				dbg("cache '%s' with link value '%s'",
-				    path_full, value);
-				strlcpy(attr->value_local, &pos[1],
-					sizeof(attr->value_local));
-				attr->value = attr->value_local;
-			}
-		}
-		goto out;
-	}
-
-	/* skip directories */
-	if (S_ISDIR(statbuf.st_mode))
-		goto out;
-
-	/* skip non-readable files */
-	if ((statbuf.st_mode & S_IRUSR) == 0)
-		goto out;
+	r = sscanf(attr, "%llu\n", size);
 
-	/* read attribute value */
-	fd = open(path_full, O_RDONLY);
-	if (fd < 0) {
-		dbg("attribute '%s' can not be opened: %s",
-		    path_full, strerror(errno));
-		goto out;
-	}
-	size = read(fd, value, sizeof(value));
-	close(fd);
-	if (size < 0)
-		goto out;
-	if (size == sizeof(value)) {
-		dbg("overflow in attribute '%s', truncating", path_full);
-		size--;
+	if (r != 1) {
+		condlog(3, "%s: Cannot parse size attribute '%s'",
+			pp->dev, attr);
+		return 1;
 	}
 
-	/* got a valid value, store and return it */
-	value[size] = '\0';
-	remove_trailing_chars(value, '\n');
-	dbg("cache '%s' with attribute value '%s'", path_full, value);
-	strlcpy(attr->value_local, value, sizeof(attr->value_local));
-	attr->value = attr->value_local;
-
-out:
-	return attr && attr->value && strlen(attr->value) ? attr->value : NULL;
+	return 0;
 }
 
-int sysfs_lookup_devpath_by_subsys_id(char *devpath_full, size_t len,
-				      const char *subsystem, const char *id)
+int sysfs_check_holders(char * check_devt, char * new_devt)
 {
-	size_t sysfs_len;
-	char path_full[PATH_SIZE];
-	char *path;
-	struct stat statbuf;
+	unsigned int major, new_minor, table_minor;
+	char path[PATH_SIZE], check_dev[PATH_SIZE];
+	char * table_name;
+	DIR *dirfd;
+	struct dirent *holder;
 
-	sysfs_len = strlcpy(path_full, sysfs_path, sizeof(path_full));
-	path = &path_full[sysfs_len];
-
-	if (strcmp(subsystem, "subsystem") == 0) {
-		strlcpy(path, "/subsystem/", sizeof(path_full) - sysfs_len);
-		strlcat(path, id, sizeof(path_full) - sysfs_len);
-		if (stat(path_full, &statbuf) == 0)
-			goto found;
-
-		strlcpy(path, "/bus/", sizeof(path_full) - sysfs_len);
-		strlcat(path, id, sizeof(path_full) - sysfs_len);
-		if (stat(path_full, &statbuf) == 0)
-			goto found;
-		goto out;
-
-		strlcpy(path, "/class/", sizeof(path_full) - sysfs_len);
-		strlcat(path, id, sizeof(path_full) - sysfs_len);
-		if (stat(path_full, &statbuf) == 0)
-			goto found;
+	if (sscanf(new_devt,"%d:%d", &major, &new_minor) != 2) {
+		condlog(1, "invalid device number %s", new_devt);
+		return 0;
 	}
 
-	if (strcmp(subsystem, "module") == 0) {
-		strlcpy(path, "/module/", sizeof(path_full) - sysfs_len);
-		strlcat(path, id, sizeof(path_full) - sysfs_len);
-		if (stat(path_full, &statbuf) == 0)
-			goto found;
-		goto out;
+	if (devt2devname(check_dev, PATH_SIZE, check_devt)) {
+		condlog(1, "can't get devname for %s", check_devt);
+		return 0;
 	}
 
-	if (strcmp(subsystem, "drivers") == 0) {
-		char subsys[NAME_SIZE];
-		char *driver;
+	condlog(3, "%s: checking holder", check_dev);
 
-		strlcpy(subsys, id, sizeof(subsys));
-		driver = strchr(subsys, ':');
-		if (driver != NULL) {
-			driver[0] = '\0';
-			driver = &driver[1];
-			strlcpy(path, "/subsystem/", sizeof(path_full) - sysfs_len);
-			strlcat(path, subsys, sizeof(path_full) - sysfs_len);
-			strlcat(path, "/drivers/", sizeof(path_full) - sysfs_len);
-			strlcat(path, driver, sizeof(path_full) - sysfs_len);
-			if (stat(path_full, &statbuf) == 0)
-				goto found;
+	snprintf(path, PATH_SIZE, "/sys/block/%s/holders", check_dev);
+	dirfd = opendir(path);
+	if (dirfd == NULL) {
+		condlog(3, "%s: failed to open directory %s (%d)",
+			check_dev, path, errno);
+		return 0;
+	}
+	while ((holder = readdir(dirfd)) != NULL) {
+		if ((strcmp(holder->d_name,".") == 0) ||
+		    (strcmp(holder->d_name,"..") == 0))
+			continue;
 
-			strlcpy(path, "/bus/", sizeof(path_full) - sysfs_len);
-			strlcat(path, subsys, sizeof(path_full) - sysfs_len);
-			strlcat(path, "/drivers/", sizeof(path_full) - sysfs_len);
-			strlcat(path, driver, sizeof(path_full) - sysfs_len);
-			if (stat(path_full, &statbuf) == 0)
-				goto found;
+		if (sscanf(holder->d_name, "dm-%d", &table_minor) != 1) {
+			condlog(3, "%s: %s is not a dm-device",
+				check_dev, holder->d_name);
+			continue;
 		}
-		goto out;
-	}
+		if (table_minor == new_minor) {
+			condlog(3, "%s: holder already correct", check_dev);
+			continue;
+		}
+		table_name = dm_mapname(major, table_minor);
 
-	strlcpy(path, "/subsystem/", sizeof(path_full) - sysfs_len);
-	strlcat(path, subsystem, sizeof(path_full) - sysfs_len);
-	strlcat(path, "/devices/", sizeof(path_full) - sysfs_len);
-	strlcat(path, id, sizeof(path_full) - sysfs_len);
-	if (stat(path_full, &statbuf) == 0)
-		goto found;
+		condlog(0, "%s: reassign table %s old %s new %s", check_dev,
+			table_name, check_devt, new_devt);
 
-	strlcpy(path, "/bus/", sizeof(path_full) - sysfs_len);
-	strlcat(path, subsystem, sizeof(path_full) - sysfs_len);
-	strlcat(path, "/devices/", sizeof(path_full) - sysfs_len);
-	strlcat(path, id, sizeof(path_full) - sysfs_len);
-	if (stat(path_full, &statbuf) == 0)
-		goto found;
+		dm_reassign_table(table_name, check_devt, new_devt);
+		FREE(table_name);
+	}
+	closedir(dirfd);
 
-	strlcpy(path, "/class/", sizeof(path_full) - sysfs_len);
-	strlcat(path, subsystem, sizeof(path_full) - sysfs_len);
-	strlcat(path, "/", sizeof(path_full) - sysfs_len);
-	strlcat(path, id, sizeof(path_full) - sysfs_len);
-	if (stat(path_full, &statbuf) == 0)
-		goto found;
-out:
 	return 0;
-found:
-	if (S_ISLNK(statbuf.st_mode))
-		sysfs_resolve_link(path, sizeof(path_full) - sysfs_len);
-	strlcpy(devpath_full, path, len);
-	return 1;
 }
diff --git a/libmultipath/sysfs.h b/libmultipath/sysfs.h
index 57d4cb1..13d7545 100644
--- a/libmultipath/sysfs.h
+++ b/libmultipath/sysfs.h
@@ -5,23 +5,8 @@
 #ifndef _LIBMULTIPATH_SYSFS_H
 #define _LIBMULTIPATH_SYSFS_H
 
-#ifdef DEBUG
-# define dbg(format, args...) condlog(4, format, ##args)
-#else
-# define dbg(format, args...) do {} while (0)
-#endif
-
-int sysfs_init(char *path, size_t len);
-void sysfs_cleanup(void);
-void sysfs_device_set_values(struct sysfs_device *dev, const char *devpath,
-			     const char *subsystem, const char *driver);
-struct sysfs_device *sysfs_device_get(const char *devpath);
-struct sysfs_device *sysfs_device_get_parent(struct sysfs_device *dev);
-struct sysfs_device *sysfs_device_get_parent_with_subsystem(struct sysfs_device *dev, const char *subsystem);
-void sysfs_device_put(struct sysfs_device *dev);
-char *sysfs_attr_get_value(const char *devpath, const char *attr_name);
-int sysfs_resolve_link(char *path, size_t size);
-int sysfs_get_size (struct sysfs_device * dev, unsigned long long * size);
-int sysfs_attr_set_value(const char *devpath, const char *attr_name,
-			 const char *value);
+ssize_t sysfs_attr_set_value(struct udev_device *dev, const char *attr_name,
+			     char * value, size_t value_len);
+int sysfs_get_size (struct path *pp, unsigned long long * size);
+int sysfs_check_holders(char * check_devt, char * new_devt);
 #endif
diff --git a/libmultipath/uevent.c b/libmultipath/uevent.c
index d8f3647..0643e14 100644
--- a/libmultipath/uevent.c
+++ b/libmultipath/uevent.c
@@ -37,83 +37,150 @@
 #include <linux/types.h>
 #include <linux/netlink.h>
 #include <pthread.h>
+#include <limits.h>
 #include <sys/mman.h>
+#include <libudev.h>
+#include <errno.h>
 
 #include "memory.h"
 #include "debug.h"
+#include "list.h"
 #include "uevent.h"
+#include "vector.h"
+#include "config.h"
 
 typedef int (uev_trigger)(struct uevent *, void * trigger_data);
 
 pthread_t uevq_thr;
-struct uevent *uevqhp, *uevqtp;
-pthread_mutex_t uevq_lock, *uevq_lockp = &uevq_lock;
-pthread_mutex_t uevc_lock, *uevc_lockp = &uevc_lock;
-pthread_cond_t  uev_cond,  *uev_condp  = &uev_cond;
+LIST_HEAD(uevq);
+pthread_mutex_t uevq_lock = PTHREAD_MUTEX_INITIALIZER;
+pthread_mutex_t *uevq_lockp = &uevq_lock;
+pthread_cond_t uev_cond = PTHREAD_COND_INITIALIZER;
+pthread_cond_t *uev_condp = &uev_cond;
 uev_trigger *my_uev_trigger;
 void * my_trigger_data;
 int servicing_uev;
 
 int is_uevent_busy(void)
 {
-	return (uevqhp != NULL || servicing_uev);
+	int empty;
+
+	pthread_mutex_lock(uevq_lockp);
+	empty = list_empty(&uevq);
+	pthread_mutex_unlock(uevq_lockp);
+	return (!empty || servicing_uev);
 }
 
-static struct uevent * alloc_uevent (void)
+struct uevent * alloc_uevent (void)
 {
-	return (struct uevent *)MALLOC(sizeof(struct uevent));
+	struct uevent *uev = MALLOC(sizeof(struct uevent));
+
+	if (uev)
+		INIT_LIST_HEAD(&uev->node);
+
+	return uev;
 }
 
 void
-service_uevq(void)
+setup_thread_attr(pthread_attr_t *attr, size_t stacksize, int detached)
 {
-	int empty;
-	struct uevent *uev;
+	if (pthread_attr_init(attr)) {
+		fprintf(stderr, "can't initialize thread attr: %s\n",
+			strerror(errno));
+		exit(1);
+	}
+	if (stacksize < PTHREAD_STACK_MIN)
+		stacksize = PTHREAD_STACK_MIN;
 
-	do {
-		pthread_mutex_lock(uevq_lockp);
-		empty = (uevqhp == NULL);
-		if (!empty) {
-			uev = uevqhp;
-			uevqhp = uev->next;
-			if (uevqtp == uev)
-				uevqtp = uev->next;
-			pthread_mutex_unlock(uevq_lockp);
-
-			if (my_uev_trigger && my_uev_trigger(uev,
-							my_trigger_data))
-				condlog(0, "uevent trigger error");
-
-			FREE(uev);
-		}
-		else {
-			pthread_mutex_unlock(uevq_lockp);
-		}
-	} while (empty == 0);
+	if (pthread_attr_setstacksize(attr, stacksize)) {
+		fprintf(stderr, "can't set thread stack size to %lu: %s\n",
+			(unsigned long)stacksize, strerror(errno));
+		exit(1);
+	}
+	if (detached && pthread_attr_setdetachstate(attr,
+						    PTHREAD_CREATE_DETACHED)) {
+		fprintf(stderr, "can't set thread to detached: %s\n",
+			strerror(errno));
+		exit(1);
+	}
+}
+
+/*
+ * Called with uevq_lockp held
+ */
+void
+service_uevq(struct list_head *tmpq)
+{
+	struct uevent *uev, *tmp;
+
+	list_for_each_entry_safe(uev, tmp, tmpq, node) {
+		list_del_init(&uev->node);
+
+		if (my_uev_trigger && my_uev_trigger(uev, my_trigger_data))
+			condlog(0, "uevent trigger error");
+
+		if (uev->udev)
+			udev_device_unref(uev->udev);
+		FREE(uev);
+	}
+}
+
+static void uevq_stop(void *arg)
+{
+	condlog(3, "Stopping uev queue");
+	pthread_mutex_lock(uevq_lockp);
+	my_uev_trigger = NULL;
+	pthread_cond_signal(uev_condp);
+	pthread_mutex_unlock(uevq_lockp);
+}
+
+void
+uevq_cleanup(struct list_head *tmpq)
+{
+	struct uevent *uev, *tmp;
+
+	list_for_each_entry_safe(uev, tmp, tmpq, node) {
+		list_del_init(&uev->node);
+		FREE(uev);
+	}
 }
 
 /*
  * Service the uevent queue.
  */
-static void *
-uevq_thread(void * et)
+int uevent_dispatch(int (*uev_trigger)(struct uevent *, void * trigger_data),
+		    void * trigger_data)
 {
+	my_uev_trigger = uev_trigger;
+	my_trigger_data = trigger_data;
+
 	mlockall(MCL_CURRENT | MCL_FUTURE);
 
 	while (1) {
-		pthread_mutex_lock(uevc_lockp);
+		LIST_HEAD(uevq_tmp);
+
+		pthread_mutex_lock(uevq_lockp);
 		servicing_uev = 0;
-		pthread_cond_wait(uev_condp, uevc_lockp);
+		/*
+		 * Condition signals are unreliable,
+		 * so make sure we only wait if we have to.
+		 */
+		if (list_empty(&uevq)) {
+			pthread_cond_wait(uev_condp, uevq_lockp);
+		}
 		servicing_uev = 1;
-		pthread_mutex_unlock(uevc_lockp);
-
-		service_uevq();
+		list_splice_init(&uevq, &uevq_tmp);
+		pthread_mutex_unlock(uevq_lockp);
+		if (!my_uev_trigger)
+			break;
+		service_uevq(&uevq_tmp);
 	}
-	return NULL;
+	condlog(3, "Terminating uev service queue");
+	uevq_cleanup(&uevq);
+	return 0;
 }
 
-int uevent_listen(int (*uev_trigger)(struct uevent *, void * trigger_data),
-		  void * trigger_data)
+int failback_listen(void)
 {
 	int sock;
 	struct sockaddr_nl snl;
@@ -124,28 +191,7 @@ int uevent_listen(int (*uev_trigger)(struct uevent *, void * trigger_data),
 	int rcvsz = 0;
 	int rcvszsz = sizeof(rcvsz);
 	unsigned int *prcvszsz = (unsigned int *)&rcvszsz;
-	pthread_attr_t attr;
 	const int feature_on = 1;
-
-	my_uev_trigger = uev_trigger;
-	my_trigger_data = trigger_data;
-
-	/*
-	 * Queue uevents for service by dedicated thread so that the uevent
-	 * listening thread does not block on multipathd locks (vecs->lock)
-	 * thereby not getting to empty the socket's receive buffer queue
-	 * often enough.
-	 */
-	uevqhp = uevqtp = NULL;
-
-	pthread_mutex_init(uevq_lockp, NULL);
-	pthread_mutex_init(uevc_lockp, NULL);
-	pthread_cond_init(uev_condp, NULL);
-
-	pthread_attr_init(&attr);
-	pthread_attr_setstacksize(&attr, 64 * 1024);
-	pthread_create(&uevq_thr, &attr, uevq_thread, NULL);
-
 	/*
 	 * First check whether we have a udev socket
 	 */
@@ -243,7 +289,7 @@ int uevent_listen(int (*uev_trigger)(struct uevent *, void * trigger_data),
 		buflen = recvmsg(sock, &smsg, 0);
 		if (buflen < 0) {
 			if (errno != EINTR)
-				condlog(0, "error receiving message");
+				condlog(0, "error receiving message, errno %d", errno);
 			continue;
 		}
 
@@ -271,6 +317,10 @@ int uevent_listen(int (*uev_trigger)(struct uevent *, void * trigger_data),
 			condlog(3, "unrecognized message header");
 			continue;
 		}
+		if ((size_t)buflen > sizeof(buf)-1) {
+			condlog(2, "buffer overflow for received uevent");
+			buflen = sizeof(buf)-1;
+		}
 
 		uev = alloc_uevent();
 
@@ -313,43 +363,242 @@ int uevent_listen(int (*uev_trigger)(struct uevent *, void * trigger_data),
 			key = &buffer[bufpos];
 			keylen = strlen(key);
 			uev->envp[i] = key;
+			/* Filter out sequence number */
+			if (strncmp(key, "SEQNUM=", 7) == 0) {
+				char *eptr;
+
+				uev->seqnum = strtoul(key + 7, &eptr, 10);
+				if (eptr == key + 7)
+					uev->seqnum = -1;
+			}
 			bufpos += keylen + 1;
 		}
 		uev->envp[i] = NULL;
 
-		condlog(3, "uevent '%s' from '%s'", uev->action, uev->devpath);
+		condlog(3, "uevent %ld '%s' from '%s'", uev->seqnum,
+			uev->action, uev->devpath);
+		uev->kernel = strrchr(uev->devpath, '/');
+		if (uev->kernel)
+			uev->kernel++;
 
 		/* print payload environment */
 		for (i = 0; uev->envp[i] != NULL; i++)
-			condlog(3, "%s", uev->envp[i]);
+			condlog(5, "%s", uev->envp[i]);
 
 		/*
 		 * Queue uevent and poke service pthread.
 		 */
 		pthread_mutex_lock(uevq_lockp);
-		if (uevqtp)
-			uevqtp->next = uev;
-		else
-			uevqhp = uev;
-		uevqtp = uev;
-		uev->next = NULL;
-		pthread_mutex_unlock(uevq_lockp);
-
-		pthread_mutex_lock(uevc_lockp);
+		list_add_tail(&uev->node, &uevq);
 		pthread_cond_signal(uev_condp);
-		pthread_mutex_unlock(uevc_lockp);
+		pthread_mutex_unlock(uevq_lockp);
 	}
 
 exit:
 	close(sock);
+	return 1;
+}
 
-	pthread_mutex_lock(uevq_lockp);
-	pthread_cancel(uevq_thr);
-	pthread_mutex_unlock(uevq_lockp);
+int uevent_listen(void)
+{
+	int err;
+	struct udev_monitor *monitor = NULL;
+	int fd, socket_flags;
+	int need_failback = 1;
+	/*
+	 * Queue uevents for service by dedicated thread so that the uevent
+	 * listening thread does not block on multipathd locks (vecs->lock)
+	 * thereby not getting to empty the socket's receive buffer queue
+	 * often enough.
+	 */
+	pthread_cleanup_push(uevq_stop, NULL);
 
-	pthread_mutex_destroy(uevq_lockp);
-	pthread_mutex_destroy(uevc_lockp);
-	pthread_cond_destroy(uev_condp);
+	monitor = udev_monitor_new_from_netlink(conf->udev, "udev");
+	if (!monitor) {
+		condlog(2, "failed to create udev monitor");
+		goto out;
+	}
+#ifdef LIBUDEV_API_RECVBUF
+	if (udev_monitor_set_receive_buffer_size(monitor, 128 * 1024 * 1024))
+		condlog(2, "failed to increase buffer size");
+#endif
+	fd = udev_monitor_get_fd(monitor);
+	if (fd < 0) {
+		condlog(2, "failed to get monitor fd");
+		goto out;
+	}
+	socket_flags = fcntl(fd, F_GETFL);
+	if (socket_flags < 0) {
+		condlog(2, "failed to get monitor socket flags : %s",
+			strerror(errno));
+		goto out;
+	}
+	if (fcntl(fd, F_SETFL, socket_flags & ~O_NONBLOCK) < 0) {
+		condlog(2, "failed to set monitor socket flags : %s",
+			strerror(errno));
+		goto out;
+	}
+	err = udev_monitor_filter_add_match_subsystem_devtype(monitor, "block",
+							      NULL);
+	if (err)
+		condlog(2, "failed to create filter : %s", strerror(-err));
+	err = udev_monitor_enable_receiving(monitor);
+	if (err) {
+		condlog(2, "failed to enable receiving : %s", strerror(-err));
+		goto out;
+	}
+	while (1) {
+		int i = 0;
+		char *pos, *end;
+		struct uevent *uev;
+		struct udev_device *dev;
+                struct udev_list_entry *list_entry;
 
-	return 1;
+		dev = udev_monitor_receive_device(monitor);
+		if (!dev) {
+			condlog(0, "failed getting udev device");
+			continue;
+		}
+
+		uev = alloc_uevent();
+		if (!uev) {
+			udev_device_unref(dev);
+			condlog(1, "lost uevent, oom");
+			continue;
+		}
+		pos = uev->buffer;
+		end = pos + HOTPLUG_BUFFER_SIZE + OBJECT_SIZE - 1;
+		udev_list_entry_foreach(list_entry, udev_device_get_properties_list_entry(dev)) {
+			const char *name, *value;
+			int bytes;
+
+			name = udev_list_entry_get_name(list_entry);
+			if (!name)
+				name = "(null)";
+			value = udev_list_entry_get_value(list_entry);
+			if (!value)
+				value = "(null)";
+			bytes = snprintf(pos, end - pos, "%s=%s", name,
+					value);
+			if (pos + bytes >= end) {
+				condlog(2, "buffer overflow for uevent");
+				break;
+			}
+			uev->envp[i] = pos;
+			pos += bytes;
+			*pos = '\0';
+			pos++;
+			if (strcmp(name, "DEVPATH") == 0)
+				uev->devpath = uev->envp[i] + 8;
+			if (strcmp(name, "ACTION") == 0)
+				uev->action = uev->envp[i] + 7;
+			i++;
+			if (i == HOTPLUG_NUM_ENVP - 1)
+				break;
+		}
+		uev->udev = dev;
+		uev->envp[i] = NULL;
+
+		condlog(3, "uevent '%s' from '%s'", uev->action, uev->devpath);
+		uev->kernel = strrchr(uev->devpath, '/');
+		if (uev->kernel)
+			uev->kernel++;
+
+		/* print payload environment */
+		for (i = 0; uev->envp[i] != NULL; i++)
+			condlog(5, "%s", uev->envp[i]);
+
+		/*
+ 		 * Queue uevent and poke service pthread.
+ 		 */
+		pthread_mutex_lock(uevq_lockp);
+		list_add_tail(&uev->node, &uevq);
+		pthread_cond_signal(uev_condp);
+		pthread_mutex_unlock(uevq_lockp);
+	}
+	need_failback = 0;
+out:
+	if (monitor)
+		udev_monitor_unref(monitor);
+	if (need_failback)
+		err = failback_listen();
+	pthread_cleanup_pop(1);
+	return err;
+}
+
+extern int
+uevent_get_major(struct uevent *uev)
+{
+	char *p, *q;
+	int i, major = -1;
+
+	for (i = 0; uev->envp[i] != NULL; i++) {
+		if (!strncmp(uev->envp[i], "MAJOR", 5) && strlen(uev->envp[i]) > 6) {
+			p = uev->envp[i] + 6;
+			major = strtoul(p, &q, 10);
+			if (p == q) {
+				condlog(2, "invalid major '%s'", p);
+				major = -1;
+			}
+			break;
+		}
+	}
+	return major;
+}
+
+extern int
+uevent_get_minor(struct uevent *uev)
+{
+	char *p, *q;
+	int i, minor = -1;
+
+	for (i = 0; uev->envp[i] != NULL; i++) {
+		if (!strncmp(uev->envp[i], "MINOR", 5) && strlen(uev->envp[i]) > 6) {
+			p = uev->envp[i] + 6;
+			minor = strtoul(p, &q, 10);
+			if (p == q) {
+				condlog(2, "invalid minor '%s'", p);
+				minor = -1;
+			}
+			break;
+		}
+	}
+	return minor;
+}
+
+extern int
+uevent_get_disk_ro(struct uevent *uev)
+{
+	char *p, *q;
+	int i, ro = -1;
+
+	for (i = 0; uev->envp[i] != NULL; i++) {
+		if (!strncmp(uev->envp[i], "DISK_RO", 6) && strlen(uev->envp[i]) > 7) {
+			p = uev->envp[i] + 8;
+			ro = strtoul(p, &q, 10);
+			if (p == q) {
+				condlog(2, "invalid read_only setting '%s'", p);
+				ro = -1;
+			}
+			break;
+		}
+	}
+	return ro;
+}
+
+extern char *
+uevent_get_dm_name(struct uevent *uev)
+{
+	char *p = NULL;
+	int i;
+
+	for (i = 0; uev->envp[i] != NULL; i++) {
+		if (!strncmp(uev->envp[i], "DM_NAME", 6) &&
+		    strlen(uev->envp[i]) > 7) {
+			p = MALLOC(strlen(uev->envp[i] + 8) + 1);
+			strcpy(p, uev->envp[i] + 8);
+			break;
+		}
+	}
+	return p;
 }
diff --git a/libmultipath/uevent.h b/libmultipath/uevent.h
index e1a1254..762595a 100644
--- a/libmultipath/uevent.h
+++ b/libmultipath/uevent.h
@@ -1,5 +1,11 @@
-/* environment buffer, the kernel's size in lib/kobject_uevent.c should fit in */
-#define HOTPLUG_BUFFER_SIZE		1024
+#ifndef _UEVENT_H
+#define _UEVENT_H
+
+/*
+ * buffer for environment variables, the kernel's size in
+ * lib/kobject_uevent.c should fit in
+*/
+#define HOTPLUG_BUFFER_SIZE		2048
 #define HOTPLUG_NUM_ENVP		32
 #define OBJECT_SIZE			512
 
@@ -8,13 +14,25 @@
 #endif
 
 struct uevent {
-	void *next;
+	struct list_head node;
+	struct udev_device *udev;
 	char buffer[HOTPLUG_BUFFER_SIZE + OBJECT_SIZE];
 	char *devpath;
 	char *action;
+	char *kernel;
+	unsigned long seqnum;
 	char *envp[HOTPLUG_NUM_ENVP];
 };
 
-int uevent_listen(int (*store_uev)(struct uevent *, void * trigger_data),
-		  void * trigger_data);
 int is_uevent_busy(void);
+void setup_thread_attr(pthread_attr_t *attr, size_t stacksize, int detached);
+
+int uevent_listen(void);
+int uevent_dispatch(int (*store_uev)(struct uevent *, void * trigger_data),
+		    void * trigger_data);
+int uevent_get_major(struct uevent *uev);
+int uevent_get_minor(struct uevent *uev);
+int uevent_get_disk_ro(struct uevent *uev);
+char *uevent_get_dm_name(struct uevent *uev);
+
+#endif /* _UEVENT_H */
diff --git a/libmultipath/util.c b/libmultipath/util.c
index ebe06dc..41ac21b 100644
--- a/libmultipath/util.c
+++ b/libmultipath/util.c
@@ -6,28 +6,9 @@
 
 #include "debug.h"
 #include "memory.h"
-
-#define PARAMS_SIZE 255
-
-int
-strcmp_chomp(char *str1, char *str2)
-{
-	int i;
-	char s1[PARAMS_SIZE],s2[PARAMS_SIZE];
-
-	if(!str1 || !str2)
-		return 1;
-
-	strncpy(s1, str1, PARAMS_SIZE);
-	strncpy(s2, str2, PARAMS_SIZE);
-
-	for (i=strlen(s1)-1; i >=0 && isspace(s1[i]); --i) ;
-	s1[++i] = '\0';
-	for (i=strlen(s2)-1; i >=0 && isspace(s2[i]); --i) ;
-	s2[++i] = '\0';
-
-	return(strcmp(s1,s2));
-}
+#include "checkers.h"
+#include "vector.h"
+#include "structs.h"
 
 void
 strchop(char *str)
@@ -38,10 +19,21 @@ strchop(char *str)
 	str[++i] = '\0';
 }
 
-void
-basenamecpy (char * str1, char * str2)
+int
+basenamecpy (const char * str1, char * str2, int str2len)
 {
-	char *p = str1 + (strlen(str1) - 1);
+	char *p;
+
+	if (!str1 || !strlen(str1))
+		return 0;
+
+	if (strlen(str1) >= str2len)
+		return 0;
+
+	if (!str2)
+		return 0;
+
+	p = (char *)str1 + (strlen(str1) - 1);
 
 	while (*--p != '/' && p != str1)
 		continue;
@@ -49,7 +41,10 @@ basenamecpy (char * str1, char * str2)
 	if (p != str1)
 		p++;
 
-	strcpy(str2, p);
+	strncpy(str2, p, str2len);
+	str2[str2len - 1] = '\0';
+	strchop(str2);
+	return strlen(str2);
 }
 
 int
@@ -91,7 +86,7 @@ get_word (char * sentence, char ** word)
 	*word = MALLOC(len + 1);
 
 	if (!*word) {
-		condlog(0, "get_word : oom\n");
+		condlog(0, "get_word : oom");
 		return 0;
 	}
 	strncpy(*word, sentence, len);
@@ -156,3 +151,97 @@ void remove_trailing_chars(char *path, char c)
 		path[--len] = '\0';
 }
 
+extern int
+devt2devname (char *devname, int devname_len, char *devt)
+{
+	FILE *fd;
+	unsigned int tmpmaj, tmpmin, major, minor;
+	char dev[FILE_NAME_SIZE];
+	char block_path[PATH_SIZE];
+	struct stat statbuf;
+
+	memset(block_path, 0, sizeof(block_path));
+	memset(dev, 0, sizeof(dev));
+	if (sscanf(devt, "%u:%u", &major, &minor) != 2) {
+		condlog(0, "Invalid device number %s", devt);
+		return 1;
+	}
+
+	if (devname_len > FILE_NAME_SIZE)
+		devname_len = FILE_NAME_SIZE;
+
+	if (stat("/sys/dev/block", &statbuf) == 0) {
+		/* Newer kernels have /sys/dev/block */
+		sprintf(block_path,"/sys/dev/block/%u:%u", major, minor);
+		if (lstat(block_path, &statbuf) == 0) {
+			if (S_ISLNK(statbuf.st_mode) &&
+			    readlink(block_path, dev, FILE_NAME_SIZE) > 0) {
+				char *p = strrchr(dev, '/');
+
+				if (!p) {
+					condlog(0, "No sysfs entry for %s",
+						block_path);
+					return 1;
+				}
+				p++;
+				strncpy(devname, p, devname_len);
+				return 0;
+			}
+		}
+		goto skip_proc;
+	}
+	memset(block_path, 0, sizeof(block_path));
+
+	if (!(fd = fopen("/proc/partitions", "r"))) {
+		condlog(0, "Cannot open /proc/partitions");
+		return 1;
+	}
+
+	while (!feof(fd)) {
+		int r = fscanf(fd,"%u %u %*d %s",&tmpmaj, &tmpmin, dev);
+		if (!r) {
+			r = fscanf(fd,"%*s\n");
+			continue;
+		}
+		if (r != 3)
+			continue;
+
+		if ((major == tmpmaj) && (minor == tmpmin)) {
+			if (snprintf(block_path, sizeof(block_path),
+				     "/sys/block/%s", dev) >= sizeof(block_path)) {
+				condlog(0, "device name %s is too long", dev);
+				fclose(fd);
+				return 1;
+			}
+			break;
+		}
+	}
+	fclose(fd);
+skip_proc:
+	if (strncmp(block_path,"/sys/block", 10)) {
+		condlog(3, "No device found for %u:%u", major, minor);
+		return 1;
+	}
+
+	if (stat(block_path, &statbuf) < 0) {
+		condlog(0, "No sysfs entry for %s", block_path);
+		return 1;
+	}
+
+	if (S_ISDIR(statbuf.st_mode) == 0) {
+		condlog(0, "sysfs entry %s is not a directory", block_path);
+		return 1;
+	}
+	basenamecpy((const char *)block_path, devname, devname_len);
+	return 0;
+}
+
+dev_t parse_devt(const char *dev_t)
+{
+	int maj, min;
+
+	if (sscanf(dev_t,"%d:%d", &maj, &min) != 2)
+		return 0;
+
+	return makedev(maj, min);
+}
diff --git a/libmultipath/util.h b/libmultipath/util.h
index 52f2578..44184a1 100644
--- a/libmultipath/util.h
+++ b/libmultipath/util.h
@@ -1,14 +1,15 @@
 #ifndef _UTIL_H
 #define _UTIL_H
 
-int strcmp_chomp(char *, char *);
 void strchop(char *);
-void basenamecpy (char * src, char * dst);
+int basenamecpy (const char * src, char * dst, int);
 int filepresent (char * run);
 int get_word (char * sentence, char ** word);
 size_t strlcpy(char *dst, const char *src, size_t size);
 size_t strlcat(char *dst, const char *src, size_t size);
 void remove_trailing_chars(char *path, char c);
+int devt2devname (char *, int, char *);
+dev_t parse_devt(const char *dev_t);
 
 #define safe_sprintf(var, format, args...)	\
 	snprintf(var, sizeof(var), format, ##args) >= sizeof(var)
diff --git a/libmultipath/uxsock.c b/libmultipath/uxsock.c
index d5d1be9..ce89428 100644
--- a/libmultipath/uxsock.c
+++ b/libmultipath/uxsock.c
@@ -25,19 +25,21 @@
  */
 int ux_socket_connect(const char *name)
 {
-	int fd;
+	int fd, len;
 	struct sockaddr_un addr;
 
 	memset(&addr, 0, sizeof(addr));
-	addr.sun_family = AF_UNIX;
-	strncpy(addr.sun_path, name, sizeof(addr.sun_path));
+	addr.sun_family = AF_LOCAL;
+	addr.sun_path[0] = '\0';
+	len = strlen(name) + 1 + sizeof(sa_family_t);
+	strncpy(&addr.sun_path[1], name, len);
 
-	fd = socket(AF_UNIX, SOCK_STREAM, 0);
+	fd = socket(AF_LOCAL, SOCK_STREAM, 0);
 	if (fd == -1) {
 		return -1;
 	}
 
-	if (connect(fd, (struct sockaddr *)&addr, sizeof(addr)) == -1) {
+	if (connect(fd, (struct sockaddr *)&addr, len) == -1) {
 		close(fd);
 		return -1;
 	}
@@ -51,20 +53,19 @@ int ux_socket_connect(const char *name)
  */
 int ux_socket_listen(const char *name)
 {
-	int fd;
+	int fd, len;
 	struct sockaddr_un addr;
 
-	/* get rid of any old socket */
-	unlink(name);
-
-	fd = socket(AF_UNIX, SOCK_STREAM, 0);
+	fd = socket(AF_LOCAL, SOCK_STREAM, 0);
 	if (fd == -1) return -1;
 
 	memset(&addr, 0, sizeof(addr));
-	addr.sun_family = AF_UNIX;
-	strncpy(addr.sun_path, name, sizeof(addr.sun_path));
+	addr.sun_family = AF_LOCAL;
+	addr.sun_path[0] = '\0';
+	len = strlen(name) + 1 + sizeof(sa_family_t);
+	strncpy(&addr.sun_path[1], name, len);
 
-	if (bind(fd, (struct sockaddr *)&addr, sizeof(addr)) == -1) {
+	if (bind(fd, (struct sockaddr *)&addr, len) == -1) {
 		close(fd);
 		return -1;
 	}
@@ -152,12 +153,22 @@ int send_packet(int fd, const char *buf, size_t len)
  */
 int recv_packet(int fd, char **buf, size_t *len)
 {
-	if (read_all(fd, len, sizeof(*len)) != sizeof(*len)) return -1;
+	if (read_all(fd, len, sizeof(*len)) != sizeof(*len)) {
+		(*buf) = NULL;
+		*len = 0;
+		return -1;
+	}
+	if (len == 0) {
+		(*buf) = NULL;
+		return 0;
+	}
 	(*buf) = MALLOC(*len);
 	if (!*buf)
 		return -1;
 	if (read_all(fd, *buf, *len) != *len) {
 		FREE(*buf);
+		(*buf) = NULL;
+		*len = 0;
 		return -1;
 	}
 	return 0;
diff --git a/libmultipath/vector.c b/libmultipath/vector.c
index 3415461..6266e0a 100644
--- a/libmultipath/vector.c
+++ b/libmultipath/vector.c
@@ -38,18 +38,41 @@ vector_alloc(void)
 void *
 vector_alloc_slot(vector v)
 {
+	void *new_slot = NULL;
+
+	if (!v)
+		return NULL;
+
 	v->allocated += VECTOR_DEFAULT_SIZE;
 	if (v->slot)
-		v->slot = REALLOC(v->slot, sizeof (void *) * v->allocated);
+		new_slot = REALLOC(v->slot, sizeof (void *) * v->allocated);
 	else
-		v->slot = (void *) MALLOC(sizeof (void *) * v->allocated);
+		new_slot = (void *) MALLOC(sizeof (void *) * v->allocated);
 
-	if (!v->slot)
+	if (!new_slot)
 		v->allocated -= VECTOR_DEFAULT_SIZE;
+	else
+		v->slot = new_slot;
 
 	return v->slot;
 }
 
+int
+vector_move_up(vector v, int src, int dest)
+{
+	void *value;
+	int i;
+	if (dest == src)
+		return 0;
+	if (dest > src || src >= v->allocated)
+		return -1;
+	value = v->slot[src];
+	for (i = src - 1; i >= dest; i--)
+		v->slot[i + 1] = v->slot[i];
+	v->slot[dest] = value;
+	return 0;
+}
+
 void *
 vector_insert_slot(vector v, int slot, void *value)
 {
@@ -58,7 +81,7 @@ vector_insert_slot(vector v, int slot, void *value)
 	if (!vector_alloc_slot(v))
 		return NULL;
 
-	for (i = (v->allocated /VECTOR_DEFAULT_SIZE) - 2; i >= slot; i--)
+	for (i = VECTOR_SIZE(v) - 2; i >= slot; i--)
 		v->slot[i + 1] = v->slot[i];
 
 	v->slot[slot] = value;
@@ -71,7 +94,10 @@ find_slot(vector v, void * addr)
 {
 	int i;
 
-	for (i = 0; i < (v->allocated / VECTOR_DEFAULT_SIZE); i++)
+	if (!v)
+		return -1;
+
+	for (i = 0; i < VECTOR_SIZE(v); i++)
 		if (v->slot[i] == addr)
 			return i;
 
@@ -83,20 +109,27 @@ vector_del_slot(vector v, int slot)
 {
 	int i;
 
-	if (!v->allocated || slot < 0 || slot > VECTOR_SIZE(v))
+	if (!v || !v->allocated || slot < 0 || slot > VECTOR_SIZE(v))
 		return;
 
-	for (i = slot + 1; i < (v->allocated / VECTOR_DEFAULT_SIZE); i++)
+	for (i = slot + 1; i < VECTOR_SIZE(v); i++)
 		v->slot[i-1] = v->slot[i];
 
 	v->allocated -= VECTOR_DEFAULT_SIZE;
 
-	if (!v->allocated) {
+	if (v->allocated <= 0) {
 		FREE(v->slot);
 		v->slot = NULL;
+		v->allocated = 0;
+	} else {
+		void *new_slot;
+
+		new_slot = REALLOC(v->slot, sizeof (void *) * v->allocated);
+		if (!new_slot)
+			v->allocated += VECTOR_DEFAULT_SIZE;
+		else
+			v->slot = new_slot;
 	}
-	else
-		v = REALLOC(v->slot, sizeof (void *) * v->allocated);
 }
 
 void
@@ -104,10 +137,10 @@ vector_repack(vector v)
 {
 	int i;
 
-	if (!v->allocated)
+	if (!v || !v->allocated)
 		return;
 
-	for (i = 0; i < (v->allocated / VECTOR_DEFAULT_SIZE); i++)
+	for (i = 0; i < VECTOR_SIZE(v); i++)
 		if (i > 0 && v->slot[i] == NULL)
 			vector_del_slot(v, i--);
 }
@@ -122,6 +155,8 @@ vector_free(vector v)
 	if (v->slot)
 		FREE(v->slot);
 
+	v->allocated = 0;
+	v->slot = NULL;
 	FREE(v);
 }
 
@@ -145,7 +180,11 @@ free_strvec(vector strvec)
 void
 vector_set_slot(vector v, void *value)
 {
-	unsigned int i = v->allocated - 1;
+	unsigned int i;
+
+	if (!v)
+		return;
 
+	i = VECTOR_SIZE(v) - 1;
 	v->slot[i] = value;
 }
diff --git a/libmultipath/vector.h b/libmultipath/vector.h
index 59cfd27..7612b4c 100644
--- a/libmultipath/vector.h
+++ b/libmultipath/vector.h
@@ -25,20 +25,22 @@
 
 /* vector definition */
 struct _vector {
-	unsigned int allocated;
+	int allocated;
 	void **slot;
 };
 typedef struct _vector *vector;
 
 #define VECTOR_DEFAULT_SIZE 1
-#define VECTOR_SLOT(V,E) (((V) && (E) < (V)->allocated) ? (V)->slot[(E)] : NULL)
-#define VECTOR_SIZE(V)   ((V) ? (V)->allocated : 0)
-#define VECTOR_LAST_SLOT(V)   (((V) && (V)->allocated) ? (V)->slot[((V)->allocated - 1)] : NULL)
+#define VECTOR_SIZE(V)   ((V) ? ((V)->allocated) / VECTOR_DEFAULT_SIZE : 0)
+#define VECTOR_SLOT(V,E) (((V) && (E) < VECTOR_SIZE(V)) ? (V)->slot[(E)] : NULL)
+#define VECTOR_LAST_SLOT(V)   (((V) && VECTOR_SIZE(V) > 0) ? (V)->slot[(VECTOR_SIZE(V) - 1)] : NULL)
 
 #define vector_foreach_slot(v,p,i) \
-	for (i = 0; (v) && i < (v)->allocated && ((p) = (v)->slot[i]); i++)
+	for (i = 0; (v) && i < VECTOR_SIZE(v) && ((p) = (v)->slot[i]); i++)
 #define vector_foreach_slot_after(v,p,i) \
-	for (; (v) && i < (v)->allocated && ((p) = (v)->slot[i]); i++)
+	for (; (v) && i < VECTOR_SIZE(v) && ((p) = (v)->slot[i]); i++)
+#define vector_foreach_slot_backwards(v,p,i) \
+	for (i = VECTOR_SIZE(v); i > 0 && ((p) = (v)->slot[i-1]); i--)
 
 /* Prototypes */
 extern vector vector_alloc(void);
@@ -52,5 +54,5 @@ int find_slot(vector v, void * addr);
 extern void vector_repack(vector v);
 extern void vector_dump(vector v);
 extern void dump_strvec(vector strvec);
-
+extern int vector_move_up(vector v, int src, int dest);
 #endif
diff --git a/libmultipath/waiter.c b/libmultipath/waiter.c
index 4fb2cff..5094290 100644
--- a/libmultipath/waiter.c
+++ b/libmultipath/waiter.c
@@ -28,35 +28,15 @@ struct event_thread *alloc_waiter (void)
 	struct event_thread *wp;
 
 	wp = (struct event_thread *)MALLOC(sizeof(struct event_thread));
+	memset(wp, 0, sizeof(struct event_thread));
 
 	return wp;
 }
 
 void free_waiter (void *data)
 {
-	sigset_t old;
 	struct event_thread *wp = (struct event_thread *)data;
 
-	/*
-	 * indicate in mpp that the wp is already freed storage
-	 */
-	block_signal(SIGHUP, &old);
-	lock(wp->vecs->lock);
-
-	if (wp->mpp)
-		/*
-		 * be careful, mpp may already be freed -- null if so
-		 */
-		wp->mpp->waiter = NULL;
-	else
-		/*
-		* This is OK condition during shutdown.
-		*/
-		condlog(3, "free_waiter, mpp freed before wp=%p (%s).", wp, wp->mapname);
-
-	unlock(wp->vecs->lock);
-	pthread_sigmask(SIG_SETMASK, &old, NULL);
-
 	if (wp->dmt)
 		dm_task_destroy(wp->dmt);
 
@@ -65,28 +45,18 @@ void free_waiter (void *data)
 
 void stop_waiter_thread (struct multipath *mpp, struct vectors *vecs)
 {
-	struct event_thread *wp = (struct event_thread *)mpp->waiter;
 	pthread_t thread;
 
-	if (!wp) {
-		condlog(3, "%s: no waiter thread", mpp->alias);
+	if (mpp->waiter == (pthread_t)0) {
+		condlog(3, "%s: event checker thread already stopped",
+			mpp->alias);
 		return;
 	}
-	thread = wp->thread;
-	condlog(2, "%s: stop event checker thread (%lu)", wp->mapname, thread);
-
-	pthread_kill(thread, SIGUSR1);
-}
-
-static sigset_t unblock_signals(void)
-{
-	sigset_t set, old;
-
-	sigemptyset(&set);
-	sigaddset(&set, SIGHUP);
-	sigaddset(&set, SIGUSR1);
-	pthread_sigmask(SIG_UNBLOCK, &set, &old);
-	return old;
+	condlog(2, "%s: stop event checker thread (%lu)", mpp->alias,
+		mpp->waiter);
+	thread = mpp->waiter;
+	mpp->waiter = (pthread_t)0;
+	pthread_cancel(thread);
 }
 
 /*
@@ -95,7 +65,6 @@ static sigset_t unblock_signals(void)
  */
 int waiteventloop (struct event_thread *waiter)
 {
-	sigset_t set;
 	int event_nr;
 	int r;
 
@@ -112,6 +81,7 @@ int waiteventloop (struct event_thread *waiter)
 		condlog(0, "%s: devmap event #%i dm_task_set_name error",
 				waiter->mapname, waiter->event_nr);
 		dm_task_destroy(waiter->dmt);
+		waiter->dmt = NULL;
 		return 1;
 	}
 
@@ -120,25 +90,21 @@ int waiteventloop (struct event_thread *waiter)
 		condlog(0, "%s: devmap event #%i dm_task_set_event_nr error",
 				waiter->mapname, waiter->event_nr);
 		dm_task_destroy(waiter->dmt);
+		waiter->dmt = NULL;
 		return 1;
 	}
 
 	dm_task_no_open_count(waiter->dmt);
 
-	/* accept wait interruption */
-	set = unblock_signals();
-
 	/* wait */
 	r = dm_task_run(waiter->dmt);
 
-	/* wait is over : event or interrupt */
-	pthread_sigmask(SIG_SETMASK, &set, NULL);
+	dm_task_destroy(waiter->dmt);
+	waiter->dmt = NULL;
 
-	if (!r) /* wait interrupted by signal */
+	if (!r)	/* wait interrupted by signal */
 		return -1;
 
-	dm_task_destroy(waiter->dmt);
-	waiter->dmt = NULL;
 	waiter->event_nr++;
 
 	/*
@@ -161,7 +127,8 @@ int waiteventloop (struct event_thread *waiter)
 		 */
 		pthread_cleanup_push(cleanup_lock, &waiter->vecs->lock);
 		lock(waiter->vecs->lock);
-		r = update_multipath(waiter->vecs, waiter->mapname);
+		pthread_testcancel();
+		r = update_multipath(waiter->vecs, waiter->mapname, 1);
 		lock_cleanup_pop(waiter->vecs->lock);
 
 		if (r) {
@@ -190,8 +157,6 @@ void *waitevent (void *et)
 	waiter = (struct event_thread *)et;
 	pthread_cleanup_push(free_waiter, et);
 
-	block_signal(SIGUSR1, NULL);
-	block_signal(SIGHUP, NULL);
 	while (1) {
 		r = waiteventloop(waiter);
 
@@ -217,21 +182,20 @@ int start_waiter_thread (struct multipath *mpp, struct vectors *vecs)
 	if (!wp)
 		goto out;
 
-	mpp->waiter = (void *)wp;
 	strncpy(wp->mapname, mpp->alias, WWID_SIZE);
 	wp->vecs = vecs;
-	wp->mpp = mpp;
 
 	if (pthread_create(&wp->thread, &waiter_attr, waitevent, wp)) {
 		condlog(0, "%s: cannot create event checker", wp->mapname);
 		goto out1;
 	}
+	mpp->waiter = wp->thread;
 	condlog(2, "%s: event checker started", wp->mapname);
 
 	return 0;
 out1:
 	free_waiter(wp);
-	mpp->waiter = NULL;
+	mpp->waiter = (pthread_t)0;
 out:
 	condlog(0, "failed to start waiter thread");
 	return 1;
diff --git a/libmultipath/waiter.h b/libmultipath/waiter.h
index ab362d1..a1f57fb 100644
--- a/libmultipath/waiter.h
+++ b/libmultipath/waiter.h
@@ -9,7 +9,6 @@ struct event_thread {
 	int event_nr;
 	char mapname[WWID_SIZE];
 	struct vectors *vecs;
-	struct multipath *mpp;
 };
 
 struct event_thread * alloc_waiter (void);
diff --git a/libmultipath/wwids.c b/libmultipath/wwids.c
new file mode 100644
index 0000000..91b07a7
--- /dev/null
+++ b/libmultipath/wwids.c
@@ -0,0 +1,270 @@
+#include <stdlib.h>
+#include <errno.h>
+#include <unistd.h>
+#include <string.h>
+#include <limits.h>
+#include <stdio.h>
+
+#include "checkers.h"
+#include "vector.h"
+#include "structs.h"
+#include "debug.h"
+#include "uxsock.h"
+#include "file.h"
+#include "wwids.h"
+#include "defaults.h"
+#include "config.h"
+
+/*
+ * Copyright (c) 2010 Benjamin Marzinski, Redhat
+ */
+
+static int
+lookup_wwid(FILE *f, char *wwid) {
+	int c;
+	char buf[LINE_MAX];
+	int count;
+
+	while ((c = fgetc(f)) != EOF){
+		if (c != '/') {
+			if (fgets(buf, LINE_MAX, f) == NULL)
+				return 0;
+			else
+				continue;
+		}
+		count = 0;
+		while ((c = fgetc(f)) != '/') {
+			if (c == EOF)
+				return 0;
+			if (count >= WWID_SIZE - 1)
+				goto next;
+			if (wwid[count] == '\0')
+				goto next;
+			if (c != wwid[count++])
+				goto next;
+		}
+		if (wwid[count] == '\0')
+			return 1;
+next:
+		if (fgets(buf, LINE_MAX, f) == NULL)
+			return 0;
+	}
+	return 0;
+}
+
+static int
+write_out_wwid(int fd, char *wwid) {
+	int ret;
+	off_t offset;
+	char buf[WWID_SIZE + 3];
+
+	ret = snprintf(buf, WWID_SIZE + 3, "/%s/\n", wwid);
+	if (ret >= (WWID_SIZE + 3) || ret < 0){
+		condlog(0, "can't format wwid for writing (%d) : %s",
+			ret, strerror(errno));
+		return -1;
+	}
+	offset = lseek(fd, 0, SEEK_END);
+	if (offset < 0) {
+		condlog(0, "can't seek to the end of wwids file : %s",
+			strerror(errno));
+		return -1;
+	}
+	if (write_all(fd, buf, strlen(buf)) != strlen(buf)) {
+		condlog(0, "cannot write wwid to wwids file : %s",
+			strerror(errno));
+		if (ftruncate(fd, offset))
+			condlog(0, "cannot truncate failed wwid write : %s",
+				strerror(errno));
+		return -1;
+	}
+	return 1;
+}
+
+int
+replace_wwids(vector mp)
+{
+	int i, fd, can_write;
+	struct multipath * mpp;
+	size_t len;
+	int ret = -1;
+
+	fd = open_file(conf->wwids_file, &can_write, WWIDS_FILE_HEADER);
+	if (fd < 0)
+		goto out;
+	if (!can_write) {
+		condlog(0, "cannot replace wwids. wwids file is read-only");
+		goto out_file;
+	}
+	if (ftruncate(fd, 0) < 0) {
+		condlog(0, "cannot truncate wwids file : %s", strerror(errno));
+		goto out_file;
+	}
+	len = strlen(WWIDS_FILE_HEADER);
+	if (write_all(fd, WWIDS_FILE_HEADER, len) != len) {
+		condlog(0, "Can't write wwid file header : %s",
+			strerror(errno));
+		/* cleanup partially written header */
+		if (ftruncate(fd, 0) < 0)
+			condlog(0, "Cannot truncate header : %s",
+				strerror(errno));
+		goto out_file;
+	}
+	if (!mp || !mp->allocated) {
+		ret = 0;
+		goto out_file;
+	}
+	vector_foreach_slot(mp, mpp, i) {
+		if (write_out_wwid(fd, mpp->wwid) < 0)
+			goto out_file;
+	}
+	ret = 0;
+out_file:
+	close(fd);
+out:
+	return ret;
+}
+
+int
+do_remove_wwid(int fd, char *str) {
+	char buf[4097];
+	char *ptr;
+	off_t start = 0;
+	int bytes;
+
+	while (1) {
+		if (lseek(fd, start, SEEK_SET) < 0) {
+			condlog(0, "wwid file read lseek failed : %s",
+				strerror(errno));
+			return -1;
+		}
+		bytes = read(fd, buf, 4096);
+		if (bytes < 0) {
+			if (errno == EINTR || errno == EAGAIN)
+				continue;
+			condlog(0, "failed to read from wwids file : %s",
+				strerror(errno));
+			return -1;
+		}
+		if (!bytes) /* didn't find wwid to remove */
+			return 1;
+		buf[bytes] = '\0';
+		ptr = strstr(buf, str);
+		if (ptr != NULL) {
+			condlog(3, "found '%s'", str);
+			if (lseek(fd, start + (ptr - buf), SEEK_SET) < 0) {
+				condlog(0, "write lseek failed : %s",
+						strerror(errno));
+				return -1;
+			}
+			while (1) {
+				if (write(fd, "#", 1) < 0) {
+					if (errno == EINTR || errno == EAGAIN)
+						continue;
+					condlog(0, "failed to write to wwids file : %s", strerror(errno));
+					return -1;
+				}
+				return 0;
+			}
+		}
+		ptr = strrchr(buf, '\n');
+		if (ptr == NULL) { /* shouldn't happen, assume it is EOF */
+			condlog(4, "couldn't find newline, assuming end of file");
+			return 1;
+		}
+		start = start + (ptr - buf) + 1;
+	}
+}
+
+
+int
+remove_wwid(char *wwid) {
+	int fd, len, can_write;
+	char *str;
+	int ret = -1;
+
+	len = strlen(wwid) + 4; /* two slashes the newline and a zero byte */
+	str = malloc(len);
+	if (str == NULL) {
+		condlog(0, "can't allocate memory to remove wwid : %s",
+			strerror(errno));
+		return -1;
+	}
+	if (snprintf(str, len, "/%s/\n", wwid) >= len) {
+		condlog(0, "string overflow trying to remove wwid");
+		goto out;
+	}
+	condlog(3, "removing line '%s' from wwids file", str);
+	fd = open_file(conf->wwids_file, &can_write, WWIDS_FILE_HEADER);
+	if (fd < 0)
+		goto out;
+	if (!can_write) {
+		condlog(0, "cannot remove wwid. wwids file is read-only");
+		goto out_file;
+	}
+	ret = do_remove_wwid(fd, str);
+
+out_file:
+	close(fd);
+out:
+	free(str);
+	return ret;
+}
+
+int
+check_wwids_file(char *wwid, int write_wwid)
+{
+	int fd, can_write, found, ret;
+	FILE *f;
+	fd = open_file(conf->wwids_file, &can_write, WWIDS_FILE_HEADER);
+	if (fd < 0)
+		return -1;
+
+	f = fdopen(fd, "r");
+	if (!f) {
+		condlog(0,"can't fdopen wwids file : %s", strerror(errno));
+		close(fd);
+		return -1;
+	}
+	found = lookup_wwid(f, wwid);
+	if (found) {
+		ret = 0;
+		goto out;
+	}
+	if (!write_wwid) {
+		ret = -1;
+		goto out;
+	}
+	if (!can_write) {
+		condlog(0, "wwids file is read-only. Can't write wwid");
+		ret = -1;
+		goto out;
+	}
+
+	if (fflush(f) != 0) {
+		condlog(0, "cannot fflush wwids file stream : %s",
+			strerror(errno));
+		ret = -1;
+		goto out;
+	}
+
+	ret = write_out_wwid(fd, wwid);
+out:
+	fclose(f);
+	return ret;
+}
+
+int
+remember_wwid(char *wwid)
+{
+	int ret = check_wwids_file(wwid, 1);
+	if (ret < 0){
+		condlog(3, "failed writing wwid %s to wwids file", wwid);
+		return -1;
+	}
+	if (ret == 1)
+		condlog(3, "wrote wwid %s to wwids file", wwid);
+	else
+		condlog(4, "wwid %s already in wwids file", wwid);
+	return 0;
+}
diff --git a/libmultipath/wwids.h b/libmultipath/wwids.h
new file mode 100644
index 0000000..f3b21fa
--- /dev/null
+++ b/libmultipath/wwids.h
@@ -0,0 +1,20 @@
+/*
+ * Copyright (c) 2010 Benjamin Marzinski, Redhat
+ */
+
+#ifndef _WWIDS_H
+#define _WWIDS_H
+
+#define WWIDS_FILE_HEADER \
+"# Multipath wwids, Version : 1.0\n" \
+"# NOTE: This file is automatically maintained by multipath and multipathd.\n" \
+"# You should not need to edit this file in normal circumstances.\n" \
+"#\n" \
+"# Valid WWIDs:\n"
+
+int remember_wwid(char *wwid);
+int check_wwids_file(char *wwid, int write_wwid);
+int remove_wwid(char *wwid);
+int replace_wwids(vector mp);
+
+#endif /* _WWIDS_H */
diff --git a/mpathpersist/Makefile b/mpathpersist/Makefile
new file mode 100644
index 0000000..2a8efe6
--- /dev/null
+++ b/mpathpersist/Makefile
@@ -0,0 +1,30 @@
+# Makefile
+#
+include ../Makefile.inc
+
+OBJS = main.o 
+
+CFLAGS += -I$(multipathdir) -I$(mpathpersistdir) 
+LDFLAGS += -lpthread -ldevmapper -L$(mpathpersistdir) -lmpathpersist -L$(multipathdir) -lmultipath 
+
+EXEC = mpathpersist
+
+all: $(EXEC)
+
+$(EXEC): $(OBJS)
+	$(CC) -g $(OBJS) -o $(EXEC) $(LDFLAGS) $(CFLAGS)
+	$(GZIP) $(EXEC).8 > $(EXEC).8.gz
+	
+install:
+	install -d $(DESTDIR)$(bindir)
+	install -m 755 $(EXEC) $(DESTDIR)$(bindir)/
+	install -d $(DESTDIR)$(mandir)
+	install -m 644 $(EXEC).8.gz $(DESTDIR)$(mandir)
+	
+clean:
+	rm -f *.o $(EXEC)
+	rm -f mpathpersist.8.gz
+
+uninstall:
+	rm $(DESTDIR)$(bindir)/$(EXEC)
+	rm $(DESTDIR)$(mandir)/$(EXEC).8.gz
diff --git a/mpathpersist/main.c b/mpathpersist/main.c
new file mode 100644
index 0000000..465fcb1
--- /dev/null
+++ b/mpathpersist/main.c
@@ -0,0 +1,816 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <fcntl.h>
+#include <checkers.h>
+#include <vector.h>
+#include <structs.h>
+#include <getopt.h>
+#include <mpath_persist.h>
+#include "main.h"
+#include <pthread.h>
+#include <ctype.h>
+#include <string.h>
+
+static const char * pr_type_strs[] = {
+	"obsolete [0]",
+	"Write Exclusive",
+	"obsolete [2]",
+	"Exclusive Access",
+	"obsolete [4]",
+	"Write Exclusive, registrants only",
+	"Exclusive Access, registrants only",
+	"Write Exclusive, all registrants",
+	"Exclusive Access, all registrants",
+	"obsolete [9]", "obsolete [0xa]", "obsolete [0xb]", "obsolete [0xc]",
+	"obsolete [0xd]", "obsolete [0xe]", "obsolete [0xf]",
+};
+
+int get_transportids_length(unsigned char * transportid_arr, int max_transportid, int num_transportids);
+void mpath_print_buf_readcap(struct prin_resp *pr_buff); 
+void mpath_print_buf_readfullstat(struct prin_resp *pr_buff);
+void mpath_print_buf_readresv(struct prin_resp *pr_buff);
+void mpath_print_buf_readkeys(struct prin_resp *pr_buff);
+void dumpHex(const char* str, int len, int no_ascii);
+void * mpath_alloc_prin_response(int prin_sa);	
+void mpath_print_transport_id(struct prin_fulldescr *fdesc);
+int construct_transportid(const char * inp, struct transportid transid[], int num_transportids);
+
+int logsink;
+unsigned int mpath_mx_alloc_len;
+
+int main (int argc, char * argv[])
+{
+	int fd, c, res;
+	const char *device_name = NULL;
+	int num_prin_sa = 0;
+	int num_prout_sa = 0;
+	int num_prout_param = 0;
+	int prin_flag = 0;
+	int prout_flag = 0;
+	int ret = 0;
+	int hex = 0;
+	uint64_t param_sark = 0;
+	unsigned int prout_type = 0;
+	int param_alltgpt = 0;
+	int param_aptpl = 0;
+	uint64_t param_rk = 0;
+	unsigned int param_rtp = 0;
+	int num_transportids = 0;
+	struct transportid transportids[MPATH_MX_TIDS];
+	int prout = 1;
+	int prin = 1;
+	int prin_sa = -1;
+	int prout_sa = -1;
+	int verbose = 0;
+	int loglevel = 0;
+	int noisy = 0;
+	int num_transport =0;
+	void *resp = NULL;
+	struct transportid * tmp; 
+
+	if (optind == argc)
+	{
+
+		fprintf (stderr, "No parameter used\n");
+		usage ();
+		exit (1);
+	}
+
+	if (getuid () != 0)
+	{
+		fprintf (stderr, "need to be root\n");
+		exit (1);
+	}
+
+
+	mpath_lib_init();
+	memset(transportids,0,MPATH_MX_TIDS);
+
+	while (1)
+	{
+		int option_index = 0;
+
+		c = getopt_long (argc, argv, "v:Cd:hHioZK:S:PAT:skrGILcRX:l:",
+				long_options, &option_index);
+		if (c == -1)
+			break;
+
+		switch (c)
+		{
+			case 'v':
+				if (1 != sscanf (optarg, "%d", &loglevel))
+				{
+					fprintf (stderr, "bad argument to '--verbose'\n");
+					return MPATH_PR_SYNTAX_ERROR;
+				}
+				break;
+
+			case 'C':
+				prout_sa = MPATH_PROUT_CLEAR_SA;
+				++num_prout_sa;
+				break;
+
+			case 'd':
+				device_name = optarg;
+				break;
+
+			case 'h':
+				usage ();
+				return 0;
+
+			case 'H':
+				hex=1;
+				break;
+
+			case 'i':
+				prin_flag = 1;
+				break;
+
+			case 'o':
+				prout_flag = 1;
+				break;
+
+			case 'Z':
+				param_aptpl = 1;
+				++num_prout_param;
+				break;
+			case 'K':
+				if (1 != sscanf (optarg, "%" SCNx64 "", &param_rk))
+				{
+					fprintf (stderr, "bad argument to '--param-rk'\n");
+					return MPATH_PR_SYNTAX_ERROR;
+				}
+				++num_prout_param;
+				break;
+
+			case 'S':
+				if (1 != sscanf (optarg, "%" SCNx64 "", &param_sark))
+				{
+					fprintf (stderr, "bad argument to '--param-sark'\n");
+					return MPATH_PR_SYNTAX_ERROR;
+				}
+				++num_prout_param;
+				break;
+
+			case 'P':
+				prout_sa = MPATH_PROUT_PREE_SA;
+				++num_prout_sa;
+				break;
+
+			case 'A':
+				prout_sa = MPATH_PROUT_PREE_AB_SA;
+				++num_prout_sa;
+				break;
+
+			case 'T':
+				if (1 != sscanf (optarg, "%x", &prout_type))
+				{
+					fprintf (stderr, "bad argument to '--prout-type'\n");
+					return MPATH_PR_SYNTAX_ERROR;
+				}
+				++num_prout_param;
+				break;
+
+			case 's':
+				prin_sa = MPATH_PRIN_RFSTAT_SA;
+				++num_prin_sa;
+				break;
+
+			case 'k':
+				prin_sa = MPATH_PRIN_RKEY_SA;
+				++num_prin_sa;
+				break;
+
+			case 'r':
+				prin_sa = MPATH_PRIN_RRES_SA;
+				++num_prin_sa;
+				break;
+
+			case 'G':
+				prout_sa = MPATH_PROUT_REG_SA;
+				++num_prout_sa;
+				break;
+
+			case 'I':
+				prout_sa = MPATH_PROUT_REG_IGN_SA;
+				++num_prout_sa;
+				break;
+
+			case 'L':
+				prout_sa = MPATH_PROUT_REL_SA;
+				++num_prout_sa;
+				break;
+
+			case 'c':
+				prin_sa = MPATH_PRIN_RCAP_SA;
+				++num_prin_sa;
+				break;
+
+			case 'R':
+				prout_sa = MPATH_PROUT_RES_SA;
+				++num_prout_sa;
+				break;
+
+			case 'X':
+				if (0 != construct_transportid(optarg, transportids, num_transport)) {
+					fprintf(stderr, "bad argument to '--transport-id'\n");
+					return MPATH_PR_SYNTAX_ERROR;
+				}
+
+				++num_transport;
+				break;
+
+			case 'l':
+                                if (1 != sscanf(optarg, "%u", &mpath_mx_alloc_len)) {
+                                        fprintf(stderr, "bad argument to '--alloc-length'\n");
+                                        return MPATH_PR_SYNTAX_ERROR;
+                                } else if (MPATH_MAX_PARAM_LEN < mpath_mx_alloc_len) {
+                                        fprintf(stderr, "'--alloc-length' argument exceeds maximum"
+                                                        " limit(%d)\n", MPATH_MAX_PARAM_LEN);
+                                        return MPATH_PR_SYNTAX_ERROR;
+                                }
+                                break;
+
+			default:
+				fprintf(stderr, "unrecognised switch " "code 0x%x ??\n", c);	
+				usage ();
+				ret = MPATH_PR_SYNTAX_ERROR;
+				goto out;
+		}
+	}
+
+	if (optind < argc)
+	{
+
+		if (NULL == device_name)
+		{
+			device_name = argv[optind];
+			++optind;
+		}
+		if (optind < argc)
+		{
+			for (; optind < argc; ++optind)
+				fprintf (stderr, "Unexpected extra argument: %s\n", argv[optind]);
+			usage ();
+			ret = MPATH_PR_SYNTAX_ERROR;
+			goto out;
+		}
+	}
+
+	/* set verbosity */
+	noisy = (loglevel >= 3) ? 1 : hex;
+	verbose	= (loglevel >= 3)? 3: loglevel;
+
+	if ((prout_flag + prin_flag) == 0)
+	{
+		fprintf (stderr, "choose either '--in' or '--out' \n");
+		usage ();
+		ret = MPATH_PR_SYNTAX_ERROR;
+		goto out;
+	}
+	if ((prout_flag + prin_flag) > 1)
+	{
+		fprintf (stderr, "choose either '--in' or '--out' \n");
+		usage ();
+		ret = MPATH_PR_SYNTAX_ERROR;
+		goto out;
+	}
+	else if (prout_flag)
+	{				/* syntax check on PROUT arguments */
+		prin = 0;
+		if ((1 != num_prout_sa) || (0 != num_prin_sa))
+		{
+			fprintf (stderr, " For Persistent Reserve Out only one "
+					"appropriate\n service action must be "
+					"chosen \n");
+			ret = MPATH_PR_SYNTAX_ERROR;
+			goto out;
+		}
+	}
+	else if (prin_flag)
+	{				/* syntax check on PRIN arguments */
+		prout = 0;
+		if (num_prout_sa > 0)
+		{
+			fprintf (stderr, " When a service action for Persistent "
+					"Reserve Out is chosen the\n"
+					" '--out' option must be given \n");
+			ret = MPATH_PR_SYNTAX_ERROR;
+			goto out;
+		}
+		if (0 == num_prin_sa)
+		{
+			fprintf (stderr,
+					" No service action given for Persistent Reserve IN\n");
+			usage();
+			ret = MPATH_PR_SYNTAX_ERROR;
+		}
+		else if (num_prin_sa > 1)
+		{
+			fprintf (stderr, " Too many service actions given; choose "
+					"one only\n");
+			usage();
+			ret = MPATH_PR_SYNTAX_ERROR;
+		}
+	}
+	else
+	{
+		usage ();
+		ret = MPATH_PR_SYNTAX_ERROR;
+		goto out;
+	}
+
+	if ((param_rtp) && (MPATH_PROUT_REG_MOV_SA != prout_sa))
+	{
+		fprintf (stderr, " --relative-target-port"
+				" only useful with --register-move\n");
+		usage ();
+		ret = MPATH_PR_SYNTAX_ERROR;
+		goto out;
+	}
+
+	if (((MPATH_PROUT_RES_SA == prout_sa) ||
+				(MPATH_PROUT_REL_SA == prout_sa) ||
+				(MPATH_PROUT_PREE_SA == prout_sa) ||
+				(MPATH_PROUT_PREE_AB_SA == prout_sa)) &&
+			(0 == prout_type)) {
+		fprintf(stderr, "Warning: --prout-type probably needs to be "
+				"given\n");
+	}
+	if ((verbose > 2) && num_transportids)
+	{
+		fprintf (stderr, "number of tranport-ids decoded from "
+				"command line : %d\n", num_transportids);
+	}
+
+	if (device_name == NULL)
+	{
+		fprintf (stderr, "No device name given \n");
+		usage ();
+		ret = MPATH_PR_SYNTAX_ERROR;
+		goto out;
+	}
+
+	/* open device */
+	if ((fd = open (device_name, O_WRONLY)) < 0)
+	{
+		fprintf (stderr, "%s: error opening file (rw) fd=%d\n",
+				device_name, fd);
+		ret = MPATH_PR_FILE_ERROR;
+		goto out;
+	}
+
+
+	if (prin)
+	{
+		resp = mpath_alloc_prin_response(prin_sa);
+		if (!resp)
+		{
+			fprintf (stderr, "failed to allocate PRIN response buffer\n");
+			ret = MPATH_PR_OTHER;
+			goto out;
+		}
+
+		ret = mpath_persistent_reserve_in (fd, prin_sa, resp, noisy, verbose);
+		if (ret != MPATH_PR_SUCCESS )
+		{
+			fprintf (stderr, "Persistent Reserve IN command failed\n");
+			goto out;	
+		}
+
+		switch(prin_sa)
+		{			
+			case MPATH_PRIN_RKEY_SA: 
+				mpath_print_buf_readkeys(resp);		
+				break;
+			case MPATH_PRIN_RRES_SA: 
+				mpath_print_buf_readresv(resp);
+				break;
+			case MPATH_PRIN_RCAP_SA:
+				mpath_print_buf_readcap(resp);		
+				break;
+			case MPATH_PRIN_RFSTAT_SA:
+				mpath_print_buf_readfullstat(resp);		
+				break;
+		}
+		free(resp);
+	}
+	else if (prout)
+	{
+		int j; 
+		struct prout_param_descriptor *paramp;
+
+		paramp= malloc(sizeof(struct prout_param_descriptor) + (sizeof(struct transportid *)*(MPATH_MX_TIDS )));
+		
+		memset(paramp, 0, sizeof(struct prout_param_descriptor) + (sizeof(struct transportid *)*(MPATH_MX_TIDS)));
+
+		for (j = 7; j >= 0; --j) {
+			paramp->key[j] = (param_rk & 0xff);
+			param_rk >>= 8;
+		}
+
+		for (j = 7; j >= 0; --j) {
+			paramp->sa_key[j] = (param_sark & 0xff);
+			param_sark >>= 8;
+		}
+
+		if (param_alltgpt)
+			paramp->sa_flags |= 0x4;
+		if (param_aptpl)
+			paramp->sa_flags |= 0x1;
+
+		if (num_transport) 
+		{
+			paramp->sa_flags |= MPATH_F_SPEC_I_PT_MASK;
+			paramp->num_transportid = num_transport;
+			for (j = 0 ; j < num_transport; j++)
+			{
+				paramp->trnptid_list[j] = (struct transportid *)malloc(sizeof(struct transportid));
+				memcpy(paramp->trnptid_list[j], &transportids[j],sizeof(struct transportid));
+			}
+		}
+
+		/* PROUT commands other than 'register and move' */
+		ret = mpath_persistent_reserve_out (fd, prout_sa, 0, prout_type,
+				paramp, noisy, verbose);
+		for (j = 0 ; j < num_transport; j++)
+		{
+			tmp = paramp->trnptid_list[j];
+			free(tmp);
+		}
+		free(paramp);
+	}
+
+	if (ret != MPATH_PR_SUCCESS)
+	{
+		switch(ret)
+		{
+			case MPATH_PR_SENSE_UNIT_ATTENTION:
+				printf("persistent reserve out: scsi status: Unit Attention\n");
+				break;
+			case MPATH_PR_RESERV_CONFLICT:
+				printf("persistent reserve out: scsi status: Reservation Conflict\n");
+				break;
+		}
+		printf("PR out: command failed\n");
+	}
+
+	res = close (fd);
+	if (res < 0)
+	{
+		mpath_lib_exit();
+		return MPATH_PR_FILE_ERROR;
+	}
+
+out :
+	mpath_lib_exit();
+
+	return (ret >= 0) ? ret : MPATH_PR_OTHER;
+}
+
+int
+get_transportids_length(unsigned char * transportid_arr, int max_transportid, int num_transportids)
+{
+	int compact_len = 0;
+	unsigned char * ucp = transportid_arr;
+	int k, off, protocol_id, len;
+	for (k = 0, off = 0; ((k < num_transportids) && (k < max_transportid));
+			++k, off += MPATH_MX_TID_LEN) {
+		protocol_id = ucp[off] & 0xf;
+		if (5 == protocol_id) {
+			len = (ucp[off + 2] << 8) + ucp[off + 3] + 4;
+			if (len < 24)
+				len = 24;
+			if (off > compact_len)
+				memmove(ucp + compact_len, ucp + off, len);
+			compact_len += len;
+
+		} else {
+			if (off > compact_len)
+				memmove(ucp + compact_len, ucp + off, 24);
+			compact_len += 24;
+		}
+	}
+
+	return compact_len;
+}
+
+void mpath_print_buf_readkeys( struct prin_resp *pr_buff)
+{
+	int i,j,k, num;
+	unsigned char *keyp;
+	uint64_t prkey;
+	printf("  PR generation=0x%x, ", pr_buff->prin_descriptor.prin_readkeys.prgeneration);
+
+	num = pr_buff->prin_descriptor.prin_readkeys.additional_length / 8;
+	if (0 == num) {
+		printf("	0 registered reservation key.\n");
+		return;
+	}
+	else if (1 == num)
+		printf("	1 registered reservation key follows:\n");
+	else
+		printf("	%d registered reservation keys follow:\n", num);
+
+
+	keyp = (unsigned char *)&pr_buff->prin_descriptor.prin_readkeys.key_list[0];
+	for (i = 0; i < num ; i++)
+	{
+		prkey = 0;
+		for (j = 0; j < 8; ++j) {
+
+			if (j > 0)
+				prkey <<= 8;
+			prkey |= keyp[j];
+		}
+		printf("    0x%" PRIx64 "\n", prkey);
+		k=8*i+j;
+		keyp = (unsigned char *)&pr_buff->prin_descriptor.prin_readkeys.key_list[k];
+	}
+}
+
+void mpath_print_buf_readresv( struct prin_resp *pr_buff)
+{
+	int j, num, scope=0, type=0;
+	unsigned char *keyp;
+	uint64_t prkey;	
+
+	num = pr_buff->prin_descriptor.prin_readresv.additional_length / 8;
+	if (0 == num)
+	{
+		printf("  PR generation=0x%x, there is NO reservation held \n", pr_buff->prin_descriptor.prin_readresv.prgeneration);
+		return ;
+	}
+	else
+		printf("  PR generation=0x%x, Reservation follows:\n", pr_buff->prin_descriptor.prin_readresv.prgeneration);
+	keyp = (unsigned  char *)&pr_buff->prin_descriptor.prin_readkeys.key_list[0]; 
+	prkey = 0;
+	for (j = 0; j < 8; ++j) {
+		if (j > 0)
+			prkey <<= 8;
+		prkey |= keyp[j];
+	}
+
+	printf("   Key = 0x%" PRIx64 "\n", prkey);
+
+	scope = (pr_buff->prin_descriptor.prin_readresv.scope_type >> 4) &  0x0f;
+	type = pr_buff->prin_descriptor.prin_readresv.scope_type & 0x0f;
+
+	if (scope == 0)	
+		printf("  scope = LU_SCOPE, type = %s", pr_type_strs[type]);
+	else
+		printf("  scope = %d, type = %s", scope, pr_type_strs[type]);
+
+	printf("\n");
+
+}
+
+void mpath_print_buf_readcap( struct prin_resp *pr_buff)
+{
+	if ( pr_buff->prin_descriptor.prin_readcap.length <= 2 ) {
+		fprintf(stderr, "Unexpected response for PRIN Report "
+				"Capabilities\n");
+		return; //MALFORMED;
+	}
+
+	printf("Report capabilities response:\n");
+
+	printf("  Compatible Reservation Handling(CRH): %d\n", !!(pr_buff->prin_descriptor.prin_readcap.flags[0] & 0x10));
+	printf("  Specify Initiator Ports Capable(SIP_C): %d\n",!!(pr_buff->prin_descriptor.prin_readcap.flags[0] & 0x8));
+	printf("  All Target Ports Capable(ATP_C): %d\n",!!(pr_buff->prin_descriptor.prin_readcap.flags[0] & 0x4 ));
+	printf("  Persist Through Power Loss Capable(PTPL_C): %d\n",!!(pr_buff->prin_descriptor.prin_readcap.flags[0]));
+	printf("  Type Mask Valid(TMV): %d\n", !!(pr_buff->prin_descriptor.prin_readcap.flags[1] & 0x80));
+	printf("  Allow Commands: %d\n", !!(( pr_buff->prin_descriptor.prin_readcap.flags[1] >> 4) & 0x7));
+	printf("  Persist Through Power Loss Active(PTPL_A): %d\n",
+			!!(pr_buff->prin_descriptor.prin_readcap.flags[1] & 0x1));
+
+	if(pr_buff->prin_descriptor.prin_readcap.flags[1] & 0x80)
+	{
+		printf("    Support indicated in Type mask:\n");
+
+		printf("      %s: %d\n", pr_type_strs[7], pr_buff->prin_descriptor.prin_readcap.pr_type_mask & 0x80);
+		printf("      %s: %d\n", pr_type_strs[6], pr_buff->prin_descriptor.prin_readcap.pr_type_mask & 0x40);
+		printf("      %s: %d\n", pr_type_strs[5], pr_buff->prin_descriptor.prin_readcap.pr_type_mask & 0x20);
+		printf("      %s: %d\n", pr_type_strs[3], pr_buff->prin_descriptor.prin_readcap.pr_type_mask & 0x8);
+		printf("      %s: %d\n", pr_type_strs[1], pr_buff->prin_descriptor.prin_readcap.pr_type_mask & 0x2);
+		printf("      %s: %d\n", pr_type_strs[8], pr_buff->prin_descriptor.prin_readcap.pr_type_mask & 0x100);
+	}
+}
+
+void mpath_print_buf_readfullstat( struct prin_resp *pr_buff)
+{
+
+	int i,j, num;
+	uint64_t  prkey;
+	uint16_t  rel_pt_addr;
+	unsigned char * keyp;
+
+	num = pr_buff->prin_descriptor.prin_readfd.number_of_descriptor;	
+	if (0 == num)
+	{
+		printf("  PR generation=0x%x \n", pr_buff->prin_descriptor.prin_readfd.prgeneration);
+		return ;
+	}
+	else
+		printf("  PR generation=0x%x \n", pr_buff->prin_descriptor.prin_readfd.prgeneration);
+
+	for (i = 0 ; i < num; i++)
+	{
+		keyp = (unsigned  char *)&pr_buff->prin_descriptor.prin_readfd.descriptors[i]->key;
+
+		prkey = 0;
+		for (j = 0; j < 8; ++j) {
+			if (j > 0)
+				prkey <<= 8;
+			prkey |= *keyp;
+			++keyp;
+		}
+		printf("   Key = 0x%" PRIx64 "\n", prkey);
+
+		if (pr_buff->prin_descriptor.prin_readfd.descriptors[i]->flag & 0x02)	
+			printf("      All target ports bit set\n");
+		else {
+			printf("      All target ports bit clear\n");
+
+			rel_pt_addr = pr_buff->prin_descriptor.prin_readfd.descriptors[i]->rtpi;
+			printf("      Relative port address: 0x%x\n",
+					rel_pt_addr);
+		}
+
+		if (pr_buff->prin_descriptor.prin_readfd.descriptors[i]->flag & 0x1) {
+			printf("      << Reservation holder >>\n");
+			j = ((pr_buff->prin_descriptor.prin_readfd.descriptors[i]->scope_type>> 4) & 0xf);
+			if (0 == j)
+				printf("      scope: LU_SCOPE, ");
+			else
+				printf("      scope: %d ", j);
+			j = (pr_buff->prin_descriptor.prin_readfd.descriptors[i]->scope_type & 0xf);
+			printf(" type: %s\n", pr_type_strs[j]);
+		} else
+			printf("      not reservation holder\n");
+		mpath_print_transport_id(pr_buff->prin_descriptor.prin_readfd.descriptors[i]);
+	}
+}
+
+static void usage()
+{
+	fprintf(stderr,
+			"Usage: mpathpersist [OPTIONS] [DEVICE]\n"
+			" Options:\n"
+			"    --verbose|-v level         verbosity level\n"
+			"                   0           Critical messages\n"
+			"                   1           Error messages\n"
+			"                   2           Warning messages\n"
+			"                   3           Informational messages\n"
+			"                   4           Informational messages with trace enabled\n"
+			"    --clear|-C                 PR Out: Clear\n"
+			"    --device=DEVICE|-d DEVICE  query or change DEVICE\n"
+			"    --help|-h                  output this usage message\n"
+			"    --hex|-H                   output response in hex\n"
+			"    --in|-i                    request PR In command \n"
+			"    --out|-o                   request PR Out command\n"
+			"    --param-aptpl|-Z           PR Out parameter 'APTPL'\n"
+			"    --read-keys|-k             PR In: Read Keys\n"
+			"    --param-sark=SARK|-S SARK  PR Out parameter service "
+			"action\n"
+			"                               reservation key (SARK is in "
+			"hex)\n"
+			"    --preempt|-P               PR Out: Preempt\n"
+			"    --preempt-abort|-A         PR Out: Preempt and Abort\n"
+			"    --prout-type=TYPE|-T TYPE  PR Out command type\n"
+			"    --read-full-status|-s      PR In: Read Full Status\n"
+			"    --read-keys|-k             PR In: Read Keys\n"
+			"    --read-reservation|-r      PR In: Read Reservation\n"
+			"    --register|-G              PR Out: Register\n"
+			"    --register-ignore|-I       PR Out: Register and Ignore\n"
+			"    --release|-L               PR Out: Release\n"
+			"    --report-capabilities|-c   PR In: Report Capabilities\n"
+			"    --reserve|-R               PR Out: Reserve\n"
+			"    --transport-id=TIDS|-X TIDS  TransportIDs can be mentioned \n"
+			"                               in several forms\n"
+			" Examples:\n"
+			"     mpathpersist --out --register --param-sark=123abc --prout-type=5 /dev/mapper/mpath9\n"
+			"     mpathpersist -i -k /dev/mapper/mpath9\n"	);
+}
+
+void
+mpath_print_transport_id(struct prin_fulldescr *fdesc)
+{
+	switch (fdesc->trnptid.protocol_id) {
+		case MPATH_PROTOCOL_ID_FC:
+			printf("   FCP-2 ");
+			if (0 != fdesc->trnptid.format_code)
+				printf(" [Unexpected format code: %d]\n", 
+						fdesc->trnptid.format_code);
+			dumpHex((const char *)fdesc->trnptid.n_port_name, 8, 0);
+			break;
+		case MPATH_PROTOCOL_ID_ISCSI:
+			printf("   iSCSI ");
+			if (0 == fdesc->trnptid.format_code) {
+				printf("name: %.*s\n", (int)sizeof(fdesc->trnptid.iscsi_name),
+					fdesc->trnptid.iscsi_name);
+			}else if (1 == fdesc->trnptid.format_code){
+				printf("world wide unique port id: %.*s\n",
+						(int)sizeof(fdesc->trnptid.iscsi_name),
+						fdesc->trnptid.iscsi_name);
+			}else {
+				printf("  [Unexpected format code: %d]\n", fdesc->trnptid.format_code);
+				dumpHex((const char *)fdesc->trnptid.iscsi_name,
+					 (int)sizeof(fdesc->trnptid.iscsi_name), 0);
+			}
+			break;
+		case MPATH_PROTOCOL_ID_SAS:
+			printf("   SAS ");
+			 if (0 != fdesc->trnptid.format_code)
+                                printf(" [Unexpected format code: %d]\n",
+                                                fdesc->trnptid.format_code);
+                        dumpHex((const char *)fdesc->trnptid.sas_address, 8, 0);
+			break;
+		default:
+			return;
+	}
+}
+
+int
+construct_transportid(const char * lcp, struct transportid transid[], int num_transportids)
+{
+	int k = 0;
+	int j, n, b, c, len, alen;
+	const char * ecp;
+	const char * isip;
+
+	if ((0 == memcmp("fcp,", lcp, 4)) ||
+			(0 == memcmp("FCP,", lcp, 4))) {
+		lcp += 4;
+		k = strspn(lcp, "0123456789aAbBcCdDeEfF");
+
+		len = strlen(lcp);
+		if (len != k) {
+			fprintf(stderr, "badly formed symbolic FCP TransportID: %s\n",
+					lcp);
+			return 1;
+		}
+		transid[num_transportids].format_code = MPATH_PROTOCOL_ID_FC;
+		transid[num_transportids].protocol_id = MPATH_WWUI_DEVICE_NAME;
+		for (k = 0, j = 0, b = 0; k < 16; ++k) {
+			c = lcp[k];
+			if (isdigit(c))
+				n = c - 0x30;
+			else if (isupper(c))
+				n = c - 0x37;
+			else
+				n = c - 0x57;
+			if (k & 1) {
+				transid[num_transportids].n_port_name[j] = b | n;
+				++j;
+			} else
+				b = n << 4;
+		}
+		goto my_cont_b;
+	}
+	if ((0 == memcmp("sas,", lcp, 4)) || (0 == memcmp("SAS,", lcp, 4))) {
+		lcp += 4;
+		k = strspn(lcp, "0123456789aAbBcCdDeEfF");
+		len =strlen(lcp);
+		if (len != k) {
+			fprintf(stderr, "badly formed symbolic SAS TransportID: %s\n",
+					lcp);
+			return 1;
+		}
+		transid[num_transportids].format_code = MPATH_PROTOCOL_ID_SAS;
+		transid[num_transportids].protocol_id = MPATH_WWUI_DEVICE_NAME;
+		memcpy(&transid[num_transportids].sas_address, lcp, 8);
+
+		goto my_cont_b;
+	}
+	if (0 == memcmp("iqn.", lcp, 4)) {
+		ecp = strpbrk(lcp, " \t");
+		isip = strstr(lcp, ",i,0x");
+		if (ecp && (isip > ecp))
+			isip = NULL;
+		len = ecp ? (ecp - lcp) : (int)strlen(lcp);
+		transid[num_transportids].format_code = (isip ? MPATH_WWUI_PORT_IDENTIFIER:MPATH_WWUI_DEVICE_NAME);
+		transid[num_transportids].protocol_id = MPATH_PROTOCOL_ID_ISCSI;
+		alen = len + 1; /* at least one trailing null */
+		if (alen < 20)
+			alen = 20;
+		else if (0 != (alen % 4))
+			alen = ((alen / 4) + 1) * 4;
+		if (alen > 241) { /* sam5r02.pdf A.2 (Annex) */
+			fprintf(stderr, "iSCSI name too long, alen=%d\n", alen);
+			return 0;
+		}
+		transid[num_transportids].iscsi_name[1] = alen & 0xff;
+		memcpy(&transid[num_transportids].iscsi_name[2], lcp, len);
+		goto my_cont_b;
+	}
+my_cont_b:
+	if (k >= MPATH_MAX_PARAM_LEN) {
+		fprintf(stderr, "build_transportid: array length exceeded\n");
+		return 1;
+	}
+	return 0;
+}
+
diff --git a/mpathpersist/main.h b/mpathpersist/main.h
new file mode 100644
index 0000000..64686ec
--- /dev/null
+++ b/mpathpersist/main.h
@@ -0,0 +1,29 @@
+static struct option long_options[] = {
+	{"verbose", 1, 0, 'v'},
+	{"clear", 0, 0, 'C'},
+	{"device", 1, 0, 'd'},
+	{"help", 0, 0, 'h'},
+	{"hex", 0, 0, 'H'},
+	{"in", 0, 0, 'i'},
+	{"out", 0, 0, 'o'},
+	{"param-aptpl", 0, 0, 'Z'},
+	{"param-rk", 1, 0, 'K'},
+	{"param-sark", 1, 0, 'S'},
+	{"preempt", 0, 0, 'P'},
+	{"preempt-abort", 0, 0, 'A'},
+	{"prout-type", 1, 0, 'T'},
+	{"read-full-status", 0, 0, 's'},
+	{"read-keys", 0, 0, 'k'},
+	{"read-reservation", 0, 0, 'r'},
+	{"register", 0, 0, 'G'},
+	{"register-ignore", 0, 0, 'I'},
+	{"release", 0, 0, 'L'},
+	{"report-capabilities", 0, 0, 'c'},		
+	{"reserve", 0, 0, 'R'},
+	{"transport-id", 1, 0, 'X'},
+	{"alloc-length", 1, 0, 'l'},
+	{0, 0, 0, 0}
+};
+
+static void usage(void);
+
diff --git a/mpathpersist/mpathpersist.8 b/mpathpersist/mpathpersist.8
new file mode 100644
index 0000000..a47a82a
--- /dev/null
+++ b/mpathpersist/mpathpersist.8
@@ -0,0 +1,96 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.39.2.
+.TH MPATHPERSIST  "8" "April 2011" "mpathpersist" "User Commands"
+.SH NAME
+mpathpersist
+.SH SYNOPSIS
+.B mpathpersist
+[\fIOPTIONS\fR] [\fIDEVICE\fR]
+.SH DESCRIPTION
+.IP
+Options:
+.TP
+\fB\-\-verbose\fR|\-v level
+verbosity level
+.TP
+0
+Critical and error messages
+.TP
+1
+Warning messages
+.TP
+2
+Informational messages
+.TP
+3
+Informational messages with trace enabled
+.TP
+\fB\-\-clear\fR|\-C
+PR Out: Clear
+.TP
+\fB\-\-device\fR=\fIDEVICE\fR|\-d DEVICE
+query or change DEVICE
+.TP
+\fB\-\-help\fR|\-h
+output this usage message
+.TP
+\fB\-\-hex\fR|\-H
+output response in hex
+.TP
+\fB\-\-in\fR|\-i
+request PR In command
+.TP
+\fB\-\-out\fR|\-o
+request PR Out command
+.TP
+\fB\-\-param\-aptpl\fR|\-Z
+PR Out parameter 'APTPL'
+.TP
+\fB\-\-read\-keys\fR|\-k
+PR In: Read Keys
+.TP
+\fB\-\-param\-sark\fR=\fISARK\fR|\-S SARK
+PR Out parameter service action
+reservation key (SARK is in hex)
+.TP
+\fB\-\-preempt\fR|\-P
+PR Out: Preempt
+.TP
+\fB\-\-preempt\-abort\fR|\-A
+PR Out: Preempt and Abort
+.TP
+\fB\-\-prout\-type\fR=\fITYPE\fR|\-T TYPE
+PR Out command type
+.TP
+\fB\-\-read\-status\fR|\-s
+PR In: Read Full Status
+.TP
+\fB\-\-read\-keys\fR|\-k
+PR In: Read Keys
+.TP
+\fB\-\-read\-reservation\fR|\-r
+PR In: Read Reservation
+.TP
+\fB\-\-register\fR|\-G
+PR Out: Register
+.TP
+\fB\-\-register\-ignore\fR|\-I
+PR Out: Register and Ignore
+.TP
+\fB\-\-release\fR|\-L
+PR Out: Release
+.TP
+\fB\-\-report\-capabilities\fR|\-c
+PR In: Report Capabilities
+.TP
+\fB\-\-reserve\fR|\-R
+PR Out: Reserve
+.TP
+\fB\-\-transport\-id\fR=\fITIDS\fR|\-X TIDS
+TransportIDs can be mentioned
+in several forms
+.IP
+Examples:
+.IP
+mpathpersist \fB\-\-out\fR \fB\-\-register\fR \fB\-\-param\-sark\fR=\fI123abc\fR \fB\-\-prout\-type\fR=\fI5\fR /dev/mapper/mpath9
+mpathpersist \fB\-i\fR \fB\-k\fR /dev/mapper/mpath9
+.PP
diff --git a/multipath.conf.annotated b/multipath.conf.annotated
index 9be7a2d..488720c 100644
--- a/multipath.conf.annotated
+++ b/multipath.conf.annotated
@@ -27,14 +27,20 @@
 #	polling_interval 10
 #
 #	#
-#	# name    : selector
+#	# name    : path_selector
 #	# scope   : multipath & multipathd
 #	# desc    : the default path selector algorithm to use
 #	#           these algorithms are offered by the kernel multipath target
-#	# values  : "round-robin 0"
-#	# default : "round-robin 0"
+#	# values  : "round-robin 0"  = Loop through every path in the path group,
+#	#                              sending the same amount of IO to each.
+#	#           "queue-length 0" = Send the next bunch of IO down the path
+#	#                              with the least amount of outstanding IO.
+#	#           "service-time 0" = Choose the path for the next bunch of IO
+#	#                              based on the amount of outstanding IO to
+#	#                              the path and its relative throughput.
+#	# default : "service-time 0"
 #	#
-#	selector	"round-robin 0"
+#	path_selector	"service-time 0"
 #
 #	#
 #	# name    : path_grouping_policy
@@ -67,7 +73,7 @@
 #	# desc    : the default function to call to obtain a path 
 #	#           priority value. The ALUA bits in SPC-3 provide an
 #	#           exploitable prio value for example.
-#	# default : (null)
+#	# default : const
 #	#
 #	prio	"alua"
 #
@@ -84,13 +90,20 @@
 #	#
 #	# name    : features
 #	# scope   : multipath & multipathd
-#	# desc    : The default extra features of multipath devices. The
-#	#           only existing feature currently is queue_if_no_path, which
-#	#           is the same as setting no_path_retry to queue.
-#	# values  : "1 queue_if_no_path"
-#	# default : (null)
-#	#
+#	# desc    : The default extra features of multipath devices.
+#	#           Syntax is "num[ feature_0 feature_1 ...]", where `num' is the
+#	#           number of features in the following (possibly empty) list of
+#	#           features.
+#	# values  : queue_if_no_path = Queue IO if no path is active; consider
+#	#                              using the `no_path_retry' keyword instead.
+#	#           no_partitions    = Disable automatic partitions generation via
+#	#                              kpartx.
+#	# default : "0"
+#	#
+#	features	"0"
 #	features	"1 queue_if_no_path"
+#	features	"1 no_partitions"
+#	features	"2 queue_if_no_path no_partitions"
 #
 #	#
 #	# name    : path_checker, checker
@@ -211,6 +224,15 @@
 #	gid disk
 #
 #	#
+#	# name    : checker_timeout
+#	# scope   : multipath & multipathd
+#	# desc    : The timeout to use for path checkers that issue scsi
+#	#           commands with an explicit timeout, in seconds.
+#	# values  : n > 0
+#	# default : taken from /sys/block/sd<x>/device/timeout
+#	checker_timeout 60
+#
+#	#
 #	# name    : fast_io_fail_tmo
 #	# scope   : multipath & multipathd
 #	# desc    : The number of seconds the scsi layer will wait after a
@@ -229,6 +251,14 @@
 #	# values  : n > 0
 #	# default : determined by the OS
 #	dev_loss_tmo 600
+#	# name    : bindings_file
+#	# scope   : multipath
+#	# desc    : The location of the bindings file that is used with
+#	#           the user_friendly_names option.
+#	# values  : <full_pathname>
+#	# default : "/var/lib/multipath/bindings"
+#	bindings_file "/etc/multipath_bindings"
+#
 #}
 #	
 ##
@@ -462,7 +492,7 @@
 #		#
 #		prio          "hp_sw"
 #
-#		#	#
+#		#
 #		# name    : prio_args
 #		# scope   : multipath & multipathd
 #		# desc    : The arguments string passed to the prio function
@@ -471,33 +501,20 @@
 #		# default : (null)
 #		#
 #		prio_args	"timeout=1000 preferredsds=foo"
-##
+#
 #		# name    : path_checker, checker
 #		# scope   : multipathd & multipathd
-#		# desc    : path checking alorithm to use to check path state
+#		# desc    : path checking algorithm to use to check path state
 #		# values  : readsector0|tur|emc_clariion|hp_sw|directio|rdac|
 #		#           cciss_tur
 #		#
 #		path_checker		directio
 #
-#		#
-#		# name    : path_selector
-#		# scope   : multipathd & multipathd
-#		# desc    : the path selector algorithm to use for this mpath
-#		#           these algo are offered by the kernel mpath target
-#		# values  : "round-robin 0"
-#		#
-#		path_selector		"round-robin 0"
+#		# as already described
+#		path_selector		"service-time 0"
 #
-#		#
-#		# name    : features
-#		# scope   : multipath & multipathd
-#		# desc    : The extra features of multipath devices. The only
-#		#           existing feature currently is queue_if_no_path,
-#		#           which is the same as setting no_path_retry to queue.
-#		# values  : "1 queue_if_no_path"
-#		#
-#		features	"1 queue_if_no_path"
+#		# as already described
+#		features	"0"
 #
 #		#
 #		# name    : hardware_handler
diff --git a/multipath.conf.defaults b/multipath.conf.defaults
index 886a678..ad32343 100644
--- a/multipath.conf.defaults
+++ b/multipath.conf.defaults
@@ -1,692 +1,898 @@
 # These are the compiled in default settings.  They will be used unless you
 # overwrite these values in your config file.
-
+ 
 #defaults {
-#	udev_dir		/dev
-#	polling_interval	5
-#	selector		"round-robin 0"
-#	path_grouping_policy	failover
-#	getuid_callout		"/lib/udev/scsi_id --whitelisted --device=/dev/%n"
-#	prio			const
-#	prio_args		""
-#	path_checker		directio
-#	rr_min_io		1000
-#	rr_weight		uniform
-#	failback		manual
-#	no_path_retry		fail
-#	user_friendly_names	no
+#	verbosity 2
+#	polling_interval 5
+#	path_selector "service-time 0"
+#	path_grouping_policy "failover"
+#	uid_attribute "ID_SERIAL"
+#	prio "const"
+#	prio_args ""
+#	features "0"
+#	path_checker "directio"
+#	alias_prefix "mpath"
+#	rr_min_io 1000
+#	rr_min_io_rq 1
+#	max_fds 1048576
+#	rr_weight "uniform"
+#	queue_without_daemon "yes"
+#	pg_timeout "none"
+#	flush_on_last_del "no"
+#	user_friendly_names "no"
+#	fast_io_fail_tmo 5
+#	bindings_file "/etc/multipath/bindings"
+#	wwids_file /etc/multipath/wwids
+#	log_checker_err always
+#	retain_attached_hw_handler no
+#	detect_prio no
 #}
-#
 #blacklist {
-#	devnode	"^(ram|raw|loop|fd|md|dm-|sr|scd|st)[0-9]*"
-#	devnode	"^hd[a-z]"
-#	devnode	"^dcssblk[0-9]*"
+#	devnode "^(ram|raw|loop|fd|md|dm-|sr|scd|st)[0-9]*"
+#	devnode "^hd[a-z]"
+#	devnode "^dcssblk[0-9]*"
+#	device {
+#		vendor "DGC"
+#		product "LUNZ"
+#	}
+#	device {
+#		vendor "EMC"
+#		product "LUNZ"
+#	}
+#	device {
+#		vendor "IBM"
+#		product "Universal Xport"
+#	}
+#	device {
+#		vendor "IBM"
+#		product "S/390.*"
+#	}
+#	device {
+#		vendor "DELL"
+#		product "Universal Xport"
+#	}
+#	device {
+#		vendor "SGI"
+#		product "Universal Xport"
+#	}
+#	device {
+#		vendor "STK"
+#		product "Universal Xport"
+#	}
+#	device {
+#		vendor "SUN"
+#		product "Universal Xport"
+#	}
+#	device {
+#		vendor "(LSI|ENGENIO)"
+#		product "Universal Xport"
+#	}
+#}
+#blacklist_exceptions {
 #}
-#
 #devices {
 #	device {
-#		vendor			"APPLE*"
-#		product			"Xserve RAID"
-#		getuid_callout		"/lib/udev/scsi_id --whitelisted --device=/dev/%n"
-#		features		"0"
-#		hardware_handler	"0"
-#		path_selector		"round-robin 0"
-#		path_grouping_policy	multibus
-#		rr_weight		uniform
-#		rr_min_io		1000
-#		path_checker		directio
-#		prio			const
-#		prio_args		""
-#	}
-#	device {
-#		vendor			"3PARdata"
-#		product			"VV"
-#		getuid_callout		"/lib/udev/scsi_id --whitelisted --device=/dev/%n"
-#		features		"0"
-#		hardware_handler	"0"
-#		path_selector		"round-robin 0"
-#		path_grouping_policy	multibus
-#		rr_weight		uniform
-#		rr_min_io		1000
-#		path_checker		directio
-#		prio			const
-#		prio_args		""
-#	}
-#	device {
-#		vendor			"DEC"
-#		product			"HSG80"
-#		getuid_callout		"/lib/udev/scsi_id --whitelisted --device=/dev/%n"
-#		features		"1 queue_if_no_path"
-#		hardware_handler	"1 hp_sw"
-#		path_selector		"round-robin 0"
-#		path_grouping_policy	multibus
-#		rr_weight		uniform
-#		rr_min_io		1000
-#		path_checker		hp_sw
-#		prio			hp_sw
-#		prio_args		""
-#	}
-#	device {
-#		vendor			"HP"
-#		product			"A6189A"
-#		getuid_callout		"/lib/udev/scsi_id --whitelisted --device=/dev/%n"
-#		features		"0"
-#		hardware_handler	"0"
-#		path_selector		"round-robin 0"
-#		path_grouping_policy	multibus
-#		rr_weight		uniform
-#		no_path_retry		12
-#		rr_min_io		1000
-#		path_checker		directio
-#		prio			const
-#		prio_args		""
-#	}
-#	device {
-#		vendor			"(COMPAQ|HP)"
-#		product			"(MSA|HSV)1.0.*"
-#		getuid_callout		"/lib/udev/scsi_id --whitelisted --device=/dev/%n"
-#		features		"1 queue_if_no_path"
-#		hardware_handler	"1 hp_sw"
-#		path_selector		"round-robin 0"
-#		path_grouping_policy	group_by_prio
-#		rr_weight		uniform
-#		no_path_retry		12
-#		rr_min_io		1000
-#		path_checker		hp_sw
-#		prio			hp_sw
-#		prio_args		""
-#	}
-#	device {
-#		vendor			"(COMPAQ|HP)"
-#		product			"MSA VOLUME"
-#		getuid_callout		"/lib/udev/scsi_id --whitelisted --device=/dev/%n"
-#		features		"0"
-#		hardware_handler	"0"
-#		path_selector		"round-robin 0"
-#		path_grouping_policy	group_by_prio
-#		failback		immediate
-#		rr_weight		uniform
-#		no_path_retry		12
-#		rr_min_io		1000
-#		path_checker		tur
-#		prio			alua
-#		prio_args		""
-#	}
-#	device {
-#		vendor			"HP"
-#		product			"MSA2000s*"
-#		getuid_callout		"/sbin/cciss_id %n"
-#		features		"0"
-#		hardware_handler	"0"
-#		path_selector		"round-robin 0"
-#		path_grouping_policy	group_by_prio
-#		failback		immediate
-#		rr_weight		uniform
-#		no_path_retry		12
-#		rr_min_io		1000
-#		path_checker		tur
-#		prio			const
-#		prio_args		""
-#	}
-#	device {
-#		vendor			"(COMPAQ|HP)"
-#		product			"HSV1[01]1|HSV2[01]0|HSV300|HSV4[05]0"
-#		getuid_callout		"/lib/udev/scsi_id --whitelisted --device=/dev/%n"
-#		features		"0"
-#		hardware_handler	"0"
-#		path_selector		"round-robin 0"
-#		path_grouping_policy	group_by_prio
-#		failback		immediate
-#		rr_weight		uniform
-#		no_path_retry		12
-#		rr_min_io		1000
-#		path_checker		tur
-#		prio			alua
-#		prio_args		""
-#	}
-#	device {
-#		vendor			"HP"
-#		product			"MSA2[02]12*"
-#		getuid_callout		"/lib/udev/scsi_id --whitelisted --device=/dev/%n"
-#		features		"0"
-#		hardware_handler	"0"
-#		path_selector		"round-robin 0"
-#		path_grouping_policy	multibus
-#		failback		immediate
-#		rr_weight		uniform
-#		no_path_retry		12
-#		rr_min_io		1000
-#		path_checker		tur
-#		prio			const
-#		prio_args		""
-#	}
-#	device {
-#		vendor			"HP"
-#		product			"LOGICAL VOLUME.*"
-#		getuid_callout		"/lib/udev/scsi_id --whitelisted --device=/dev/%n"
-#		features		"0"
-#		hardware_handler	"0"
-#		path_selector		"round-robin 0"
-#		path_grouping_policy	multibus
-#		failback		immediate
-#		rr_weight		uniform
-#		no_path_retry		12
-#		rr_min_io		1000
-#		path_checker		tur
-#		prio			const
-#		prio_args		""
-#	}
-#	device {
-#		vendor			"DDN"
-#		product			"SAN DataDirector"
-#		getuid_callout		"/lib/udev/scsi_id --whitelisted --device=/dev/%n"
-#		features		"0"
-#		hardware_handler	"0"
-#		path_selector		"round-robin 0"
-#		path_grouping_policy	multibus
-#		rr_weight		uniform
-#		rr_min_io		1000
-#		path_checker		directio
-#		prio			const
-#		prio_args		""
-#	}
-#	device {
-#		vendor			"EMC"
-#		product			"SYMMETRIX"
-#		getuid_callout		"/lib/udev/scsi_id --whitelisted --page=pre-spc3-83 --device=/dev/%n"
-#		features		"0"
-#		hardware_handler	"0"
-#		path_selector		"round-robin 0"
-#		path_grouping_policy	multibus
-#		rr_weight		uniform
-#		rr_min_io		1000
-#		path_checker		directio
-#		prio			const
-#		prio_args		""
-#	}
-#	device {
-#		vendor			"DGC"
-#		product			".*"
-#		product_blacklist	"LUNZ"
-#		getuid_callout		"/lib/udev/scsi_id --whitelisted --device=/dev/%n"
-#		features		"1 queue_if_no_path"
-#		hardware_handler	"1 emc"
-#		path_selector		"round-robin 0"
-#		path_grouping_policy	group_by_prio
-#		failback		immediate
-#		rr_weight		uniform
-#		no_path_retry		60
-#		rr_min_io		1000
-#		path_checker		emc_clariion
-#		prio			emc
-#		prio_args		""
-#	}
-#	device {
-#		vendor                  "EMC"
-#		product                 "Invista"
-#		product_blacklist       "LUNZ"
-#		getuid_callout		"/sbin/scsi_id --whitelisted --device=/dev/%n"
-#		features                "0"
-#		hardware_handler        "0"
-#		path_selector           "round-robin 0"
-#		path_grouping_policy    failover
-#		rr_weight               uniform
-#		no_path_retry           5
-#		rr_min_io               1000
-#		path_checker            tur
-#	}
-#	device {
-#		vendor			"EMC"
-#		product			"Invista"
-#		product_blacklist	"LUNZ"
-#		getuid_callout		"/lib/udev/scsi_id --whitelisted --page=pre-spc3-83 --device=/dev/%n"
-#		features		"0"
-#		hardware_handler	"0"
-#		path_selector		"round-robin 0"
-#		path_grouping_policy	multibus
-#		rr_weight		uniform
-#		no_path_retry		5
-#		rr_min_io		1000
-#		path_checker		tur
-#		prio			const
-#		prio_args		""
-#	}
-#	device {
-#		vendor			"FSC"
-#		product			"CentricStor"
-#		getuid_callout		"/lib/udev/scsi_id --whitelisted --device=/dev/%n"
-#		features		"0"
-#		hardware_handler	"0"
-#		path_selector		"round-robin 0"
-#		path_grouping_policy	group_by_serial
-#		rr_weight		uniform
-#		rr_min_io		1000
-#		path_checker		directio
-#		prio			const
-#		prio_args		""
-#	}
-#	device {
-#		vendor			"(HITACHI|HP)"
-#		product			"OPEN-.*"
-#		getuid_callout		"/lib/udev/scsi_id --whitelisted --device=/dev/%n"
-#		features		"1 queue_if_no_path"
-#		hardware_handler	"0"
-#		path_selector		"round-robin 0"
-#		path_grouping_policy	multibus
-#		rr_weight		uniform
-#		rr_min_io		100
-#		path_checker		tur
-#		prio			const
-#		prio_args		""
-#	}
-#	device {
-#		vendor			"HITACHI"
-#		product			"DF.*"
-#		getuid_callout		"/lib/udev/scsi_id --whitelisted --device=/dev/%n"
-#		features		"1 queue_if_no_path"
-#		hardware_handler	"0"
-#		path_selector		"round-robin 0"
-#		path_grouping_policy	group_by_prio
-#		failback		immediate
-#		rr_weight		uniform
-#		rr_min_io		1000
-#		path_checker		tur
-#		prio			hds
-#		prio_args		""
-#	}
-#	device {
-#		vendor			"IBM"
-#		product			"ProFibre 4000R"
-#		getuid_callout		"/lib/udev/scsi_id --whitelisted --device=/dev/%n"
-#		features		"0"
-#		hardware_handler	"0"
-#		path_selector		"round-robin 0"
-#		path_grouping_policy	multibus
-#		rr_weight		uniform
-#		rr_min_io		1000
-#		path_checker		readsector0
-#		prio			const
-#		prio_args		""
-#	}
-#	device {
-#		vendor			"IBM"
-#		product			"1722-600"
-#		getuid_callout		"/lib/udev/scsi_id --whitelisted --device=/dev/%n"
-#		features		"1 queue_if_no_path"
-#		hardware_handler	"1 rdac"
-#		path_selector		"round-robin 0"
-#		path_grouping_policy	group_by_prio
-#		failback		immediate
-#		rr_weight		uniform
-#		no_path_retry		300
-#		rr_min_io		1000
-#		path_checker		rdac
-#		prio			rdac
-#		prio_args		""
-#	}
-#	device {
-#		vendor			"IBM"
-#		product			"1742"
-#		getuid_callout		"/lib/udev/scsi_id --whitelisted --device=/dev/%n"
-#		features		"0"
-#		hardware_handler	"1 rdac"
-#		path_selector		"round-robin 0"
-#		path_grouping_policy	group_by_prio
-#		failback		immediate
-#		rr_weight		uniform
-#		no_path_retry		queue
-#		rr_min_io		1000
-#		path_checker		rdac
-#		prio			rdac
-#		prio_args		""
-#	}
-#	device {
-#		vendor			"IBM"
-#		product			"1745|1746"
-#		getuid_callout		"/lib/udev/scsi_id --whitelisted --device=/dev/%n"
-#		features		"2 pg_init_retries 50"
-#		hardware_handler	"1 rdac"
-#		path_selector		"round-robin 0"
-#		path_grouping_policy	group_by_prio
-#		failback		immediate
-#		rr_weight		uniform
-#		no_path_retry		queue
-#		rr_min_io		1000
-#		path_checker		rdac
-#		prio			rdac
-#		prio_args		""
-#	}
-#	device {
-#		vendor			"IBM"
-#		product			"1814"
-#		getuid_callout		"/lib/udev/scsi_id --whitelisted --device=/dev/%n"
-#		features		"0"
-#		hardware_handler	"1 rdac"
-#		path_selector		"round-robin 0"
-#		path_grouping_policy	group_by_prio
-#		failback		immediate
-#		rr_weight		uniform
-#		no_path_retry		queue
-#		rr_min_io		1000
-#		path_checker		rdac
-#		prio			rdac
-#		prio_args		""
-#	}
-#	device {
-#		vendor			"IBM"
-#		product			"1815"
-#		getuid_callout		"/lib/udev/scsi_id --whitelisted --device=/dev/%n"
-#		features		"0"
-#		hardware_handler	"1 rdac"
-#		path_selector		"round-robin 0"
-#		path_grouping_policy	group_by_prio
-#		failback		immediate
-#		rr_weight		uniform
-#		no_path_retry		queue
-#		rr_min_io		1000
-#		path_checker		rdac
-#		prio			rdac
-#		prio_args		""
-#	}
-#	device {
-#		vendor			"IBM"
-#		product			"3526"
-#		getuid_callout		"/lib/udev/scsi_id --whitelisted --device=/dev/%n"
-#		features		"0"
-#		hardware_handler	"1 rdac"
-#		path_selector		"round-robin 0"
-#		path_grouping_policy	group_by_prio
-#		failback		immediate
-#		rr_weight		uniform
-#		no_path_retry		queue
-#		rr_min_io		1000
-#		path_checker		rdac
-#		prio			rdac
-#		prio_args		""
-#	}
-#	device {
-#		vendor			"IBM"
-#		product			"3542"
-#		getuid_callout		"/lib/udev/scsi_id --whitelisted --device=/dev/%n"
-#		features		"0"
-#		hardware_handler	"0"
-#		path_selector		"round-robin 0"
-#		path_grouping_policy	group_by_serial
-#		rr_weight		uniform
-#		rr_min_io		1000
-#		path_checker		tur
-#		prio			const
-#		prio_args		""
-#	}
-#	device {
-#		vendor			"IBM"
-#		product			"2105(800|F20)"
-#		getuid_callout		"/lib/udev/scsi_id --whitelisted --device=/dev/%n"
-#		features		"1 queue_if_no_path"
-#		hardware_handler	"0"
-#		path_selector		"round-robin 0"
-#		path_grouping_policy	group_by_serial
-#		rr_weight		uniform
-#		rr_min_io		1000
-#		path_checker		tur
-#		prio			const
-#		prio_args		""
-#	}
-#	device {
-#		vendor			"IBM"
-#		product			"1750500"
-#		getuid_callout		"/lib/udev/scsi_id --whitelisted --device=/dev/%n"
-#		features		"1 queue_if_no_path"
-#		hardware_handler	"0"
-#		path_selector		"round-robin 0"
-#		path_grouping_policy	group_by_prio
-#		failback		immediate
-#		rr_weight		uniform
-#		rr_min_io		1000
-#		path_checker		tur
-#		prio			alua
-#		prio_args		""
-#	}
-#	device {
-#		vendor			"IBM"
-#		product			"2107900"
-#		getuid_callout		"/lib/udev/scsi_id --whitelisted --device=/dev/%n"
-#		features		"1 queue_if_no_path"
-#		hardware_handler	"0"
-#		path_selector		"round-robin 0"
-#		path_grouping_policy	multibus
-#		rr_weight		uniform
-#		rr_min_io		1000
-#		path_checker		tur
-#		prio			const
-#		prio_args		""
-#	}
-#	device {
-#		vendor			"IBM"
-#		product			"2145"
-#		getuid_callout		"/lib/udev/scsi_id --whitelisted --device=/dev/%n"
-#		features		"1 queue_if_no_path"
-#		hardware_handler	"0"
-#		path_selector		"round-robin 0"
-#		path_grouping_policy	group_by_prio
-#		failback		immediate
-#		rr_weight		uniform
-#		rr_min_io		1000
-#		path_checker		tur
-#		prio			alua
-#		prio_args		""
-#	}
-#	device {
-#		vendor			"IBM"
-#		product			"S/390 DASD ECKD"
-#		product_blacklist	"S/390.*"
-#		getuid_callout		"/sbin/dasd_id /dev/%n"
-#		features		"1 queue_if_no_path"
-#		hardware_handler	"0"
-#		path_selector		"round-robin 0"
-#		path_grouping_policy	multibus
-#		rr_weight		uniform
-#		rr_min_io		1000
-#		path_checker		directio
-#		prio			const
-#		prio_args		""
-#	}
-#	device {
-#		vendor			"NETAPP"
-#		product			"LUN.*"
-#		getuid_callout		"/lib/udev/scsi_id --whitelisted --device=/dev/%n"
-#		features		"1 queue_if_no_path"
-#		hardware_handler	"0"
-#		path_selector		"round-robin 0"
-#		path_grouping_policy	group_by_prio
-#		failback		immediate
-#		rr_weight		uniform
-#		rr_min_io		128
-#		path_checker		directio
-#		prio			netapp
-#		prio_args		""
-#	}
-#	device {
-#		vendor			"NEXENTA"
-#		product			"COMSTAR"
-#		getuid_callout		"/lib/udev/scsi_id --whitelisted --device=/dev/%n"
-#		features		"1 queue_if_no_path"
-#		hardware_handler	"0"
-#		path_selector		"round-robin 0"
-#		path_grouping_policy	group_by_serial
-#		failback		immediate
-#		rr_weight		uniform
-#		no_path_retry		30
-#		rr_min_io		128
-#		path_checker		directio
-#		prio			const
-#		prio_args		""
-#	}
-#	device {
-#		vendor			"IBM"
-#		product			"Nseries.*"
-#		getuid_callout		"/lib/udev/scsi_id --whitelisted --device=/dev/%n"
-#		features		"1 queue_if_no_path"
-#		hardware_handler	"0"
-#		path_selector		"round-robin 0"
-#		path_grouping_policy	group_by_prio
-#		failback		immediate
-#		rr_weight		uniform
-#		rr_min_io		128
-#		path_checker		directio
-#		prio			netapp
-#		prio_args		""
-#	}
-#	device {
-#		vendor			"Pillar"
-#		product			"Axiom.*"
-#		getuid_callout		"/lib/udev/scsi_id --whitelisted --device=/dev/%n"
-#		features		"0"
-#		hardware_handler	"0"
-#		path_selector		"round-robin 0"
-#		path_grouping_policy	group_by_prio
-#		rr_weight		uniform
-#		rr_min_io		1000
-#		path_checker		tur
-#		prio			alua
-#		prio_args		""
-#	}
-#	device {
-#		vendor			"SGI"
-#		product			"TP9[13]00"
-#		getuid_callout		"/lib/udev/scsi_id --whitelisted --device=/dev/%n"
-#		features		"0"
-#		hardware_handler	"0"
-#		path_selector		"round-robin 0"
-#		path_grouping_policy	multibus
-#		rr_weight		uniform
-#		rr_min_io		1000
-#		path_checker		directio
-#		prio			const
-#		prio_args		""
-#	}
-#	device {
-#		vendor			"SGI"
-#		product			"TP9[45]00"
-#		getuid_callout		"/lib/udev/scsi_id --whitelisted --device=/dev/%n"
-#		features		"0"
-#		hardware_handler	"1 rdac"
-#		path_selector		"round-robin 0"
-#		path_grouping_policy	group_by_prio
-#		failback		immediate
-#		rr_weight		uniform
-#		no_path_retry		queue
-#		rr_min_io		1000
-#		path_checker		rdac
-#		prio			rdac
-#		prio_args		""
-#	}
-#	device {
-#		vendor			"SGI"
-#		product			"IS.*"
-#		getuid_callout		"/lib/udev/scsi_id --whitelisted --device=/dev/%n"
-#		features		"0"
-#		hardware_handler	"1 rdac"
-#		path_selector		"round-robin 0"
-#		path_grouping_policy	group_by_prio
-#		failback		immediate
-#		rr_weight		uniform
-#		no_path_retry		queue
-#		rr_min_io		1000
-#		path_checker		rdac
-#		prio			rdac
-#		prio_args		""
-#	}
-#	device {
-#		vendor			"STK"
-#		product			"OPENstorage D280"
-#		getuid_callout		"/lib/udev/scsi_id --whitelisted --device=/dev/%n"
-#		features		"0"
-#		hardware_handler	"0"
-#		path_selector		"round-robin 0"
-#		path_grouping_policy	group_by_prio
-#		failback		immediate
-#		rr_weight		uniform
-#		rr_min_io		1000
-#		path_checker		tur
-#		prio			rdac
-#		prio_args		""
-#	}
-#	device {
-#		vendor			"SUN"
-#		product			"(StorEdge 3510|T4)"
-#		getuid_callout		"/lib/udev/scsi_id --whitelisted --device=/dev/%n"
-#		features		"0"
-#		hardware_handler	"0"
-#		path_selector		"round-robin 0"
-#		path_grouping_policy	multibus
-#		rr_weight		uniform
-#		rr_min_io		1000
-#		path_checker		directio
-#		prio			const
-#		prio_args		""
-#	}
-#	device {
-#		vendor			"PIVOT3"
-#		product			"RAIGE VOLUME"
-#		getuid_callout		"/lib/udev/scsi_id --whitelisted --page=0x80 --device=/dev/%n"
-#		features		"1 queue_if_no_path"
-#		hardware_handler	"0"
-#		path_selector		"round-robin 0"
-#		path_grouping_policy	multibus
-#		rr_weight		uniform
-#		rr_min_io		1000
-#		path_checker		tur
-#		prio			const
-#		prio_args		""
-#	}
-#	device {
-#		vendor			"SUN"
-#		product			"CSM200_R"
-#		getuid_callout		"/lib/udev/scsi_id --whitelisted --device=/dev/%n"
-#		features		"0"
-#		hardware_handler	"1 rdac"
-#		path_selector		"round-robin 0"
-#		path_grouping_policy	group_by_prio
-#		failback		immediate
-#		rr_weight		uniform
-#		no_path_retry		queue
-#		rr_min_io		1000
-#		path_checker		rdac
-#		prio			rdac
-#		prio_args		""
-#	}
-#	device {
-#		vendor			"SUN"
-#		product			"LCSM100_[IF]"
-#		getuid_callout		"/lib/udev/scsi_id --whitelisted --device=/dev/%n"
-#		features		"0"
-#		hardware_handler	"1 rdac"
-#		path_selector		"round-robin 0"
-#		path_grouping_policy	group_by_prio
-#		failback		immediate
-#		rr_weight		uniform
-#		no_path_retry		queue
-#		rr_min_io		1000
-#		path_checker		rdac
-#		prio			rdac
-#		prio_args		""
-#	}
-#	device {
-#		vendor			"STK"
-#		product			"FLEXLINE 380"
-#		product_blacklist	"Universal Xport"
-#		getuid_callout		"/lib/udev/scsi_id --whitelisted --device=/dev/%n"
-#		features		"0"
-#		hardware_handler	"1 rdac"
-#		path_selector		"round-robin 0"
-#		path_grouping_policy	group_by_prio
-#		failback		immediate
-#		rr_weight		uniform
-#		no_path_retry		queue
-#		rr_min_io		1000
-#		path_checker		rdac
-#		prio			rdac
-#		prio_args		""
+#		vendor "COMPELNT"
+#		product "Compellent Vol"
+#		path_grouping_policy "multibus"
+#		path_checker "tur"
+#		features "0"
+#		hardware_handler "0"
+#		prio "const"
+#		failback immediate
+#		rr_weight "uniform"
+#		no_path_retry "queue"
+#	}
+#	device {
+#		vendor "APPLE*"
+#		product "Xserve RAID "
+#		path_grouping_policy "multibus"
+#		path_checker "directio"
+#		features "0"
+#		hardware_handler "0"
+#		prio "const"
+#		rr_weight "uniform"
+#	}
+#	device {
+#		vendor "3PARdata"
+#		product "VV"
+#		path_grouping_policy "multibus"
+#		path_checker "directio"
+#		features "0"
+#		hardware_handler "0"
+#		prio "const"
+#		rr_weight "uniform"
+#	}
+#	device {
+#		vendor "DEC"
+#		product "HSG80"
+#		path_grouping_policy "group_by_prio"
+#		path_checker "hp_sw"
+#		features "1 queue_if_no_path"
+#		hardware_handler "1 hp_sw"
+#		prio "hp_sw"
+#		rr_weight "uniform"
+#	}
+#	device {
+#		vendor "HP"
+#		product "A6189A"
+#		path_grouping_policy "multibus"
+#		path_checker "directio"
+#		features "0"
+#		hardware_handler "0"
+#		prio "const"
+#		rr_weight "uniform"
+#		no_path_retry 12
+#	}
+#	device {
+#		vendor "(COMPAQ|HP)"
+#		product "(MSA|HSV)1.0.*"
+#		path_grouping_policy "group_by_prio"
+#		path_checker "hp_sw"
+#		features "1 queue_if_no_path"
+#		hardware_handler "1 hp_sw"
+#		prio "hp_sw"
+#		rr_weight "uniform"
+#		no_path_retry 12
+#		rr_min_io 100
+#	}
+#	device {
+#		vendor "(COMPAQ|HP)"
+#		product "MSA VOLUME"
+#		path_grouping_policy "group_by_prio"
+#		path_checker "tur"
+#		features "0"
+#		hardware_handler "0"
+#		prio "alua"
+#		failback immediate
+#		rr_weight "uniform"
+#		no_path_retry 12
+#		rr_min_io 100
+#	}
+#	device {
+#		vendor "(COMPAQ|HP)"
+#		product "HSV1[01]1|HSV2[01]0|HSV3[046]0|HSV4[05]0"
+#		path_grouping_policy "group_by_prio"
+#		path_checker "tur"
+#		features "0"
+#		hardware_handler "0"
+#		prio "alua"
+#		failback immediate
+#		rr_weight "uniform"
+#		no_path_retry 12
+#		rr_min_io 100
+#	}
+#	device {
+#		vendor "HP"
+#		product "MSA2[02]12fc|MSA2012i"
+#		path_grouping_policy "multibus"
+#		path_checker "tur"
+#		features "0"
+#		hardware_handler "0"
+#		prio "const"
+#		failback immediate
+#		rr_weight "uniform"
+#		no_path_retry 18
+#		rr_min_io 100
+#	}
+#	device {
+#		vendor "HP"
+#		product "MSA2012sa|MSA23(12|24)(fc|i|sa)|MSA2000s VOLUME"
+#		path_grouping_policy "group_by_prio"
+#		path_checker "tur"
+#		features "0"
+#		hardware_handler "0"
+#		prio "alua"
+#		failback immediate
+#		rr_weight "uniform"
+#		no_path_retry 18
+#		rr_min_io 100
+#	}
+#	device {
+#		vendor "HP"
+#		product "HSVX700"
+#		path_grouping_policy "group_by_prio"
+#		path_checker "tur"
+#		features "0"
+#		hardware_handler "1 alua"
+#		prio "alua"
+#		failback immediate
+#		rr_weight "uniform"
+#		no_path_retry 12
+#		rr_min_io 100
+#	}
+#	device {
+#		vendor "HP"
+#		product "LOGICAL VOLUME.*"
+#		path_grouping_policy "multibus"
+#		path_checker "tur"
+#		features "0"
+#		hardware_handler "0"
+#		prio "const"
+#		rr_weight "uniform"
+#		no_path_retry 12
+#	}
+#	device {
+#		vendor "HP"
+#		product "P2000 G3 FC|P2000G3 FC/iSCSI|P2000 G3 SAS|P2000 G3 iSCSI"
+#		path_grouping_policy "group_by_prio"
+#		path_checker "tur"
+#		features "0"
+#		hardware_handler "0"
+#		prio "alua"
+#		failback immediate
+#		rr_weight "uniform"
+#		no_path_retry 18
+#		rr_min_io 100
+#	}
+#	device {
+#		vendor "DDN"
+#		product "SAN DataDirector"
+#		path_grouping_policy "multibus"
+#		path_checker "directio"
+#		features "0"
+#		hardware_handler "0"
+#		prio "const"
+#		rr_weight "uniform"
+#	}
+#	device {
+#		vendor "EMC"
+#		product "SYMMETRIX"
+#		path_grouping_policy "multibus"
+#		path_checker "tur"
+#		features "0"
+#		hardware_handler "0"
+#		prio "const"
+#		rr_weight "uniform"
+#		no_path_retry 6
+#	}
+#	device {
+#		vendor "DGC"
+#		product ".*"
+#		product_blacklist "LUNZ"
+#		path_grouping_policy "group_by_prio"
+#		path_checker "emc_clariion"
+#		features "1 queue_if_no_path"
+#		hardware_handler "1 emc"
+#		prio "emc"
+#		failback immediate
+#		rr_weight "uniform"
+#		no_path_retry 60
+#	}
+#	device {
+#		vendor "EMC"
+#		product "Invista"
+#		product_blacklist "LUNZ"
+#		path_grouping_policy "multibus"
+#		path_checker "tur"
+#		features "0"
+#		hardware_handler "0"
+#		prio "const"
+#		rr_weight "uniform"
+#		no_path_retry 5
+#	}
+#	device {
+#		vendor "FSC"
+#		product "CentricStor"
+#		path_grouping_policy "group_by_serial"
+#		path_checker "directio"
+#		features "0"
+#		hardware_handler "0"
+#		prio "const"
+#		rr_weight "uniform"
+#	}
+#	device {
+#		vendor "FUJITSU"
+#		product "ETERNUS_DX(L|400|8000)"
+#		path_grouping_policy "group_by_prio"
+#		path_checker "tur"
+#		features "1 queue_if_no_path"
+#		hardware_handler "0"
+#		prio "alua"
+#		failback immediate
+#		rr_weight "uniform"
+#		no_path_retry 10
+#	}
+#	device {
+#		vendor "(HITACHI|HP)"
+#		product "OPEN-.*"
+#		path_grouping_policy "multibus"
+#		path_checker "tur"
+#		features "0"
+#		hardware_handler "0"
+#		prio "const"
+#		rr_weight "uniform"
+#	}
+#	device {
+#		vendor "HITACHI"
+#		product "DF.*"
+#		path_grouping_policy "group_by_prio"
+#		path_checker "tur"
+#		features "1 queue_if_no_path"
+#		hardware_handler "0"
+#		prio "hds"
+#		failback immediate
+#		rr_weight "uniform"
+#	}
+#	device {
+#		vendor "IBM"
+#		product "ProFibre 4000R"
+#		path_grouping_policy "multibus"
+#		path_checker "directio"
+#		features "0"
+#		hardware_handler "0"
+#		prio "const"
+#		rr_weight "uniform"
+#	}
+#	device {
+#		vendor "IBM"
+#		product "^1722-600"
+#		product_blacklist "Universal Xport"
+#		path_grouping_policy "group_by_prio"
+#		path_checker "rdac"
+#		features "1 queue_if_no_path"
+#		hardware_handler "1 rdac"
+#		prio "rdac"
+#		failback immediate
+#		rr_weight "uniform"
+#		no_path_retry 300
+#	}
+#	device {
+#		vendor "IBM"
+#		product "^1724"
+#		product_blacklist "Universal Xport"
+#		path_grouping_policy "group_by_prio"
+#		path_checker "rdac"
+#		features "1 queue_if_no_path"
+#		hardware_handler "1 rdac"
+#		prio "rdac"
+#		failback immediate
+#		rr_weight "uniform"
+#		no_path_retry 300
+#	}
+#	device {
+#		vendor "IBM"
+#		product "^1726"
+#		product_blacklist "Universal Xport"
+#		path_grouping_policy "group_by_prio"
+#		path_checker "rdac"
+#		features "1 queue_if_no_path"
+#		hardware_handler "1 rdac"
+#		prio "rdac"
+#		failback immediate
+#		rr_weight "uniform"
+#		no_path_retry 300
+#	}
+#	device {
+#		vendor "IBM"
+#		product "^1742"
+#		product_blacklist "Universal Xport"
+#		path_grouping_policy "group_by_prio"
+#		path_checker "rdac"
+#		features "0"
+#		hardware_handler "1 rdac"
+#		prio "rdac"
+#		failback immediate
+#		rr_weight "uniform"
+#		no_path_retry "queue"
+#	}
+#	device {
+#		vendor "IBM"
+#		product "^1745|^1746"
+#		product_blacklist "Universal Xport"
+#		path_grouping_policy "group_by_prio"
+#		path_checker "rdac"
+#		features "2 pg_init_retries 50"
+#		hardware_handler "1 rdac"
+#		prio "rdac"
+#		failback immediate
+#		rr_weight "uniform"
+#		no_path_retry 15
+#	}
+#	device {
+#		vendor "IBM"
+#		product "^1814"
+#		product_blacklist "Universal Xport"
+#		path_grouping_policy "group_by_prio"
+#		path_checker "rdac"
+#		features "0"
+#		hardware_handler "1 rdac"
+#		prio "rdac"
+#		failback immediate
+#		rr_weight "uniform"
+#		no_path_retry "queue"
+#	}
+#	device {
+#		vendor "IBM"
+#		product "^1815"
+#		product_blacklist "Universal Xport"
+#		path_grouping_policy "group_by_prio"
+#		path_checker "rdac"
+#		features "0"
+#		hardware_handler "1 rdac"
+#		prio "rdac"
+#		failback immediate
+#		rr_weight "uniform"
+#		no_path_retry "queue"
+#	}
+#	device {
+#		vendor "IBM"
+#		product "^1818"
+#		product_blacklist "Universal Xport"
+#		path_grouping_policy "group_by_prio"
+#		path_checker "rdac"
+#		features "0"
+#		hardware_handler "1 rdac"
+#		prio "rdac"
+#		failback immediate
+#		rr_weight "uniform"
+#		no_path_retry "queue"
+#	}
+#	device {
+#		vendor "IBM"
+#		product "^3526"
+#		product_blacklist "Universal Xport"
+#		path_grouping_policy "group_by_prio"
+#		path_checker "rdac"
+#		features "0"
+#		hardware_handler "1 rdac"
+#		prio "rdac"
+#		failback immediate
+#		rr_weight "uniform"
+#		no_path_retry "queue"
+#	}
+#	device {
+#		vendor "IBM"
+#		product "^3542"
+#		path_grouping_policy "group_by_serial"
+#		path_checker "tur"
+#		features "0"
+#		hardware_handler "0"
+#		prio "const"
+#		rr_weight "uniform"
+#	}
+#	device {
+#		vendor "IBM"
+#		product "^2105800"
+#		path_grouping_policy "group_by_serial"
+#		path_checker "tur"
+#		features "1 queue_if_no_path"
+#		hardware_handler "0"
+#		prio "const"
+#		rr_weight "uniform"
+#	}
+#	device {
+#		vendor "IBM"
+#		product "^2105F20"
+#		path_grouping_policy "group_by_serial"
+#		path_checker "tur"
+#		features "1 queue_if_no_path"
+#		hardware_handler "0"
+#		prio "const"
+#		rr_weight "uniform"
+#	}
+#	device {
+#		vendor "IBM"
+#		product "^1750500"
+#		path_grouping_policy "group_by_prio"
+#		path_checker "tur"
+#		features "1 queue_if_no_path"
+#		hardware_handler "0"
+#		prio "alua"
+#		failback immediate
+#		rr_weight "uniform"
+#	}
+#	device {
+#		vendor "IBM"
+#		product "^2107900"
+#		path_grouping_policy "multibus"
+#		path_checker "tur"
+#		features "1 queue_if_no_path"
+#		hardware_handler "0"
+#		prio "const"
+#		rr_weight "uniform"
+#	}
+#	device {
+#		vendor "IBM"
+#		product "^2145"
+#		path_grouping_policy "group_by_prio"
+#		path_checker "tur"
+#		features "1 queue_if_no_path"
+#		hardware_handler "0"
+#		prio "alua"
+#		failback immediate
+#		rr_weight "uniform"
+#	}
+#	device {
+#		vendor "IBM"
+#		product "S/390 DASD ECKD"
+#		product_blacklist "S/390.*"
+#		path_grouping_policy "multibus"
+#		uid_attribute "ID_UID"
+#		path_checker "directio"
+#		features "1 queue_if_no_path"
+#		hardware_handler "0"
+#		prio "const"
+#		rr_weight "uniform"
+#	}
+#	device {
+#		vendor "IBM"
+#		product "S/390 DASD FBA"
+#		product_blacklist "S/390.*"
+#		path_grouping_policy "multibus"
+#		uid_attribute "ID_UID"
+#		path_checker "directio"
+#		features "1 queue_if_no_path"
+#		hardware_handler "0"
+#		prio "const"
+#		rr_weight "uniform"
+#	}
+#	device {
+#		vendor "IBM"
+#		product "^IPR.*"
+#		path_grouping_policy "group_by_prio"
+#		path_checker "tur"
+#		features "1 queue_if_no_path"
+#		hardware_handler "1 alua"
+#		prio "alua"
+#		failback immediate
+#		rr_weight "uniform"
+#	}
+#	device {
+#		vendor "IBM"
+#		product "1820N00"
+#		path_grouping_policy "group_by_prio"
+#		path_checker "tur"
+#		features "0"
+#		hardware_handler "0"
+#		prio "alua"
+#		failback immediate
+#		rr_weight "uniform"
+#		no_path_retry "queue"
+#		rr_min_io 100
+#	}
+#	device {
+#		vendor "IBM"
+#		product "2810XIV"
+#		path_grouping_policy "multibus"
+#		path_checker "tur"
+#		features "1 queue_if_no_path"
+#		hardware_handler "0"
+#		prio "const"
+#		failback 15
+#		rr_weight "uniform"
+#		rr_min_io 15
+#	}
+#	device {
+#		vendor "AIX"
+#		product "VDASD"
+#		path_grouping_policy "multibus"
+#		path_checker "directio"
+#		features "0"
+#		hardware_handler "0"
+#		prio "const"
+#		failback immediate
+#		rr_weight "uniform"
+#		no_path_retry 60
+#	}
+#	device {
+#		vendor "IBM"
+#		product "3303      NVDISK"
+#		path_grouping_policy "failover"
+#		path_checker "tur"
+#		features "0"
+#		hardware_handler "0"
+#		prio "const"
+#		failback immediate
+#		rr_weight "uniform"
+#		no_path_retry 60
+#	}
+#	device {
+#		vendor "AIX"
+#		product "NVDISK"
+#		path_grouping_policy "group_by_prio"
+#		path_checker "tur"
+#		features "0"
+#		hardware_handler "1 alua"
+#		prio "alua"
+#		failback immediate
+#		rr_weight "uniform"
+#		no_path_retry 60
+#	}
+#	device {
+#		vendor "DELL"
+#		product "MD3000"
+#		product_blacklist "Universal Xport"
+#		path_grouping_policy "group_by_prio"
+#		path_checker "rdac"
+#		features "2 pg_init_retries 50"
+#		hardware_handler "1 rdac"
+#		prio "rdac"
+#		failback immediate
+#		rr_weight "uniform"
+#		no_path_retry 15
+#	}
+#	device {
+#		vendor "DELL"
+#		product "MD3000i"
+#		product_blacklist "Universal Xport"
+#		path_grouping_policy "group_by_prio"
+#		path_checker "rdac"
+#		features "2 pg_init_retries 50"
+#		hardware_handler "1 rdac"
+#		prio "rdac"
+#		failback immediate
+#		rr_weight "uniform"
+#		no_path_retry 15
+#	}
+#	device {
+#		vendor "DELL"
+#		product "MD32xx"
+#		product_blacklist "Universal Xport"
+#		path_grouping_policy "group_by_prio"
+#		path_checker "rdac"
+#		features "2 pg_init_retries 50"
+#		hardware_handler "1 rdac"
+#		prio "rdac"
+#		failback immediate
+#		rr_weight "uniform"
+#		no_path_retry 15
+#	}
+#	device {
+#		vendor "DELL"
+#		product "MD32xxi"
+#		product_blacklist "Universal Xport"
+#		path_grouping_policy "group_by_prio"
+#		path_checker "rdac"
+#		features "2 pg_init_retries 50"
+#		hardware_handler "1 rdac"
+#		prio "rdac"
+#		failback immediate
+#		rr_weight "uniform"
+#		no_path_retry 15
+#	}
+#	device {
+#		vendor "NETAPP"
+#		product "LUN.*"
+#		path_grouping_policy "group_by_prio"
+#		path_checker "tur"
+#		features "3 queue_if_no_path pg_init_retries 50"
+#		hardware_handler "0"
+#		prio "ontap"
+#		failback immediate
+#		rr_weight "uniform"
+#		rr_min_io 128
+#		flush_on_last_del "yes"
+#		dev_loss_tmo "infinity"
+#		retain_attached_hw_handler yes
+#		detect_prio yes
+#	}
+#	device {
+#		vendor "NEXENTA"
+#		product "COMSTAR"
+#		path_grouping_policy "group_by_serial"
+#		path_checker "directio"
+#		features "1 queue_if_no_path"
+#		hardware_handler "0"
+#		prio "const"
+#		failback immediate
+#		rr_weight "uniform"
+#		no_path_retry 30
+#		rr_min_io 128
+#	}
+#	device {
+#		vendor "IBM"
+#		product "Nseries.*"
+#		path_grouping_policy "group_by_prio"
+#		path_checker "directio"
+#		features "1 queue_if_no_path"
+#		hardware_handler "0"
+#		prio "ontap"
+#		failback immediate
+#		rr_weight "uniform"
+#		rr_min_io 128
+#	}
+#	device {
+#		vendor "Pillar"
+#		product "Axiom.*"
+#		path_grouping_policy "group_by_prio"
+#		path_checker "tur"
+#		features "0"
+#		hardware_handler "0"
+#		prio "alua"
+#		rr_weight "uniform"
+#	}
+#	device {
+#		vendor "SGI"
+#		product "TP9[13]00"
+#		path_grouping_policy "multibus"
+#		path_checker "directio"
+#		features "0"
+#		hardware_handler "0"
+#		prio "const"
+#		rr_weight "uniform"
+#	}
+#	device {
+#		vendor "SGI"
+#		product "TP9[45]00"
+#		product_blacklist "Universal Xport"
+#		path_grouping_policy "group_by_prio"
+#		path_checker "rdac"
+#		features "0"
+#		hardware_handler "1 rdac"
+#		prio "rdac"
+#		failback immediate
+#		rr_weight "uniform"
+#		no_path_retry "queue"
+#	}
+#	device {
+#		vendor "SGI"
+#		product "IS.*"
+#		product_blacklist "Universal Xport"
+#		path_grouping_policy "group_by_prio"
+#		path_checker "rdac"
+#		features "2 pg_init_retries 50"
+#		hardware_handler "1 rdac"
+#		prio "rdac"
+#		failback immediate
+#		rr_weight "uniform"
+#		no_path_retry 15
+#	}
+#	device {
+#		vendor "NEC"
+#		product "DISK ARRAY"
+#		path_grouping_policy "group_by_prio"
+#		path_checker "tur"
+#		features "0"
+#		hardware_handler "1 alua"
+#		prio "alua"
+#		failback immediate
+#		rr_weight "uniform"
+#	}
+#	device {
+#		vendor "STK"
+#		product "OPENstorage D280"
+#		product_blacklist "Universal Xport"
+#		path_grouping_policy "group_by_prio"
+#		path_checker "tur"
+#		features "0"
+#		hardware_handler "1 rdac"
+#		prio "rdac"
+#		failback immediate
+#		rr_weight "uniform"
+#	}
+#	device {
+#		vendor "SUN"
+#		product "(StorEdge 3510|T4)"
+#		path_grouping_policy "multibus"
+#		path_checker "directio"
+#		features "0"
+#		hardware_handler "0"
+#		prio "const"
+#		rr_weight "uniform"
+#	}
+#	device {
+#		vendor "SUN"
+#		product "STK6580_6780"
+#		path_grouping_policy "group_by_prio"
+#		path_checker "tur"
+#		features "0"
+#		hardware_handler "1 rdac"
+#		prio "rdac"
+#		failback immediate
+#		rr_weight "uniform"
+#	}
+#	device {
+#		vendor "EUROLOGC"
+#		product "FC2502"
+#		path_grouping_policy "group_by_prio"
+#		path_checker "directio"
+#		features "0"
+#		hardware_handler "0"
+#		prio "const"
+#		rr_weight "uniform"
+#	}
+#	device {
+#		vendor "PIVOT3"
+#		product "RAIGE VOLUME"
+#		path_grouping_policy "multibus"
+#		path_checker "tur"
+#		features "1 queue_if_no_path"
+#		hardware_handler "0"
+#		prio "const"
+#		rr_weight "uniform"
+#		rr_min_io 100
+#	}
+#	device {
+#		vendor "SUN"
+#		product "CSM200_R"
+#		product_blacklist "Universal Xport"
+#		path_grouping_policy "group_by_prio"
+#		path_checker "rdac"
+#		features "0"
+#		hardware_handler "1 rdac"
+#		prio "rdac"
+#		failback immediate
+#		rr_weight "uniform"
+#		no_path_retry "queue"
+#	}
+#	device {
+#		vendor "SUN"
+#		product "LCSM100_[IEFS]"
+#		product_blacklist "Universal Xport"
+#		path_grouping_policy "group_by_prio"
+#		path_checker "rdac"
+#		features "0"
+#		hardware_handler "1 rdac"
+#		prio "rdac"
+#		failback immediate
+#		rr_weight "uniform"
+#		no_path_retry "queue"
+#	}
+#	device {
+#		vendor "SUN"
+#		product "SUN_6180"
+#		path_grouping_policy "group_by_prio"
+#		path_checker "rdac"
+#		features "0"
+#		hardware_handler "1 rdac"
+#		prio "rdac"
+#		failback immediate
+#		rr_weight "uniform"
+#		no_path_retry "queue"
+#		rr_min_io 1000
+#		rr_min_io_rq 1
+#	}
+#	device {
+#		vendor "(LSI|ENGENIO)"
+#		product "INF-01-00"
+#		product_blacklist "Universal Xport"
+#		path_grouping_policy "group_by_prio"
+#		path_checker "rdac"
+#		features "2 pg_init_retries 50"
+#		hardware_handler "1 rdac"
+#		prio "rdac"
+#		failback immediate
+#		rr_weight "uniform"
+#		no_path_retry 15
+#	}
+#	device {
+#		vendor "STK"
+#		product "FLEXLINE 380"
+#		product_blacklist "Universal Xport"
+#		path_grouping_policy "group_by_prio"
+#		path_checker "rdac"
+#		features "0"
+#		hardware_handler "1 rdac"
+#		prio "rdac"
+#		failback immediate
+#		rr_weight "uniform"
+#		no_path_retry "queue"
+#	}
+#	device {
+#		vendor "Intel"
+#		product "Multi-Flex"
+#		path_grouping_policy "group_by_prio"
+#		path_checker "tur"
+#		features "0"
+#		hardware_handler "1 alua"
+#		prio "alua"
+#		failback immediate
+#		rr_weight "uniform"
+#		no_path_retry "queue"
+#	}
+#	device {
+#		vendor "DataCore"
+#		product "SANmelody"
+#		path_grouping_policy "group_by_prio"
+#		path_checker "tur"
+#		features "0"
+#		hardware_handler "0"
+#		prio "alua"
+#		failback immediate
+#		rr_weight "uniform"
+#		no_path_retry "queue"
 #	}
 #}
+#multipaths {
+#}
diff --git a/multipath.conf.synthetic b/multipath.conf.synthetic
index 44d1329..bda1b75 100644
--- a/multipath.conf.synthetic
+++ b/multipath.conf.synthetic
@@ -5,7 +5,7 @@
 #defaults {
 #	udev_dir		/dev
 #	polling_interval 	10
-#	selector		"round-robin 0"
+#	path_selector		"round-robin 0"
 #	path_grouping_policy	multibus
 #	getuid_callout		"/lib/udev/scsi_id --whitelisted --device=/dev/%n"
 #	prio			const
diff --git a/multipath/Makefile b/multipath/Makefile
index 5cbab2f..593c78d 100644
--- a/multipath/Makefile
+++ b/multipath/Makefile
@@ -7,7 +7,7 @@ include ../Makefile.inc
 OBJS = main.o
 
 CFLAGS += -I$(multipathdir)
-LDFLAGS += -lpthread -ldevmapper -ldl -lmultipath -L$(multipathdir)
+LDFLAGS += -lpthread -ldevmapper -ldl -L$(multipathdir) -lmultipath
 
 EXEC = multipath
 
@@ -21,15 +21,12 @@ $(EXEC): $(OBJS)
 install:
 	$(INSTALL_PROGRAM) -d $(DESTDIR)$(bindir)
 	$(INSTALL_PROGRAM) -m 755 $(EXEC) $(DESTDIR)$(bindir)/
-	$(INSTALL_PROGRAM) -d $(DESTDIR)/etc/udev/rules.d
-	$(INSTALL_PROGRAM) -m 644 multipath.rules $(DESTDIR)/etc/udev/rules.d/
 	$(INSTALL_PROGRAM) -d $(DESTDIR)$(mandir)
 	$(INSTALL_PROGRAM) -m 644 $(EXEC).8.gz $(DESTDIR)$(mandir)
 	$(INSTALL_PROGRAM) -d $(DESTDIR)$(man5dir)
 	$(INSTALL_PROGRAM) -m 644 $(EXEC).conf.5.gz $(DESTDIR)$(man5dir)
 
 uninstall:
-	rm $(DESTDIR)/etc/udev/rules.d/multipath.rules
 	rm $(DESTDIR)$(bindir)/$(EXEC)
 	rm $(DESTDIR)$(mandir)/$(EXEC).8.gz
 	rm $(DESTDIR)$(man5dir)/$(EXEC).conf.5.gz
diff --git a/multipath/dev_t.h b/multipath/dev_t.h
index 90c64f3..aa80d5e 100644
--- a/multipath/dev_t.h
+++ b/multipath/dev_t.h
@@ -1,15 +1,3 @@
-#define MINORBITS       20
-#define MINORMASK       ((1U << MINORBITS) - 1)
-
-#define MAJOR(dev)      ((unsigned int) ((dev) >> MINORBITS))
-#define MINOR(dev)      ((unsigned int) ((dev) & MINORMASK))
-#define MKDEV(ma,mi)    (((ma) << MINORBITS) | (mi))
-
-#define print_dev_t(buffer, dev)                                        \
-	sprintf((buffer), "%u:%u\n", MAJOR(dev), MINOR(dev))
-
-#define format_dev_t(buffer, dev)                                       \
-	({                                                              \
-		sprintf(buffer, "%u:%u", MAJOR(dev), MINOR(dev));       \
-		buffer;                                                 \
-	})
+#define MAJOR(dev)      ((dev & 0xfff00) >> 8)
+#define MINOR(dev)      ((dev & 0xff) | ((dev >> 12) & 0xfff00))
+#define MKDEV(ma,mi)    ((mi & 0xff) | (ma << 8) | ((mi & ~0xff) << 12))
diff --git a/multipath/main.c b/multipath/main.c
index 1689efd..f1b3ec9 100644
--- a/multipath/main.c
+++ b/multipath/main.c
@@ -22,6 +22,8 @@
  * Copyright (c) 2005 Edward Goggin, EMC
  */
 
+#include <sys/types.h>
+#include <sys/stat.h>
 #include <stdio.h>
 #include <unistd.h>
 #include <ctype.h>
@@ -51,6 +53,8 @@
 #include <errno.h>
 #include <sys/time.h>
 #include <sys/resource.h>
+#include <wwids.h>
+#include "dev_t.h"
 
 int logsink;
 
@@ -79,9 +83,10 @@ usage (char * progname)
 {
 	fprintf (stderr, VERSION_STRING);
 	fprintf (stderr, "Usage:\n");
-	fprintf (stderr, "  %s [-d] [-r] [-v lvl] [-p pol] [-b fil] [dev]\n", progname);
+	fprintf (stderr, "  %s [-c|-w|-W] [-d] [-r] [-v lvl] [-p pol] [-b fil] [-q] [dev]\n", progname);
 	fprintf (stderr, "  %s -l|-ll|-f [-v lvl] [-b fil] [dev]\n", progname);
 	fprintf (stderr, "  %s -F [-v lvl]\n", progname);
+	fprintf (stderr, "  %s -t\n", progname);
 	fprintf (stderr, "  %s -h\n", progname);
 	fprintf (stderr,
 		"\n"
@@ -91,10 +96,16 @@ usage (char * progname)
 		"  -ll     show multipath topology (maximum info)\n" \
 		"  -f      flush a multipath device map\n" \
 		"  -F      flush all multipath device maps\n" \
+		"  -c      check if a device should be a path in a multipath device\n" \
+		"  -q      allow queue_if_no_path when multipathd is not running\n"\
 		"  -d      dry run, do not create or update devmaps\n" \
+		"  -t      dump internal hardware table\n" \
 		"  -r      force devmap reload\n" \
+		"  -B      treat the bindings file as read only\n" \
 		"  -p      policy failover|multibus|group_by_serial|group_by_prio\n" \
 		"  -b fil  bindings file location\n" \
+		"  -w      remove a device from the wwids file\n" \
+		"  -W      reset the wwids file include only the current devices\n" \
 		"  -p pol  force all maps to specified path grouping policy :\n" \
 		"          . failover            one path per priority group\n" \
 		"          . multibus            all paths in one priority group\n" \
@@ -113,7 +124,6 @@ usage (char * progname)
 		"          . multipath including the path with maj:min 'dev' (ex: 8:0)\n" \
 		);
 
-	exit(1);
 }
 
 static int
@@ -132,11 +142,12 @@ update_paths (struct multipath * mpp)
 
 		vector_foreach_slot (pgp->paths, pp, j) {
 			if (!strlen(pp->dev)) {
-				if (devt2devname(pp->dev, pp->dev_t)) {
+				if (devt2devname(pp->dev, FILE_NAME_SIZE,
+						 pp->dev_t)) {
 					/*
 					 * path is not in sysfs anymore
 					 */
-					pp->state = PATH_DOWN;
+					pp->chkrstate = pp->state = PATH_DOWN;
 					continue;
 				}
 				pp->mpp = mpp;
@@ -160,6 +171,7 @@ get_dm_mpvec (vector curmp, vector pathvec, char * refwwid)
 {
 	int i;
 	struct multipath * mpp;
+	char params[PARAMS_SIZE], status[PARAMS_SIZE];
 
 	if (dm_get_maps(curmp))
 		return 1;
@@ -177,10 +189,12 @@ get_dm_mpvec (vector curmp, vector pathvec, char * refwwid)
 			continue;
 		}
 
-		condlog(3, "params = %s", mpp->params);
-		condlog(3, "status = %s", mpp->status);
+		dm_get_map(mpp->alias, &mpp->size, params);
+		condlog(3, "params = %s", params);
+		dm_get_status(mpp->alias, status);
+		condlog(3, "status = %s", status);
 
-		disassemble_map(pathvec, mpp->params, mpp);
+		disassemble_map(pathvec, params, mpp);
 
 		/*
 		 * disassemble_map() can add new paths to pathvec.
@@ -193,7 +207,7 @@ get_dm_mpvec (vector curmp, vector pathvec, char * refwwid)
 		if (conf->list > 1)
 			mpp->bestpg = select_path_group(mpp);
 
-		disassemble_status(mpp->status, mpp);
+		disassemble_status(status, mpp);
 
 		if (conf->list)
 			print_multipath_topology(mpp, conf->verbosity);
@@ -245,29 +259,53 @@ configure (void)
 		else
 			dev = conf->dev;
 	}
-	
+
 	/*
 	 * if we have a blacklisted device parameter, exit early
 	 */
-	if (dev && 
-	    (filter_devnode(conf->blist_devnode, conf->elist_devnode, dev) > 0))
-			goto out;
-	
+	if (dev && conf->dev_type == DEV_DEVNODE && conf->dry_run != 3 &&
+	    (filter_devnode(conf->blist_devnode,
+			    conf->elist_devnode, dev) > 0)) {
+		if (conf->dry_run == 2)
+			printf("%s is not a valid multipath device path\n",
+			       conf->dev);
+		goto out;
+	}
 	/*
 	 * scope limiting must be translated into a wwid
 	 * failing the translation is fatal (by policy)
 	 */
 	if (conf->dev) {
-		refwwid = get_refwwid(conf->dev, conf->dev_type, pathvec);
-
+		int failed = get_refwwid(conf->dev, conf->dev_type, pathvec,
+					 &refwwid);
 		if (!refwwid) {
-			condlog(3, "scope is nul");
+			if (failed == 2 && conf->dry_run == 2)
+				printf("%s is not a valid multipath device path\n", conf->dev);
+			else
+				condlog(3, "scope is nul");
+			goto out;
+		}
+		if (conf->dry_run == 3) {
+			r = remove_wwid(refwwid);
+			if (r == 0)
+				printf("wwid '%s' removed\n", refwwid);
+			else if (r == 1) {
+				printf("wwid '%s' not in wwids file\n",
+					refwwid);
+				r = 0;
+			}
 			goto out;
 		}
 		condlog(3, "scope limited to %s", refwwid);
-		if (filter_wwid(conf->blist_wwid, conf->elist_wwid,
-				refwwid) > 0)
+		if (conf->dry_run == 2) {
+			if (check_wwids_file(refwwid, 0) == 0){
+				printf("%s is a valid multipath device path\n", conf->dev);
+				r = 0;
+			}
+			else
+				printf("%s is not a valid multipath device path\n", conf->dev);
 			goto out;
+		}
 	}
 
 	/*
@@ -319,13 +357,88 @@ out:
 	return r;
 }
 
+static int
+dump_config (void)
+{
+	char * c;
+	char * reply;
+	unsigned int maxlen = 256;
+	int again = 1;
+
+	reply = MALLOC(maxlen);
+
+	while (again) {
+		if (!reply)
+			return 1;
+		c = reply;
+		c += snprint_defaults(c, reply + maxlen - c);
+		again = ((c - reply) == maxlen);
+		if (again) {
+			reply = REALLOC(reply, maxlen *= 2);
+			continue;
+		}
+		c += snprint_blacklist(c, reply + maxlen - c);
+		again = ((c - reply) == maxlen);
+		if (again) {
+			reply = REALLOC(reply, maxlen *= 2);
+			continue;
+		}
+		c += snprint_blacklist_except(c, reply + maxlen - c);
+		again = ((c - reply) == maxlen);
+		if (again) {
+			reply = REALLOC(reply, maxlen *= 2);
+			continue;
+		}
+		c += snprint_hwtable(c, reply + maxlen - c, conf->hwtable);
+		again = ((c - reply) == maxlen);
+		if (again) {
+			reply = REALLOC(reply, maxlen *= 2);
+			continue;
+		}
+		c += snprint_mptable(c, reply + maxlen - c, conf->mptable);
+		again = ((c - reply) == maxlen);
+		if (again)
+			reply = REALLOC(reply, maxlen *= 2);
+	}
+
+	printf("%s", reply);
+	FREE(reply);
+	return 0;
+}
+
+static int
+get_dev_type(char *dev) {
+	struct stat buf;
+	int i;
+
+	if (stat(dev, &buf) == 0 && S_ISBLK(buf.st_mode)) {
+		if (dm_is_dm_major(MAJOR(buf.st_rdev)))
+			return DEV_DEVMAP;
+		return DEV_DEVNODE;
+	}
+	else if (sscanf(dev, "%d:%d", &i, &i) == 2)
+		return DEV_DEVT;
+	else
+		return DEV_DEVMAP;
+}
+
+static void
+convert_dev(char *dev)
+{
+	char *ptr = strstr(dev, "cciss/");
+	if (ptr) {
+		ptr += 5;
+		*ptr = '!';
+	}
+}
+
 int
 main (int argc, char *argv[])
 {
 	int arg;
 	extern char *optarg;
 	extern int optind;
-	int i, r = 1;
+	int r = 1;
 
 	if (getuid() != 0) {
 		fprintf(stderr, "need to be root\n");
@@ -338,34 +451,34 @@ main (int argc, char *argv[])
 	if (load_config(DEFAULT_CONFIGFILE))
 		exit(1);
 
-	if (init_checkers()) {
-		condlog(0, "failed to initialize checkers");
-		exit(1);
-	}
-	if (init_prio()) {
-		condlog(0, "failed to initialize prioritizers");
-		exit(1);
-	}
-	if (sysfs_init(conf->sysfs_dir, FILE_NAME_SIZE)) {
-		condlog(0, "multipath tools need sysfs mounted");
-		exit(1);
-	}
-	while ((arg = getopt(argc, argv, ":dhl::FfM:v:p:b:r")) != EOF ) {
+	while ((arg = getopt(argc, argv, ":dchl::FfM:v:p:b:BrtqwW")) != EOF ) {
 		switch(arg) {
 		case 1: printf("optarg : %s\n",optarg);
 			break;
 		case 'v':
 			if (sizeof(optarg) > sizeof(char *) ||
-			    !isdigit(optarg[0]))
+			    !isdigit(optarg[0])) {
 				usage (argv[0]);
+				exit(1);
+			}
 
 			conf->verbosity = atoi(optarg);
 			break;
 		case 'b':
-			conf->bindings_file = optarg;
+			conf->bindings_file = strdup(optarg);
+			break;
+		case 'B':
+			conf->bindings_read_only = 1;
+			break;
+		case 'q':
+			conf->allow_queueing = 1;
+			break;
+		case 'c':
+			conf->dry_run = 2;
 			break;
 		case 'd':
-			conf->dry_run = 1;
+			if (!conf->dry_run)
+				conf->dry_run = 1;
 			break;
 		case 'f':
 			conf->remove = FLUSH_ONE;
@@ -391,23 +504,37 @@ main (int argc, char *argv[])
 			if (conf->pgpolicy_flag == -1) {
 				printf("'%s' is not a valid policy\n", optarg);
 				usage(argv[0]);
-			}                
+				exit(1);
+			}
 			break;
 		case 'r':
 			conf->force_reload = 1;
 			break;
+		case 't':
+			r = dump_config();
+			goto out;
 		case 'h':
 			usage(argv[0]);
+			exit(0);
+		case 'w':
+			conf->dry_run = 3;
+			break;
+		case 'W':
+			conf->dry_run = 4;
+			break;
 		case ':':
-			fprintf(stderr, "Missing option arguement\n");
-			usage(argv[0]);        
+			fprintf(stderr, "Missing option argument\n");
+			usage(argv[0]);
+			exit(1);
 		case '?':
 			fprintf(stderr, "Unknown switch: %s\n", optarg);
 			usage(argv[0]);
+			exit(1);
 		default:
 			usage(argv[0]);
+			exit(1);
 		}
-	}        
+	}
 	if (optind < argc) {
 		conf->dev = MALLOC(FILE_NAME_SIZE);
 
@@ -415,14 +542,9 @@ main (int argc, char *argv[])
 			goto out;
 
 		strncpy(conf->dev, argv[optind], FILE_NAME_SIZE);
-
-		if (filepresent(conf->dev))
-			conf->dev_type = DEV_DEVNODE;
-		else if (sscanf(conf->dev, "%d:%d", &i, &i) == 2)
-			conf->dev_type = DEV_DEVT;
-		else
-			conf->dev_type = DEV_DEVMAP;
-
+		conf->dev_type = get_dev_type(conf->dev);
+		if (conf->dev_type == DEV_DEVNODE)
+			convert_dev(conf->dev);
 	}
 	conf->daemon = 0;
 
@@ -432,16 +554,54 @@ main (int argc, char *argv[])
 		fd_limit.rlim_cur = conf->max_fds;
 		fd_limit.rlim_max = conf->max_fds;
 		if (setrlimit(RLIMIT_NOFILE, &fd_limit) < 0)
-			condlog(0, "can't set open fds limit to %d : %s\n",
+			condlog(0, "can't set open fds limit to %d : %s",
 				conf->max_fds, strerror(errno));
 	}
 
+	if (init_checkers()) {
+		condlog(0, "failed to initialize checkers");
+		exit(1);
+	}
+	if (init_prio()) {
+		condlog(0, "failed to initialize prioritizers");
+		exit(1);
+	}
 	dm_init();
 
+	if (conf->dry_run == 2 &&
+	    (!conf->dev || conf->dev_type == DEV_DEVMAP)) {
+		condlog(0, "the -c option requires a path to check");
+		goto out;
+	}
+	if (conf->dry_run == 3 && !conf->dev) {
+		condlog(0, "the -w option requires a device");
+		goto out;
+	}
+	if (conf->dry_run == 4) {
+		struct multipath * mpp;
+		int i;
+		vector curmp;
+
+		curmp = vector_alloc();
+		if (!curmp) {
+			condlog(0, "can't allocate memory for mp list");
+			goto out;
+		}
+		if (dm_get_maps(curmp) == 0)
+			r = replace_wwids(curmp);
+		if (r == 0)
+			printf("successfully reset wwids\n");
+		vector_foreach_slot_backwards(curmp, mpp, i) {
+			vector_del_slot(curmp, i);
+			free_multipath(mpp, KEEP_PATHS);
+		}
+		vector_free(curmp);
+		goto out;
+	}
 	if (conf->remove == FLUSH_ONE) {
-		if (conf->dev_type == DEV_DEVMAP)
-			r = dm_flush_map(conf->dev);
-		else
+		if (conf->dev_type == DEV_DEVMAP) {
+			r = dm_suspend_and_flush_map(conf->dev);
+		} else
 			condlog(0, "must provide a map name to remove");
 
 		goto out;
@@ -452,11 +612,10 @@ main (int argc, char *argv[])
 	}
 	while ((r = configure()) < 0)
 		condlog(3, "restart multipath configuration process");
-	
+
 out:
-	dm_udev_wait(conf->cookie);
+	udev_wait(conf->cookie);
 
-	sysfs_cleanup();
 	dm_lib_release();
 	dm_lib_exit();
 
diff --git a/multipath/multipath.8 b/multipath/multipath.8
index 7ba7126..a2262ac 100644
--- a/multipath/multipath.8
+++ b/multipath/multipath.8
@@ -5,14 +5,16 @@ multipath \- Device mapper target autoconfig
 .B multipath
 .RB [\| \-v\ \c
 .IR verbosity \|]
+.RB [\| \-b\ \c
+.IR bindings_file \|]
 .RB [\| \-d \|]
-.RB [\| \-h | \-l | \-ll | \-f | \-F \|]
+.RB [\| \-h | \-l | \-ll | \-f | \-t | \-F | \-B | \-c | \-q | \|-r | \-w | \-W \|]
 .RB [\| \-p\ \c
 .BR failover | multibus | group_by_serial | group_by_prio | group_by_node_name \|]
 .RB [\| device \|]
 .SH DESCRIPTION
 .B multipath
-is used to detect multiple paths to devices for fail-over or performance reasons and coalesces them
+is used to detect and coalesce multiple paths to devices, for fail-over or performance reasons.
 .SH OPTIONS
 .TP
 .B \-v " level"
@@ -47,8 +49,33 @@ flush a multipath device map specified as parameter, if unused
 .B \-F
 flush all unused multipath device maps
 .TP
+.B \-t
+print internal hardware table to stdout
+.TP
+.B \-r
+force devmap reload
+.TP
+.B \-B
+treat the bindings file as read only
+.TP
+.B \-b " bindings_file"
+set user_friendly_names bindings file location.  The default is
+/etc/multipath/bindings
+.TP
+.B \-c
+check if a block device should be a path in a multipath device
+.TP
+.B \-q
+allow device tables with queue_if_no_path when multipathd is not running
+.TP
+.B \-w
+remove the wwid for the specified device from the wwids file
+.TP
+.B \-W
+reset the wwids file to only include the current multipath devices
+.TP
 .BI \-p " policy"
-force maps to specified policy:
+force new maps to use the specified policy:
 .RS 1.2i
 .TP 1.2i
 .B failover
@@ -64,18 +91,30 @@ all paths in 1 priority group
 1 priority group per priority value. Priorities are determined by callout programs specified as a global, per-controller or per-multipath option in the configuration file
 .TP
 .B group_by_node_name
-1 priority group per target node name. Target node names are fetched in /sys/class/fc_transport/target*/node_name.
+1 priority group per target node name. Target node names are fetched
+in /sys/class/fc_transport/target*/node_name.
+.TP
 .RE
+Existing maps are not modified.
 .TP
 .BI device
-update only the devmap the path pointed by
-.I device
-is in. 
-.I device
-is in the /dev/sdb (as shown by udev in the $DEVNAME variable) or major:minor format.
-.I device
-may alternatively be a multipath mapname
+update only the devmap specified by
+.IR device ,
+which is either:
+.RS 1.2i
+.IP \[bu]
+a devmap name
+.IP \[bu]
+a path associated with the desired devmap; the path may be in one of the following formats:
+.RS 1.2i
+.IP \[bu]
+.B /dev/sdb
+.IP \[bu]
+.B major:minor
 .SH "SEE ALSO"
+.BR multipathd (8),
+.BR multipath.conf (5),
+.BR kpartx (8),
 .BR udev (8),
 .BR dmsetup (8)
 .BR hotplug (8)
diff --git a/multipath/multipath.conf.5 b/multipath/multipath.conf.5
index 165982e..70d15f3 100644
--- a/multipath/multipath.conf.5
+++ b/multipath/multipath.conf.5
@@ -34,13 +34,14 @@ The configuration file contains entries of the form:
 .LP
 Each \fIsection\fP contains one or more attributes or subsections. The
 recognized keywords for attributes or subsections depend on the
-section in which they occor.
+section in which they occur.
 .LP
 The following \fIsection\fP keywords are recognized:
 .TP 17
 .B defaults
 This section defines default values for attributes which are used
-whenever no specific setting is given.
+whenever no values are given in the appropriate device or multipath
+sections.
 .TP
 .B blacklist
 This section defines which devices should be excluded from the
@@ -54,8 +55,9 @@ section.
 .TP
 .B multipaths
 This section defines the multipath topologies. They are indexed by a
-\fIWorld Wide Identifier\fR(wwid), which is the result of the
-\fIgetuid_callout\fR program.
+\fIWorld Wide Identifier\fR(wwid), which is taken to be the value of
+the udev attribute given by the
+\fIuid_attribute\fR keyword.
 .TP
 .B devices
 This section defines the device-specific settings.
@@ -67,24 +69,49 @@ The
 section recognizes the following keywords:
 .TP 17
 .B polling_interval
-interval between two path checks in seconds For properly functioning paths,
-the interval between checks will gradually increase to (4 * polling_interval);
+interval between two path checks in seconds. For properly functioning paths,
+the interval between checks will gradually increase to
+.B max_polling_interval;
 default is
 .I 5
 .TP
-.B udev_dir
-directory where udev creates its device nodes; default is
-.I /dev
+.B max_polling_interval
+maximal interval between two path checks in seconds; default is
+.I 4 * polling_interval
+.TP
+.B multipath_dir
+directory where the dynamic shared objects are stored; default is system
+dependent, commonly
+.I /lib/multipath
 .TP
 .B verbosity
 default verbosity. Higher values increase the verbosity level. Valid
 levels are between 0 and 6; default is
 .I 2
 .TP
-.B selector
+.B reassign_maps
+enable reassigning of device-mapper maps. With this option multipathd
+will remap existing device-mapper maps to always point to multipath
+device, not the underlying block devices. Possible values are
+\fIyes\fR and \fIno\fR. Default is
+.I yes
+.TP
+.B path_selector
 The default path selector algorithm to use; they are offered by the
-kernel multipath target. The only currently implemented is
-.I "round-robin 0"
+kernel multipath target. There are three selector algorithms.
+.RS
+.TP 12
+.B "round-robin 0"
+Loop through every path in the path group, sending the same amount of IO to
+each.
+.TP
+.B "queue-length 0"
+Send the next bunch of IO down the path with the least amount of outstanding IO.
+.TP
+.B "service-time 0"
+Choose the path for the next bunch of IO based on the amount of outstanding IO
+to the path and its relative throughput.
+.RE
 .TP
 .B path_grouping_policy
 The default path grouping policy to apply to unspecified
@@ -109,65 +136,91 @@ per-multipath option in the configuration file.
 1 priority group per target node name. Target node names are fetched
 in /sys/class/fc_transport/target*/node_name.
 .TP
-Default value is \fImultibus\fR.
+Default value is \fIfailover\fR.
 .RE
 .TP
-.B getuid_callout
-The default program and args to callout to obtain a unique path
-identifier. Should be specified with an absolute path. Default value
-is
-.I /lib/udev/scsi_id --whitelisted --device=/dev/%n
-.TP
-.B prio_callout
-The default program and args to callout to obtain a path priority
-value. The specified program will be executed and should return a
-numeric value specifying the relative priority of this path. Higher
-number have a higher priority. A '%n' in the command line will be expanded
-to the device name, a '%b' will be expanded to the device number in
-.I major:minor
-format.
+.B uid_attribute
+The udev attribute providing a unique path
+identifier. Default value is
+.I ID_SERIAL
+.TP
+.B prio
+The name of the path priority routine. The specified routine
+should return a numeric value specifying the relative priority
+of this path. Higher number have a higher priority.
 .I "none"
-is a valid value. Currently the following path priority programs are
-implemented:
+is a valid value. Currently the following path priority routines
+are implemented:
 .RS
 .TP 12
-.B mpath_prio_emc /dev/%n
-Generate the path priority for EMC arrays
+.B const
+Return a constant priority of \fI1\fR.
 .TP
-.B mpath_prio_alua /dev/%n
+.B emc
+Generate the path priority for EMC arrays.
+.TP
+.B alua
 Generate the path priority based on the SCSI-3 ALUA settings.
 .TP
-.B mpath_prio_netapp /dev/%n
+.B ontap
 Generate the path priority for NetApp arrays.
 .TP
-.B mpath_prio_rdac /dev/%n
-Generate the path priority for LSI/Engenio RDAC controller.
+.B rdac
+Generate the path priority for LSI/Engenio/NetApp E-Series RDAC controller.
 .TP
-.B mpath_prio_hp_sw /dev/%n
+.B hp_sw
 Generate the path priority for Compaq/HP controller in
 active/standby mode.
 .TP
-.B mpath_prio_hds_modular %b
+.B hds
 Generate the path priority for Hitachi HDS Modular storage arrays.
 .TP
+.B random
+Generate a random priority between 1 and 10.
+.TP 12
+.B weightedpath
+Generate the path priority based on the regular expression and the 
+priority provided as argument. requires prio_args keyword.
+.TP
 Default value is \fBnone\fR.
 .RE
 .TP
+.B prio_args
+Arguments to pass to to the prio function.  Currently only used with
+.I weighted, which needs a value of the form
+.I "<hbtl|devname> <regex1> <prio1> <regex2> <prio2> ..."
+.I hbtl
+regex can be of SCSI H:B:T:L format  Ex: 1:0:.:. , *:0:0:.
+.I devname
+regex can be of device name format  Ex: sda , sd.e
+.TP
 .B features
-Specify any device-mapper features to be used. The most common of
-these features is
-.I "1 queue_if_no_path" 
-Note that this can also be set via the
+Specify any device-mapper features to be used. Syntax is
+.I num list
+where
+.I num
+is the number of features in
+.I list.
+Possible values for the feature list are
+.RS
+.TP 12
+.B queue_if_no_path
+Queue IO if no path is active; identical to the
 .I no_path_retry
 keyword.
 .TP
+.B no_partitions
+Disable automatic partitions generation via kpartx.
+.RE
+.TP
 .B path_checker
-The default method used to determine the paths' state. Possible values
+The default method used to determine the paths state. Possible values
 are
 .RS
 .TP 12
 .B readsector0
-Read the first sector of the device
+(Deprecated) Read the first sector of the device. This checker is being
+deprecated, please use \fIdirectio\fR instead
 .TP
 .B tur
 Issue a
@@ -182,28 +235,47 @@ state.
 Check the path state for HP storage arrays with Active/Standby firmware.
 .TP
 .B rdac
-Check the path state for LSI/Engenio RDAC storage controller.
+Check the path state for LSI/Engenio/NetApp E-Series RDAC storage controller.
 .TP
 .B directio
 Read the first sector with direct I/O.
 .TP
-Default value is \fIreadsector0\fR.
+Default value is \fIdirectio\fR.
 .RE
 .TP
 .B failback
-Tell the daemon to manage path group failback, or not to. 0 or
-.I immediate
-means immediate failback, values >0 means deferred failback (in
-seconds).
-.I manual
-means no failback. Default value is
-.I manual
+Tell multipathd how to manage path group failback.
+.RS
+.TP 12
+.B immediate
+Immediately failback to the highest priority pathgroup that contains
+active paths.
+.TP
+.B manual
+Do not perform automatic failback.
+.TP
+.B followover
+Only perform automatic failback when the first path of a pathgroup
+becomes active. This keeps a node from automatically failing back when
+another node requested the failover.
+.TP
+.B values > 0
+deferred failback (time to defer in seconds)
+.TP
+Default value is \fImanual\fR.
+.RE
 .TP
 .B  rr_min_io
 The number of IO to route to a path before switching to the next in
-the same path group. Default is
+the same path group. This is only for BIO based multipath. Default is
 .I 1000
 .TP
+.B rr_min_io_rq
+The number of IO requests to route to a path before switching to the
+next in the same path group. This is only for request based multipath.
+Default is
+.I 1
+.TP
 .B rr_weight
 If set to \fIpriorities\fR the multipath configurator will assign
 path weights as "path prio * rr_min_io". Possible values are
@@ -229,18 +301,30 @@ to assign a persistent and unique alias to the multipath, in the form of mpath<n
 If set to 
 .I no
 use the WWID as the alias. In either case this be will
-be overriden by any specific aliases in the \fImultipaths\fR section.
+be overridden by any specific aliases in the \fImultipaths\fR section.
 Default is
 .I no
 .TP
+.B flush_on_last_del
+If set to
+.I yes
+, multipathd will disable queueing when the last path to a device has been
+deleted. Default is
+.I no
+.TP
 .B max_fds
 Specify the maximum number of file descriptors that can be opened by multipath
-and multipathd.  This is equivalent to ulimit -n. A value of \fImax\fR will set
+and multipathd.  This is equivalent to ulimit \-n. A value of \fImax\fR will set
 this to the system limit from /proc/sys/fs/nr_open. If this is not set, the
 maximum number of open fds is taken from the calling process. It is usually
 1024. To be safe, this should be set to the maximum number of paths plus 32,
 if that number is greated than 1024.
 .TP
+.B checker_timeout
+Specify the timeout to user for path checkers that issue scsi commands with an
+explicit timeout, in seconds; default taken from
+.I /sys/block/sd<x>/device/timeout
+.TP
 .B fast_io_fail_tmo
 Specify the number of seconds the scsi layer will wait after a problem has been
 detected on a FC remote port before failing IO to devices on that remote port.
@@ -250,7 +334,15 @@ will disable the timeout.
 .TP
 .B dev_loss_tmo
 Specify the number of seconds the scsi layer will wait after a problem has
-been detected on a FC remote port before removing it from the system.
+been detected on a FC remote port before removing it from the system. This
+can be set to "infinity" which sets it to the max value of 2147483647
+seconds, or 68 years. It will be automatically adjusted to the overall
+retry interval
+\fIno_path_retry\fR * \fIpolling_interval\fR
+if a number of retries is given with \fIno_path_retry\fR and the
+overall retry interval is longer than the specified \fIdev_loss_tmo\fR value.
+The linux kernel will cap this value to \fI300\fR if \fBfast_io_fail_tmo\fR
+is not set.
 .TP
 .B queue_without_daemon
 If set to
@@ -264,6 +356,50 @@ cannot be told to stop queueing IO. Setting queue_without_daemon to
 .I no
 , avoids this problem. Default is
 .I yes
+.TP
+.B bindings_file
+The full pathname of the binding file to be used when the user_friendly_names option is set. Defaults to
+.I /etc/multipath/bindings
+.TP
+.B wwids_file
+The full pathname of the wwids file, which is used by multipath to keep track
+of the wwids for LUNs it has created multipath devices on in the past.
+Defaults to
+.I /etc/multipath/wwids
+.TP
+.B log_checker_err
+If set to
+.I once
+, multipathd logs the first path checker error at logging level 2. Any later
+errors are logged at level 3 until the device is restored. If set to
+.I always
+, multipathd always logs the path checker error at logging level 2. Default is
+.I always
+.TP
+.B reservation_key
+This is the service action reservation key used by mpathpersist.  It must be
+set for all multipath devices using persistent reservations, and it must be
+the same as the RESERVATION KEY field of the PERSISTENT RESERVE OUT parameter
+list which contains an 8-byte value provided by the application client to the
+device server to identify the I_T nexus. It is unset by default.
+.TP
+.B retain_attached_hw_handler
+If set to
+.I yes
+and the scsi layer has already attached a hardware_handler to the device,
+multipath will not force the device to use the hardware_handler specified by
+mutipath.conf. If the scsi layer has not attached a hardware handler,
+multipath will continue to use its configured hardware handler. Default is
+.I no
+.TP
+.B detect_prio
+If set to
+.I yes
+, multipath will try to detect if the device supports ALUA. If so, the device
+will automatically use the
+.I alua
+prioritizer. If not, the prioritizer will be selected as usual. Default is
+.I no
 .
 .SH "blacklist section"
 The
@@ -294,7 +430,7 @@ The
 section is used to revert the actions of the
 .I blacklist
 section, ie to include specific device in the
-multipath topology. This allows to selectively include devices which
+multipath topology. This allows one to selectively include devices which
 would normally be excluded via the
 .I blacklist
 section.
@@ -335,6 +471,8 @@ Index of the container. Mandatory for this subsection.
 The following attributes are optional; if not set the default values
 are taken from the
 .I defaults
+or
+.I devices
 section:
 .sp 1
 .PD .1v
@@ -344,11 +482,25 @@ section:
 .TP
 .B path_selector
 .TP
+.B prio
+.TP
+.B prio_args
+.TP
 .B failback
 .TP
+.B rr_weight
+.TP
+.B flush_on_last_del
+.TP
 .B no_path_retry
 .TP
 .B rr_min_io
+.TP
+.B rr_min_io_rq
+.TP
+.B features
+.TP
+.B reservation_key
 .RE
 .PD
 .LP
@@ -369,8 +521,15 @@ subsection recognizes the following attributes:
 .B product
 (Mandatory) Product identifier
 .TP
+.B revision
+(Optional) Revision identfier
+.TP
 .B product_blacklist
-Product strings to blacklist for this vendor
+(Optional) Product strings to blacklist for this vendor
+.TP
+.B alias_prefix
+(Optional) The user_friendly_names prefix to use for this
+device type, instead of the default "mpath"
 .TP
 .B hardware_handler
 (Optional) The hardware handler to use for this device type.
@@ -379,6 +538,16 @@ The following hardware handler are implemented:
 .TP 12
 .B 1 emc
 Hardware handler for EMC storage arrays.
+.TP
+.B 1 rdac
+Hardware handler for LSI/Engenio/NetApp E-Series RDAC storage controller.
+.TP
+.B 1 hp_sw
+Hardware handler for Compaq/HP storage arrays in active/standby
+mode.
+.TP
+.B 1 alua
+Hardware handler for SCSI-3 ALUA compatible arrays.
 .RE
 .LP
 The following attributes are optional; if not set the default values
@@ -391,15 +560,17 @@ section:
 .TP 18
 .B path_grouping_policy
 .TP
-.B getuid_callout
+.B uid_attribute
 .TP
 .B path_selector
 .TP
 .B path_checker
 .TP
-.B features
+.B prio
 .TP
-.B prio_callout
+.B prio_args
+.TP
+.B features
 .TP
 .B failback
 .TP
@@ -409,9 +580,17 @@ section:
 .TP
 .B rr_min_io
 .TP
+.B rr_min_io_rq
+.TP
 .B fast_io_fail_tmo
 .TP
 .B dev_loss_tmo
+.TP
+.B flush_on_last_del
+.TP
+.B retain_attached_hw_handler
+.TP
+.B detect_prio
 .RE
 .PD
 .LP
@@ -424,6 +603,20 @@ processes being hung and not killable in situations where all the paths to the L
 It is advisable to use the
 .B no_path_retry
 option instead.
+.P
+The use of
+.B queue_if_no_path
+or
+.B no_path_retry
+might lead to a deadlock if the
+.B dev_loss_tmo
+setting results in a device being removed while I/O is still queued.
+The multipath daemon will update the
+.B dev_loss_tmo
+setting accordingly to avoid this deadlock. Hence if both values are
+specified the order of precedence is
+.I no_path_retry, queue_if_no_path, dev_loss_tmo
+
 .SH "SEE ALSO"
 .BR udev (8),
 .BR dmsetup (8)
diff --git a/multipath/multipath.init.suse b/multipath/multipath.init.suse
new file mode 100644
index 0000000..de1cc1f
--- /dev/null
+++ b/multipath/multipath.init.suse
@@ -0,0 +1,158 @@
+#! /bin/sh
+# Copyright (c) 2005 SuSE GmbH Nuernberg, Germany.
+#
+# Author: Hannes Reinecke <feedback@suse.de>
+#
+# init.d/boot.multipath
+#
+### BEGIN INIT INFO
+# Provides:          boot.multipath
+# Required-Start:    boot.device-mapper boot.udev
+# Required-Stop:     boot.device-mapper boot.udev
+# Should-Start:      boot.xdrsetsite
+# Should-Stop:       boot.xdrsetsite
+# Default-Start:     B
+# Default-Stop:
+# Short-Description:       Create multipath device targets
+# Description:       Setup initial multipath device-mapper targets
+### END INIT INFO
+
+PATH=/bin:/usr/bin:/sbin:/usr/sbin
+PROGRAM=/sbin/multipath
+
+# Set the maximum number of open files
+MAX_OPEN_FDS=4096
+
+# Number of seconds to wait for disks and partitions
+MPATH_DEVICE_TIMEOUT=30
+
+test -x $PROGRAM || exit 5
+
+# Shell functions sourced from /etc/rc.status:
+#      rc_check         check and set local and overall rc status
+#      rc_status        check and set local and overall rc status
+#      rc_status -v     ditto but be verbose in local rc status
+#      rc_status -v -r  ditto and clear the local rc status
+#      rc_failed        set local and overall rc status to failed
+#      rc_reset         clear local rc status (overall remains)
+#      rc_exit          exit appropriate to overall rc status
+. /etc/rc.status
+
+# First reset status of this service
+rc_reset
+
+# Return values acc. to LSB for all commands but status:
+# 0 - success
+# 1 - misc error
+# 2 - invalid or excess args
+# 3 - unimplemented feature (e.g. reload)
+# 4 - insufficient privilege
+# 5 - program not installed
+# 6 - program not configured
+# 7 - program is not running
+# 
+# Note that starting an already running service, stopping
+# or restarting a not-running service as well as the restart
+# with force-reload (in case signalling is not supported) are
+# considered a success.
+
+case "$1" in
+    start)
+	# Check for existing multipath mappings
+	if dmsetup table --target multipath | grep -q multipath ; then
+	    # Multipath active, start daemon
+	    exec /etc/init.d/multipathd $1
+	fi
+
+	echo -n "Creating multipath targets:"
+	# Check whether multipath daemon is already running
+	if /sbin/multipathd -k"list paths" > /dev/null 2>&1 ; then
+	    echo -n " (multipathd running)"
+	    rc_status -v
+	    rc_exit
+	fi
+	# Load prerequisite module
+	modprobe dm-multipath
+	
+	# Set the maximum number of open files
+	if [ -n "$MAX_OPEN_FDS" ] ; then
+	    ulimit -n $MAX_OPEN_FDS
+	fi
+
+	# Start the program directly as checkproc doesn't work here
+	$PROGRAM -v 0
+	echo -n " (waiting for udev)"
+	# Wait for all multipathed devices to appear
+	maplist=$(/sbin/dmsetup ls --target multipath | sed '/No devices/d' | sed -n 's/\(^[^ ()]*\)[\t ]*.*/\1/p')
+	wait=$MPATH_DEVICE_TIMEOUT
+	while [ $wait -gt 0 ] ; do
+	    num=0
+	    for map in $maplist; do
+		[ -e /dev/disk/by-id/dm-name-$map ] && continue
+		num=$((num + 1))
+	    done
+	    [ $num -eq 0 ] && break
+	    wait=$((wait - 1))
+	    sleep 1;
+	done
+	if [ $wait -le 0 ] ; then
+	    echo -n " timeout: $num devices left"
+	    rc_failed 1
+	else
+	    # Reset to wait for partitions
+	    wait=$MPATH_DEVICE_TIMEOUT
+	fi
+        # Wait for all partitions on multipathed devices
+	while [ $wait -gt 0 ] ; do
+	    num=0
+	    for map in $maplist ; do
+		[ -e /dev/disk/by-id/dm-name-$map ] || continue
+		partlist=$(/sbin/kpartx -l -p _part /dev/disk/by-id/dm-name-$map | sed 's/\([^ ]*\) :.*/\1/p')
+		for part in $partlist; do
+		    [ -e /dev/disk/by-id/dm-name-$part ] && continue
+		    num=$((num + 1))
+		done
+	    done
+	    [ $num -eq 0 ] && break
+	    wait=$((wait - 1))
+	    sleep 1;
+	done
+	if [ $wait -le 0 ] ; then
+	    echo -n "timeout: $num partitions left"
+	    rc_failed 1
+	fi
+
+	# Remember status and be verbose
+	rc_status -v
+	;;
+    stop)
+	echo -n "Removing multipath targets:"
+
+	# Flush all existing maps
+	$PROGRAM -F
+
+	rc_failed 0
+	rc_status -v
+	;;
+    status)
+	echo -n "Checking multipath targets: "
+	# Display active multipath tables
+	tblnum=$(/sbin/dmsetup ls --target multipath | sed '/No devices/d' | wc --lines)
+	if [ "$tblnum" ] && [ $tblnum -gt 0 ] ; then
+	    echo -n "($tblnum multipath devices) "
+	    rc_failed 0
+	else
+	    rc_failed 3
+	fi
+	rc_status -v
+	;;
+    restart)
+	$0 stop
+	$0 start
+	;;
+    *)
+	echo "Usage: $0 {start|stop|status|restart}"
+	exit 1
+	;;
+esac
+rc_exit
diff --git a/multipath/multipath.rules b/multipath/multipath.rules
deleted file mode 100644
index ac97749..0000000
--- a/multipath/multipath.rules
+++ /dev/null
@@ -1,7 +0,0 @@
-#
-# udev rules for multipathing.
-# The persistent symlinks are created with the kpartx rules
-#
-
-# socket for uevents
-SUBSYSTEM=="block", RUN+="socket:/org/kernel/dm/multipath_event"
diff --git a/multipathd/Makefile b/multipathd/Makefile
index 32d9ef5..b490c1d 100644
--- a/multipathd/Makefile
+++ b/multipathd/Makefile
@@ -5,9 +5,9 @@ include ../Makefile.inc
 #
 # basic flags setting
 #
-CFLAGS += -I$(multipathdir)
-LDFLAGS += -lpthread -ldevmapper -lreadline -lncurses -ldl \
-	   -lmultipath -L$(multipathdir)
+CFLAGS += -I$(multipathdir) -I$(mpathpersistdir)
+LDFLAGS += -lpthread -ldevmapper -lreadline -ludev -ldl \
+	   -L$(multipathdir) -lmultipath -L$(mpathpersistdir) -lmpathpersist
 
 #
 # debuging stuff
@@ -28,13 +28,15 @@ OBJS = main.o pidfile.o uxlsnr.o uxclnt.o cli.o cli_handlers.o
 all : $(EXEC)
 
 $(EXEC): $(OBJS)
-	$(CC) $(CFLAGS) $(LDFLAGS) -o $(EXEC) $(OBJS)
+	$(CC) $(CFLAGS) $(OBJS) $(LDFLAGS) -o $(EXEC)
 	$(GZIP) $(EXEC).8 > $(EXEC).8.gz
 
 install:
 	$(INSTALL_PROGRAM) -d $(DESTDIR)$(bindir)
 	$(INSTALL_PROGRAM) -m 755 $(EXEC) $(DESTDIR)$(bindir)
 	$(INSTALL_PROGRAM) -d $(DESTDIR)$(rcdir)
+	$(INSTALL_PROGRAM) -d $(DESTDIR)$(unitdir)
+	$(INSTALL_PROGRAM) -m 644 $(EXEC).service $(DESTDIR)$(unitdir)
 	$(INSTALL_PROGRAM) -d $(DESTDIR)$(mandir)
 	$(INSTALL_PROGRAM) -m 644 $(EXEC).8.gz $(DESTDIR)$(mandir)
 
@@ -42,6 +44,7 @@ uninstall:
 	rm -f $(DESTDIR)$(bindir)/$(EXEC)
 	rm -f $(DESTDIR)$(rcdir)/$(EXEC)
 	rm -f $(DESTDIR)$(mandir)/$(EXEC).8.gz
+	rm -f $(DESTDIR)$(unitdir)/$(EXEC).service
 
 clean:
 	rm -f core *.o $(EXEC) *.gz
diff --git a/multipathd/cli.c b/multipathd/cli.c
index 208a0ad..2a5edfa 100644
--- a/multipathd/cli.c
+++ b/multipathd/cli.c
@@ -10,6 +10,9 @@
 
 #include "cli.h"
 
+static vector keys;
+static vector handlers;
+
 static struct key *
 alloc_key (void)
 {
@@ -23,7 +26,7 @@ alloc_handler (void)
 }
 
 static int
-add_key (vector vec, char * str, int code, int has_param)
+add_key (vector vec, char * str, unsigned long code, int has_param)
 {
 	struct key * kw;
 
@@ -54,7 +57,7 @@ out:
 }
 
 int
-add_handler (int fp, int (*fn)(void *, char **, int *, void *))
+add_handler (unsigned long fp, int (*fn)(void *, char **, int *, void *))
 {
 	struct handler * h;
 
@@ -76,7 +79,7 @@ add_handler (int fp, int (*fn)(void *, char **, int *, void *))
 }
 
 static struct handler *
-find_handler (int fp)
+find_handler (unsigned long fp)
 {
 	int i;
 	struct handler *h;
@@ -89,7 +92,7 @@ find_handler (int fp)
 }
 
 int
-set_handler_callback (int fp, int (*fn)(void *, char **, int *, void *))
+set_handler_callback (unsigned long fp, int (*fn)(void *, char **, int *, void *))
 {
 	struct handler * h = find_handler(fp);
 
@@ -124,15 +127,16 @@ free_keys (vector vec)
 }
 
 void
-free_handlers (vector vec)
+free_handlers (void)
 {
 	int i;
 	struct handler * h;
 
-	vector_foreach_slot (vec, h, i)
+	vector_foreach_slot (handlers, h, i)
 		FREE(h);
 
-	vector_free(vec);
+	vector_free(handlers);
+	handlers = NULL;
 }
 
 int
@@ -156,6 +160,9 @@ load_keys (void)
 	r += add_key(keys, "reinstate", REINSTATE, 0);
 	r += add_key(keys, "fail", FAIL, 0);
 	r += add_key(keys, "resize", RESIZE, 0);
+	r += add_key(keys, "reset", RESET, 0);
+	r += add_key(keys, "reload", RELOAD, 0);
+	r += add_key(keys, "forcequeueing", FORCEQ, 0);
 	r += add_key(keys, "disablequeueing", DISABLEQ, 0);
 	r += add_key(keys, "restorequeueing", RESTOREQ, 0);
 	r += add_key(keys, "paths", PATHS, 0);
@@ -166,6 +173,7 @@ load_keys (void)
 	r += add_key(keys, "multipath", MAP, 1);
 	r += add_key(keys, "group", GROUP, 1);
 	r += add_key(keys, "reconfigure", RECONFIGURE, 0);
+	r += add_key(keys, "daemon", DAEMON, 0);
 	r += add_key(keys, "status", STATUS, 0);
 	r += add_key(keys, "stats", STATS, 0);
 	r += add_key(keys, "topology", TOPOLOGY, 0);
@@ -176,6 +184,10 @@ load_keys (void)
 	r += add_key(keys, "wildcards", WILDCARDS, 0);
 	r += add_key(keys, "quit", QUIT, 0);
 	r += add_key(keys, "exit", QUIT, 0);
+	r += add_key(keys, "shutdown", SHUTDOWN, 0);
+	r += add_key(keys, "getprstatus", GETPRSTATUS, 0);
+	r += add_key(keys, "setprstatus", SETPRSTATUS, 0);
+	r += add_key(keys, "unsetprstatus", UNSETPRSTATUS, 0);
 
 	if (r) {
 		free_keys(keys);
@@ -228,10 +240,9 @@ get_cmdvec (char * cmd, vector *v)
 
 	strvec = alloc_strvec(cmd);
 	if (!strvec)
-		return 0;
+		return E_NOMEM;
 
 	cmdvec = vector_alloc();
-	*v = cmdvec;
 
 	if (!cmdvec) {
 		free_strvec(strvec);
@@ -271,21 +282,21 @@ get_cmdvec (char * cmd, vector *v)
 		r = E_NOPARM;
 		goto out;
 	}
+	*v = cmdvec;
 	free_strvec(strvec);
 	return 0;
 
 out:
 	free_strvec(strvec);
 	free_keys(cmdvec);
-	*v = NULL;
 	return r;
 }
 
-static int 
+static unsigned long 
 fingerprint(vector vec)
 {
 	int i;
-	int fp = 0;
+	unsigned long fp = 0;
 	struct key * kw;
 
 	if (!vec)
@@ -325,7 +336,7 @@ static char *
 genhelp_handler (void)
 {
 	int i, j;
-	int fp;
+	unsigned long fp;
 	struct handler * h;
 	struct key * kw;
 	char * reply;
@@ -363,13 +374,11 @@ parse_cmd (char * cmd, char ** reply, int * len, void * data)
 {
 	int r;
 	struct handler * h;
-	vector cmdvec;
+	vector cmdvec = NULL;
 
 	r = get_cmdvec(cmd, &cmdvec);
 
 	if (r) {
-		if (cmdvec)
-			free_keys(cmdvec);
 		*reply = genhelp_handler();
 		*len = strlen(*reply) + 1;
 		return 0;
@@ -377,7 +386,7 @@ parse_cmd (char * cmd, char ** reply, int * len, void * data)
 
 	h = find_handler(fingerprint(cmdvec));
 
-	if (!h) {
+	if (!h || !h->fn) {
 		*reply = genhelp_handler();
 		*len = strlen(*reply) + 1;
 		free_keys(cmdvec);
@@ -394,7 +403,7 @@ parse_cmd (char * cmd, char ** reply, int * len, void * data)
 }
 
 char *
-get_keyparam (vector v, int code)
+get_keyparam (vector v, unsigned long code)
 {
 	struct key * kw;
 	int i;
@@ -417,6 +426,7 @@ cli_init (void) {
 	add_handler(LIST+PATHS, NULL);
 	add_handler(LIST+PATHS+FMT, NULL);
 	add_handler(LIST+STATUS, NULL);
+	add_handler(LIST+DAEMON, NULL);
 	add_handler(LIST+MAPS, NULL);
 	add_handler(LIST+MAPS+STATUS, NULL);
 	add_handler(LIST+MAPS+STATS, NULL);
@@ -437,6 +447,8 @@ cli_init (void) {
 	add_handler(SUSPEND+MAP, NULL);
 	add_handler(RESUME+MAP, NULL);
 	add_handler(RESIZE+MAP, NULL);
+	add_handler(RESET+MAP, NULL);
+	add_handler(RELOAD+MAP, NULL);
 	add_handler(DISABLEQ+MAP, NULL);
 	add_handler(RESTOREQ+MAP, NULL);
 	add_handler(DISABLEQ+MAPS, NULL);
@@ -444,12 +456,25 @@ cli_init (void) {
 	add_handler(REINSTATE+PATH, NULL);
 	add_handler(FAIL+PATH, NULL);
 	add_handler(QUIT, NULL);
+	add_handler(SHUTDOWN, NULL);
+	add_handler(GETPRSTATUS+MAP, NULL);
+	add_handler(SETPRSTATUS+MAP, NULL);
+	add_handler(UNSETPRSTATUS+MAP, NULL);
+	add_handler(FORCEQ+DAEMON, NULL);
+	add_handler(RESTOREQ+DAEMON, NULL);
 
 	return 0;
 }
 
+void cli_exit(void)
+{
+	free_handlers();
+	free_keys(keys);
+	keys = NULL;
+}
+
 static int
-key_match_fingerprint (struct key * kw, int fp)
+key_match_fingerprint (struct key * kw, unsigned long fp)
 {
 	if (!fp)
 		return 0;
@@ -463,11 +488,12 @@ key_match_fingerprint (struct key * kw, int fp)
 char *
 key_generator (const char * str, int state)
 {
-	static int index, len, rlfp, has_param;
+	static int index, len, has_param;
+	static unsigned long rlfp;	
 	struct key * kw;
 	int i;
 	struct handler *h;
-	vector v;
+	vector v = NULL;
 
 	if (!state) {
 		index = 0;
@@ -533,7 +559,7 @@ key_generator (const char * str, int state)
 			 * nfp is the candidate fingerprint we try to
 			 * validate against all known command fingerprints.
 			 */
-			int nfp = rlfp | kw->code;
+			unsigned long nfp = rlfp | kw->code;
 			vector_foreach_slot(handlers, h, i) {
 				if (!rlfp || ((h->fingerprint & nfp) == nfp)) {
 					/*
diff --git a/multipathd/cli.h b/multipathd/cli.h
index 1a19e4c..09fdc68 100644
--- a/multipathd/cli.h
+++ b/multipathd/cli.h
@@ -8,6 +8,9 @@ enum {
 	__REINSTATE,
 	__FAIL,
 	__RESIZE,
+	__RESET,
+	__RELOAD,
+	__FORCEQ,
 	__DISABLEQ,
 	__RESTOREQ,
 	__PATHS,
@@ -16,6 +19,7 @@ enum {
 	__MAP,
 	__GROUP,
 	__RECONFIGURE,
+	__DAEMON,
 	__STATUS,
 	__STATS,
 	__TOPOLOGY,
@@ -25,6 +29,10 @@ enum {
 	__FMT,
 	__WILDCARDS,
 	__QUIT,
+	__SHUTDOWN,
+	__GETPRSTATUS,
+	__SETPRSTATUS,
+	__UNSETPRSTATUS,
 };
 
 #define LIST		(1 << __LIST)
@@ -36,6 +44,9 @@ enum {
 #define REINSTATE	(1 << __REINSTATE)
 #define FAIL		(1 << __FAIL)
 #define RESIZE		(1 << __RESIZE)
+#define RESET		(1 << __RESET)
+#define RELOAD		(1 << __RELOAD)
+#define FORCEQ		(1 << __FORCEQ)
 #define DISABLEQ	(1 << __DISABLEQ)
 #define RESTOREQ	(1 << __RESTOREQ)
 #define PATHS		(1 << __PATHS)
@@ -44,23 +55,28 @@ enum {
 #define MAP		(1 << __MAP)
 #define GROUP		(1 << __GROUP)
 #define RECONFIGURE	(1 << __RECONFIGURE)
+#define DAEMON		(1 << __DAEMON)
 #define STATUS		(1 << __STATUS)
 #define STATS		(1 << __STATS)
 #define TOPOLOGY	(1 << __TOPOLOGY)
 #define CONFIG		(1 << __CONFIG)
 #define BLACKLIST	(1 << __BLACKLIST)
-#define DEVICES  	(1 << __DEVICES)
-#define FMT 	 	(1 << __FMT)
+#define DEVICES		(1 << __DEVICES)
+#define FMT		(1 << __FMT)
 #define COUNT		(1 << __COUNT)
 #define WILDCARDS	(1 << __WILDCARDS)
 #define QUIT		(1 << __QUIT)
+#define SHUTDOWN	(1 << __SHUTDOWN)
+#define GETPRSTATUS	(1UL << __GETPRSTATUS)
+#define SETPRSTATUS	(1UL << __SETPRSTATUS)
+#define UNSETPRSTATUS	(1UL << __UNSETPRSTATUS)
 
-#define INITIAL_REPLY_LEN 1000
+#define INITIAL_REPLY_LEN	1100
 
 struct key {
 	char * str;
 	char * param;
-	int code;
+	unsigned long code;
 	int has_param;
 };
 
@@ -69,16 +85,14 @@ struct handler {
 	int (*fn)(void *, char **, int *, void *);
 };
 
-vector keys;
-vector handlers;
-
 int alloc_handlers (void);
-int add_handler (int fp, int (*fn)(void *, char **, int *, void *));
-int set_handler_callback (int fp, int (*fn)(void *, char **, int *, void *));
+int add_handler (unsigned long fp, int (*fn)(void *, char **, int *, void *));
+int set_handler_callback (unsigned long fp, int (*fn)(void *, char **, int *, void *));
 int parse_cmd (char * cmd, char ** reply, int * len, void *);
 int load_keys (void);
-char * get_keyparam (vector v, int code);
+char * get_keyparam (vector v, unsigned long code);
 void free_keys (vector vec);
-void free_handlers (vector vec);
+void free_handlers (void);
 int cli_init (void);
+void cli_exit(void);
 char * key_generator (const char * str, int state);
diff --git a/multipathd/cli_handlers.c b/multipathd/cli_handlers.c
index 71a73ff..7b1cb62 100644
--- a/multipathd/cli_handlers.c
+++ b/multipathd/cli_handlers.c
@@ -8,6 +8,7 @@
 #include <structs_vec.h>
 #include <libdevmapper.h>
 #include <devmapper.h>
+#include <discovery.h>
 #include <config.h>
 #include <configure.h>
 #include <blacklist.h>
@@ -15,9 +16,23 @@
 #include <print.h>
 #include <sysfs.h>
 #include <errno.h>
+#include <libudev.h>
+#include <util.h>
 
 #include "main.h"
 #include "cli.h"
+#include "uevent.h"
+
+#define REALLOC_REPLY(r, a, m)					\
+	do {							\
+		if ((a)) {					\
+			(r) = REALLOC((r), (m) * 2);		\
+			if ((r)) {				\
+				memset((r) + (m), 0, (m));	\
+				(m) *= 2;			\
+			}					\
+		}						\
+	} while (0)
 
 int
 show_paths (char ** r, int * len, struct vectors * vecs, char * style)
@@ -48,9 +63,7 @@ show_paths (char ** r, int * len, struct vectors * vecs, char * style)
 
 		again = ((c - reply) == (maxlen - 1));
 
-		if (again)
-			reply = REALLOC(reply, maxlen *= 2);
-
+		REALLOC_REPLY(reply, again, maxlen);
 	}
 	*r = reply;
 	*len = (int)(c - reply + 1);
@@ -58,13 +71,16 @@ show_paths (char ** r, int * len, struct vectors * vecs, char * style)
 }
 
 int
-show_map_topology (char ** r, int * len, struct multipath * mpp)
+show_map_topology (char ** r, int * len, struct multipath * mpp,
+		   struct vectors * vecs)
 {
 	char * c;
 	char * reply;
 	unsigned int maxlen = INITIAL_REPLY_LEN;
 	int again = 1;
 
+	if (update_multipath(vecs, mpp->alias, 0))
+		return 1;
 	reply = MALLOC(maxlen);
 
 	while (again) {
@@ -76,9 +92,7 @@ show_map_topology (char ** r, int * len, struct multipath * mpp)
 		c += snprint_multipath_topology(c, reply + maxlen - c, mpp, 2);
 		again = ((c - reply) == (maxlen - 1));
 
-		if (again)
-			reply = REALLOC(reply, maxlen *= 2);
-
+		REALLOC_REPLY(reply, again, maxlen);
 	}
 	*r = reply;
 	*len = (int)(c - reply + 1);
@@ -104,15 +118,18 @@ show_maps_topology (char ** r, int * len, struct vectors * vecs)
 
 		c = reply;
 
-		vector_foreach_slot(vecs->mpvec, mpp, i)
+		vector_foreach_slot(vecs->mpvec, mpp, i) {
+			if (update_multipath(vecs, mpp->alias, 0)) {
+				i--;
+				continue;
+			}
 			c += snprint_multipath_topology(c, reply + maxlen - c,
 							mpp, 2);
+		}
 
 		again = ((c - reply) == (maxlen - 1));
 
-		if (again)
-			reply = REALLOC(reply, maxlen *= 2);
-
+		REALLOC_REPLY(reply, again, maxlen);
 	}
 	*r = reply;
 	*len = (int)(c - reply + 1);
@@ -136,31 +153,46 @@ show_config (char ** r, int * len)
 		c += snprint_defaults(c, reply + maxlen - c);
 		again = ((c - reply) == maxlen);
 		if (again) {
-			reply = REALLOC(reply, maxlen *= 2);
+			reply = REALLOC(reply, maxlen * 2);
+			if (!reply)
+				return 1;
+			memset(reply + maxlen, 0, maxlen);
+			maxlen *= 2;
 			continue;
 		}
 		c += snprint_blacklist(c, reply + maxlen - c);
 		again = ((c - reply) == maxlen);
 		if (again) {
-			reply = REALLOC(reply, maxlen *= 2);
+			reply = REALLOC(reply, maxlen * 2);
+			if (!reply)
+				return 1;
+			memset(reply + maxlen, 0, maxlen);
+			maxlen *= 2;
 			continue;
 		}
 		c += snprint_blacklist_except(c, reply + maxlen - c);
 		again = ((c - reply) == maxlen);
 		if (again) {
-			reply = REALLOC(reply, maxlen *= 2);
+			reply = REALLOC(reply, maxlen * 2);
+			if (!reply)
+				return 1;
+			memset(reply + maxlen, 0, maxlen);
+			maxlen *= 2;
 			continue;
 		}
 		c += snprint_hwtable(c, reply + maxlen - c, conf->hwtable);
 		again = ((c - reply) == maxlen);
 		if (again) {
-			reply = REALLOC(reply, maxlen *= 2);
+			reply = REALLOC(reply, maxlen * 2);
+			if (!reply)
+				return 1;
+			memset(reply + maxlen, 0, maxlen);
+			maxlen *= 2;
 			continue;
 		}
 		c += snprint_mptable(c, reply + maxlen - c, conf->mptable);
 		again = ((c - reply) == maxlen);
-		if (again)
-			reply = REALLOC(reply, maxlen *= 2);
+		REALLOC_REPLY(reply, again, maxlen);
 	}
 	*r = reply;
 	*len = (int)(c - reply + 1);
@@ -211,7 +243,7 @@ cli_list_map_topology (void * v, char ** reply, int * len, void * data)
 
 	condlog(3, "list multipath %s (operator)", param);
 
-	return show_map_topology(reply, len, mpp);
+	return show_map_topology(reply, len, mpp, vecs);
 }
 
 int
@@ -262,6 +294,27 @@ show_status (char ** r, int *len, struct vectors * vecs)
 }
 
 int
+show_daemon (char ** r, int *len)
+{
+	char * c;
+	char * reply;
+
+	unsigned int maxlen = INITIAL_REPLY_LEN;
+	reply = MALLOC(maxlen);
+
+	if (!reply)
+		return 1;
+
+	c = reply;
+	c += snprintf(c, INITIAL_REPLY_LEN, "pid %d %s\n",
+		      daemon_pid, daemon_status());
+
+	*r = reply;
+	*len = (int)(c - reply + 1);
+	return 0;
+}
+
+int
 show_maps (char ** r, int *len, struct vectors * vecs, char * style)
 {
 	int i;
@@ -289,8 +342,7 @@ show_maps (char ** r, int *len, struct vectors * vecs, char * style)
 
 		again = ((c - reply) == (maxlen - 1));
 
-		if (again)
-			reply = REALLOC(reply, maxlen *= 2);
+		REALLOC_REPLY(reply, again, maxlen);
 	}
 	*r = reply;
 	*len = (int)(c - reply + 1);
@@ -349,22 +401,55 @@ cli_list_maps_stats (void * v, char ** reply, int * len, void * data)
 }
 
 int
+cli_list_daemon (void * v, char ** reply, int * len, void * data)
+{
+	condlog(3, "list daemon (operator)");
+
+	return show_daemon(reply, len);
+}
+
+int
 cli_add_path (void * v, char ** reply, int * len, void * data)
 {
 	struct vectors * vecs = (struct vectors *)data;
 	char * param = get_keyparam(v, PATH);
+	struct path *pp;
 	int r;
 
 	condlog(2, "%s: add path (operator)", param);
 
 	if (filter_devnode(conf->blist_devnode, conf->elist_devnode,
-	    param) > 0 || (r = ev_add_path(param, vecs)) == 2) {
-		*reply = strdup("blacklisted\n");
-		*len = strlen(*reply) + 1;
-		condlog(2, "%s: path blacklisted", param);
-		return 0;
+			   param) > 0)
+		goto blacklisted;
+
+	pp = find_path_by_dev(vecs->pathvec, param);
+	if (pp) {
+		condlog(2, "%s: path already in pathvec", param);
+		if (pp->mpp)
+			return 0;
+	} else {
+		struct udev_device *udevice;
+
+		udevice = udev_device_new_from_subsystem_sysname(conf->udev,
+								 "block",
+								 param);
+		r = store_pathinfo(vecs->pathvec, conf->hwtable,
+				   udevice, DI_ALL, &pp);
+		udev_device_unref(udevice);
+		if (!pp) {
+			if (r == 2)
+				goto blacklisted;
+			condlog(0, "%s: failed to store path info", param);
+			return 1;
+		}
+		pp->checkint = conf->checkint;
 	}
-	return r;
+	return ev_add_path(pp, vecs);
+blacklisted:
+	*reply = strdup("blacklisted\n");
+	*len = strlen(*reply) + 1;
+	condlog(2, "%s: path blacklisted", param);
+	return 0;
 }
 
 int
@@ -372,10 +457,15 @@ cli_del_path (void * v, char ** reply, int * len, void * data)
 {
 	struct vectors * vecs = (struct vectors *)data;
 	char * param = get_keyparam(v, PATH);
+	struct path *pp;
 
 	condlog(2, "%s: remove path (operator)", param);
-
-	return ev_remove_path(param, vecs);
+	pp = find_path_by_dev(vecs->pathvec, param);
+	if (!pp) {
+		condlog(0, "%s: path already removed", param);
+		return 0;
+	}
+	return ev_remove_path(pp, vecs);
 }
 
 int
@@ -383,9 +473,10 @@ cli_add_map (void * v, char ** reply, int * len, void * data)
 {
 	struct vectors * vecs = (struct vectors *)data;
 	char * param = get_keyparam(v, MAP);
-	int minor;
+	int major, minor;
 	char dev_path[PATH_SIZE];
-	struct sysfs_device *sysdev;
+	char *alias;
+	int rc;
 
 	condlog(2, "%s: add map (operator)", param);
 
@@ -400,13 +491,21 @@ cli_add_map (void * v, char ** reply, int * len, void * data)
 		condlog(2, "%s: not a device mapper table", param);
 		return 0;
 	}
-	sprintf(dev_path,"/block/dm-%d", minor);
-	sysdev = sysfs_device_get(dev_path);
-	if (!sysdev) {
-		condlog(2, "%s: not found in sysfs", param);
+	major = dm_get_major(param);
+	if (major < 0) {
+		condlog(2, "%s: not a device mapper table", param);
 		return 0;
 	}
-	return ev_add_map(sysdev, vecs);
+	sprintf(dev_path,"dm-%d", minor);
+	alias = dm_mapname(major, minor);
+	if (!alias) {
+		condlog(2, "%s: mapname not found for %d:%d",
+			param, major, minor);
+		return 0;
+	}
+	rc = ev_add_map(dev_path, alias, vecs);
+	FREE(alias);
+	return rc;
 }
 
 int
@@ -414,20 +513,66 @@ cli_del_map (void * v, char ** reply, int * len, void * data)
 {
 	struct vectors * vecs = (struct vectors *)data;
 	char * param = get_keyparam(v, MAP);
+	int major, minor;
+	char dev_path[PATH_SIZE];
+	char *alias;
+	int rc;
 
 	condlog(2, "%s: remove map (operator)", param);
+	minor = dm_get_minor(param);
+	if (minor < 0) {
+		condlog(2, "%s: not a device mapper table", param);
+		return 0;
+	}
+	major = dm_get_major(param);
+	if (major < 0) {
+		condlog(2, "%s: not a device mapper table", param);
+		return 0;
+	}
+	sprintf(dev_path,"dm-%d", minor);
+	alias = dm_mapname(major, minor);
+	if (!alias) {
+		condlog(2, "%s: mapname not found for %d:%d",
+			param, major, minor);
+		return 0;
+	}
+	rc = ev_remove_map(param, alias, minor, vecs);
+	FREE(alias);
+	return rc;
+}
+
+int
+cli_reload(void *v, char **reply, int *len, void *data)
+{
+	struct vectors * vecs = (struct vectors *)data;
+	char * mapname = get_keyparam(v, MAP);
+	struct multipath *mpp;
+	int minor;
 
-	return ev_remove_map(param, vecs);
+	condlog(2, "%s: reload map (operator)", mapname);
+	if (sscanf(mapname, "dm-%d", &minor) == 1)
+		mpp = find_mp_by_minor(vecs->mpvec, minor);
+	else
+		mpp = find_mp_by_alias(vecs->mpvec, mapname);
+
+	if (!mpp) {
+		condlog(0, "%s: invalid map name. cannot reload", mapname);
+		return 1;
+	}
+
+	return reload_map(vecs, mpp, 0);
 }
 
 int resize_map(struct multipath *mpp, unsigned long long size,
 	       struct vectors * vecs)
 {
+	char params[PARAMS_SIZE] = {0};
+
 	mpp->size = size;
 	update_mpp_paths(mpp, vecs->pathvec);
-	setup_map(mpp);
+	setup_map(mpp, params, PARAMS_SIZE);
 	mpp->action = ACT_RESIZE;
-	if (domap(mpp) <= 0) {
+	if (domap(mpp, params) <= 0) {
 		condlog(0, "%s: failed to resize map : %s", mpp->alias,
 			strerror(errno));
 		return 1;
@@ -459,7 +604,7 @@ cli_resize(void *v, char **reply, int *len, void *data)
 
 	pgp = VECTOR_SLOT(mpp->pg, 0);
 	pp = VECTOR_SLOT(pgp->paths, 0);
-	if (sysfs_get_size(pp->sysdev, &size)) {
+	if (!pp->udev || sysfs_get_size(pp, &size)) {
 		condlog(0, "%s: couldn't get size for sysfs. cannot resize",
 			mapname);
 		return 1;
@@ -483,6 +628,24 @@ cli_resize(void *v, char **reply, int *len, void *data)
 }
 
 int
+cli_force_no_daemon_q(void * v, char ** reply, int * len, void * data)
+{
+	condlog(2, "force queue_without_daemon (operator)");
+	if (conf->queue_without_daemon == QUE_NO_DAEMON_OFF)
+		conf->queue_without_daemon = QUE_NO_DAEMON_FORCE;
+	return 0;
+}
+
+int
+cli_restore_no_daemon_q(void * v, char ** reply, int * len, void * data)
+{
+	condlog(2, "restore queue_without_daemon (operator)");
+	if (conf->queue_without_daemon == QUE_NO_DAEMON_FORCE)
+		conf->queue_without_daemon = QUE_NO_DAEMON_OFF;
+	return 0;
+}
+
+int
 cli_restore_queueing(void *v, char **reply, int *len, void *data)
 {
 	struct vectors * vecs = (struct vectors *)data;
@@ -658,6 +821,17 @@ cli_reinstate(void * v, char ** reply, int * len, void * data)
 }
 
 int
+cli_reassign (void * v, char ** reply, int * len, void * data)
+{
+	char * param = get_keyparam(v, MAP);
+
+	condlog(3, "%s: reset devices (operator)", param);
+
+	dm_reassign(param);
+	return 0;
+}
+
+int
 cli_fail(void * v, char ** reply, int * len, void * data)
 {
 	struct vectors * vecs = (struct vectors *)data;
@@ -693,19 +867,16 @@ show_blacklist (char ** r, int * len)
 	unsigned int maxlen = INITIAL_REPLY_LEN;
 	int again = 1;
 
+	reply = MALLOC(maxlen);
+
 	while (again) {
-		reply = MALLOC(maxlen);
 		if (!reply)
 			return 1;
 
 		c = reply;
 		c += snprint_blacklist_report(c, maxlen);
 		again = ((c - reply) == maxlen);
-		if (again) {
-			maxlen  *= 2;
-			FREE(reply);
-			continue;
-		}
+		REALLOC_REPLY(reply, again, maxlen);
 	}
 
 	*r = reply;
@@ -730,19 +901,16 @@ show_devices (char ** r, int * len, struct vectors *vecs)
 	unsigned int maxlen = INITIAL_REPLY_LEN;
 	int again = 1;
 
+	reply = MALLOC(maxlen);
+
 	while (again) {
-		reply = MALLOC(maxlen);
 		if (!reply)
 			return 1;
 
 		c = reply;
 		c += snprint_devices(c, maxlen, vecs);
 		again = ((c - reply) == maxlen);
-		if (again) {
-			maxlen  *= 2;
-			FREE(reply);
-			continue;
-		}
+		REALLOC_REPLY(reply, again, maxlen);
 	}
 
 	*r = reply;
@@ -766,3 +934,83 @@ cli_quit (void * v, char ** reply, int * len, void * data)
 {
 	return 0;
 }
+
+int
+cli_shutdown (void * v, char ** reply, int * len, void * data)
+{
+	condlog(3, "shutdown (operator)");
+	exit_daemon();
+	return 0;
+}
+
+int
+cli_getprstatus (void * v, char ** reply, int * len, void * data)
+{
+	struct multipath * mpp;
+	struct vectors * vecs = (struct vectors *)data;
+	char * param = get_keyparam(v, MAP);
+
+	get_path_layout(vecs->pathvec, 0);
+	mpp = find_mp_by_str(vecs->mpvec, param);
+
+	if (!mpp)
+		return 1;
+
+	condlog(3, "%s: prflag = %u", param, (unsigned int)mpp->prflag);
+
+	*reply =(char *)malloc(2);
+	*len = 2;
+	memset(*reply,0,2);
+
+
+	sprintf(*reply,"%d",mpp->prflag);
+	(*reply)[1]='\0';
+
+
+	condlog(3, "%s: reply = %s", param, *reply);
+
+	return 0;
+}
+
+int
+cli_setprstatus(void * v, char ** reply, int * len, void * data)
+{
+	struct multipath * mpp;
+	struct vectors * vecs = (struct vectors *)data;
+	char * param = get_keyparam(v, MAP);
+
+	get_path_layout(vecs->pathvec, 0);
+	mpp = find_mp_by_str(vecs->mpvec, param);
+
+	if (!mpp)
+		return 1;
+
+	if (!mpp->prflag) {
+		mpp->prflag = 1;
+		condlog(2, "%s: prflag set", param);
+	}
+
+
+	return 0;
+}
+
+int
+cli_unsetprstatus(void * v, char ** reply, int * len, void * data)
+{
+	struct multipath * mpp;
+	struct vectors * vecs = (struct vectors *)data;
+	char * param = get_keyparam(v, MAP);
+
+	get_path_layout(vecs->pathvec, 0);
+	mpp = find_mp_by_str(vecs->mpvec, param);
+
+	if (!mpp)
+		return 1;
+
+	if (mpp->prflag) {
+		mpp->prflag = 0;
+		condlog(2, "%s: prflag unset", param);
+	}
+
+	return 0;
+}
diff --git a/multipathd/cli_handlers.h b/multipathd/cli_handlers.h
index b3ad377..de51961 100644
--- a/multipathd/cli_handlers.h
+++ b/multipathd/cli_handlers.h
@@ -1,6 +1,7 @@
 int cli_list_paths (void * v, char ** reply, int * len, void * data);
 int cli_list_paths_fmt (void * v, char ** reply, int * len, void * data);
 int cli_list_status (void * v, char ** reply, int * len, void * data);
+int cli_list_daemon (void * v, char ** reply, int * len, void * data);
 int cli_list_maps (void * v, char ** reply, int * len, void * data);
 int cli_list_maps_fmt (void * v, char ** reply, int * len, void * data);
 int cli_list_maps_status (void * v, char ** reply, int * len, void * data);
@@ -18,6 +19,7 @@ int cli_del_map (void * v, char ** reply, int * len, void * data);
 int cli_switch_group(void * v, char ** reply, int * len, void * data);
 int cli_reconfigure(void * v, char ** reply, int * len, void * data);
 int cli_resize(void * v, char ** reply, int * len, void * data);
+int cli_reload(void * v, char ** reply, int * len, void * data);
 int cli_disable_queueing(void * v, char ** reply, int * len, void * data);
 int cli_disable_all_queueing(void * v, char ** reply, int * len, void * data);
 int cli_restore_queueing(void * v, char ** reply, int * len, void * data);
@@ -26,4 +28,12 @@ int cli_suspend(void * v, char ** reply, int * len, void * data);
 int cli_resume(void * v, char ** reply, int * len, void * data);
 int cli_reinstate(void * v, char ** reply, int * len, void * data);
 int cli_fail(void * v, char ** reply, int * len, void * data);
+int cli_force_no_daemon_q(void * v, char ** reply, int * len, void * data);
+int cli_restore_no_daemon_q(void * v, char ** reply, int * len, void * data);
 int cli_quit(void * v, char ** reply, int * len, void * data);
+int cli_shutdown(void * v, char ** reply, int * len, void * data);
+int cli_reassign (void * v, char ** reply, int * len, void * data);
+int cli_getprstatus(void * v, char ** reply, int * len, void * data);
+int cli_setprstatus(void * v, char ** reply, int * len, void * data);
+int cli_unsetprstatus(void * v, char ** reply, int * len, void * data);
+
diff --git a/multipathd/main.c b/multipathd/main.c
index 6ee7903..0fa1b17 100644
--- a/multipathd/main.c
+++ b/multipathd/main.c
@@ -15,6 +15,10 @@
 #include <sys/time.h>
 #include <sys/resource.h>
 #include <limits.h>
+#include <linux/oom.h>
+#include <libudev.h>
+#include <semaphore.h>
+#include <mpath_persist.h>
 
 /*
  * libcheckers
@@ -32,7 +36,6 @@
 #include <hwtable.h>
 #include <defaults.h>
 #include <structs.h>
-#include <callout.h>
 #include <blacklist.h>
 #include <structs_vec.h>
 #include <dmparser.h>
@@ -47,6 +50,9 @@
 #include <print.h>
 #include <configure.h>
 #include <prio.h>
+#include <pgpolicies.h>
+#include <uevent.h>
+#include <log.h>
 
 #include "main.h"
 #include "pidfile.h"
@@ -56,18 +62,32 @@
 #include "cli_handlers.h"
 #include "lock.h"
 #include "waiter.h"
+#include "wwids.h"
 
 #define FILE_NAME_SIZE 256
 #define CMDSIZE 160
 
-#define LOG_MSG(a,b) \
-	if (strlen(b)) condlog(a, "%s: %s - %s", pp->mpp->alias, pp->dev, b);
+#define LOG_MSG(a, b) \
+do { \
+	if (pp->offline) \
+		condlog(a, "%s: %s - path offline", pp->mpp->alias, pp->dev); \
+	else if (strlen(b)) \
+		condlog(a, "%s: %s - %s", pp->mpp->alias, pp->dev, b); \
+} while(0)
+
+struct mpath_event_param
+{
+	char * devname;
+	struct multipath *mpp;
+};
 
-pthread_cond_t exit_cond = PTHREAD_COND_INITIALIZER;
-pthread_mutex_t exit_mutex = PTHREAD_MUTEX_INITIALIZER;
+unsigned int mpath_mx_alloc_len;
 
 int logsink;
+enum daemon_status running_state;
+pid_t daemon_pid;
 
+static sem_t exit_sem;
 /*
  * global copy of vecs for use in sig handlers
  */
@@ -143,6 +163,10 @@ coalesce_maps(struct vectors *vecs, vector nmpv)
 				dm_lib_release();
 				condlog(2, "%s devmap removed", ompp->alias);
 			}
+		} else if (conf->reassign_maps) {
+			condlog(3, "%s: Reassign existing device-mapper"
+				" devices", ompp->alias);
+			dm_reassign(ompp->alias);
 		}
 	}
 	return 0;
@@ -213,38 +237,41 @@ flush_map(struct multipath * mpp, struct vectors * vecs)
 }
 
 static int
-uev_add_map (struct sysfs_device * dev, struct vectors * vecs)
+uev_add_map (struct uevent * uev, struct vectors * vecs)
 {
-	condlog(2, "%s: add map (uevent)", dev->kernel);
-	return ev_add_map(dev, vecs);
+	char *alias;
+	int major = -1, minor = -1, rc;
+
+	condlog(3, "%s: add map (uevent)", uev->kernel);
+	alias = uevent_get_dm_name(uev);
+	if (!alias) {
+		condlog(3, "%s: No DM_NAME in uevent", uev->kernel);
+		major = uevent_get_major(uev);
+		minor = uevent_get_minor(uev);
+		alias = dm_mapname(major, minor);
+		if (!alias) {
+			condlog(2, "%s: mapname not found for %d:%d",
+				uev->kernel, major, minor);
+			return 1;
+		}
+	}
+	rc = ev_add_map(uev->kernel, alias, vecs);
+	FREE(alias);
+	return rc;
 }
 
 int
-ev_add_map (struct sysfs_device * dev, struct vectors * vecs)
+ev_add_map (char * dev, char * alias, struct vectors * vecs)
 {
-	char * alias;
-	char *dev_t;
-	int major, minor;
 	char * refwwid;
 	struct multipath * mpp;
 	int map_present;
 	int r = 1;
 
-	dev_t = sysfs_attr_get_value(dev->devpath, "dev");
-
-	if (!dev_t || sscanf(dev_t, "%d:%d", &major, &minor) != 2)
-		return 1;
-
-	alias = dm_mapname(major, minor);
-
-	if (!alias)
-		return 1;
-
 	map_present = dm_map_present(alias);
 
 	if (map_present && dm_type(alias, TGT_MPATH) <= 0) {
 		condlog(4, "%s: not a multipath map", alias);
-		FREE(alias);
 		return 0;
 	}
 
@@ -256,21 +283,24 @@ ev_add_map (struct sysfs_device * dev, struct vectors * vecs)
 		 * if we create a multipath mapped device as a result
 		 * of uev_add_path
 		 */
-		condlog(0, "%s: devmap already registered",
-			dev->kernel);
-		FREE(alias);
+		if (conf->reassign_maps) {
+			condlog(3, "%s: Reassign existing device-mapper devices",
+				alias);
+			dm_reassign(alias);
+		}
 		return 0;
 	}
+	condlog(2, "%s: adding map", alias);
 
 	/*
 	 * now we can register the map
 	 */
-	if (map_present && (mpp = add_map_without_path(vecs, minor, alias))) {
+	if (map_present && (mpp = add_map_without_path(vecs, alias))) {
 		sync_map_state(mpp);
-		condlog(2, "%s: devmap %s added", alias, dev->kernel);
+		condlog(2, "%s: devmap %s registered", alias, dev);
 		return 0;
 	}
-	refwwid = get_refwwid(dev->kernel, DEV_DEVMAP, vecs->pathvec);
+	r = get_refwwid(dev, DEV_DEVMAP, vecs->pathvec, &refwwid);
 
 	if (refwwid) {
 		r = coalesce_paths(vecs, NULL, refwwid, 0);
@@ -278,122 +308,147 @@ ev_add_map (struct sysfs_device * dev, struct vectors * vecs)
 	}
 
 	if (!r)
-		condlog(2, "%s: devmap %s added", alias, dev->kernel);
+		condlog(2, "%s: devmap %s added", alias, dev);
+	else if (r == 2)
+		condlog(2, "%s: uev_add_map %s blacklisted", alias, dev);
 	else
-		condlog(0, "%s: uev_add_map %s failed", alias, dev->kernel);
+		condlog(0, "%s: uev_add_map %s failed", alias, dev);
 
 	FREE(refwwid);
-	FREE(alias);
 	return r;
 }
 
 static int
-uev_remove_map (struct sysfs_device * dev, struct vectors * vecs)
-{
-	condlog(2, "%s: remove map (uevent)", dev->kernel);
-	return ev_remove_map(dev->kernel, vecs);
-}
-
-int
-ev_remove_map (char * devname, struct vectors * vecs)
+uev_remove_map (struct uevent * uev, struct vectors * vecs)
 {
-	struct multipath * mpp;
+	char *alias;
+	int minor;
+	struct multipath *mpp;
 
-	mpp = find_mp_by_str(vecs->mpvec, devname);
+	condlog(2, "%s: remove map (uevent)", uev->kernel);
+	alias = uevent_get_dm_name(uev);
+	if (!alias) {
+		condlog(3, "%s: No DM_NAME in uevent, ignoring", uev->kernel);
+		return 0;
+	}
+	minor = uevent_get_minor(uev);
+	mpp = find_mp_by_minor(vecs->mpvec, minor);
 
 	if (!mpp) {
 		condlog(2, "%s: devmap not registered, can't remove",
-			devname);
-		return 0;
+			uev->kernel);
+		goto out;
+	}
+	if (strcmp(mpp->alias, alias)) {
+		condlog(2, "%s: minor number mismatch (map %d, event %d)",
+			mpp->alias, mpp->dmi->minor, minor);
+		goto out;
 	}
-	flush_map(mpp, vecs);
 
+	orphan_paths(vecs->pathvec, mpp);
+	remove_map_and_stop_waiter(mpp, vecs, 1);
+out:
+	FREE(alias);
 	return 0;
 }
 
-static int
-uev_umount_map (struct sysfs_device * dev, struct vectors * vecs)
+int
+ev_remove_map (char * devname, char * alias, int minor, struct vectors * vecs)
 {
 	struct multipath * mpp;
 
-	condlog(2, "%s: umount map (uevent)", dev->kernel);
-
-	mpp = find_mp_by_str(vecs->mpvec, dev->kernel);
+	mpp = find_mp_by_minor(vecs->mpvec, minor);
 
-	if (!mpp)
+	if (!mpp) {
+		condlog(2, "%s: devmap not registered, can't remove",
+			devname);
 		return 0;
-
-	update_mpp_paths(mpp, vecs->pathvec);
-	verify_paths(mpp, vecs, NULL);
-
-	if (!VECTOR_SIZE(mpp->paths))
-		flush_map(mpp, vecs);
-
-	return 0;
+	}
+	if (strcmp(mpp->alias, alias)) {
+		condlog(2, "%s: minor number mismatch (map %d, event %d)",
+			mpp->alias, mpp->dmi->minor, minor);
+		return 0;
+	}
+	return flush_map(mpp, vecs);
 }
 
 static int
-uev_add_path (struct sysfs_device * dev, struct vectors * vecs)
+uev_add_path (struct uevent *uev, struct vectors * vecs)
 {
-	condlog(2, "%s: add path (uevent)", dev->kernel);
-	return (ev_add_path(dev->kernel, vecs) != 1)? 0 : 1;
-}
-
-
-/*
- * returns:
- * 0: added
- * 1: error
- * 2: blacklisted
- */
-int
-ev_add_path (char * devname, struct vectors * vecs)
-{
-	struct multipath * mpp;
-	struct path * pp;
-	char empty_buff[WWID_SIZE] = {0};
+	struct path *pp;
+	int ret, i;
 
-	if (strstr(devname, "..") != NULL) {
+	condlog(2, "%s: add path (uevent)", uev->kernel);
+	if (strstr(uev->kernel, "..") != NULL) {
 		/*
 		 * Don't allow relative device names in the pathvec
 		 */
-		condlog(0, "%s: path name is invalid", devname);
+		condlog(0, "%s: path name is invalid", uev->kernel);
 		return 1;
 	}
 
-	pp = find_path_by_dev(vecs->pathvec, devname);
-
+	pp = find_path_by_dev(vecs->pathvec, uev->kernel);
 	if (pp) {
 		condlog(0, "%s: spurious uevent, path already in pathvec",
-			devname);
+			uev->kernel);
 		if (pp->mpp)
 			return 0;
-	}
-	else {
+		if (!strlen(pp->wwid)) {
+			udev_device_unref(pp->udev);
+			pp->udev = udev_device_ref(uev->udev);
+			ret = pathinfo(pp, conf->hwtable,
+				       DI_ALL | DI_BLACKLIST);
+			if (ret == 2) {
+				i = find_slot(vecs->pathvec, (void *)pp);
+				if (i != -1)
+					vector_del_slot(vecs->pathvec, i);
+				free_path(pp);
+				return 0;
+			} else if (ret == 1) {
+				condlog(0, "%s: failed to reinitialize path",
+					uev->kernel);
+				return 1;
+			}
+		}
+	} else {
 		/*
 		 * get path vital state
 		 */
-		if (!(pp = store_pathinfo(vecs->pathvec, conf->hwtable,
-		      devname, DI_ALL))) {
-			condlog(0, "%s: failed to store path info", devname);
+		ret = store_pathinfo(vecs->pathvec, conf->hwtable,
+				     uev->udev, DI_ALL, &pp);
+		if (!pp) {
+			if (ret == 2)
+				return 0;
+			condlog(0, "%s: failed to store path info",
+				uev->kernel);
 			return 1;
 		}
 		pp->checkint = conf->checkint;
 	}
 
+	return ev_add_path(pp, vecs);
+}
+
+/*
+ * returns:
+ * 0: added
+ * 1: error
+ */
+int
+ev_add_path (struct path * pp, struct vectors * vecs)
+{
+	struct multipath * mpp;
+	char empty_buff[WWID_SIZE] = {0};
+	char params[PARAMS_SIZE] = {0};
+	int retries = 3;
+	int start_waiter = 0;
+
 	/*
 	 * need path UID to go any further
 	 */
 	if (memcmp(empty_buff, pp->wwid, WWID_SIZE) == 0) {
-		condlog(0, "%s: failed to get path uid", devname);
-		return 1; /* leave path added to pathvec */
-	}
-	if (filter_path(conf, pp) > 0){
-		int i = find_slot(vecs->pathvec, (void *)pp);
-		if (i != -1)
-			vector_del_slot(vecs->pathvec, i);
-		free_path(pp);
-		return 2;
+		condlog(0, "%s: failed to get path uid", pp->dev);
+		goto fail; /* leave path added to pathvec */
 	}
 	mpp = pp->mpp = find_mp_by_wwid(vecs->mpvec, pp->wwid);
 rescan:
@@ -402,11 +457,11 @@ rescan:
 			if (!pp->size)
 				condlog(0, "%s: failed to add new path %s, "
 					"device size is 0",
-					devname, pp->dev);
+					mpp->alias, pp->dev);
 			else
 				condlog(0, "%s: failed to add new path %s, "
 					"device size mismatch",
-					devname, pp->dev);
+					mpp->alias, pp->dev);
 			int i = find_slot(vecs->pathvec, (void *)pp);
 			if (i != -1)
 				vector_del_slot(vecs->pathvec, i);
@@ -416,8 +471,8 @@ rescan:
 
 		condlog(4,"%s: adopting all paths for path %s",
 			mpp->alias, pp->dev);
-		if (adopt_paths(vecs->pathvec, mpp))
-			return 1; /* leave path added to pathvec */
+		if (adopt_paths(vecs->pathvec, mpp, 1))
+			goto fail; /* leave path added to pathvec */
 
 		verify_paths(mpp, vecs, NULL);
 		mpp->flush_on_last_del = FLUSH_UNDEF;
@@ -426,7 +481,7 @@ rescan:
 	else {
 		if (!pp->size) {
 			condlog(0, "%s: failed to create new map,"
-				" %s device size is 0 ", devname, pp->dev);
+				" device size is 0 ", pp->dev);
 			int i = find_slot(vecs->pathvec, (void *)pp);
 			if (i != -1)
 				vector_del_slot(vecs->pathvec, i);
@@ -435,37 +490,48 @@ rescan:
 		}
 
 		condlog(4,"%s: creating new map", pp->dev);
-		if ((mpp = add_map_with_path(vecs, pp, 1)))
+		if ((mpp = add_map_with_path(vecs, pp, 1))) {
 			mpp->action = ACT_CREATE;
+			/*
+			 * We don't depend on ACT_CREATE, as domap will
+			 * set it to ACT_NOTHING when complete.
+			 */
+			start_waiter = 1;
+		}
 		else
-			return 1; /* leave path added to pathvec */
+			goto fail; /* leave path added to pathvec */
 	}
 
+	/* persistent reseravtion check*/
+	mpath_pr_event_handle(pp);	
+
 	/*
 	 * push the map to the device-mapper
 	 */
-	if (setup_map(mpp)) {
+	if (setup_map(mpp, params, PARAMS_SIZE)) {
 		condlog(0, "%s: failed to setup map for addition of new "
-			"path %s", mpp->alias, devname);
-		goto out;
+			"path %s", mpp->alias, pp->dev);
+		goto fail_map;
 	}
 	/*
 	 * reload the map for the multipath mapped device
 	 */
-	if (domap(mpp) <= 0) {
+	if (domap(mpp, params) <= 0) {
 		condlog(0, "%s: failed in domap for addition of new "
-			"path %s", mpp->alias, devname);
+			"path %s", mpp->alias, pp->dev);
 		/*
 		 * deal with asynchronous uevents :((
 		 */
-		if (mpp->action == ACT_RELOAD) {
+		if (mpp->action == ACT_RELOAD && retries-- > 0) {
 			condlog(0, "%s: uev_add_path sleep", mpp->alias);
 			sleep(1);
 			update_mpp_paths(mpp, vecs->pathvec);
 			goto rescan;
 		}
+		else if (mpp->action == ACT_RELOAD)
+			condlog(0, "%s: giving up reload", mpp->alias);
 		else
-			goto out;
+			goto fail_map;
 	}
 	dm_lib_release();
 
@@ -473,49 +539,53 @@ rescan:
 	 * update our state from kernel regardless of create or reload
 	 */
 	if (setup_multipath(vecs, mpp))
-		goto out;
+		goto fail; /* if setup_multipath fails, it removes the map */
 
 	sync_map_state(mpp);
 
-	if (mpp->action == ACT_CREATE &&
+	if ((mpp->action == ACT_CREATE ||
+	     (mpp->action == ACT_NOTHING && start_waiter && !mpp->waiter)) &&
 	    start_waiter_thread(mpp, vecs))
-			goto out;
+			goto fail_map;
 
-	condlog(2, "%s path added to devmap %s", devname, mpp->alias);
-	return 0;
+	if (retries >= 0) {
+		condlog(2, "%s [%s]: path added to devmap %s",
+			pp->dev, pp->dev_t, mpp->alias);
+		return 0;
+	}
+	else
+		return 1;
 
-out:
+fail_map:
 	remove_map(mpp, vecs, 1);
+fail:
+	orphan_path(pp);
 	return 1;
 }
 
 static int
-uev_remove_path (struct sysfs_device * dev, struct vectors * vecs)
+uev_remove_path (struct uevent *uev, struct vectors * vecs)
 {
-	int retval;
+	struct path *pp;
 
-	condlog(2, "%s: remove path (uevent)", dev->kernel);
-	retval = ev_remove_path(dev->kernel, vecs);
-	if (!retval)
-		sysfs_device_put(dev);
+	condlog(2, "%s: remove path (uevent)", uev->kernel);
+	pp = find_path_by_dev(vecs->pathvec, uev->kernel);
 
-	return retval;
+	if (!pp) {
+		/* Not an error; path might have been purged earlier */
+		condlog(0, "%s: path already removed", uev->kernel);
+		return 0;
+	}
+
+	return ev_remove_path(pp, vecs);
 }
 
 int
-ev_remove_path (char * devname, struct vectors * vecs)
+ev_remove_path (struct path *pp, struct vectors * vecs)
 {
 	struct multipath * mpp;
-	struct path * pp;
 	int i, retval = 0;
-
-	pp = find_path_by_dev(vecs->pathvec, devname);
-
-	if (!pp) {
-		/* Not an error; path might have been purged earlier */
-		condlog(0, "%s: path already removed", devname);
-		return 0;
-	}
+	char params[PARAMS_SIZE] = {0};
 
 	/*
 	 * avoid referring to the map of an orphaned path
@@ -562,20 +632,19 @@ ev_remove_path (char * devname, struct vectors * vecs)
 			 */
 		}
 
-		if (setup_map(mpp)) {
+		if (setup_map(mpp, params, PARAMS_SIZE)) {
 			condlog(0, "%s: failed to setup map for"
-				" removal of path %s", mpp->alias,
-				devname);
+				" removal of path %s", mpp->alias, pp->dev);
 			goto fail;
 		}
 		/*
 		 * reload the map
 		 */
 		mpp->action = ACT_RELOAD;
-		if (domap(mpp) <= 0) {
+		if (domap(mpp, params) <= 0) {
 			condlog(0, "%s: failed in domap for "
 				"removal of path %s",
-				mpp->alias, devname);
+				mpp->alias, pp->dev);
 			retval = 1;
 		} else {
 			/*
@@ -586,8 +655,8 @@ ev_remove_path (char * devname, struct vectors * vecs)
 			}
 			sync_map_state(mpp);
 
-			condlog(2, "%s: path removed from map %s",
-				devname, mpp->alias);
+			condlog(2, "%s [%s]: path removed from map %s",
+				pp->dev, pp->dev_t, mpp->alias);
 		}
 	}
 
@@ -605,6 +674,36 @@ fail:
 }
 
 static int
+uev_update_path (struct uevent *uev, struct vectors * vecs)
+{
+	int ro, retval = 0;
+
+	ro = uevent_get_disk_ro(uev);
+
+	if (ro >= 0) {
+		struct path * pp;
+
+		condlog(2, "%s: update path write_protect to '%d' (uevent)",
+			uev->kernel, ro);
+		pp = find_path_by_dev(vecs->pathvec, uev->kernel);
+		if (!pp) {
+			condlog(0, "%s: spurious uevent, path not found",
+				uev->kernel);
+			return 1;
+		}
+		if (pp->mpp) {
+			retval = reload_map(vecs, pp->mpp, 0);
+
+			condlog(2, "%s: map %s reloaded (retval %d)",
+				uev->kernel, pp->mpp->alias, retval);
+		}
+
+	}
+
+	return retval;
+}
+
+static int
 map_discovery (struct vectors * vecs)
 {
 	struct multipath * mpp;
@@ -632,6 +731,7 @@ uxsock_trigger (char * str, char ** reply, int * len, void * trigger_data)
 
 	pthread_cleanup_push(cleanup_lock, &vecs->lock);
 	lock(vecs->lock);
+	pthread_testcancel();
 
 	r = parse_cmd(str, reply, len, vecs);
 
@@ -677,7 +777,6 @@ int
 uev_trigger (struct uevent * uev, void * trigger_data)
 {
 	int r = 0;
-	struct sysfs_device *sysdev;
 	struct vectors * vecs;
 
 	vecs = (struct vectors *)trigger_data;
@@ -685,28 +784,22 @@ uev_trigger (struct uevent * uev, void * trigger_data)
 	if (uev_discard(uev->devpath))
 		return 0;
 
-	sysdev = sysfs_device_get(uev->devpath);
-	if(!sysdev)
-		return 0;
-
+	pthread_cleanup_push(cleanup_lock, &vecs->lock);
 	lock(vecs->lock);
+	pthread_testcancel();
 
 	/*
 	 * device map event
 	 * Add events are ignored here as the tables
 	 * are not fully initialised then.
 	 */
-	if (!strncmp(sysdev->kernel, "dm-", 3)) {
+	if (!strncmp(uev->kernel, "dm-", 3)) {
 		if (!strncmp(uev->action, "change", 6)) {
-			r = uev_add_map(sysdev, vecs);
+			r = uev_add_map(uev, vecs);
 			goto out;
 		}
 		if (!strncmp(uev->action, "remove", 6)) {
-			r = uev_remove_map(sysdev, vecs);
-			goto out;
-		}
-		if (!strncmp(uev->action, "umount", 6)) {
-			r = uev_umount_map(sysdev, vecs);
+			r = uev_remove_map(uev, vecs);
 			goto out;
 		}
 		goto out;
@@ -716,41 +809,47 @@ uev_trigger (struct uevent * uev, void * trigger_data)
 	 * path add/remove event
 	 */
 	if (filter_devnode(conf->blist_devnode, conf->elist_devnode,
-			   sysdev->kernel) > 0)
+			   uev->kernel) > 0)
 		goto out;
 
 	if (!strncmp(uev->action, "add", 3)) {
-		r = uev_add_path(sysdev, vecs);
+		r = uev_add_path(uev, vecs);
 		goto out;
 	}
 	if (!strncmp(uev->action, "remove", 6)) {
-		r = uev_remove_path(sysdev, vecs);
+		r = uev_remove_path(uev, vecs);
+		goto out;
+	}
+	if (!strncmp(uev->action, "change", 6)) {
+		r = uev_update_path(uev, vecs);
 		goto out;
 	}
 
 out:
-	unlock(vecs->lock);
+	lock_cleanup_pop(vecs->lock);
 	return r;
 }
 
 static void *
 ueventloop (void * ap)
 {
-	block_signal(SIGUSR1, NULL);
-	block_signal(SIGHUP, NULL);
-
-	if (uevent_listen(&uev_trigger, ap))
-		fprintf(stderr, "error starting uevent listener");
+	if (uevent_listen())
+		condlog(0, "error starting uevent listener");
 
 	return NULL;
 }
 
 static void *
-uxlsnrloop (void * ap)
+uevqloop (void * ap)
 {
-	block_signal(SIGUSR1, NULL);
-	block_signal(SIGHUP, NULL);
+	if (uevent_dispatch(&uev_trigger, ap))
+		condlog(0, "error starting uevent dispatcher");
 
+	return NULL;
+}
+static void *
+uxlsnrloop (void * ap)
+{
 	if (cli_init())
 		return NULL;
 
@@ -758,6 +857,7 @@ uxlsnrloop (void * ap)
 	set_handler_callback(LIST+PATHS+FMT, cli_list_paths_fmt);
 	set_handler_callback(LIST+MAPS, cli_list_maps);
 	set_handler_callback(LIST+STATUS, cli_list_status);
+	set_handler_callback(LIST+DAEMON, cli_list_daemon);
 	set_handler_callback(LIST+MAPS+STATUS, cli_list_maps_status);
 	set_handler_callback(LIST+MAPS+STATS, cli_list_maps_stats);
 	set_handler_callback(LIST+MAPS+FMT, cli_list_maps_fmt);
@@ -777,6 +877,8 @@ uxlsnrloop (void * ap)
 	set_handler_callback(SUSPEND+MAP, cli_suspend);
 	set_handler_callback(RESUME+MAP, cli_resume);
 	set_handler_callback(RESIZE+MAP, cli_resize);
+	set_handler_callback(RELOAD+MAP, cli_reload);
+	set_handler_callback(RESET+MAP, cli_reassign);
 	set_handler_callback(REINSTATE+PATH, cli_reinstate);
 	set_handler_callback(FAIL+PATH, cli_fail);
 	set_handler_callback(DISABLEQ+MAP, cli_disable_queueing);
@@ -784,6 +886,12 @@ uxlsnrloop (void * ap)
 	set_handler_callback(DISABLEQ+MAPS, cli_disable_all_queueing);
 	set_handler_callback(RESTOREQ+MAPS, cli_restore_all_queueing);
 	set_handler_callback(QUIT, cli_quit);
+	set_handler_callback(SHUTDOWN, cli_shutdown);
+	set_handler_callback(GETPRSTATUS+MAP, cli_getprstatus);
+	set_handler_callback(SETPRSTATUS+MAP, cli_setprstatus);
+	set_handler_callback(UNSETPRSTATUS+MAP, cli_unsetprstatus);
+	set_handler_callback(FORCEQ+DAEMON, cli_force_no_daemon_q);
+	set_handler_callback(RESTOREQ+DAEMON, cli_restore_no_daemon_q);
 
 	umask(077);
 	uxsock_listen(&uxsock_trigger, ap);
@@ -791,20 +899,28 @@ uxlsnrloop (void * ap)
 	return NULL;
 }
 
-static int
-exit_daemon (int status)
+void
+exit_daemon (void)
 {
-	if (status != 0)
-		fprintf(stderr, "bad exit status. see daemon.log\n");
-
-	condlog(3, "unlink pidfile");
-	unlink(DEFAULT_PIDFILE);
-
-	pthread_mutex_lock(&exit_mutex);
-	pthread_cond_signal(&exit_cond);
-	pthread_mutex_unlock(&exit_mutex);
+	sem_post(&exit_sem);
+}
 
-	return status;
+const char *
+daemon_status(void)
+{
+	switch (running_state) {
+	case DAEMON_INIT:
+		return "init";
+	case DAEMON_START:
+		return "startup";
+	case DAEMON_CONFIGURE:
+		return "configure";
+	case DAEMON_RUNNING:
+		return "running";
+	case DAEMON_SHUTDOWN:
+		return "shutdown";
+	}
+	return NULL;
 }
 
 static void
@@ -880,6 +996,32 @@ mpvec_garbage_collector (struct vectors * vecs)
 	}
 }
 
+/* This is called after a path has started working again. It the multipath
+ * device for this path uses the followover failback type, and this is the
+ * best pathgroup, and this is the first path in the pathgroup to come back
+ * up, then switch to this pathgroup */
+static int
+followover_should_failback(struct path * pp)
+{
+	struct pathgroup * pgp;
+	struct path *pp1;
+	int i;
+
+	if (pp->mpp->pgfailback != -FAILBACK_FOLLOWOVER ||
+	    !pp->mpp->pg || !pp->pgindex ||
+	    pp->pgindex != pp->mpp->bestpg)
+		return 0;
+
+	pgp = VECTOR_SLOT(pp->mpp->pg, pp->pgindex - 1);
+	vector_foreach_slot(pgp->paths, pp1, i) {
+		if (pp1 == pp)
+			continue;
+		if (pp1->chkrstate != PATH_DOWN && pp1->chkrstate != PATH_SHAKY)
+			return 0;
+	}
+	return 1;
+}
+
 static void
 defered_failback_tick (vector mpvec)
 {
@@ -917,10 +1059,52 @@ retry_count_tick(vector mpvec)
 	}
 }
 
+int update_prio(struct path *pp, int refresh_all)
+{
+	int oldpriority;
+	struct path *pp1;
+	struct pathgroup * pgp;
+	int i, j, changed = 0;
+
+	if (refresh_all) {
+		vector_foreach_slot (pp->mpp->pg, pgp, i) {
+			vector_foreach_slot (pgp->paths, pp1, j) {
+				oldpriority = pp1->priority;
+				pathinfo(pp1, conf->hwtable, DI_PRIO);
+				if (pp1->priority != oldpriority)
+					changed = 1;
+			}
+		}
+		return changed;
+	}
+	oldpriority = pp->priority;
+	pathinfo(pp, conf->hwtable, DI_PRIO);
+
+	if (pp->priority == oldpriority)
+		return 0;
+	return 1;
+}
+
+int update_path_groups(struct multipath *mpp, struct vectors *vecs, int refresh)
+{
+	if (reload_map(vecs, mpp, refresh))
+		return 1;
+
+	dm_lib_release();
+	if (setup_multipath(vecs, mpp) != 0)
+		return 1;
+	sync_map_state(mpp);
+
+	return 0;
+}
+
 void
 check_path (struct vectors * vecs, struct path * pp)
 {
 	int newstate;
+	int new_path_up = 0;
+	int chkr_new_path_up = 0;
+	int oldchkrstate = pp->chkrstate;
 
 	if (!pp->mpp)
 		return;
@@ -934,7 +1118,9 @@ check_path (struct vectors * vecs, struct path * pp)
 	 */
 	pp->tick = conf->checkint;
 
-	newstate = get_state(pp, 1);
+	newstate = path_offline(pp);
+	if (newstate == PATH_UP)
+		newstate = get_state(pp, 1);
 
 	if (newstate == PATH_WILD || newstate == PATH_UNCHECKED) {
 		condlog(2, "%s: unusable path", pp->dev);
@@ -949,6 +1135,15 @@ check_path (struct vectors * vecs, struct path * pp)
 		pp->tick = 1;
 		return;
 	}
+	/*
+	 * Synchronize with kernel state
+	 */
+	if (update_multipath_strings(pp->mpp, vecs->pathvec)) {
+		condlog(1, "%s: Could not synchronize with kernel state",
+			pp->dev);
+		pp->dmstate = PSTATE_UNDEF;
+	}
+	pp->chkrstate = newstate;
 	if (newstate != pp->state) {
 		int oldstate = pp->state;
 		pp->state = newstate;
@@ -960,8 +1155,7 @@ check_path (struct vectors * vecs, struct path * pp)
 		 */
 		pp->checkint = conf->checkint;
 
-		if (newstate == PATH_DOWN || newstate == PATH_SHAKY ||
-		    update_multipath_strings(pp->mpp, vecs->pathvec)) {
+		if (newstate == PATH_DOWN || newstate == PATH_SHAKY) {
 			/*
 			 * proactively fail path in the DM
 			 */
@@ -980,6 +1174,17 @@ check_path (struct vectors * vecs, struct path * pp)
 			return;
 		}
 
+		if(newstate == PATH_UP || newstate == PATH_GHOST){
+			if ( pp->mpp && pp->mpp->prflag ){
+				/*
+				 * Check Persistent Reservation.
+				 */
+			condlog(2, "%s: checking persistent reservation "
+				"registration", pp->dev);
+			mpath_pr_event_handle(pp);
+			}
+		}
+
 		/*
 		 * reinstate this path
 		 */
@@ -989,15 +1194,10 @@ check_path (struct vectors * vecs, struct path * pp)
 		else
 			reinstate_path(pp, 0);
 
-		/*
-		 * schedule [defered] failback
-		 */
-		if (pp->mpp->pgfailback > 0)
-			pp->mpp->failback_tick =
-				pp->mpp->pgfailback + 1;
-		else if (pp->mpp->pgfailback == -FAILBACK_IMMEDIATE &&
-		    need_switch_pathgroup(pp->mpp, 1))
-			switch_pathgroup(pp->mpp);
+		new_path_up = 1;
+
+		if (oldchkrstate != PATH_UP && oldchkrstate != PATH_GHOST)
+			chkr_new_path_up = 1;
 
 		/*
 		 * if at least one path is up in a group, and
@@ -1007,22 +1207,34 @@ check_path (struct vectors * vecs, struct path * pp)
 			enable_group(pp);
 	}
 	else if (newstate == PATH_UP || newstate == PATH_GHOST) {
-		LOG_MSG(4, checker_message(&pp->checker));
-		/*
-		 * double the next check delay.
-		 * max at conf->max_checkint
-		 */
-		if (pp->checkint < (conf->max_checkint / 2))
-			pp->checkint = 2 * pp->checkint;
-		else
-			pp->checkint = conf->max_checkint;
+		if (pp->dmstate == PSTATE_FAILED ||
+		    pp->dmstate == PSTATE_UNDEF) {
+			/* Clear IO errors */
+			reinstate_path(pp, 0);
+		} else {
+			LOG_MSG(4, checker_message(&pp->checker));
+			if (pp->checkint != conf->max_checkint) {
+				/*
+				 * double the next check delay.
+				 * max at conf->max_checkint
+				 */
+				if (pp->checkint < (conf->max_checkint / 2))
+					pp->checkint = 2 * pp->checkint;
+				else
+					pp->checkint = conf->max_checkint;
 
-		pp->tick = pp->checkint;
-		condlog(4, "%s: delay next check %is",
-				pp->dev_t, pp->tick);
+				condlog(4, "%s: delay next check %is",
+					pp->dev_t, pp->checkint);
+			}
+			pp->tick = pp->checkint;
+		}
+	}
+	else if (newstate == PATH_DOWN) {
+		if (conf->log_checker_err == LOG_CHKR_ERR_ONCE)
+			LOG_MSG(3, checker_message(&pp->checker));
+		else
+			LOG_MSG(2, checker_message(&pp->checker));
 	}
-	else if (newstate == PATH_DOWN)
-		LOG_MSG(2, checker_message(&pp->checker));
 
 	pp->state = newstate;
 
@@ -1030,18 +1242,18 @@ check_path (struct vectors * vecs, struct path * pp)
 	 * path prio refreshing
 	 */
 	condlog(4, "path prio refresh");
-	pathinfo(pp, conf->hwtable, DI_PRIO);
 
-	/*
-	 * pathgroup failback policy
-	 */
-	if (need_switch_pathgroup(pp->mpp, 0)) {
+	if (update_prio(pp, new_path_up) &&
+	    (pp->mpp->pgpolicyfn == (pgpolicyfn *)group_by_prio) &&
+	     pp->mpp->pgfailback == -FAILBACK_IMMEDIATE)
+		update_path_groups(pp->mpp, vecs, !new_path_up);
+	else if (need_switch_pathgroup(pp->mpp, 0)) {
 		if (pp->mpp->pgfailback > 0 &&
-		    pp->mpp->failback_tick <= 0)
+		    (new_path_up || pp->mpp->failback_tick <= 0))
 			pp->mpp->failback_tick =
 				pp->mpp->pgfailback + 1;
-		else if (pp->mpp->pgfailback ==
-				-FAILBACK_IMMEDIATE)
+		else if (pp->mpp->pgfailback == -FAILBACK_IMMEDIATE ||
+			 (chkr_new_path_up && followover_should_failback(pp)))
 			switch_pathgroup(pp->mpp);
 	}
 }
@@ -1053,7 +1265,6 @@ checkerloop (void *ap)
 	struct path *pp;
 	int count = 0;
 	unsigned int i;
-	sigset_t old;
 
 	mlockall(MCL_CURRENT | MCL_FUTURE);
 	vecs = (struct vectors *)ap;
@@ -1067,9 +1278,9 @@ checkerloop (void *ap)
 	}
 
 	while (1) {
-		block_signal(SIGHUP, &old);
 		pthread_cleanup_push(cleanup_lock, &vecs->lock);
 		lock(vecs->lock);
+		pthread_testcancel();
 		condlog(4, "tick");
 
 		if (vecs->pathvec) {
@@ -1090,7 +1301,6 @@ checkerloop (void *ap)
 		}
 
 		lock_cleanup_pop(vecs->lock);
-		pthread_sigmask(SIG_SETMASK, &old, NULL);
 		sleep(1);
 	}
 	return NULL;
@@ -1133,7 +1343,7 @@ configure (struct vectors * vecs, int start_waiters)
 	/*
 	 * create new set of maps & push changed ones into dm
 	 */
-	if (coalesce_paths(vecs, mpvec, NULL, 0))
+	if (coalesce_paths(vecs, mpvec, NULL, 1))
 		return 1;
 
 	/*
@@ -1146,6 +1356,10 @@ configure (struct vectors * vecs, int start_waiters)
 	dm_lib_release();
 
 	sync_maps_state(mpvec);
+	vector_foreach_slot(mpvec, mpp, i){
+		remember_wwid(mpp->wwid);
+		update_map_pr(mpp);
+	}
 
 	/*
 	 * purge dm of old maps
@@ -1175,6 +1389,7 @@ int
 reconfigure (struct vectors * vecs)
 {
 	struct config * old = conf;
+	int retval = 1;
 
 	/*
 	 * free old map and path vectors ... they use old conf state
@@ -1188,19 +1403,15 @@ reconfigure (struct vectors * vecs)
 	vecs->pathvec = NULL;
 	conf = NULL;
 
-	if (load_config(DEFAULT_CONFIGFILE))
-		return 1;
-
-	conf->verbosity = old->verbosity;
-
-	if (!conf->checkint) {
-		conf->checkint = DEFAULT_CHECKINT;
-		conf->max_checkint = MAX_CHECKINT(conf->checkint);
+	if (!load_config(DEFAULT_CONFIGFILE)) {
+		conf->verbosity = old->verbosity;
+		conf->daemon = 1;
+		configure(vecs, 1);
+		free_config(old);
+		retval = 0;
 	}
-	conf->daemon = 1;
-	configure(vecs, 1);
-	free_config(old);
-	return 0;
+
+	return retval;
 }
 
 static struct vectors *
@@ -1249,35 +1460,56 @@ signal_set(int signo, void (*func) (int))
 		return (osig.sa_handler);
 }
 
+void
+handle_signals(void)
+{
+	if (reconfig_sig && running_state == DAEMON_RUNNING) {
+		condlog(2, "reconfigure (signal)");
+		pthread_cleanup_push(cleanup_lock,
+				&gvecs->lock);
+		lock(gvecs->lock);
+		pthread_testcancel();
+		reconfigure(gvecs);
+		lock_cleanup_pop(gvecs->lock);
+	}
+	if (log_reset_sig) {
+		condlog(2, "reset log (signal)");
+		pthread_mutex_lock(&logq_lock);
+		log_reset("multipathd");
+		pthread_mutex_unlock(&logq_lock);
+	}
+	reconfig_sig = 0;
+	log_reset_sig = 0;
+}
+
 static void
 sighup (int sig)
 {
-	condlog(2, "reconfigure (SIGHUP)");
-
-	lock(gvecs->lock);
-	reconfigure(gvecs);
-	unlock(gvecs->lock);
-
-#ifdef _DEBUG_
-	dbg_free_final(NULL);
-#endif
+	reconfig_sig = 1;
 }
 
 static void
 sigend (int sig)
 {
-	exit_daemon(0);
+	exit_daemon();
 }
 
 static void
 sigusr1 (int sig)
 {
-	condlog(3, "SIGUSR1 received");
+	log_reset_sig = 1;
 }
 
 static void
 signal_init(void)
 {
+	sigset_t set;
+
+	sigemptyset(&set);
+	sigaddset(&set, SIGHUP);
+	sigaddset(&set, SIGUSR1);
+	pthread_sigmask(SIG_BLOCK, &set, NULL);
+
 	signal_set(SIGHUP, sighup);
 	signal_set(SIGUSR1, sigusr1);
 	signal_set(SIGINT, sigend);
@@ -1301,53 +1533,60 @@ setscheduler (void)
 }
 
 static void
-set_oom_adj (int val)
+set_oom_adj (void)
 {
+#ifdef OOM_SCORE_ADJ_MIN
+	int retry = 1;
+	char *file = "/proc/self/oom_score_adj";
+	int score = OOM_SCORE_ADJ_MIN;
+#else
+	int retry = 0;
+	char *file = "/proc/self/oom_adj";
+	int score = OOM_ADJUST_MIN;
+#endif
 	FILE *fp;
-
-	fp = fopen("/proc/self/oom_adj", "w");
-
-	if (!fp)
-		return;
-
-	fprintf(fp, "%i", val);
-	fclose(fp);
-}
-
-void
-setup_thread_attr(pthread_attr_t *attr, size_t stacksize, int detached)
-{
-	if (pthread_attr_init(attr)) {
-		fprintf(stderr, "can't initialize thread attr: %s\n",
-			strerror(errno));
-		exit(1);
-	}
-	if (stacksize < PTHREAD_STACK_MIN)
-		stacksize = PTHREAD_STACK_MIN;
-
-	if (pthread_attr_setstacksize(attr, stacksize)) {
-		fprintf(stderr, "can't set thread stack size to %lu: %s\n",
-			(unsigned long)stacksize, strerror(errno));
-		exit(1);
-	}
-	if (detached && pthread_attr_setdetachstate(attr,
-						    PTHREAD_CREATE_DETACHED)) {
-		fprintf(stderr, "can't set thread to detached: %s\n",
-			strerror(errno));
-		exit(1);
-	}
+	struct stat st;
+
+	do {
+		if (stat(file, &st) == 0){
+			fp = fopen(file, "w");
+			if (!fp) {
+				condlog(0, "couldn't fopen %s : %s", file,
+					strerror(errno));
+				return;
+			}
+			fprintf(fp, "%i", score);
+			fclose(fp);
+			return;
+		}
+		if (errno != ENOENT) {
+			condlog(0, "couldn't stat %s : %s", file,
+				strerror(errno));
+			return;
+		}
+#ifdef OOM_ADJUST_MIN
+		file = "/proc/self/oom_adj";
+		score = OOM_ADJUST_MIN;
+#else
+		retry = 0;
+#endif
+	} while (retry--);
+	condlog(0, "couldn't adjust oom score");
 }
 
 static int
 child (void * param)
 {
-	pthread_t check_thr, uevent_thr, uxlsnr_thr;
+	pthread_t check_thr, uevent_thr, uxlsnr_thr, uevq_thr;
 	pthread_attr_t log_attr, misc_attr;
 	struct vectors * vecs;
 	struct multipath * mpp;
 	int i;
+	int rc, pid_rc;
 
 	mlockall(MCL_CURRENT | MCL_FUTURE);
+	sem_init(&exit_sem, 0, 0);
+	signal_init();
 
 	setup_thread_attr(&misc_attr, 64 * 1024, 1);
 	setup_thread_attr(&waiter_attr, 32 * 1024, 1);
@@ -1358,6 +1597,8 @@ child (void * param)
 		pthread_attr_destroy(&log_attr);
 	}
 
+	running_state = DAEMON_START;
+
 	condlog(2, "--------start up--------");
 	condlog(2, "read " DEFAULT_CONFIGFILE);
 
@@ -1375,90 +1616,110 @@ child (void * param)
 
 	setlogmask(LOG_UPTO(conf->verbosity + 3));
 
-	/*
-	 * fill the voids left in the config file
-	 */
-	if (!conf->checkint) {
-		conf->checkint = DEFAULT_CHECKINT;
-		conf->max_checkint = MAX_CHECKINT(conf->checkint);
-	}
-
 	if (conf->max_fds) {
 		struct rlimit fd_limit;
 
-		fd_limit.rlim_cur = conf->max_fds;
-		fd_limit.rlim_max = conf->max_fds;
-		if (setrlimit(RLIMIT_NOFILE, &fd_limit) < 0)
-			condlog(0, "can't set open fds limit to %d : %s\n",
-				conf->max_fds, strerror(errno));
-	}
-
-	if (pidfile_create(DEFAULT_PIDFILE, getpid())) {
-		if (logsink)
-			log_thread_stop();
+		if (getrlimit(RLIMIT_NOFILE, &fd_limit) < 0) {
+			condlog(0, "can't get open fds limit: %s",
+				strerror(errno));
+			fd_limit.rlim_cur = 0;
+			fd_limit.rlim_max = 0;
+		}
+		if (fd_limit.rlim_cur < conf->max_fds) {
+			fd_limit.rlim_cur = conf->max_fds;
+			if (fd_limit.rlim_max < conf->max_fds)
+				fd_limit.rlim_max = conf->max_fds;
+			if (setrlimit(RLIMIT_NOFILE, &fd_limit) < 0) {
+				condlog(0, "can't set open fds limit to "
+					"%lu/%lu : %s",
+					fd_limit.rlim_cur, fd_limit.rlim_max,
+					strerror(errno));
+			} else {
+				condlog(3, "set open fds limit to %lu/%lu",
+					fd_limit.rlim_cur, fd_limit.rlim_max);
+			}
+		}
 
-		exit(1);
 	}
-	signal_init();
-	setscheduler();
-	set_oom_adj(-16);
-	vecs = gvecs = init_vecs();
 
+	vecs = gvecs = init_vecs();
 	if (!vecs)
 		exit(1);
 
-	if (sysfs_init(conf->sysfs_dir, FILE_NAME_SIZE)) {
-		condlog(0, "can not find sysfs mount point");
+	setscheduler();
+	set_oom_adj();
+
+	conf->daemon = 1;
+	udev_set_sync_support(0);
+	/*
+	 * Start uevent listener early to catch events
+	 */
+	if ((rc = pthread_create(&uevent_thr, &misc_attr, ueventloop, vecs))) {
+		condlog(0, "failed to create uevent thread: %d", rc);
+		exit(1);
+	}
+	if ((rc = pthread_create(&uxlsnr_thr, &misc_attr, uxlsnrloop, vecs))) {
+		condlog(0, "failed to create cli listener: %d", rc);
 		exit(1);
 	}
-	conf->daemon = 1;
-	dm_udev_set_sync_support(0);
 	/*
 	 * fetch and configure both paths and multipaths
 	 */
+	running_state = DAEMON_CONFIGURE;
+
+	lock(vecs->lock);
 	if (configure(vecs, 1)) {
+		unlock(vecs->lock);
 		condlog(0, "failure during configuration");
 		exit(1);
 	}
+	unlock(vecs->lock);
+
 	/*
 	 * start threads
 	 */
-	pthread_create(&check_thr, &misc_attr, checkerloop, vecs);
-	pthread_create(&uevent_thr, &misc_attr, ueventloop, vecs);
-	pthread_create(&uxlsnr_thr, &misc_attr, uxlsnrloop, vecs);
+	if ((rc = pthread_create(&check_thr, &misc_attr, checkerloop, vecs))) {
+		condlog(0,"failed to create checker loop thread: %d", rc);
+		exit(1);
+	}
+	if ((rc = pthread_create(&uevq_thr, &misc_attr, uevqloop, vecs))) {
+		condlog(0, "failed to create uevent dispatcher: %d", rc);
+		exit(1);
+	}
 	pthread_attr_destroy(&misc_attr);
 
-	pthread_mutex_lock(&exit_mutex);
-	pthread_cond_wait(&exit_cond, &exit_mutex);
+	/* Startup complete, create logfile */
+	pid_rc = pidfile_create(DEFAULT_PIDFILE, daemon_pid);
+	/* Ignore errors, we can live without */
+
+	running_state = DAEMON_RUNNING;
 
 	/*
 	 * exit path
 	 */
-	block_signal(SIGHUP, NULL);
+	while(sem_wait(&exit_sem) != 0); /* Do nothing */
+	running_state = DAEMON_SHUTDOWN;
 	lock(vecs->lock);
 	if (conf->queue_without_daemon == QUE_NO_DAEMON_OFF)
 		vector_foreach_slot(vecs->mpvec, mpp, i)
 			dm_queue_if_no_path(mpp->alias, 0);
 	remove_maps_and_stop_waiters(vecs);
-	free_pathvec(vecs->pathvec, FREE_PATHS);
+	unlock(vecs->lock);
 
 	pthread_cancel(check_thr);
 	pthread_cancel(uevent_thr);
 	pthread_cancel(uxlsnr_thr);
+	pthread_cancel(uevq_thr);
 
-	sysfs_cleanup();
-
-	free_keys(keys);
-	keys = NULL;
-	free_handlers(handlers);
-	handlers = NULL;
-	free_polls();
-
+	lock(vecs->lock);
+	free_pathvec(vecs->pathvec, FREE_PATHS);
+	vecs->pathvec = NULL;
 	unlock(vecs->lock);
 	/* Now all the waitevent threads will start rushing in. */
 	while (vecs->lock.depth > 0) {
 		sleep (1); /* This is weak. */
-		condlog(3,"Have %d wait event checkers threads to de-alloc, waiting..\n", vecs->lock.depth);
+		condlog(3, "Have %d wait event checkers threads to de-alloc,"
+			" waiting...", vecs->lock.depth);
 	}
 	pthread_mutex_destroy(vecs->lock.mutex);
 	FREE(vecs->lock.mutex);
@@ -1467,16 +1728,23 @@ child (void * param)
 	FREE(vecs);
 	vecs = NULL;
 
+	cleanup_checkers();
+	cleanup_prio();
+
+	dm_lib_release();
+	dm_lib_exit();
+
+	/* We're done here */
+	if (!pid_rc) {
+		condlog(3, "unlink pidfile");
+		unlink(DEFAULT_PIDFILE);
+	}
+
 	condlog(2, "--------shut down-------");
 
 	if (logsink)
 		log_thread_stop();
 
-	dm_lib_release();
-	dm_lib_exit();
-
-	cleanup_prio();
-	cleanup_checkers();
 	/*
 	 * Freeing config must be done after condlog() and dm_lib_exit(),
 	 * because logging functions like dlog() and dm_write_log()
@@ -1496,7 +1764,7 @@ static int
 daemonize(void)
 {
 	int pid;
-	int in_fd, out_fd;
+	int dev_null_fd;
 
 	if( (pid = fork()) < 0){
 		fprintf(stderr, "Failed first fork : %s\n", strerror(errno));
@@ -1512,31 +1780,36 @@ daemonize(void)
 	else if (pid != 0)
 		_exit(0);
 
-	in_fd = open("/dev/null", O_RDONLY);
-	if (in_fd < 0){
-		fprintf(stderr, "cannot open /dev/null for input : %s\n",
+	if (chdir("/") < 0)
+		fprintf(stderr, "cannot chdir to '/', continuing\n");
+
+	dev_null_fd = open("/dev/null", O_RDWR);
+	if (dev_null_fd < 0){
+		fprintf(stderr, "cannot open /dev/null for input & output : %s\n",
 			strerror(errno));
 		_exit(0);
 	}
-	out_fd = open("/dev/console", O_WRONLY);
-	if (out_fd < 0){
-		fprintf(stderr, "cannot open /dev/console for output : %s\n",
+
+	close(STDIN_FILENO);
+	if (dup(dev_null_fd) < 0) {
+		fprintf(stderr, "cannot dup /dev/null to stdin : %s\n",
 			strerror(errno));
 		_exit(0);
 	}
-
-	close(STDIN_FILENO);
-	dup(in_fd);
 	close(STDOUT_FILENO);
-	dup(out_fd);
+	if (dup(dev_null_fd) < 0) {
+		fprintf(stderr, "cannot dup /dev/null to stdout : %s\n",
+			strerror(errno));
+		_exit(0);
+	}
 	close(STDERR_FILENO);
-	dup(out_fd);
-
-	close(in_fd);
-	close(out_fd);
-	if (chdir("/") < 0)
-		fprintf(stderr, "cannot chdir to '/', continuing\n");
-
+	if (dup(dev_null_fd) < 0) {
+		fprintf(stderr, "cannot dup /dev/null to stderr : %s\n",
+			strerror(errno));
+		_exit(0);
+	}
+	close(dev_null_fd);
+	daemon_pid = getpid();
 	return 0;
 }
 
@@ -1549,6 +1822,7 @@ main (int argc, char *argv[])
 	int err;
 
 	logsink = 1;
+	running_state = DAEMON_INIT;
 	dm_init();
 
 	if (getuid() != 0) {
@@ -1557,7 +1831,9 @@ main (int argc, char *argv[])
 	}
 
 	/* make sure we don't lock any path */
-	chdir("/");
+	if (chdir("/") < 0)
+		fprintf(stderr, "can't chdir to root directory : %s\n",
+			strerror(errno));
 	umask(umask(077) | 022);
 
 	conf = alloc_config();
@@ -1618,3 +1894,116 @@ main (int argc, char *argv[])
 		return (child(NULL));
 }
 
+void *  mpath_pr_event_handler_fn (void * pathp )
+{
+	struct multipath * mpp;
+	int i,j, ret, isFound;
+	struct path * pp = (struct path *)pathp;
+	unsigned char *keyp;
+	uint64_t prkey;
+	struct prout_param_descriptor *param;
+	struct prin_resp *resp;
+
+	mpp = pp->mpp;
+
+	resp = mpath_alloc_prin_response(MPATH_PRIN_RKEY_SA);
+	if (!resp){
+		condlog(0,"%s Alloc failed for prin response", pp->dev);
+		return NULL;
+	}
+
+	ret = prin_do_scsi_ioctl(pp->dev, MPATH_PRIN_RKEY_SA, resp, 0);
+	if (ret != MPATH_PR_SUCCESS )
+	{
+		condlog(0,"%s : pr in read keys service action failed. Error=%d", pp->dev, ret);
+		goto out;
+	}
+
+	condlog(3, " event pr=%d addlen=%d",resp->prin_descriptor.prin_readkeys.prgeneration,
+			resp->prin_descriptor.prin_readkeys.additional_length );
+
+	if (resp->prin_descriptor.prin_readkeys.additional_length == 0 )
+	{
+		condlog(1, "%s: No key found. Device may not be registered.", pp->dev);
+		ret = MPATH_PR_SUCCESS;
+		goto out;
+	}
+	prkey = 0;
+	keyp = (unsigned char *)mpp->reservation_key;
+	for (j = 0; j < 8; ++j) {
+		if (j > 0)
+			prkey <<= 8;
+		prkey |= *keyp;
+		++keyp;
+	}
+	condlog(2, "Multipath  reservation_key: 0x%" PRIx64 " ", prkey);
+
+	isFound =0;
+	for (i = 0; i < resp->prin_descriptor.prin_readkeys.additional_length/8; i++ )
+	{
+		condlog(2, "PR IN READKEYS[%d]  reservation key:",i);
+		dumpHex((char *)&resp->prin_descriptor.prin_readkeys.key_list[i*8], 8 , -1);
+		if (!memcmp(mpp->reservation_key, &resp->prin_descriptor.prin_readkeys.key_list[i*8], 8))
+		{
+			condlog(2, "%s: pr key found in prin readkeys response", mpp->alias);
+			isFound =1;
+			break;
+		}
+	}
+	if (!isFound)
+	{
+		condlog(0, "%s: Either device not registered or ", pp->dev);
+		condlog(0, "host is not authorised for registration. Skip path");
+		ret = MPATH_PR_OTHER;
+		goto out;
+	}
+
+	param= malloc(sizeof(struct prout_param_descriptor));
+	memset(param, 0 , sizeof(struct prout_param_descriptor));
+
+	for (j = 7; j >= 0; --j) {
+		param->sa_key[j] = (prkey & 0xff);
+		prkey >>= 8;
+	}
+	param->num_transportid = 0;
+
+	condlog(3, "device %s:%s", pp->dev, pp->mpp->wwid);
+
+	ret = prout_do_scsi_ioctl(pp->dev, MPATH_PROUT_REG_IGN_SA, 0, 0, param, 0);
+	if (ret != MPATH_PR_SUCCESS )
+	{
+		condlog(0,"%s: Reservation registration failed. Error: %d", pp->dev, ret);
+	}
+	mpp->prflag = 1;
+
+	free(param);
+out:
+	free(resp);
+	return NULL;
+}
+
+int mpath_pr_event_handle(struct path *pp)
+{
+	pthread_t thread;
+	int rc;
+	pthread_attr_t attr;
+	struct multipath * mpp;
+
+	mpp = pp->mpp;
+
+	if (!mpp->reservation_key)
+		return -1;
+
+	pthread_attr_init(&attr);
+	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
+
+	rc = pthread_create(&thread, NULL , mpath_pr_event_handler_fn, pp);
+	if (rc) {
+		condlog(0, "%s: ERROR; return code from pthread_create() is %d", pp->dev, rc);
+		return -1;
+	}
+	pthread_attr_destroy(&attr);
+	rc = pthread_join(thread, NULL);
+	return 0;
+}
+
diff --git a/multipathd/main.h b/multipathd/main.h
index 136b7e5..10378ef 100644
--- a/multipathd/main.h
+++ b/multipathd/main.h
@@ -3,11 +3,38 @@
 
 #define MAPGCINT 5
 
+enum daemon_status {
+    DAEMON_INIT,
+    DAEMON_START,
+    DAEMON_CONFIGURE,
+    DAEMON_RUNNING,
+    DAEMON_SHUTDOWN,
+};
+
+struct prout_param_descriptor;
+struct prin_resp;
+
+extern pid_t daemon_pid;
+
+void exit_daemon(void);
+const char * daemon_status(void);
 int reconfigure (struct vectors *);
-int ev_add_path (char *, struct vectors *);
-int ev_remove_path (char *, struct vectors *);
-int ev_add_map (struct sysfs_device *, struct vectors *);
-int ev_remove_map (char *, struct vectors *);
+int ev_add_path (struct path *, struct vectors *);
+int ev_remove_path (struct path *, struct vectors *);
+int ev_add_map (char *, char *, struct vectors *);
+int ev_remove_map (char *, char *, int, struct vectors *);
 void sync_map_state (struct multipath *);
+void * mpath_alloc_prin_response(int prin_sa);
+int prin_do_scsi_ioctl(char *, int rq_servact, struct prin_resp * resp,
+       int noisy);
+void dumpHex(const char * , int len, int no_ascii);
+int prout_do_scsi_ioctl(char * , int rq_servact, int rq_scope,
+       unsigned int rq_type, struct prout_param_descriptor *param,
+       int noisy);
+int mpath_pr_event_handle(struct path *pp);
+void * mpath_pr_event_handler_fn (void * );
+int update_map_pr(struct multipath *mpp);
+void * mpath_pr_event_handler_fn (void * pathp );
+void handle_signals(void);
 
 #endif /* MAIN_H */
diff --git a/multipathd/multipathd.8 b/multipathd/multipathd.8
index c63185c..ccc5f54 100644
--- a/multipathd/multipathd.8
+++ b/multipathd/multipathd.8
@@ -35,9 +35,17 @@ The following commands can be used in interactive mode:
 .B list|show paths
 Show the paths that multipathd is monitoring, and their state. 
 .TP
+.B list|show paths format $format
+Show the paths that multipathd is monitoring, using a format string with path
+format wildcards.
+.TP
 .B list|show maps|multipaths
 Show the multipath devices that the multipathd is monitoring. 
 .TP
+.B list|show maps|multipaths format $format
+Show the status of all multipath devices that the multipathd is monitoring,
+using a format string with multipath format wildcards.
+.TP
 .B list|show maps|multipaths status
 Show the status of all multipath devices that the multipathd is monitoring.
 .TP
@@ -45,15 +53,18 @@ Show the status of all multipath devices that the multipathd is monitoring.
 Show some statistics of all multipath devices that the multipathd is monitoring.
 .TP
 .B list|show maps|multipaths topology
-Show the current multipath topology. Same as "multipath -ll".
+Show the current multipath topology. Same as "multipath \-ll".
 .TP
 .B list|show topology
-Show the current multipath topology. Same as "multipath -ll".
+Show the current multipath topology. Same as "multipath \-ll".
 .TP
 .B list|show map|multipath $map topology
 Show topology of a single multipath device specified by $map, e.g. 36005076303ffc56200000000000010aa.
 This map could be obtained from "list maps".
 .TP
+.B list|show wildcards
+Show the format wildcards used in interactive commands taking $format
+.TP
 .B list|show config
 Show the currently used configuration, derived from default values and values specified within the configuration file /etc/multipath.conf.
 .TP
@@ -99,11 +110,20 @@ Sets path $path into failed state.
 .B reinstate path $path
 Resumes path $path from failed state.
 .TP
+.B disablequeueing maps|multipaths
+Disable queueing on all multipath devices.
+.TP
+.B restorequeueing maps|multipaths
+Restore queueing on all multipath devices.
+.TP
 .B disablequeueing map|multipath $map
-Disabled queuing on multipathed map $map
+Disable queuing on multipathed map $map
 .TP
 .B restorequeueing map|multipath $map
 Restore queuing on multipahted map $map
+.TP
+.B quit|exit
+End interactive session.
 
 .SH "SEE ALSO"
 .BR multipath (8)
diff --git a/multipathd/multipathd.init.debian b/multipathd/multipathd.init.debian
index f1e2de0..ed23b5b 100644
--- a/multipathd/multipathd.init.debian
+++ b/multipathd/multipathd.init.debian
@@ -2,25 +2,19 @@
 
 PATH=/bin:/usr/bin:/sbin:/usr/sbin
 DAEMON=/usr/bin/multipathd
-PIDFILE=/var/run/multipathd.pid
 
 test -x $DAEMON || exit 0
 
 case "$1" in
   start)
 	echo -n "Starting multipath daemon: multipathd"
-        $DAEMON
+	$DAEMON
 	echo "."
 	;;
   stop)
 	echo -n "Stopping multipath daemon: multipathd"
 	echo "."
-	if [ -f $PIDFILE ]
-	then
-		kill `cat $PIDFILE`
-	else
-		echo "multipathd not running: Nothing to stop..."
-	fi
+	$DAEMON shutdown
 	;;
   force-reload|restart)
 	$0 stop
diff --git a/multipathd/multipathd.init.redhat b/multipathd/multipathd.init.redhat
index 15b5753..d46ef80 100644
--- a/multipathd/multipathd.init.redhat
+++ b/multipathd/multipathd.init.redhat
@@ -81,23 +81,28 @@ force_stop() {
 	echo
 }
 
-stop() {
+check_root() {
         root_dev=$(awk '{ if ($1 !~ /^[ \t]*#/ && $2 == "/") { print $1; }}' /etc/mtab)
 	dm_num=`dmsetup info -c --noheadings -o minor $root_dev 2> /dev/null`
 	if [ $? -eq 0 ]; then
 		root_dm_device="dm-$dm_num"
 		[ -d $syspath/$root_dm_device ] && teardown_slaves $syspath/$root_dm_device
 	fi
+}
 
-	force_stop
+force_queue_without_daemon() {
+	$DAEMON forcequeueing daemon
 }
 
 restart() {
-	stop
+	force_queue_without_daemon
+	check_root
+	force_stop
 	start
 }
 
 force_restart() {
+	force_queue_without_daemon
 	force_stop
 	start
 }
@@ -115,7 +120,8 @@ start)
 	start
 	;;
 stop)
-	stop
+	check_root
+	force_stop
 	;;
 force-stop)
 	force_stop
diff --git a/multipathd/multipathd.init.suse b/multipathd/multipathd.init.suse
index d851354..d1319b1 100644
--- a/multipathd/multipathd.init.suse
+++ b/multipathd/multipathd.init.suse
@@ -3,28 +3,30 @@
 #
 # Author: Hannes Reinecke <feedback@suse.de>
 #
-# init.d/routed
-#
-#   and symbolic its link
-#
-# /usr/sbin/rcrouted
+# init.d/multipathd
 #
 ### BEGIN INIT INFO
 # Provides:          multipathd
 # Required-Start:    $syslog
-# Required-Stop:
+# Required-Stop:     $syslog
 # Default-Start:     3 5
 # Default-Stop:	     0 1 2 4 6
-# Description:       Starts multipath daemon
+# Short-Description: Starts multipath daemon
+# Description:       Starts the multipath daemon
 ### END INIT INFO
 
 PATH=/bin:/usr/bin:/sbin:/usr/sbin
 DAEMON=/sbin/multipathd
 PIDFILE=/var/run/multipathd.pid
+MPATH_INIT_TIMEOUT=10
+ARGS=""
 
 # Set the maximum number of open files
 MAX_OPEN_FDS=4096
 
+# Set to enable asynchronous daemon startup
+DAEMON_ASYNC_STARTUP=
+
 test -x $DAEMON || exit 5
 
 . /etc/rc.status
@@ -35,6 +37,12 @@ rc_reset
 case "$1" in
     start)
 	echo -n "Starting multipathd"
+	ulimit -c unlimited
+	if $DAEMON -k"reconfigure" > /dev/null 2>&1 ; then
+	    echo -n " (multipathd running)"
+	    rc_status -v
+	    rc_exit
+	fi
 
 	modprobe dm-multipath
 
@@ -43,31 +51,95 @@ case "$1" in
 	    ulimit -n $MAX_OPEN_FDS
 	fi
 
-	if [ -f $PIDFILE ]; then
-		PID="$(cat $PIDFILE)"
-		PROCNAME="$(ps -o cmd --no-headers $PID)"
-	fi
+	$DAEMON $ARGS
 
-	if [ "$PROCNAME" != "$DAEMON" ]; then
-		$DAEMON
+	if [ -n "$DAEMON_ASYNC_STARTUP" ] ; then
+	    rc_status -v
+	    rc_exit
+	fi
+	# Wait for the daemon to start up
+	status=$($DAEMON -k'show daemon' 2> /dev/null)
+	timeout=$MPATH_INIT_TIMEOUT
+	while [ $timeout -gt 0 ] ; do
+	    if [ -n "$status" ] ; then
+		PID=${status##pid }
+		STATUS=${PID##* }
+		# Configuration might be taking some time,
+		# so don't increase the timeout here
+		[ "$STATUS" != "configure" ] && timeout=$(( $timeout - 1 ))
+
+		[ "$STATUS" == "running" ] && break
+	    else
+		timeout=$(( $timeout - 1 ))
+	    fi
+	    sleep 1
+	    status=$($DAEMON -k'show daemon' 2> /dev/null)
+	done
+	if [ -z "$status" ] ; then
+	    rc_failed 7
+	fi
+	if [ $timeout -le 0 ] ; then
+	    rc_failed 1
 	fi
-	
 	# Remember status and be verbose
 	rc_status -v
-	sleep 1
 	;;
     stop)
 	echo -n "Shutting down multipathd"
-	# Because of the way how multipathd sets up its own namespace
-	# and chroots to it, killproc cannot be used with this process.
-	# So implement a cruder version:
-	if [ -f $PIDFILE ]; then
+	STATUS="unknown"
+	# Try to get PID from daemon
+	status=$($DAEMON -k'show daemon' 2> /dev/null)
+	if [ -n "$status" ] ; then
+	    PID=${status##pid }
+	    STATUS=${PID##* }
+	    PID=${PID%% *}
+	fi
+	# Fallback to PID file for older versions
+	if [ -z "$PID" ] || [ "$PID" == "multipath-tools" ] ; then
+	    if [ -f $PIDFILE ]; then
 		PID="$(cat $PIDFILE)"
-		PROCNAME="$(ps -o cmd --no-headers $PID)"
+		STATUS="running"
+	    else
+		rc_failed 7
+		rc_status -v
+		rc_exit
+	    fi
 	fi
-
-	if [ "$PROCNAME" == "$DAEMON" ]; then
-		kill -TERM $PID
+	# Shutdown the daemon via CLI
+	if [ "$STATUS" = "running" ] ; then
+	    status=$($DAEMON -k'shutdown' 2> /dev/null)
+	    if [ "$status" = "ok" ] ; then
+		timeout=$MPATH_INIT_TIMEOUT
+		while [ $timeout -gt 0 ] ; do
+		    PROCNAME="$(ps -p $PID -o comm=)"
+		    if [ "$PROCNAME" != "multipathd" ] &&
+			[ "$PROCNAME" != "multipathd <defunct>" ] ; then
+			STATUS="shutdown"
+			break
+		    fi
+		    sleep 1
+		    timeout=$(( $timeout - 1 ))
+		done
+	    fi
+	fi
+	# Kill the daemon if the above failed
+	if [ -n "$PID" -a "$STATUS" != "shutdown" ] ; then
+	    kill -TERM $PID
+	    timeout=$MPATH_INIT_TIMEOUT
+	    while [ $timeout -gt 0 ] ; do
+		PROCNAME="$(ps -p $PID -o comm=)"
+		if [ "$PROCNAME" != "multipathd" ] &&
+		    [ "$PROCNAME" != "multipathd <defunct>" ] ; then
+		    STATUS="shutdown"
+		    break
+		fi
+		sleep 1
+		timeout=$(( $timeout - 1 ))
+	    done
+	fi
+	if [ $STATUS != "shutdown" ] ; then
+	    echo -n " (still running)"
+	    rc_failed 1
 	fi
 
 	# Remember status and be verbose
@@ -94,8 +166,10 @@ case "$1" in
 	## Like force-reload, but if daemon does not support
 	## signalling, do nothing (!)
 
-	# If it does not support reload:
-	exit 3
+	$DAEMON -k"reconfigure" > /dev/null 2>&1
+
+	# Remember status and be quiet
+	rc_status
 	;;
     status)
 	echo -n "Checking for multipathd: "
@@ -106,18 +180,12 @@ case "$1" in
 	# 2 - service dead, but /var/lock/ lock file exists
 	# 3 - service not running
 
-	if [ -f $PIDFILE ]; then
-		PID="$(cat $PIDFILE)"
-		PROCNAME="$(ps -o cmd --no-headers $PID)"
-		if [ "$PROCNAME" == "$DAEMON" ]; then
-			(exit 0)
-		else
-			(exit 1)
-		fi
+	status=$($DAEMON -k'show daemon' 2> /dev/null)
+	if [ -n "$status" ]; then
+	        (exit 0)
 	else
 		(exit 3)
 	fi
-
 	rc_status -v
 	;;
     probe)
diff --git a/multipathd/multipathd.service b/multipathd/multipathd.service
new file mode 100644
index 0000000..d6da067
--- /dev/null
+++ b/multipathd/multipathd.service
@@ -0,0 +1,16 @@
+[Unit]
+Description=Device-Mapper Multipath Device Controller
+Before=iscsi.service iscsid.service lvm2-activation-early.service
+After=syslog.target
+DefaultDependencies=no
+Conflicts=shutdown.target
+
+[Service]
+Type=forking
+PIDFile=/var/run/multipathd.pid
+ExecStart=/sbin/multipathd
+ExecReload=/sbin/multipathd reconfigure
+#ExecStop=/path/to/scrip delete-me if not necessary
+
+[Install]
+WantedBy=sysinit.target
diff --git a/multipathd/uxclnt.c b/multipathd/uxclnt.c
index 2882716..4e3ed26 100644
--- a/multipathd/uxclnt.c
+++ b/multipathd/uxclnt.c
@@ -1,6 +1,6 @@
 /*
  * Original author : tridge@samba.org, January 2002
- * 
+ *
  * Copyright (c) 2005 Christophe Varoqui
  * Copyright (c) 2005 Benjamin Marzinski, Redhat
  */
@@ -33,12 +33,12 @@ static void print_reply(char *s)
 	/* strip ANSI color markers */
 	while (*s != '\0') {
 		if ((*s == 0x1b) && (*(s+1) == '['))
-			while ((*s++ != 'm') && (*s != '\0')) {}; 
+			while ((*s++ != 'm') && (*s != '\0')) {};
 		putchar(*s++);
 	}
 }
 /*
- * process the client 
+ * process the client
  */
 static void process(int fd)
 {
@@ -79,14 +79,18 @@ static void process_req(int fd, char * inbuf)
 	char *reply;
 	size_t len;
 
-	if (send_packet(fd, inbuf, strlen(inbuf) + 1) != 0)
+	if (send_packet(fd, inbuf, strlen(inbuf) + 1) != 0) {
+		printf("cannot send packet\n");
 		return;
-	if (recv_packet(fd, &reply, &len) == 0) {
-		print_reply(reply);
+	}
+	if (recv_packet(fd, &reply, &len) != 0)
+		printf("error receiving packet\n");
+	else {
+		printf("%s", reply);
 		FREE(reply);
 	}
 }
-	
+
 /*
  * entry point
  */
@@ -104,6 +108,6 @@ int uxclnt(char * inbuf)
 		process_req(fd, inbuf);
 	else
 		process(fd);
-	
+
 	return 0;
 }
diff --git a/multipathd/uxlsnr.c b/multipathd/uxlsnr.c
index a05719f..c0ddd8d 100644
--- a/multipathd/uxlsnr.c
+++ b/multipathd/uxlsnr.c
@@ -1,6 +1,6 @@
 /*
  * Original author : tridge@samba.org, January 2002
- * 
+ *
  * Copyright (c) 2005 Christophe Varoqui
  * Copyright (c) 2005 Benjamin Marzinski, Redhat
  */
@@ -8,6 +8,7 @@
 /*
  * A simple domain socket listener
  */
+#define _GNU_SOURCE
 #include <stdio.h>
 #include <stdlib.h>
 #include <unistd.h>
@@ -19,19 +20,21 @@
 #include <sys/socket.h>
 #include <sys/un.h>
 #include <sys/poll.h>
-
+#include <signal.h>
 #include <checkers.h>
-
 #include <memory.h>
 #include <debug.h>
 #include <vector.h>
 #include <structs.h>
+#include <structs_vec.h>
 #include <uxsock.h>
 #include <defaults.h>
 
+#include "main.h"
+#include "cli.h"
 #include "uxlsnr.h"
 
-#define SLEEP_TIME 5000
+struct timespec sleep_time = {5, 0};
 
 struct client {
 	int fd;
@@ -40,6 +43,9 @@ struct client {
 
 static struct client *clients;
 static unsigned num_clients;
+struct pollfd *polls;
+volatile sig_atomic_t reconfig_sig = 0;
+volatile sig_atomic_t log_reset_sig = 0;
 
 /*
  * handle a new client joining
@@ -52,7 +58,7 @@ static void new_client(int ux_sock)
 	int fd;
 
 	fd = accept(ux_sock, &addr, &len);
-	
+
 	if (fd == -1)
 		return;
 
@@ -81,7 +87,14 @@ static void dead_client(struct client *c)
 
 void free_polls (void)
 {
-	FREE(polls);
+	if (polls)
+		FREE(polls);
+}
+
+void uxsock_cleanup(void *arg)
+{
+	cli_exit();
+	free_polls();
 }
 
 /*
@@ -95,6 +108,7 @@ void * uxsock_listen(int (*uxsock_trigger)(char *, char **, int *, void *),
 	int rlen;
 	char *inbuf;
 	char *reply;
+	sigset_t mask;
 
 	ux_sock = ux_socket_listen(DEFAULT_SOCKET);
 
@@ -103,8 +117,12 @@ void * uxsock_listen(int (*uxsock_trigger)(char *, char **, int *, void *),
 		exit(1);
 	}
 
-	polls = (struct pollfd *)MALLOC(0);
+	pthread_cleanup_push(uxsock_cleanup, NULL);
 
+	polls = (struct pollfd *)MALLOC(0);
+	pthread_sigmask(SIG_SETMASK, NULL, &mask);
+	sigdelset(&mask, SIGHUP);
+	sigdelset(&mask, SIGUSR1);
 	while (1) {
 		struct client *c;
 		int i, poll_count;
@@ -121,15 +139,17 @@ void * uxsock_listen(int (*uxsock_trigger)(char *, char **, int *, void *),
 		}
 
 		/* most of our life is spent in this call */
-		poll_count = poll(polls, i, SLEEP_TIME);
-		
+		poll_count = ppoll(polls, i, &sleep_time, &mask);
+
 		if (poll_count == -1) {
-			if (errno == EINTR)
+			if (errno == EINTR) {
+				handle_signals();
 				continue;
+			}
 
 			/* something went badly wrong! */
 			condlog(0, "poll");
-			exit(1);
+			pthread_exit(NULL);
 		}
 
 		if (poll_count == 0)
@@ -146,13 +166,14 @@ void * uxsock_listen(int (*uxsock_trigger)(char *, char **, int *, void *),
 					inbuf[len - 1] = 0;
 					condlog(4, "Got request [%s]", inbuf);
 					uxsock_trigger(inbuf, &reply, &rlen,
-							trigger_data);
-
+						       trigger_data);
 					if (reply) {
 						if (send_packet(c->fd, reply,
-						     rlen) != 0) {
+								rlen) != 0) {
 							dead_client(c);
 						}
+						condlog(4, "Reply [%d bytes]",
+							rlen);
 						FREE(reply);
 						reply = NULL;
 					}
@@ -168,6 +189,7 @@ void * uxsock_listen(int (*uxsock_trigger)(char *, char **, int *, void *),
 		}
 	}
 
+	pthread_cleanup_pop(1);
 	close(ux_sock);
 	return NULL;
 }
diff --git a/multipathd/uxlsnr.h b/multipathd/uxlsnr.h
index 00d98b0..8b5a525 100644
--- a/multipathd/uxlsnr.h
+++ b/multipathd/uxlsnr.h
@@ -1,7 +1,11 @@
-struct pollfd *polls;
+#ifndef _UXLSNR_H
+#define _UXLSNR_H
 
-void free_polls(void);
 void * uxsock_listen(int (*uxsock_trigger)
 			(char *, char **, int *, void *),
 			void * trigger_data);
 
+extern volatile sig_atomic_t reconfig_sig;
+extern volatile sig_atomic_t log_reset_sig;
+#endif
+
